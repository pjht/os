.TH "kernel/cpu/paging.h" 9 "Sun Jul 26 2020" "MyOS Kernel" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kernel/cpu/paging.h
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBmap_pages\fP (void *virt_addr_ptr, void *phys_addr_ptr, int num_pages, char usr, char wr)"
.br
.ti -1c
.RI "void \fBunmap_pages\fP (void *start_virt, int num_pages)"
.br
.ti -1c
.RI "void * \fBalloc_pages\fP (int num_pages)"
.br
.ti -1c
.RI "void \fBalloc_pages_virt\fP (int num_pages, void *addr)"
.br
.ti -1c
.RI "void \fBpaging_init\fP ()"
.br
.ti -1c
.RI "void * \fBpaging_new_address_space\fP ()"
.br
.ti -1c
.RI "void \fBload_address_space\fP (void *cr3)"
.br
.ti -1c
.RI "void * \fBvirt_to_phys\fP (void *virt_addr)"
.br
.ti -1c
.RI "void * \fBfind_free_pages\fP (int num_pages)"
.br
.ti -1c
.RI "void * \fBget_cr3\fP ()"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void* alloc_pages (int num_pages)"
Allocate virtual pages & map them to physical memory\&. 
.PP
\fBParameters\fP
.RS 4
\fInum_pages\fP The number of pages to allocate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to the allocated pages\&. 
.RE
.PP

.SS "void alloc_pages_virt (int num_pages, void * addr)"
Allocate virtual pages at a specific address & map them to physical memory\&. 
.PP
\fBParameters\fP
.RS 4
\fInum_pages\fP The number of pages to allocate\&. 
.br
\fIaddr\fP The adress to start allocation at\&. 
.RE
.PP

.SS "void* find_free_pages (int num_pages)"
Finds free virtual pages and returns the start address 
.PP
\fBParameters\fP
.RS 4
\fInum_pages\fP The minimum size of the free area 
.RE
.PP
\fBReturns\fP
.RS 4
the start of the free area 
.RE
.PP

.SS "void* get_cr3 ()"
Get the current address space 
.PP
\fBReturns\fP
.RS 4
a pointer to the current address space in physical memory\&. 
.RE
.PP

.SS "void load_address_space (void * cr3)"
Load an address space 
.PP
\fBParameters\fP
.RS 4
\fIcr3\fP The address space to load 
.RE
.PP

.SS "void map_pages (void * virt_addr_ptr, void * phys_addr_ptr, int num_pages, char usr, char wr)"
Map virtual pages to physical frames\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirt_addr_ptr\fP The start of the virtual range to map\&. 
.br
\fIphys_addr_ptr\fP The start of the physical range to map\&. 
.br
\fInum_pages\fP The number of pages to map\&. 
.br
\fIusr\fP Are the pages acessible by user mode code 
.br
\fIwr\fP Are the pages writable by user mode code (kernel always has write permissions) 
.RE
.PP

.SS "void paging_init ()"
Initialize paging 
.SS "void* paging_new_address_space ()"
Create a new address space 
.PP
\fBReturns\fP
.RS 4
a pointer to the new address space in physical memory\&. 
.RE
.PP

.SS "void unmap_pages (void * start_virt, int num_pages)"
Unmap virtual pages, 
.PP
\fBParameters\fP
.RS 4
\fIstart_virt\fP The start of the virtual range to unmap\&. 
.br
\fInum_pages\fP The number of pages to map\&. 
.RE
.PP

.SS "void* virt_to_phys (void * virt_addr)"
Convert a virtual address to a physical one\&. 
.PP
\fBParameters\fP
.RS 4
\fIvirt_addr\fP The virtual address to convert 
.RE
.PP
\fBReturns\fP
.RS 4
the physical adress it maps to, or NULL if it is not mapped\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for MyOS Kernel from the source code\&.
