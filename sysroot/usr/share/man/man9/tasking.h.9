.TH "kernel/tasking.h" 9 "Sun Jul 26 2020" "MyOS Kernel" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kernel/tasking.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBProcess\fP"
.br
.ti -1c
.RI "struct \fBThread\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBthread_state\fP { \fBTHREAD_RUNNING\fP, \fBTHREAD_READY\fP, \fBTHREAD_EXITED\fP, \fBTHREAD_BLOCKED\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBtasking_create_task\fP (void *eip, void *cr3, char kmode, char param1_exists, void *param1_arg, char param2_exists, void *param2_arg, char isThread)"
.br
.ti -1c
.RI "void \fBtasking_init\fP ()"
.br
.ti -1c
.RI "char \fBtasking_is_privleged\fP ()"
.br
.ti -1c
.RI "pid_t \fBtasking_get_PID\fP ()"
.br
.ti -1c
.RI "int * \fBtasking_get_errno_address\fP ()"
.br
.ti -1c
.RI "pid_t \fBtasking_new_thread\fP (void *start, pid_t pid, char param_exists, void *param_arg)"
.br
.ti -1c
.RI "void \fBtasking_exit\fP (int code)"
.br
.ti -1c
.RI "void \fBtasking_block\fP (\fBthread_state\fP newstate)"
.br
.ti -1c
.RI "void \fBtasking_unblock\fP (pid_t pid, pid_t tid)"
.br
.ti -1c
.RI "void \fBtasking_yield\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBThread\fP * \fBcurrent_thread\fP"
.br
.RI "Currently running thread\&. "
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBthread_state\fP"
Represents the state of a thread 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fITHREAD_RUNNING \fP\fP
The state of a running thread\&. 
.TP
\fB\fITHREAD_READY \fP\fP
The state of a ready to run thread\&. 
.TP
\fB\fITHREAD_EXITED \fP\fP
The state of an exited thread\&. 
.TP
\fB\fITHREAD_BLOCKED \fP\fP
The state of a generically blocked thread\&. 
.SH "Function Documentation"
.PP 
.SS "void tasking_block (\fBthread_state\fP newstate)"
Block the current thread & yield 
.PP
\fBParameters\fP
.RS 4
\fInewstate\fP The state to block it in 
.RE
.PP

.SS "void tasking_create_task (void * eip, void * cr3, char kmode, char param1_exists, void * param1_arg, char param2_exists, void * param2_arg, char isThread)"
Create a task 
.PP
\fBParameters\fP
.RS 4
\fIeip\fP The start address of the task 
.br
\fIcr3\fP The address space of the task 
.br
\fIkmode\fP Whether the task is a kernel mode task 
.br
\fIparam1_exists\fP Whether param1_arg is a valid value 
.br
\fIparam1_arg\fP The thread's start function first parameter 
.br
\fIparam2_exists\fP Whether param2_arg is a valid value 
.br
\fIparam2_arg\fP The thread's start function second parameter/ 
.br
\fIisThread\fP Whether we are creating a new process or a thread in a process\&. If we are creating a theead, param2_arg becomes the PID for the newly created thread, and param2_exists must be 0\&. 
.RE
.PP

.SS "void tasking_exit (int code)"
Terminate the current thread If the main thread terminates, the whole process terminates\&. 
.PP
\fBNote\fP
.RS 4
Currently, calling tasking_exit from any thread terminates the whole process\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIcode\fP The exit code of the thread 
.RE
.PP

.SS "int* tasking_get_errno_address ()"
Get the adddress of errno for the current thread 
.PP
\fBReturns\fP
.RS 4
The address of errno 
.RE
.PP

.SS "pid_t tasking_get_PID ()"
Get the PID of the current thread\&. 
.PP
\fBReturns\fP
.RS 4
The current thread's PID 
.RE
.PP

.SS "void tasking_init ()"
Initialize tasking 
.SS "char tasking_is_privleged ()"
Check whether the current process is privleged 
.PP
\fBReturns\fP
.RS 4
whether the current process is privleged 
.RE
.PP

.SS "pid_t tasking_new_thread (void * start, pid_t pid, char param_exists, void * param_arg)"
Create a new thread 
.PP
\fBParameters\fP
.RS 4
\fIstart\fP The start address of the task 
.br
\fIpid\fP The PID that gets the new thread 
.br
\fIparam_exists\fP Whether param_arg is a valid value 
.br
\fIparam_arg\fP The thread's start function parameter 
.RE
.PP
\fBReturns\fP
.RS 4
the TID of the thread 
.RE
.PP

.SS "void tasking_unblock (pid_t pid, pid_t tid)"
Unblock a thread 
.PP
\fBParameters\fP
.RS 4
\fIpid\fP The PID that contains the thread to unblock 
.br
\fItid\fP The TID in the process to unblock\&. 
.RE
.PP

.SS "void tasking_yield ()"
Yield to the next ready thread in any process 
.SH "Author"
.PP 
Generated automatically by Doxygen for MyOS Kernel from the source code\&.
