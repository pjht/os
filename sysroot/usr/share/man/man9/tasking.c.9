.TH "kernel/tasking.c" 9 "Sun Jul 26 2020" "MyOS Kernel" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kernel/tasking.c
.SH SYNOPSIS
.br
.PP
\fC#include 'cpu/halt\&.h'\fP
.br
\fC#include 'cpu/paging\&.h'\fP
.br
\fC#include 'cpu/serial\&.h'\fP
.br
\fC#include 'cpu/tasking_helpers\&.h'\fP
.br
\fC#include 'kmalloc\&.h'\fP
.br
\fC#include 'tasking\&.h'\fP
.br
\fC#include <sys/types\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMAX_PROCS\fP   32768"
.br
.RI "Maximum number of processes that can be running at a time\&. "
.ti -1c
.RI "#define \fBHAS_UNBLOCKED_THREADS\fP(proc)   (proc\->numThreads!=proc\->numThreadsBlocked)"
.br
.RI "Macro to check whethe a process has unblocked threads\&. "
.ti -1c
.RI "#define \fBNUM_UNBLOCKED_THREADS\fP(proc)   (proc\->numThreads\-proc\->numThreadsBlocked)"
.br
.RI "Macro to get the number of unblocked threads for a process\&. "
.ti -1c
.RI "#define \fBSAME_PROC\fP(thread1,  thread2)   (thread1\->process\->pid==thread2\->process\->pid)"
.br
.RI "Macro to check whether two threads have the same PID\&. "
.ti -1c
.RI "#define \fBSAME_THREAD\fP(thread1,  thread2)   (thread1\->process\->pid==thread2\->process\->pid&&thread1\->tid==thread2\->tid)"
.br
.RI "Macro to check whether two threads have the same PID and TID\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static char \fBis_proc_scheduled\fP (pid_t index)"
.br
.ti -1c
.RI "static void \fBmark_proc_scheduled\fP (pid_t index)"
.br
.ti -1c
.RI "static void \fBunmark_proc_scheduled\fP (pid_t index)"
.br
.ti -1c
.RI "void \fBtasking_create_task\fP (void *eip, void *cr3, char kmode, char param1_exists, void *param1_arg, char param2_exists, void *param2_arg, char isThread)"
.br
.ti -1c
.RI "void \fBtasking_init\fP ()"
.br
.ti -1c
.RI "char \fBtasking_is_privleged\fP ()"
.br
.ti -1c
.RI "pid_t \fBtasking_get_PID\fP ()"
.br
.ti -1c
.RI "int * \fBtasking_get_errno_address\fP ()"
.br
.ti -1c
.RI "pid_t \fBtasking_new_thread\fP (void *start, pid_t pid, char param_exists, void *param_arg)"
.br
.ti -1c
.RI "void \fBswitch_to_thread\fP (\fBThread\fP *thread)"
.br
.ti -1c
.RI "void \fBtasking_yield\fP ()"
.br
.ti -1c
.RI "void \fBtasking_block\fP (\fBthread_state\fP newstate)"
.br
.ti -1c
.RI "void \fBtasking_unblock\fP (pid_t pid, pid_t tid)"
.br
.ti -1c
.RI "void \fBtasking_exit\fP (int code)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "pid_t \fBnext_pid\fP =0"
.br
.RI "PID to use for the next created process\&. "
.ti -1c
.RI "size_t \fBnum_procs\fP =0"
.br
.RI "Number of non-exited processes\&. "
.ti -1c
.RI "\fBProcess\fP * \fBprocesses\fP [\fBMAX_PROCS\fP]"
.br
.RI "Array pf processes by PID\&. "
.ti -1c
.RI "char \fBproc_schedule_bmap\fP [\fBMAX_PROCS\fP/8]"
.br
.RI "Bitmap of what processes are scheduled\&. "
.ti -1c
.RI "\fBThread\fP * \fBcurrent_thread\fP"
.br
.RI "Currently running thread\&. "
.ti -1c
.RI "static \fBThread\fP * \fBready_to_run_head\fP =NULL"
.br
.RI "Head of the linked list of ready to run threads\&. "
.ti -1c
.RI "static \fBThread\fP * \fBready_to_run_tail\fP =NULL"
.br
.RI "Tail of the linked list of ready to run threads\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "static char is_proc_scheduled (pid_t index)\fC [static]\fP"
Check whether a process is scheduled 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The PID to check 
.RE
.PP
\fBReturns\fP
.RS 4
whether the process is scheduled 
.RE
.PP

.SS "static void mark_proc_scheduled (pid_t index)\fC [static]\fP"
Mark a process as scheduled 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The PID to mark 
.RE
.PP

.SS "void switch_to_thread (\fBThread\fP * thread)"
Switch to a thread and schedule the next ready thread in the current process, if there is one\&. 
.PP
\fBParameters\fP
.RS 4
\fIthread\fP The thread to switch to 
.RE
.PP

.SS "void tasking_block (\fBthread_state\fP newstate)"
Block the current thread & yield 
.PP
\fBParameters\fP
.RS 4
\fInewstate\fP The state to block it in 
.RE
.PP

.SS "void tasking_create_task (void * eip, void * cr3, char kmode, char param1_exists, void * param1_arg, char param2_exists, void * param2_arg, char isThread)"
Create a task 
.PP
\fBParameters\fP
.RS 4
\fIeip\fP The start address of the task 
.br
\fIcr3\fP The address space of the task 
.br
\fIkmode\fP Whether the task is a kernel mode task 
.br
\fIparam1_exists\fP Whether param1_arg is a valid value 
.br
\fIparam1_arg\fP The thread's start function first parameter 
.br
\fIparam2_exists\fP Whether param2_arg is a valid value 
.br
\fIparam2_arg\fP The thread's start function second parameter/ 
.br
\fIisThread\fP Whether we are creating a new process or a thread in a process\&. If we are creating a theead, param2_arg becomes the PID for the newly created thread, and param2_exists must be 0\&. 
.RE
.PP

.SS "void tasking_exit (int code)"
Terminate the current thread If the main thread terminates, the whole process terminates\&. 
.PP
\fBNote\fP
.RS 4
Currently, calling tasking_exit from any thread terminates the whole process\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIcode\fP The exit code of the thread 
.RE
.PP

.SS "int* tasking_get_errno_address ()"
Get the adddress of errno for the current thread 
.PP
\fBReturns\fP
.RS 4
The address of errno 
.RE
.PP

.SS "pid_t tasking_get_PID ()"
Get the PID of the current thread\&. 
.PP
\fBReturns\fP
.RS 4
The current thread's PID 
.RE
.PP

.SS "void tasking_init ()"
Initialize tasking 
.SS "char tasking_is_privleged ()"
Check whether the current process is privleged 
.PP
\fBReturns\fP
.RS 4
whether the current process is privleged 
.RE
.PP

.SS "pid_t tasking_new_thread (void * start, pid_t pid, char param_exists, void * param_arg)"
Create a new thread 
.PP
\fBParameters\fP
.RS 4
\fIstart\fP The start address of the task 
.br
\fIpid\fP The PID that gets the new thread 
.br
\fIparam_exists\fP Whether param_arg is a valid value 
.br
\fIparam_arg\fP The thread's start function parameter 
.RE
.PP
\fBReturns\fP
.RS 4
the TID of the thread 
.RE
.PP

.SS "void tasking_unblock (pid_t pid, pid_t tid)"
Unblock a thread 
.PP
\fBParameters\fP
.RS 4
\fIpid\fP The PID that contains the thread to unblock 
.br
\fItid\fP The TID in the process to unblock\&. 
.RE
.PP

.SS "void tasking_yield ()"
Yield to the next ready thread in any process 
.SS "static void unmark_proc_scheduled (pid_t index)\fC [static]\fP"
Unmark a process as scheduled 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP The PID to unmark 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for MyOS Kernel from the source code\&.
