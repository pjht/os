
init:     file format elf32-i386


Disassembly of section .init:

08048074 <_init>:
 8048074:	e8 ff 00 00 00       	call   8048178 <frame_dummy>
 8048079:	e8 06 1e 00 00       	call   8049e84 <__do_global_ctors_aux>
 804807e:	c2 00 00             	ret    $0x0

Disassembly of section .text:

08048090 <_start>:
 8048090:	e8 14 08 00 00       	call   80488a9 <__stdio_init>
 8048095:	e8 f5 04 00 00       	call   804858f <main>
 804809a:	6a 00                	push   $0x0
 804809c:	e8 93 1a 00 00       	call   8049b34 <exit>
 80480a1:	c3                   	ret    
 80480a2:	66 90                	xchg   %ax,%ax

080480a4 <deregister_tm_clones>:
 80480a4:	b8 14 b0 04 08       	mov    $0x804b014,%eax
 80480a9:	3d 14 b0 04 08       	cmp    $0x804b014,%eax
 80480ae:	74 1c                	je     80480cc <deregister_tm_clones+0x28>
 80480b0:	b8 00 00 00 00       	mov    $0x0,%eax
 80480b5:	85 c0                	test   %eax,%eax
 80480b7:	74 13                	je     80480cc <deregister_tm_clones+0x28>
 80480b9:	55                   	push   %ebp
 80480ba:	89 e5                	mov    %esp,%ebp
 80480bc:	83 ec 14             	sub    $0x14,%esp
 80480bf:	68 14 b0 04 08       	push   $0x804b014
 80480c4:	ff d0                	call   *%eax
 80480c6:	83 c4 10             	add    $0x10,%esp
 80480c9:	c9                   	leave  
 80480ca:	c3                   	ret    
 80480cb:	90                   	nop
 80480cc:	c3                   	ret    
 80480cd:	8d 76 00             	lea    0x0(%esi),%esi

080480d0 <register_tm_clones>:
 80480d0:	b8 14 b0 04 08       	mov    $0x804b014,%eax
 80480d5:	2d 14 b0 04 08       	sub    $0x804b014,%eax
 80480da:	89 c2                	mov    %eax,%edx
 80480dc:	c1 fa 02             	sar    $0x2,%edx
 80480df:	c1 e8 1f             	shr    $0x1f,%eax
 80480e2:	01 d0                	add    %edx,%eax
 80480e4:	d1 f8                	sar    %eax
 80480e6:	74 1c                	je     8048104 <register_tm_clones+0x34>
 80480e8:	ba 00 00 00 00       	mov    $0x0,%edx
 80480ed:	85 d2                	test   %edx,%edx
 80480ef:	74 13                	je     8048104 <register_tm_clones+0x34>
 80480f1:	55                   	push   %ebp
 80480f2:	89 e5                	mov    %esp,%ebp
 80480f4:	83 ec 10             	sub    $0x10,%esp
 80480f7:	50                   	push   %eax
 80480f8:	68 14 b0 04 08       	push   $0x804b014
 80480fd:	ff d2                	call   *%edx
 80480ff:	83 c4 10             	add    $0x10,%esp
 8048102:	c9                   	leave  
 8048103:	c3                   	ret    
 8048104:	c3                   	ret    
 8048105:	8d 76 00             	lea    0x0(%esi),%esi

08048108 <__do_global_dtors_aux>:
 8048108:	80 3d 20 b0 04 08 00 	cmpb   $0x0,0x804b020
 804810f:	75 63                	jne    8048174 <__do_global_dtors_aux+0x6c>
 8048111:	55                   	push   %ebp
 8048112:	89 e5                	mov    %esp,%ebp
 8048114:	56                   	push   %esi
 8048115:	53                   	push   %ebx
 8048116:	bb 0c b0 04 08       	mov    $0x804b00c,%ebx
 804811b:	81 eb 08 b0 04 08    	sub    $0x804b008,%ebx
 8048121:	c1 fb 02             	sar    $0x2,%ebx
 8048124:	4b                   	dec    %ebx
 8048125:	be 08 b0 04 08       	mov    $0x804b008,%esi
 804812a:	a1 24 b0 04 08       	mov    0x804b024,%eax
 804812f:	39 d8                	cmp    %ebx,%eax
 8048131:	73 13                	jae    8048146 <__do_global_dtors_aux+0x3e>
 8048133:	90                   	nop
 8048134:	40                   	inc    %eax
 8048135:	a3 24 b0 04 08       	mov    %eax,0x804b024
 804813a:	ff 14 86             	call   *(%esi,%eax,4)
 804813d:	a1 24 b0 04 08       	mov    0x804b024,%eax
 8048142:	39 d8                	cmp    %ebx,%eax
 8048144:	72 ee                	jb     8048134 <__do_global_dtors_aux+0x2c>
 8048146:	e8 59 ff ff ff       	call   80480a4 <deregister_tm_clones>
 804814b:	b8 00 00 00 00       	mov    $0x0,%eax
 8048150:	85 c0                	test   %eax,%eax
 8048152:	74 10                	je     8048164 <__do_global_dtors_aux+0x5c>
 8048154:	83 ec 0c             	sub    $0xc,%esp
 8048157:	68 e4 9f 04 08       	push   $0x8049fe4
 804815c:	e8 9f 7e fb f7       	call   0 <_init-0x8048074>
 8048161:	83 c4 10             	add    $0x10,%esp
 8048164:	c6 05 20 b0 04 08 01 	movb   $0x1,0x804b020
 804816b:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804816e:	5b                   	pop    %ebx
 804816f:	5e                   	pop    %esi
 8048170:	5d                   	pop    %ebp
 8048171:	c3                   	ret    
 8048172:	66 90                	xchg   %ax,%ax
 8048174:	c3                   	ret    
 8048175:	8d 76 00             	lea    0x0(%esi),%esi

08048178 <frame_dummy>:
 8048178:	b8 00 00 00 00       	mov    $0x0,%eax
 804817d:	85 c0                	test   %eax,%eax
 804817f:	74 1f                	je     80481a0 <frame_dummy+0x28>
 8048181:	55                   	push   %ebp
 8048182:	89 e5                	mov    %esp,%ebp
 8048184:	83 ec 10             	sub    $0x10,%esp
 8048187:	68 28 b0 04 08       	push   $0x804b028
 804818c:	68 e4 9f 04 08       	push   $0x8049fe4
 8048191:	e8 6a 7e fb f7       	call   0 <_init-0x8048074>
 8048196:	83 c4 10             	add    $0x10,%esp
 8048199:	c9                   	leave  
 804819a:	e9 31 ff ff ff       	jmp    80480d0 <register_tm_clones>
 804819f:	90                   	nop
 80481a0:	e9 2b ff ff ff       	jmp    80480d0 <register_tm_clones>

080481a5 <getsize>:
  char mtime[12];
  char chksum[8];
  char typeflag[1];
} tar_header;

size_t getsize(const char *in) {
 80481a5:	55                   	push   %ebp
 80481a6:	89 e5                	mov    %esp,%ebp
 80481a8:	83 ec 10             	sub    $0x10,%esp
    size_t size=0;
 80481ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    size_t j;
    size_t count=1;
 80481b2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    for (j=11;j>0;j--,count*=8) {
 80481b9:	c7 45 f8 0b 00 00 00 	movl   $0xb,-0x8(%ebp)
 80481c0:	eb 21                	jmp    80481e3 <getsize+0x3e>
        size+=((in[j-1]-'0')*count);
 80481c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80481c5:	8d 50 ff             	lea    -0x1(%eax),%edx
 80481c8:	8b 45 08             	mov    0x8(%ebp),%eax
 80481cb:	01 d0                	add    %edx,%eax
 80481cd:	8a 00                	mov    (%eax),%al
 80481cf:	0f be c0             	movsbl %al,%eax
 80481d2:	83 e8 30             	sub    $0x30,%eax
 80481d5:	0f af 45 f4          	imul   -0xc(%ebp),%eax
 80481d9:	01 45 fc             	add    %eax,-0x4(%ebp)
    for (j=11;j>0;j--,count*=8) {
 80481dc:	ff 4d f8             	decl   -0x8(%ebp)
 80481df:	c1 65 f4 03          	shll   $0x3,-0xc(%ebp)
 80481e3:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
 80481e7:	75 d9                	jne    80481c2 <getsize+0x1d>
    }
    return size;
 80481e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 80481ec:	c9                   	leave  
 80481ed:	c3                   	ret    

080481ee <find_loc>:

size_t find_loc(char* name,char* initrd) {
 80481ee:	55                   	push   %ebp
 80481ef:	89 e5                	mov    %esp,%ebp
 80481f1:	81 ec c8 00 00 00    	sub    $0xc8,%esp
  size_t pos=0;
 80481f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  tar_header tar_hdr;
  for (int i=0;;i++) {
 80481fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    char* tar_hdr_ptr=(char*)&tar_hdr;
 8048205:	8d 85 47 ff ff ff    	lea    -0xb9(%ebp),%eax
 804820b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for (size_t i=0;i<sizeof(tar_hdr);i++) {
 804820e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 8048215:	eb 1c                	jmp    8048233 <find_loc+0x45>
      tar_hdr_ptr[i]=initrd[pos+i];
 8048217:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804821a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804821d:	01 c2                	add    %eax,%edx
 804821f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048222:	01 d0                	add    %edx,%eax
 8048224:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 8048227:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804822a:	01 ca                	add    %ecx,%edx
 804822c:	8a 00                	mov    (%eax),%al
 804822e:	88 02                	mov    %al,(%edx)
    for (size_t i=0;i<sizeof(tar_hdr);i++) {
 8048230:	ff 45 ec             	incl   -0x14(%ebp)
 8048233:	81 7d ec 9c 00 00 00 	cmpl   $0x9c,-0x14(%ebp)
 804823a:	76 db                	jbe    8048217 <find_loc+0x29>
    }
    if (tar_hdr.filename[0]=='\0') break;
 804823c:	8a 85 47 ff ff ff    	mov    -0xb9(%ebp),%al
 8048242:	84 c0                	test   %al,%al
 8048244:	74 64                	je     80482aa <find_loc+0xbc>
    size_t size=getsize(tar_hdr.size);
 8048246:	8d 85 47 ff ff ff    	lea    -0xb9(%ebp),%eax
 804824c:	83 c0 7c             	add    $0x7c,%eax
 804824f:	50                   	push   %eax
 8048250:	e8 50 ff ff ff       	call   80481a5 <getsize>
 8048255:	83 c4 04             	add    $0x4,%esp
 8048258:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pos+=512;
 804825b:	81 45 f4 00 02 00 00 	addl   $0x200,-0xc(%ebp)
    if (strcmp(tar_hdr.filename,name)==0) {
 8048262:	83 ec 08             	sub    $0x8,%esp
 8048265:	ff 75 08             	pushl  0x8(%ebp)
 8048268:	8d 85 47 ff ff ff    	lea    -0xb9(%ebp),%eax
 804826e:	50                   	push   %eax
 804826f:	e8 50 14 00 00       	call   80496c4 <strcmp>
 8048274:	83 c4 10             	add    $0x10,%esp
 8048277:	85 c0                	test   %eax,%eax
 8048279:	75 05                	jne    8048280 <find_loc+0x92>
      return pos;
 804827b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804827e:	eb 30                	jmp    80482b0 <find_loc+0xc2>
      break;
    }
    pos+=size;
 8048280:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048283:	01 45 f4             	add    %eax,-0xc(%ebp)
    if (pos%512!=0) {
 8048286:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048289:	25 ff 01 00 00       	and    $0x1ff,%eax
 804828e:	85 c0                	test   %eax,%eax
 8048290:	74 10                	je     80482a2 <find_loc+0xb4>
      pos+=512-(pos%512);
 8048292:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048295:	25 00 fe ff ff       	and    $0xfffffe00,%eax
 804829a:	05 00 02 00 00       	add    $0x200,%eax
 804829f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (int i=0;;i++) {
 80482a2:	ff 45 f0             	incl   -0x10(%ebp)
 80482a5:	e9 5b ff ff ff       	jmp    8048205 <find_loc+0x17>
    if (tar_hdr.filename[0]=='\0') break;
 80482aa:	90                   	nop
    }
  }
  return 0;
 80482ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
 80482b0:	c9                   	leave  
 80482b1:	c3                   	ret    

080482b2 <load_proc>:

char load_proc(size_t datapos,char* initrd) {
 80482b2:	55                   	push   %ebp
 80482b3:	89 e5                	mov    %esp,%ebp
 80482b5:	81 ec 88 00 00 00    	sub    $0x88,%esp
  int pos=0;
 80482bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  elf_header header;
  pos=datapos;
 80482c2:	8b 45 08             	mov    0x8(%ebp),%eax
 80482c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char* hdr_ptr=(char*)&header;
 80482c8:	8d 45 a0             	lea    -0x60(%ebp),%eax
 80482cb:	89 45 e0             	mov    %eax,-0x20(%ebp)
  for (size_t i=0;i<sizeof(elf_header);i++) {
 80482ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 80482d5:	eb 1a                	jmp    80482f1 <load_proc+0x3f>
    hdr_ptr[i]=initrd[pos];
 80482d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80482da:	8b 45 0c             	mov    0xc(%ebp),%eax
 80482dd:	01 d0                	add    %edx,%eax
 80482df:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 80482e2:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80482e5:	01 ca                	add    %ecx,%edx
 80482e7:	8a 00                	mov    (%eax),%al
 80482e9:	88 02                	mov    %al,(%edx)
    pos++;
 80482eb:	ff 45 f4             	incl   -0xc(%ebp)
  for (size_t i=0;i<sizeof(elf_header);i++) {
 80482ee:	ff 45 f0             	incl   -0x10(%ebp)
 80482f1:	83 7d f0 33          	cmpl   $0x33,-0x10(%ebp)
 80482f5:	76 e0                	jbe    80482d7 <load_proc+0x25>
  }
  if (header.magic!=ELF_MAGIC) {
 80482f7:	8b 45 a0             	mov    -0x60(%ebp),%eax
 80482fa:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
 80482ff:	74 07                	je     8048308 <load_proc+0x56>
    return 0;
 8048301:	b0 00                	mov    $0x0,%al
 8048303:	e9 01 01 00 00       	jmp    8048409 <load_proc+0x157>
  } else {
    void* address_space=new_address_space();
 8048308:	e8 0d 05 00 00       	call   804881a <new_address_space>
 804830d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    for (int i=0;i<header.pheader_ent_nm;i++) {
 8048310:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 8048317:	e9 c9 00 00 00       	jmp    80483e5 <load_proc+0x133>
      elf_pheader pheader;
      pos=(header.prog_hdr)+(header.pheader_ent_sz*i)+datapos;
 804831c:	8b 55 bc             	mov    -0x44(%ebp),%edx
 804831f:	66 8b 45 ca          	mov    -0x36(%ebp),%ax
 8048323:	0f b7 c0             	movzwl %ax,%eax
 8048326:	0f af 45 ec          	imul   -0x14(%ebp),%eax
 804832a:	01 c2                	add    %eax,%edx
 804832c:	8b 45 08             	mov    0x8(%ebp),%eax
 804832f:	01 d0                	add    %edx,%eax
 8048331:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char* phdr_ptr=(char*)&pheader;
 8048334:	8d 45 80             	lea    -0x80(%ebp),%eax
 8048337:	89 45 d8             	mov    %eax,-0x28(%ebp)
      for (size_t i=0;i<sizeof(elf_pheader);i++) {
 804833a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 8048341:	eb 1a                	jmp    804835d <load_proc+0xab>
        phdr_ptr[i]=initrd[pos];
 8048343:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048346:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048349:	01 d0                	add    %edx,%eax
 804834b:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 804834e:	8b 55 e8             	mov    -0x18(%ebp),%edx
 8048351:	01 ca                	add    %ecx,%edx
 8048353:	8a 00                	mov    (%eax),%al
 8048355:	88 02                	mov    %al,(%edx)
        pos++;
 8048357:	ff 45 f4             	incl   -0xc(%ebp)
      for (size_t i=0;i<sizeof(elf_pheader);i++) {
 804835a:	ff 45 e8             	incl   -0x18(%ebp)
 804835d:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%ebp)
 8048361:	76 e0                	jbe    8048343 <load_proc+0x91>
      }
      char* ptr=alloc_memory(((pheader.memsz)/4096)+1);
 8048363:	8b 45 94             	mov    -0x6c(%ebp),%eax
 8048366:	c1 e8 0c             	shr    $0xc,%eax
 8048369:	40                   	inc    %eax
 804836a:	83 ec 0c             	sub    $0xc,%esp
 804836d:	50                   	push   %eax
 804836e:	e8 66 04 00 00       	call   80487d9 <alloc_memory>
 8048373:	83 c4 10             	add    $0x10,%esp
 8048376:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      memset(ptr,0,pheader.memsz);
 8048379:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804837c:	83 ec 04             	sub    $0x4,%esp
 804837f:	50                   	push   %eax
 8048380:	6a 00                	push   $0x0
 8048382:	ff 75 d4             	pushl  -0x2c(%ebp)
 8048385:	e8 08 13 00 00       	call   8049692 <memset>
 804838a:	83 c4 10             	add    $0x10,%esp
      if (pheader.filesz>0) {
 804838d:	8b 45 90             	mov    -0x70(%ebp),%eax
 8048390:	85 c0                	test   %eax,%eax
 8048392:	74 36                	je     80483ca <load_proc+0x118>
        pos=pheader.offset+datapos;
 8048394:	8b 55 84             	mov    -0x7c(%ebp),%edx
 8048397:	8b 45 08             	mov    0x8(%ebp),%eax
 804839a:	01 d0                	add    %edx,%eax
 804839c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for (size_t i=0;i<pheader.filesz;i++) {
 804839f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 80483a6:	eb 1a                	jmp    80483c2 <load_proc+0x110>
          ptr[i]=initrd[pos];
 80483a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80483ab:	8b 45 0c             	mov    0xc(%ebp),%eax
 80483ae:	01 d0                	add    %edx,%eax
 80483b0:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 80483b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 80483b6:	01 ca                	add    %ecx,%edx
 80483b8:	8a 00                	mov    (%eax),%al
 80483ba:	88 02                	mov    %al,(%edx)
          pos++;
 80483bc:	ff 45 f4             	incl   -0xc(%ebp)
        for (size_t i=0;i<pheader.filesz;i++) {
 80483bf:	ff 45 e4             	incl   -0x1c(%ebp)
 80483c2:	8b 45 90             	mov    -0x70(%ebp),%eax
 80483c5:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
 80483c8:	72 de                	jb     80483a8 <load_proc+0xf6>
        }
      }
      copy_data(address_space,ptr,pheader.memsz,(void*)pheader.vaddr);
 80483ca:	8b 45 88             	mov    -0x78(%ebp),%eax
 80483cd:	89 c2                	mov    %eax,%edx
 80483cf:	8b 45 94             	mov    -0x6c(%ebp),%eax
 80483d2:	52                   	push   %edx
 80483d3:	50                   	push   %eax
 80483d4:	ff 75 d4             	pushl  -0x2c(%ebp)
 80483d7:	ff 75 dc             	pushl  -0x24(%ebp)
 80483da:	e8 57 04 00 00       	call   8048836 <copy_data>
 80483df:	83 c4 10             	add    $0x10,%esp
    for (int i=0;i<header.pheader_ent_nm;i++) {
 80483e2:	ff 45 ec             	incl   -0x14(%ebp)
 80483e5:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80483e8:	0f b7 c0             	movzwl %ax,%eax
 80483eb:	39 45 ec             	cmp    %eax,-0x14(%ebp)
 80483ee:	0f 8c 28 ff ff ff    	jl     804831c <load_proc+0x6a>
    }
    create_proc((void*)header.entry,address_space,NULL,NULL);
 80483f4:	8b 45 b8             	mov    -0x48(%ebp),%eax
 80483f7:	6a 00                	push   $0x0
 80483f9:	6a 00                	push   $0x0
 80483fb:	ff 75 dc             	pushl  -0x24(%ebp)
 80483fe:	50                   	push   %eax
 80483ff:	e8 11 17 00 00       	call   8049b15 <create_proc>
 8048404:	83 c4 10             	add    $0x10,%esp
  }
  return 1;
 8048407:	b0 01                	mov    $0x1,%al
}
 8048409:	c9                   	leave  
 804840a:	c3                   	ret    

0804840b <load_proc_devfs>:

char load_proc_devfs(size_t datapos) {
 804840b:	55                   	push   %ebp
 804840c:	89 e5                	mov    %esp,%ebp
 804840e:	83 ec 78             	sub    $0x78,%esp
  FILE* initrd=fopen("/dev/initrd","r");
 8048411:	83 ec 08             	sub    $0x8,%esp
 8048414:	68 b8 9e 04 08       	push   $0x8049eb8
 8048419:	68 ba 9e 04 08       	push   $0x8049eba
 804841e:	e8 8c 04 00 00       	call   80488af <fopen>
 8048423:	83 c4 10             	add    $0x10,%esp
 8048426:	89 45 f0             	mov    %eax,-0x10(%ebp)
  elf_header header;
  fseek(initrd,datapos,SEEK_SET);
 8048429:	8b 45 08             	mov    0x8(%ebp),%eax
 804842c:	83 ec 04             	sub    $0x4,%esp
 804842f:	6a 03                	push   $0x3
 8048431:	50                   	push   %eax
 8048432:	ff 75 f0             	pushl  -0x10(%ebp)
 8048435:	e8 a4 0c 00 00       	call   80490de <fseek>
 804843a:	83 c4 10             	add    $0x10,%esp
  fread(&header,sizeof(elf_header),1,initrd);
 804843d:	ff 75 f0             	pushl  -0x10(%ebp)
 8048440:	6a 01                	push   $0x1
 8048442:	6a 34                	push   $0x34
 8048444:	8d 45 b4             	lea    -0x4c(%ebp),%eax
 8048447:	50                   	push   %eax
 8048448:	e8 1a 06 00 00       	call   8048a67 <fread>
 804844d:	83 c4 10             	add    $0x10,%esp
  if (header.magic!=ELF_MAGIC) {
 8048450:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8048453:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
 8048458:	74 49                	je     80484a3 <load_proc_devfs+0x98>
    serial_print("Bad magic number (");
 804845a:	83 ec 0c             	sub    $0xc,%esp
 804845d:	68 c6 9e 04 08       	push   $0x8049ec6
 8048462:	e8 2e 03 00 00       	call   8048795 <serial_print>
 8048467:	83 c4 10             	add    $0x10,%esp
    char str[32];
    hex_to_ascii(header.magic,str);
 804846a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804846d:	83 ec 08             	sub    $0x8,%esp
 8048470:	8d 55 94             	lea    -0x6c(%ebp),%edx
 8048473:	52                   	push   %edx
 8048474:	50                   	push   %eax
 8048475:	e8 04 14 00 00       	call   804987e <hex_to_ascii>
 804847a:	83 c4 10             	add    $0x10,%esp
    serial_print(str);
 804847d:	83 ec 0c             	sub    $0xc,%esp
 8048480:	8d 45 94             	lea    -0x6c(%ebp),%eax
 8048483:	50                   	push   %eax
 8048484:	e8 0c 03 00 00       	call   8048795 <serial_print>
 8048489:	83 c4 10             	add    $0x10,%esp
    serial_print(")\n");
 804848c:	83 ec 0c             	sub    $0xc,%esp
 804848f:	68 d9 9e 04 08       	push   $0x8049ed9
 8048494:	e8 fc 02 00 00       	call   8048795 <serial_print>
 8048499:	83 c4 10             	add    $0x10,%esp
    return 0;
 804849c:	b0 00                	mov    $0x0,%al
 804849e:	e9 ea 00 00 00       	jmp    804858d <load_proc_devfs+0x182>
  } else {
    void* address_space=new_address_space();
 80484a3:	e8 72 03 00 00       	call   804881a <new_address_space>
 80484a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for (int i=0;i<header.pheader_ent_nm;i++) {
 80484ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 80484b2:	e9 b2 00 00 00       	jmp    8048569 <load_proc_devfs+0x15e>
      elf_pheader pheader;
      fseek(initrd,(header.prog_hdr)+(header.pheader_ent_sz*i)+datapos,SEEK_SET);
 80484b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
 80484ba:	66 8b 45 de          	mov    -0x22(%ebp),%ax
 80484be:	0f b7 c0             	movzwl %ax,%eax
 80484c1:	0f af 45 f4          	imul   -0xc(%ebp),%eax
 80484c5:	01 c2                	add    %eax,%edx
 80484c7:	8b 45 08             	mov    0x8(%ebp),%eax
 80484ca:	01 d0                	add    %edx,%eax
 80484cc:	83 ec 04             	sub    $0x4,%esp
 80484cf:	6a 03                	push   $0x3
 80484d1:	50                   	push   %eax
 80484d2:	ff 75 f0             	pushl  -0x10(%ebp)
 80484d5:	e8 04 0c 00 00       	call   80490de <fseek>
 80484da:	83 c4 10             	add    $0x10,%esp
      fread(&pheader,sizeof(elf_pheader),1,initrd);
 80484dd:	ff 75 f0             	pushl  -0x10(%ebp)
 80484e0:	6a 01                	push   $0x1
 80484e2:	6a 20                	push   $0x20
 80484e4:	8d 45 94             	lea    -0x6c(%ebp),%eax
 80484e7:	50                   	push   %eax
 80484e8:	e8 7a 05 00 00       	call   8048a67 <fread>
 80484ed:	83 c4 10             	add    $0x10,%esp
      char* ptr=alloc_memory(((pheader.memsz)/4096)+1);
 80484f0:	8b 45 a8             	mov    -0x58(%ebp),%eax
 80484f3:	c1 e8 0c             	shr    $0xc,%eax
 80484f6:	40                   	inc    %eax
 80484f7:	83 ec 0c             	sub    $0xc,%esp
 80484fa:	50                   	push   %eax
 80484fb:	e8 d9 02 00 00       	call   80487d9 <alloc_memory>
 8048500:	83 c4 10             	add    $0x10,%esp
 8048503:	89 45 e8             	mov    %eax,-0x18(%ebp)
      memset(ptr,0,pheader.memsz);
 8048506:	8b 45 a8             	mov    -0x58(%ebp),%eax
 8048509:	83 ec 04             	sub    $0x4,%esp
 804850c:	50                   	push   %eax
 804850d:	6a 00                	push   $0x0
 804850f:	ff 75 e8             	pushl  -0x18(%ebp)
 8048512:	e8 7b 11 00 00       	call   8049692 <memset>
 8048517:	83 c4 10             	add    $0x10,%esp
      if (pheader.filesz>0) {
 804851a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804851d:	85 c0                	test   %eax,%eax
 804851f:	74 2d                	je     804854e <load_proc_devfs+0x143>
        fseek(initrd,pheader.offset+datapos,SEEK_SET);
 8048521:	8b 55 98             	mov    -0x68(%ebp),%edx
 8048524:	8b 45 08             	mov    0x8(%ebp),%eax
 8048527:	01 d0                	add    %edx,%eax
 8048529:	83 ec 04             	sub    $0x4,%esp
 804852c:	6a 03                	push   $0x3
 804852e:	50                   	push   %eax
 804852f:	ff 75 f0             	pushl  -0x10(%ebp)
 8048532:	e8 a7 0b 00 00       	call   80490de <fseek>
 8048537:	83 c4 10             	add    $0x10,%esp
        fread(ptr,sizeof(char),pheader.filesz,initrd);
 804853a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804853d:	ff 75 f0             	pushl  -0x10(%ebp)
 8048540:	50                   	push   %eax
 8048541:	6a 01                	push   $0x1
 8048543:	ff 75 e8             	pushl  -0x18(%ebp)
 8048546:	e8 1c 05 00 00       	call   8048a67 <fread>
 804854b:	83 c4 10             	add    $0x10,%esp
      }
      copy_data(address_space,ptr,pheader.memsz,(void*)pheader.vaddr);
 804854e:	8b 45 9c             	mov    -0x64(%ebp),%eax
 8048551:	89 c2                	mov    %eax,%edx
 8048553:	8b 45 a8             	mov    -0x58(%ebp),%eax
 8048556:	52                   	push   %edx
 8048557:	50                   	push   %eax
 8048558:	ff 75 e8             	pushl  -0x18(%ebp)
 804855b:	ff 75 ec             	pushl  -0x14(%ebp)
 804855e:	e8 d3 02 00 00       	call   8048836 <copy_data>
 8048563:	83 c4 10             	add    $0x10,%esp
    for (int i=0;i<header.pheader_ent_nm;i++) {
 8048566:	ff 45 f4             	incl   -0xc(%ebp)
 8048569:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804856c:	0f b7 c0             	movzwl %ax,%eax
 804856f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 8048572:	0f 8c 3f ff ff ff    	jl     80484b7 <load_proc_devfs+0xac>
    }
    create_proc((void*)header.entry,address_space,NULL,NULL);
 8048578:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804857b:	6a 00                	push   $0x0
 804857d:	6a 00                	push   $0x0
 804857f:	ff 75 ec             	pushl  -0x14(%ebp)
 8048582:	50                   	push   %eax
 8048583:	e8 8d 15 00 00       	call   8049b15 <create_proc>
 8048588:	83 c4 10             	add    $0x10,%esp
  }
  return 1;
 804858b:	b0 01                	mov    $0x1,%al
}
 804858d:	c9                   	leave  
 804858e:	c3                   	ret    

0804858f <main>:

int main() {
 804858f:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 8048593:	83 e4 f0             	and    $0xfffffff0,%esp
 8048596:	ff 71 fc             	pushl  -0x4(%ecx)
 8048599:	55                   	push   %ebp
 804859a:	89 e5                	mov    %esp,%ebp
 804859c:	51                   	push   %ecx
 804859d:	83 ec 14             	sub    $0x14,%esp
  serial_print("Init running\n");
 80485a0:	83 ec 0c             	sub    $0xc,%esp
 80485a3:	68 dc 9e 04 08       	push   $0x8049edc
 80485a8:	e8 e8 01 00 00       	call   8048795 <serial_print>
 80485ad:	83 c4 10             	add    $0x10,%esp
  long size=initrd_sz();
 80485b0:	e8 f4 01 00 00       	call   80487a9 <initrd_sz>
 80485b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char* initrd=malloc(size);
 80485b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80485bb:	83 ec 0c             	sub    $0xc,%esp
 80485be:	50                   	push   %eax
 80485bf:	e8 97 0d 00 00       	call   804935b <malloc>
 80485c4:	83 c4 10             	add    $0x10,%esp
 80485c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  initrd_get(initrd);
 80485ca:	83 ec 0c             	sub    $0xc,%esp
 80485cd:	ff 75 f0             	pushl  -0x10(%ebp)
 80485d0:	e8 f0 01 00 00       	call   80487c5 <initrd_get>
 80485d5:	83 c4 10             	add    $0x10,%esp
  size_t datapos=find_loc("vfs",initrd);
 80485d8:	83 ec 08             	sub    $0x8,%esp
 80485db:	ff 75 f0             	pushl  -0x10(%ebp)
 80485de:	68 ea 9e 04 08       	push   $0x8049eea
 80485e3:	e8 06 fc ff ff       	call   80481ee <find_loc>
 80485e8:	83 c4 10             	add    $0x10,%esp
 80485eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  load_proc(datapos,initrd);
 80485ee:	83 ec 08             	sub    $0x8,%esp
 80485f1:	ff 75 f0             	pushl  -0x10(%ebp)
 80485f4:	ff 75 ec             	pushl  -0x14(%ebp)
 80485f7:	e8 b6 fc ff ff       	call   80482b2 <load_proc>
 80485fc:	83 c4 10             	add    $0x10,%esp
  while(rpc_is_init(2)==0);
 80485ff:	90                   	nop
 8048600:	83 ec 0c             	sub    $0xc,%esp
 8048603:	6a 02                	push   $0x2
 8048605:	e8 17 16 00 00       	call   8049c21 <rpc_is_init>
 804860a:	83 c4 10             	add    $0x10,%esp
 804860d:	84 c0                	test   %al,%al
 804860f:	74 ef                	je     8048600 <main+0x71>
  datapos=find_loc("devfs",initrd);
 8048611:	83 ec 08             	sub    $0x8,%esp
 8048614:	ff 75 f0             	pushl  -0x10(%ebp)
 8048617:	68 ee 9e 04 08       	push   $0x8049eee
 804861c:	e8 cd fb ff ff       	call   80481ee <find_loc>
 8048621:	83 c4 10             	add    $0x10,%esp
 8048624:	89 45 ec             	mov    %eax,-0x14(%ebp)
  load_proc(datapos,initrd);
 8048627:	83 ec 08             	sub    $0x8,%esp
 804862a:	ff 75 f0             	pushl  -0x10(%ebp)
 804862d:	ff 75 ec             	pushl  -0x14(%ebp)
 8048630:	e8 7d fc ff ff       	call   80482b2 <load_proc>
 8048635:	83 c4 10             	add    $0x10,%esp
  while(rpc_is_init(3)==0);
 8048638:	90                   	nop
 8048639:	83 ec 0c             	sub    $0xc,%esp
 804863c:	6a 03                	push   $0x3
 804863e:	e8 de 15 00 00       	call   8049c21 <rpc_is_init>
 8048643:	83 c4 10             	add    $0x10,%esp
 8048646:	84 c0                	test   %al,%al
 8048648:	74 ef                	je     8048639 <main+0xaa>
  int err=mount("","devfs","/dev");
 804864a:	83 ec 04             	sub    $0x4,%esp
 804864d:	68 f4 9e 04 08       	push   $0x8049ef4
 8048652:	68 ee 9e 04 08       	push   $0x8049eee
 8048657:	68 f9 9e 04 08       	push   $0x8049ef9
 804865c:	e8 58 07 00 00       	call   8048db9 <mount>
 8048661:	83 c4 10             	add    $0x10,%esp
 8048664:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if (err) {
 8048667:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804866b:	74 1a                	je     8048687 <main+0xf8>
    serial_print("Failed to mount devfs\n");
 804866d:	83 ec 0c             	sub    $0xc,%esp
 8048670:	68 fa 9e 04 08       	push   $0x8049efa
 8048675:	e8 1b 01 00 00       	call   8048795 <serial_print>
 804867a:	83 c4 10             	add    $0x10,%esp
    exit(1);
 804867d:	83 ec 0c             	sub    $0xc,%esp
 8048680:	6a 01                	push   $0x1
 8048682:	e8 ad 14 00 00       	call   8049b34 <exit>
  }
  datapos=find_loc("initrd_drv",initrd);
 8048687:	83 ec 08             	sub    $0x8,%esp
 804868a:	ff 75 f0             	pushl  -0x10(%ebp)
 804868d:	68 11 9f 04 08       	push   $0x8049f11
 8048692:	e8 57 fb ff ff       	call   80481ee <find_loc>
 8048697:	83 c4 10             	add    $0x10,%esp
 804869a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  load_proc(datapos,initrd);
 804869d:	83 ec 08             	sub    $0x8,%esp
 80486a0:	ff 75 f0             	pushl  -0x10(%ebp)
 80486a3:	ff 75 ec             	pushl  -0x14(%ebp)
 80486a6:	e8 07 fc ff ff       	call   80482b2 <load_proc>
 80486ab:	83 c4 10             	add    $0x10,%esp
  while(rpc_is_init(4)==0);
 80486ae:	90                   	nop
 80486af:	83 ec 0c             	sub    $0xc,%esp
 80486b2:	6a 04                	push   $0x4
 80486b4:	e8 68 15 00 00       	call   8049c21 <rpc_is_init>
 80486b9:	83 c4 10             	add    $0x10,%esp
 80486bc:	84 c0                	test   %al,%al
 80486be:	74 ef                	je     80486af <main+0x120>
  serial_print("Loading VGA driver\n");
 80486c0:	83 ec 0c             	sub    $0xc,%esp
 80486c3:	68 1c 9f 04 08       	push   $0x8049f1c
 80486c8:	e8 c8 00 00 00       	call   8048795 <serial_print>
 80486cd:	83 c4 10             	add    $0x10,%esp
  datapos=find_loc("vga_drv",initrd);
 80486d0:	83 ec 08             	sub    $0x8,%esp
 80486d3:	ff 75 f0             	pushl  -0x10(%ebp)
 80486d6:	68 30 9f 04 08       	push   $0x8049f30
 80486db:	e8 0e fb ff ff       	call   80481ee <find_loc>
 80486e0:	83 c4 10             	add    $0x10,%esp
 80486e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  load_proc_devfs(datapos);
 80486e6:	83 ec 0c             	sub    $0xc,%esp
 80486e9:	ff 75 ec             	pushl  -0x14(%ebp)
 80486ec:	e8 1a fd ff ff       	call   804840b <load_proc_devfs>
 80486f1:	83 c4 10             	add    $0x10,%esp
  while(rpc_is_init(5)==0);
 80486f4:	90                   	nop
 80486f5:	83 ec 0c             	sub    $0xc,%esp
 80486f8:	6a 05                	push   $0x5
 80486fa:	e8 22 15 00 00       	call   8049c21 <rpc_is_init>
 80486ff:	83 c4 10             	add    $0x10,%esp
 8048702:	84 c0                	test   %al,%al
 8048704:	74 ef                	je     80486f5 <main+0x166>
  serial_print("Opening /dev/vga\n");
 8048706:	83 ec 0c             	sub    $0xc,%esp
 8048709:	68 38 9f 04 08       	push   $0x8049f38
 804870e:	e8 82 00 00 00       	call   8048795 <serial_print>
 8048713:	83 c4 10             	add    $0x10,%esp
  stdout=fopen("/dev/vga","w");
 8048716:	83 ec 08             	sub    $0x8,%esp
 8048719:	68 4a 9f 04 08       	push   $0x8049f4a
 804871e:	68 4c 9f 04 08       	push   $0x8049f4c
 8048723:	e8 87 01 00 00       	call   80488af <fopen>
 8048728:	83 c4 10             	add    $0x10,%esp
 804872b:	a3 44 b0 04 08       	mov    %eax,0x804b044
  if (!stdout) {
 8048730:	a1 44 b0 04 08       	mov    0x804b044,%eax
 8048735:	85 c0                	test   %eax,%eax
 8048737:	75 1a                	jne    8048753 <main+0x1c4>
    serial_print("Could not open /dev/vga\n");
 8048739:	83 ec 0c             	sub    $0xc,%esp
 804873c:	68 55 9f 04 08       	push   $0x8049f55
 8048741:	e8 4f 00 00 00       	call   8048795 <serial_print>
 8048746:	83 c4 10             	add    $0x10,%esp
    exit(1);
 8048749:	83 ec 0c             	sub    $0xc,%esp
 804874c:	6a 01                	push   $0x1
 804874e:	e8 e1 13 00 00       	call   8049b34 <exit>
  }
  serial_print("Writing to screen\n");
 8048753:	83 ec 0c             	sub    $0xc,%esp
 8048756:	68 6e 9f 04 08       	push   $0x8049f6e
 804875b:	e8 35 00 00 00       	call   8048795 <serial_print>
 8048760:	83 c4 10             	add    $0x10,%esp
  puts("Puts test");
 8048763:	83 ec 0c             	sub    $0xc,%esp
 8048766:	68 81 9f 04 08       	push   $0x8049f81
 804876b:	e8 0c 04 00 00       	call   8048b7c <puts>
 8048770:	83 c4 10             	add    $0x10,%esp
  printf("Printf test with file opened to %s\n","/dev/vga");
 8048773:	83 ec 08             	sub    $0x8,%esp
 8048776:	68 4c 9f 04 08       	push   $0x8049f4c
 804877b:	68 8c 9f 04 08       	push   $0x8049f8c
 8048780:	e8 15 09 00 00       	call   804909a <printf>
 8048785:	83 c4 10             	add    $0x10,%esp
 8048788:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804878d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
 8048790:	c9                   	leave  
 8048791:	8d 61 fc             	lea    -0x4(%ecx),%esp
 8048794:	c3                   	ret    

08048795 <serial_print>:
#include <sys/syscalls.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void serial_print(char* str) {
 8048795:	55                   	push   %ebp
 8048796:	89 e5                	mov    %esp,%ebp
 8048798:	53                   	push   %ebx
  asm volatile("  \
 8048799:	8b 45 08             	mov    0x8(%ebp),%eax
 804879c:	89 c3                	mov    %eax,%ebx
 804879e:	b8 0b 00 00 00       	mov    $0xb,%eax
 80487a3:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_SERIAL_PRINT) ", %%eax; \
    int $80; \
  "::"b"(str));
}
 80487a5:	90                   	nop
 80487a6:	5b                   	pop    %ebx
 80487a7:	5d                   	pop    %ebp
 80487a8:	c3                   	ret    

080487a9 <initrd_sz>:
#include <sys/syscalls.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

long initrd_sz() {
 80487a9:	55                   	push   %ebp
 80487aa:	89 e5                	mov    %esp,%ebp
 80487ac:	53                   	push   %ebx
 80487ad:	83 ec 10             	sub    $0x10,%esp
  long size;
  asm volatile("  \
 80487b0:	b8 0c 00 00 00       	mov    $0xc,%eax
 80487b5:	cd 50                	int    $0x50
 80487b7:	89 d8                	mov    %ebx,%eax
 80487b9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_GET_INITRD_SZ) ", %%eax; \
    int $80; \
  ":"=b"(size));
  return size;
 80487bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 80487bf:	83 c4 10             	add    $0x10,%esp
 80487c2:	5b                   	pop    %ebx
 80487c3:	5d                   	pop    %ebp
 80487c4:	c3                   	ret    

080487c5 <initrd_get>:

void initrd_get(char* initrd) {
 80487c5:	55                   	push   %ebp
 80487c6:	89 e5                	mov    %esp,%ebp
 80487c8:	53                   	push   %ebx
  asm volatile("  \
 80487c9:	8b 45 08             	mov    0x8(%ebp),%eax
 80487cc:	89 c3                	mov    %eax,%ebx
 80487ce:	b8 0d 00 00 00       	mov    $0xd,%eax
 80487d3:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_COPY_INITRD) ", %%eax; \
    int $80; \
  "::"b"(initrd));
}
 80487d5:	90                   	nop
 80487d6:	5b                   	pop    %ebx
 80487d7:	5d                   	pop    %ebp
 80487d8:	c3                   	ret    

080487d9 <alloc_memory>:
#include <sys/syscalls.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void* alloc_memory(int num_pages) {
 80487d9:	55                   	push   %ebp
 80487da:	89 e5                	mov    %esp,%ebp
 80487dc:	53                   	push   %ebx
 80487dd:	83 ec 10             	sub    $0x10,%esp
  void* address;
  asm volatile("  \
 80487e0:	8b 45 08             	mov    0x8(%ebp),%eax
 80487e3:	ba 00 00 00 00       	mov    $0x0,%edx
 80487e8:	89 c3                	mov    %eax,%ebx
 80487ea:	89 d1                	mov    %edx,%ecx
 80487ec:	b8 07 00 00 00       	mov    $0x7,%eax
 80487f1:	cd 50                	int    $0x50
 80487f3:	89 d8                	mov    %ebx,%eax
 80487f5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_ALLOC_MEM) ", %%eax; \
    int $80; \
  ":"=b"(address):"b"(num_pages),"c"(NULL));
  return address;
 80487f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 80487fb:	83 c4 10             	add    $0x10,%esp
 80487fe:	5b                   	pop    %ebx
 80487ff:	5d                   	pop    %ebp
 8048800:	c3                   	ret    

08048801 <alloc_memory_virt>:

void alloc_memory_virt(int num_pages,void* addr) {
 8048801:	55                   	push   %ebp
 8048802:	89 e5                	mov    %esp,%ebp
 8048804:	53                   	push   %ebx
  asm volatile("  \
 8048805:	8b 45 08             	mov    0x8(%ebp),%eax
 8048808:	8b 55 0c             	mov    0xc(%ebp),%edx
 804880b:	89 c3                	mov    %eax,%ebx
 804880d:	89 d1                	mov    %edx,%ecx
 804880f:	b8 07 00 00 00       	mov    $0x7,%eax
 8048814:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_ALLOC_MEM) ", %%eax; \
    int $80; \
  "::"b"(num_pages),"c"(addr));
}
 8048816:	90                   	nop
 8048817:	5b                   	pop    %ebx
 8048818:	5d                   	pop    %ebp
 8048819:	c3                   	ret    

0804881a <new_address_space>:

void* new_address_space() {
 804881a:	55                   	push   %ebp
 804881b:	89 e5                	mov    %esp,%ebp
 804881d:	53                   	push   %ebx
 804881e:	83 ec 10             	sub    $0x10,%esp
  void* address_space;
  asm volatile("  \
 8048821:	b8 09 00 00 00       	mov    $0x9,%eax
 8048826:	cd 50                	int    $0x50
 8048828:	89 d8                	mov    %ebx,%eax
 804882a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_NEW_ADDR_SPACE) ", %%eax; \
    int $80; \
  ":"=b"(address_space));
  return address_space;
 804882d:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 8048830:	83 c4 10             	add    $0x10,%esp
 8048833:	5b                   	pop    %ebx
 8048834:	5d                   	pop    %ebp
 8048835:	c3                   	ret    

08048836 <copy_data>:

void copy_data(void* address_space, void* data,size_t size,void* virt_addr) {
 8048836:	55                   	push   %ebp
 8048837:	89 e5                	mov    %esp,%ebp
 8048839:	56                   	push   %esi
 804883a:	53                   	push   %ebx
  asm volatile("  \
 804883b:	8b 45 08             	mov    0x8(%ebp),%eax
 804883e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8048841:	8b 55 10             	mov    0x10(%ebp),%edx
 8048844:	8b 75 14             	mov    0x14(%ebp),%esi
 8048847:	89 c3                	mov    %eax,%ebx
 8048849:	b8 0a 00 00 00       	mov    $0xa,%eax
 804884e:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_ADDR_SPACES_COPY_DATA) ", %%eax; \
    int $80; \
  "::"b"(address_space),"c"(data),"d"(size),"S"(virt_addr));
}
 8048850:	90                   	nop
 8048851:	5b                   	pop    %ebx
 8048852:	5e                   	pop    %esi
 8048853:	5d                   	pop    %ebp
 8048854:	c3                   	ret    

08048855 <put_data>:

void* put_data(void* address_space, void* data,size_t size) {
 8048855:	55                   	push   %ebp
 8048856:	89 e5                	mov    %esp,%ebp
 8048858:	56                   	push   %esi
 8048859:	53                   	push   %ebx
 804885a:	83 ec 10             	sub    $0x10,%esp
  void* virt_addr;
  asm volatile("  \
 804885d:	8b 45 08             	mov    0x8(%ebp),%eax
 8048860:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8048863:	8b 55 10             	mov    0x10(%ebp),%edx
 8048866:	be 00 00 00 00       	mov    $0x0,%esi
 804886b:	89 c3                	mov    %eax,%ebx
 804886d:	b8 0a 00 00 00       	mov    $0xa,%eax
 8048872:	cd 50                	int    $0x50
 8048874:	89 d8                	mov    %ebx,%eax
 8048876:	89 45 f4             	mov    %eax,-0xc(%ebp)
    mov $" QU(SYSCALL_ADDR_SPACES_COPY_DATA) ", %%eax; \
    int $80; \
  ":"=b"(virt_addr):"b"(address_space),"c"(data),"d"(size),"S"(NULL));
  return virt_addr;
 8048879:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804887c:	83 c4 10             	add    $0x10,%esp
 804887f:	5b                   	pop    %ebx
 8048880:	5e                   	pop    %esi
 8048881:	5d                   	pop    %ebp
 8048882:	c3                   	ret    

08048883 <map_phys>:

void* map_phys(void* phys_addr,size_t num_pages) {
 8048883:	55                   	push   %ebp
 8048884:	89 e5                	mov    %esp,%ebp
 8048886:	53                   	push   %ebx
 8048887:	83 ec 10             	sub    $0x10,%esp
  void* virt_addr;
  asm volatile("  \
 804888a:	8b 45 08             	mov    0x8(%ebp),%eax
 804888d:	8b 55 0c             	mov    0xc(%ebp),%edx
 8048890:	89 c3                	mov    %eax,%ebx
 8048892:	89 d1                	mov    %edx,%ecx
 8048894:	b8 08 00 00 00       	mov    $0x8,%eax
 8048899:	cd 50                	int    $0x50
 804889b:	89 d8                	mov    %ebx,%eax
 804889d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_PRIV_MAP_PAGES) ", %%eax; \
    int $80; \
  ":"=b"(virt_addr):"b"(phys_addr),"c"(num_pages));
  return virt_addr;
 80488a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 80488a3:	83 c4 10             	add    $0x10,%esp
 80488a6:	5b                   	pop    %ebx
 80488a7:	5d                   	pop    %ebp
 80488a8:	c3                   	ret    

080488a9 <__stdio_init>:

/** 
 * Initialize stdio.
 * Must not be called by user code.
*/
void __stdio_init() {
 80488a9:	55                   	push   %ebp
 80488aa:	89 e5                	mov    %esp,%ebp
}
 80488ac:	90                   	nop
 80488ad:	5d                   	pop    %ebp
 80488ae:	c3                   	ret    

080488af <fopen>:

FILE* fopen(char* filename,char* mode) {
 80488af:	55                   	push   %ebp
 80488b0:	89 e5                	mov    %esp,%ebp
 80488b2:	83 ec 28             	sub    $0x28,%esp
  serdes_state state={0};
 80488b5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 80488bc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  serialize_str(filename,&state);
 80488c3:	83 ec 0c             	sub    $0xc,%esp
 80488c6:	ff 75 08             	pushl  0x8(%ebp)
 80488c9:	e8 55 0e 00 00       	call   8049723 <strlen>
 80488ce:	83 c4 10             	add    $0x10,%esp
 80488d1:	40                   	inc    %eax
 80488d2:	89 c2                	mov    %eax,%edx
 80488d4:	83 ec 08             	sub    $0x8,%esp
 80488d7:	8d 45 dc             	lea    -0x24(%ebp),%eax
 80488da:	50                   	push   %eax
 80488db:	52                   	push   %edx
 80488dc:	e8 61 13 00 00       	call   8049c42 <serialize_int>
 80488e1:	83 c4 10             	add    $0x10,%esp
 80488e4:	83 ec 0c             	sub    $0xc,%esp
 80488e7:	ff 75 08             	pushl  0x8(%ebp)
 80488ea:	e8 34 0e 00 00       	call   8049723 <strlen>
 80488ef:	83 c4 10             	add    $0x10,%esp
 80488f2:	8d 50 01             	lea    0x1(%eax),%edx
 80488f5:	83 ec 04             	sub    $0x4,%esp
 80488f8:	8d 45 dc             	lea    -0x24(%ebp),%eax
 80488fb:	50                   	push   %eax
 80488fc:	52                   	push   %edx
 80488fd:	ff 75 08             	pushl  0x8(%ebp)
 8048900:	e8 d1 13 00 00       	call   8049cd6 <serialize_ary>
 8048905:	83 c4 10             	add    $0x10,%esp
  void* retval=rpc_call(2,"open",state.buf,state.sizeorpos);
 8048908:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804890b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804890e:	52                   	push   %edx
 804890f:	50                   	push   %eax
 8048910:	68 b0 9f 04 08       	push   $0x8049fb0
 8048915:	6a 02                	push   $0x2
 8048917:	e8 7f 12 00 00       	call   8049b9b <rpc_call>
 804891c:	83 c4 10             	add    $0x10,%esp
 804891f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  free(state.buf);
 8048922:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048925:	83 ec 0c             	sub    $0xc,%esp
 8048928:	50                   	push   %eax
 8048929:	e8 91 0c 00 00       	call   80495bf <free>
 804892e:	83 c4 10             	add    $0x10,%esp
  start_deserialize(retval,&state);
 8048931:	83 ec 08             	sub    $0x8,%esp
 8048934:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048937:	50                   	push   %eax
 8048938:	ff 75 f4             	pushl  -0xc(%ebp)
 804893b:	e8 f1 13 00 00       	call   8049d31 <start_deserialize>
 8048940:	83 c4 10             	add    $0x10,%esp
  int err=deserialize_int(&state);
 8048943:	83 ec 0c             	sub    $0xc,%esp
 8048946:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048949:	50                   	push   %eax
 804894a:	e8 fa 13 00 00       	call   8049d49 <deserialize_int>
 804894f:	83 c4 10             	add    $0x10,%esp
 8048952:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void* fs_data=deserialize_ptr(&state);
 8048955:	83 ec 0c             	sub    $0xc,%esp
 8048958:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804895b:	50                   	push   %eax
 804895c:	e8 14 14 00 00       	call   8049d75 <deserialize_ptr>
 8048961:	83 c4 10             	add    $0x10,%esp
 8048964:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pid_t fs_pid=deserialize_int(&state);
 8048967:	83 ec 0c             	sub    $0xc,%esp
 804896a:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804896d:	50                   	push   %eax
 804896e:	e8 d6 13 00 00       	call   8049d49 <deserialize_int>
 8048973:	83 c4 10             	add    $0x10,%esp
 8048976:	89 45 e8             	mov    %eax,-0x18(%ebp)
  rpc_deallocate_buf(retval,state.sizeorpos);
 8048979:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804897c:	83 ec 08             	sub    $0x8,%esp
 804897f:	50                   	push   %eax
 8048980:	ff 75 f4             	pushl  -0xc(%ebp)
 8048983:	e8 5a 12 00 00       	call   8049be2 <rpc_deallocate_buf>
 8048988:	83 c4 10             	add    $0x10,%esp
  if (err) {
 804898b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804898f:	74 07                	je     8048998 <fopen+0xe9>
    return NULL;
 8048991:	b8 00 00 00 00       	mov    $0x0,%eax
 8048996:	eb 2e                	jmp    80489c6 <fopen+0x117>
  } else {
    FILE* file=malloc(sizeof(FILE));
 8048998:	83 ec 0c             	sub    $0xc,%esp
 804899b:	6a 0c                	push   $0xc
 804899d:	e8 b9 09 00 00       	call   804935b <malloc>
 80489a2:	83 c4 10             	add    $0x10,%esp
 80489a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    file->fs_pid=fs_pid;
 80489a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80489ab:	8b 55 e8             	mov    -0x18(%ebp),%edx
 80489ae:	89 10                	mov    %edx,(%eax)
    file->fs_data=fs_data;
 80489b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80489b3:	8b 55 ec             	mov    -0x14(%ebp),%edx
 80489b6:	89 50 04             	mov    %edx,0x4(%eax)
    file->pos=0;
 80489b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80489bc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return file;
 80489c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  }
}
 80489c6:	c9                   	leave  
 80489c7:	c3                   	ret    

080489c8 <fputc>:
 * \param stream The stream to write to
 * \returns the written character, or EOF on failure
*/
int putc(int c, FILE* stream) __attribute__ ((alias ("fputc")));

int fputc(int c, FILE* stream) {
 80489c8:	55                   	push   %ebp
 80489c9:	89 e5                	mov    %esp,%ebp
 80489cb:	83 ec 18             	sub    $0x18,%esp
  char str[]={c,'\0'};
 80489ce:	8b 45 08             	mov    0x8(%ebp),%eax
 80489d1:	88 45 f6             	mov    %al,-0xa(%ebp)
 80489d4:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (fputs(str,stream)==0) {
 80489d8:	83 ec 08             	sub    $0x8,%esp
 80489db:	ff 75 0c             	pushl  0xc(%ebp)
 80489de:	8d 45 f6             	lea    -0xa(%ebp),%eax
 80489e1:	50                   	push   %eax
 80489e2:	e8 25 02 00 00       	call   8048c0c <fputs>
 80489e7:	83 c4 10             	add    $0x10,%esp
 80489ea:	85 c0                	test   %eax,%eax
 80489ec:	75 07                	jne    80489f5 <fputc+0x2d>
    return EOF;
 80489ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80489f3:	eb 03                	jmp    80489f8 <fputc+0x30>
  } else {
    return c;
 80489f5:	8b 45 08             	mov    0x8(%ebp),%eax
  }
  return EOF;
}
 80489f8:	c9                   	leave  
 80489f9:	c3                   	ret    

080489fa <fgetc>:
 * \param stream The file to read from
 * \returns the read character, or EOF if the read fails
*/
int getc(FILE* stream) __attribute__ ((alias ("fgetc"))); 

int fgetc(FILE* stream) {
 80489fa:	55                   	push   %ebp
 80489fb:	89 e5                	mov    %esp,%ebp
 80489fd:	83 ec 18             	sub    $0x18,%esp
  char c[2];
  if (fgets(&c[0],1,stream)==NULL) {
 8048a00:	83 ec 04             	sub    $0x4,%esp
 8048a03:	ff 75 08             	pushl  0x8(%ebp)
 8048a06:	6a 01                	push   $0x1
 8048a08:	8d 45 f6             	lea    -0xa(%ebp),%eax
 8048a0b:	50                   	push   %eax
 8048a0c:	e8 37 00 00 00       	call   8048a48 <fgets>
 8048a11:	83 c4 10             	add    $0x10,%esp
 8048a14:	85 c0                	test   %eax,%eax
 8048a16:	75 07                	jne    8048a1f <fgetc+0x25>
    return EOF;
 8048a18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048a1d:	eb 06                	jmp    8048a25 <fgetc+0x2b>
  } else {
    return c[0];
 8048a1f:	8a 45 f6             	mov    -0xa(%ebp),%al
 8048a22:	0f be c0             	movsbl %al,%eax
  }
  return EOF;
}
 8048a25:	c9                   	leave  
 8048a26:	c3                   	ret    

08048a27 <gets>:

char* gets(char* s) {
 8048a27:	55                   	push   %ebp
 8048a28:	89 e5                	mov    %esp,%ebp
 8048a2a:	83 ec 08             	sub    $0x8,%esp
  return fgets(s,INT_MAX,stdin);
 8048a2d:	a1 40 b0 04 08       	mov    0x804b040,%eax
 8048a32:	83 ec 04             	sub    $0x4,%esp
 8048a35:	50                   	push   %eax
 8048a36:	68 ff ff ff 7f       	push   $0x7fffffff
 8048a3b:	ff 75 08             	pushl  0x8(%ebp)
 8048a3e:	e8 05 00 00 00       	call   8048a48 <fgets>
 8048a43:	83 c4 10             	add    $0x10,%esp
}
 8048a46:	c9                   	leave  
 8048a47:	c3                   	ret    

08048a48 <fgets>:

char* fgets(char* str,int count,FILE* stream) {
 8048a48:	55                   	push   %ebp
 8048a49:	89 e5                	mov    %esp,%ebp
 8048a4b:	83 ec 08             	sub    $0x8,%esp
  fread(str,1,count,stream);
 8048a4e:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048a51:	ff 75 10             	pushl  0x10(%ebp)
 8048a54:	50                   	push   %eax
 8048a55:	6a 01                	push   $0x1
 8048a57:	ff 75 08             	pushl  0x8(%ebp)
 8048a5a:	e8 08 00 00 00       	call   8048a67 <fread>
 8048a5f:	83 c4 10             	add    $0x10,%esp
  return str;
 8048a62:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8048a65:	c9                   	leave  
 8048a66:	c3                   	ret    

08048a67 <fread>:

size_t fread(void* buffer_ptr,size_t size,size_t count,FILE* stream) {
 8048a67:	55                   	push   %ebp
 8048a68:	89 e5                	mov    %esp,%ebp
 8048a6a:	83 ec 28             	sub    $0x28,%esp
  serdes_state state={0};
 8048a6d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 8048a74:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  serialize_ptr(stream->fs_data,&state);
 8048a7b:	8b 45 14             	mov    0x14(%ebp),%eax
 8048a7e:	8b 40 04             	mov    0x4(%eax),%eax
 8048a81:	83 ec 08             	sub    $0x8,%esp
 8048a84:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 8048a87:	52                   	push   %edx
 8048a88:	50                   	push   %eax
 8048a89:	e8 fe 11 00 00       	call   8049c8c <serialize_ptr>
 8048a8e:	83 c4 10             	add    $0x10,%esp
  serialize_int(size*count,&state);
 8048a91:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048a94:	0f af 45 10          	imul   0x10(%ebp),%eax
 8048a98:	89 c2                	mov    %eax,%edx
 8048a9a:	83 ec 08             	sub    $0x8,%esp
 8048a9d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048aa0:	50                   	push   %eax
 8048aa1:	52                   	push   %edx
 8048aa2:	e8 9b 11 00 00       	call   8049c42 <serialize_int>
 8048aa7:	83 c4 10             	add    $0x10,%esp
  serialize_int(stream->pos,&state);
 8048aaa:	8b 45 14             	mov    0x14(%ebp),%eax
 8048aad:	8b 40 08             	mov    0x8(%eax),%eax
 8048ab0:	83 ec 08             	sub    $0x8,%esp
 8048ab3:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 8048ab6:	52                   	push   %edx
 8048ab7:	50                   	push   %eax
 8048ab8:	e8 85 11 00 00       	call   8049c42 <serialize_int>
 8048abd:	83 c4 10             	add    $0x10,%esp
  void* retbuf=rpc_call(stream->fs_pid,"read",state.buf,state.sizeorpos);
 8048ac0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 8048ac3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8048ac6:	8b 45 14             	mov    0x14(%ebp),%eax
 8048ac9:	8b 00                	mov    (%eax),%eax
 8048acb:	51                   	push   %ecx
 8048acc:	52                   	push   %edx
 8048acd:	68 b5 9f 04 08       	push   $0x8049fb5
 8048ad2:	50                   	push   %eax
 8048ad3:	e8 c3 10 00 00       	call   8049b9b <rpc_call>
 8048ad8:	83 c4 10             	add    $0x10,%esp
 8048adb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  free(state.buf);
 8048ade:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048ae1:	83 ec 0c             	sub    $0xc,%esp
 8048ae4:	50                   	push   %eax
 8048ae5:	e8 d5 0a 00 00       	call   80495bf <free>
 8048aea:	83 c4 10             	add    $0x10,%esp
  state.buf=NULL;
 8048aed:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  state.sizeorpos=0;
 8048af4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  start_deserialize(retbuf,&state);
 8048afb:	83 ec 08             	sub    $0x8,%esp
 8048afe:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048b01:	50                   	push   %eax
 8048b02:	ff 75 f4             	pushl  -0xc(%ebp)
 8048b05:	e8 27 12 00 00       	call   8049d31 <start_deserialize>
 8048b0a:	83 c4 10             	add    $0x10,%esp
  int bytes_read=deserialize_int(&state);
 8048b0d:	83 ec 0c             	sub    $0xc,%esp
 8048b10:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048b13:	50                   	push   %eax
 8048b14:	e8 30 12 00 00       	call   8049d49 <deserialize_int>
 8048b19:	83 c4 10             	add    $0x10,%esp
 8048b1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (bytes_read) {
 8048b1f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 8048b23:	74 2f                	je     8048b54 <fread+0xed>
    void* ary=deserialize_ary(bytes_read,&state);
 8048b25:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048b28:	83 ec 08             	sub    $0x8,%esp
 8048b2b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 8048b2e:	52                   	push   %edx
 8048b2f:	50                   	push   %eax
 8048b30:	e8 6c 12 00 00       	call   8049da1 <deserialize_ary>
 8048b35:	83 c4 10             	add    $0x10,%esp
 8048b38:	89 45 ec             	mov    %eax,-0x14(%ebp)
    memcpy(buffer_ptr,ary,size*count);
 8048b3b:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048b3e:	0f af 45 10          	imul   0x10(%ebp),%eax
 8048b42:	83 ec 04             	sub    $0x4,%esp
 8048b45:	50                   	push   %eax
 8048b46:	ff 75 ec             	pushl  -0x14(%ebp)
 8048b49:	ff 75 08             	pushl  0x8(%ebp)
 8048b4c:	e8 02 0b 00 00       	call   8049653 <memcpy>
 8048b51:	83 c4 10             	add    $0x10,%esp
  }
  rpc_deallocate_buf(retbuf,state.sizeorpos);
 8048b54:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048b57:	83 ec 08             	sub    $0x8,%esp
 8048b5a:	50                   	push   %eax
 8048b5b:	ff 75 f4             	pushl  -0xc(%ebp)
 8048b5e:	e8 7f 10 00 00       	call   8049be2 <rpc_deallocate_buf>
 8048b63:	83 c4 10             	add    $0x10,%esp
  stream->pos+=bytes_read;
 8048b66:	8b 45 14             	mov    0x14(%ebp),%eax
 8048b69:	8b 50 08             	mov    0x8(%eax),%edx
 8048b6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048b6f:	01 c2                	add    %eax,%edx
 8048b71:	8b 45 14             	mov    0x14(%ebp),%eax
 8048b74:	89 50 08             	mov    %edx,0x8(%eax)
  return bytes_read;
 8048b77:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048b7a:	c9                   	leave  
 8048b7b:	c3                   	ret    

08048b7c <puts>:

int puts(const char *s) {
 8048b7c:	55                   	push   %ebp
 8048b7d:	89 e5                	mov    %esp,%ebp
 8048b7f:	83 ec 18             	sub    $0x18,%esp
  char* str=malloc(sizeof(char)*(strlen(s)+2));
 8048b82:	83 ec 0c             	sub    $0xc,%esp
 8048b85:	ff 75 08             	pushl  0x8(%ebp)
 8048b88:	e8 96 0b 00 00       	call   8049723 <strlen>
 8048b8d:	83 c4 10             	add    $0x10,%esp
 8048b90:	83 c0 02             	add    $0x2,%eax
 8048b93:	83 ec 0c             	sub    $0xc,%esp
 8048b96:	50                   	push   %eax
 8048b97:	e8 bf 07 00 00       	call   804935b <malloc>
 8048b9c:	83 c4 10             	add    $0x10,%esp
 8048b9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  strcpy(str,s);
 8048ba2:	83 ec 08             	sub    $0x8,%esp
 8048ba5:	ff 75 08             	pushl  0x8(%ebp)
 8048ba8:	ff 75 f4             	pushl  -0xc(%ebp)
 8048bab:	e8 98 0b 00 00       	call   8049748 <strcpy>
 8048bb0:	83 c4 10             	add    $0x10,%esp
  str[strlen(s)]='\n';
 8048bb3:	83 ec 0c             	sub    $0xc,%esp
 8048bb6:	ff 75 08             	pushl  0x8(%ebp)
 8048bb9:	e8 65 0b 00 00       	call   8049723 <strlen>
 8048bbe:	83 c4 10             	add    $0x10,%esp
 8048bc1:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048bc4:	01 d0                	add    %edx,%eax
 8048bc6:	c6 00 0a             	movb   $0xa,(%eax)
  str[strlen(s)+1]='\0';
 8048bc9:	83 ec 0c             	sub    $0xc,%esp
 8048bcc:	ff 75 08             	pushl  0x8(%ebp)
 8048bcf:	e8 4f 0b 00 00       	call   8049723 <strlen>
 8048bd4:	83 c4 10             	add    $0x10,%esp
 8048bd7:	8d 50 01             	lea    0x1(%eax),%edx
 8048bda:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048bdd:	01 d0                	add    %edx,%eax
 8048bdf:	c6 00 00             	movb   $0x0,(%eax)
  int code=fputs(str,stdout);
 8048be2:	a1 44 b0 04 08       	mov    0x804b044,%eax
 8048be7:	83 ec 08             	sub    $0x8,%esp
 8048bea:	50                   	push   %eax
 8048beb:	ff 75 f4             	pushl  -0xc(%ebp)
 8048bee:	e8 19 00 00 00       	call   8048c0c <fputs>
 8048bf3:	83 c4 10             	add    $0x10,%esp
 8048bf6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  free(str);
 8048bf9:	83 ec 0c             	sub    $0xc,%esp
 8048bfc:	ff 75 f4             	pushl  -0xc(%ebp)
 8048bff:	e8 bb 09 00 00       	call   80495bf <free>
 8048c04:	83 c4 10             	add    $0x10,%esp
  return code;
 8048c07:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048c0a:	c9                   	leave  
 8048c0b:	c3                   	ret    

08048c0c <fputs>:

int fputs(const char* s, FILE* stream) {
 8048c0c:	55                   	push   %ebp
 8048c0d:	89 e5                	mov    %esp,%ebp
 8048c0f:	83 ec 18             	sub    $0x18,%esp
  size_t retval=fwrite((void*)s,strlen(s),1,stream);
 8048c12:	83 ec 0c             	sub    $0xc,%esp
 8048c15:	ff 75 08             	pushl  0x8(%ebp)
 8048c18:	e8 06 0b 00 00       	call   8049723 <strlen>
 8048c1d:	83 c4 10             	add    $0x10,%esp
 8048c20:	ff 75 0c             	pushl  0xc(%ebp)
 8048c23:	6a 01                	push   $0x1
 8048c25:	50                   	push   %eax
 8048c26:	ff 75 08             	pushl  0x8(%ebp)
 8048c29:	e8 1a 00 00 00       	call   8048c48 <fwrite>
 8048c2e:	83 c4 10             	add    $0x10,%esp
 8048c31:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (retval==0) {
 8048c34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8048c38:	75 07                	jne    8048c41 <fputs+0x35>
    return 0;
 8048c3a:	b8 00 00 00 00       	mov    $0x0,%eax
 8048c3f:	eb 05                	jmp    8048c46 <fputs+0x3a>
  } else {
    return EOF;
 8048c41:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
}
 8048c46:	c9                   	leave  
 8048c47:	c3                   	ret    

08048c48 <fwrite>:

size_t fwrite(void* buffer_ptr,size_t size,size_t count,FILE* stream) {
 8048c48:	55                   	push   %ebp
 8048c49:	89 e5                	mov    %esp,%ebp
 8048c4b:	83 ec 18             	sub    $0x18,%esp
  serdes_state state={0};
 8048c4e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 8048c55:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  serialize_ptr(stream->fs_data,&state);
 8048c5c:	8b 45 14             	mov    0x14(%ebp),%eax
 8048c5f:	8b 40 04             	mov    0x4(%eax),%eax
 8048c62:	83 ec 08             	sub    $0x8,%esp
 8048c65:	8d 55 e8             	lea    -0x18(%ebp),%edx
 8048c68:	52                   	push   %edx
 8048c69:	50                   	push   %eax
 8048c6a:	e8 1d 10 00 00       	call   8049c8c <serialize_ptr>
 8048c6f:	83 c4 10             	add    $0x10,%esp
  serialize_int(size*count,&state);
 8048c72:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048c75:	0f af 45 10          	imul   0x10(%ebp),%eax
 8048c79:	89 c2                	mov    %eax,%edx
 8048c7b:	83 ec 08             	sub    $0x8,%esp
 8048c7e:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048c81:	50                   	push   %eax
 8048c82:	52                   	push   %edx
 8048c83:	e8 ba 0f 00 00       	call   8049c42 <serialize_int>
 8048c88:	83 c4 10             	add    $0x10,%esp
  serialize_int(stream->pos,&state);
 8048c8b:	8b 45 14             	mov    0x14(%ebp),%eax
 8048c8e:	8b 40 08             	mov    0x8(%eax),%eax
 8048c91:	83 ec 08             	sub    $0x8,%esp
 8048c94:	8d 55 e8             	lea    -0x18(%ebp),%edx
 8048c97:	52                   	push   %edx
 8048c98:	50                   	push   %eax
 8048c99:	e8 a4 0f 00 00       	call   8049c42 <serialize_int>
 8048c9e:	83 c4 10             	add    $0x10,%esp
  serialize_ary(buffer_ptr,size*count,&state);
 8048ca1:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048ca4:	0f af 45 10          	imul   0x10(%ebp),%eax
 8048ca8:	83 ec 04             	sub    $0x4,%esp
 8048cab:	8d 55 e8             	lea    -0x18(%ebp),%edx
 8048cae:	52                   	push   %edx
 8048caf:	50                   	push   %eax
 8048cb0:	ff 75 08             	pushl  0x8(%ebp)
 8048cb3:	e8 1e 10 00 00       	call   8049cd6 <serialize_ary>
 8048cb8:	83 c4 10             	add    $0x10,%esp
  void* retbuf=rpc_call(stream->fs_pid,"write",state.buf,state.sizeorpos);
 8048cbb:	8b 4d ec             	mov    -0x14(%ebp),%ecx
 8048cbe:	8b 55 e8             	mov    -0x18(%ebp),%edx
 8048cc1:	8b 45 14             	mov    0x14(%ebp),%eax
 8048cc4:	8b 00                	mov    (%eax),%eax
 8048cc6:	51                   	push   %ecx
 8048cc7:	52                   	push   %edx
 8048cc8:	68 ba 9f 04 08       	push   $0x8049fba
 8048ccd:	50                   	push   %eax
 8048cce:	e8 c8 0e 00 00       	call   8049b9b <rpc_call>
 8048cd3:	83 c4 10             	add    $0x10,%esp
 8048cd6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  free(state.buf);
 8048cd9:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048cdc:	83 ec 0c             	sub    $0xc,%esp
 8048cdf:	50                   	push   %eax
 8048ce0:	e8 da 08 00 00       	call   80495bf <free>
 8048ce5:	83 c4 10             	add    $0x10,%esp
  start_deserialize(retbuf,&state);
 8048ce8:	83 ec 08             	sub    $0x8,%esp
 8048ceb:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048cee:	50                   	push   %eax
 8048cef:	ff 75 f4             	pushl  -0xc(%ebp)
 8048cf2:	e8 3a 10 00 00       	call   8049d31 <start_deserialize>
 8048cf7:	83 c4 10             	add    $0x10,%esp
  int bytes_wrote=deserialize_int(&state);
 8048cfa:	83 ec 0c             	sub    $0xc,%esp
 8048cfd:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048d00:	50                   	push   %eax
 8048d01:	e8 43 10 00 00       	call   8049d49 <deserialize_int>
 8048d06:	83 c4 10             	add    $0x10,%esp
 8048d09:	89 45 f0             	mov    %eax,-0x10(%ebp)
  rpc_deallocate_buf(retbuf,state.sizeorpos);
 8048d0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8048d0f:	83 ec 08             	sub    $0x8,%esp
 8048d12:	50                   	push   %eax
 8048d13:	ff 75 f4             	pushl  -0xc(%ebp)
 8048d16:	e8 c7 0e 00 00       	call   8049be2 <rpc_deallocate_buf>
 8048d1b:	83 c4 10             	add    $0x10,%esp
  stream->pos+=bytes_wrote;
 8048d1e:	8b 45 14             	mov    0x14(%ebp),%eax
 8048d21:	8b 50 08             	mov    0x8(%eax),%edx
 8048d24:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048d27:	01 c2                	add    %eax,%edx
 8048d29:	8b 45 14             	mov    0x14(%ebp),%eax
 8048d2c:	89 50 08             	mov    %edx,0x8(%eax)
  return bytes_wrote;
 8048d2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048d32:	c9                   	leave  
 8048d33:	c3                   	ret    

08048d34 <register_fs>:

void register_fs(const char* name,pid_t pid) {
 8048d34:	55                   	push   %ebp
 8048d35:	89 e5                	mov    %esp,%ebp
 8048d37:	83 ec 18             	sub    $0x18,%esp
  serdes_state state={0};
 8048d3a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 8048d41:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  serialize_str((char*)name,&state);
 8048d48:	83 ec 0c             	sub    $0xc,%esp
 8048d4b:	ff 75 08             	pushl  0x8(%ebp)
 8048d4e:	e8 d0 09 00 00       	call   8049723 <strlen>
 8048d53:	83 c4 10             	add    $0x10,%esp
 8048d56:	40                   	inc    %eax
 8048d57:	89 c2                	mov    %eax,%edx
 8048d59:	83 ec 08             	sub    $0x8,%esp
 8048d5c:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8048d5f:	50                   	push   %eax
 8048d60:	52                   	push   %edx
 8048d61:	e8 dc 0e 00 00       	call   8049c42 <serialize_int>
 8048d66:	83 c4 10             	add    $0x10,%esp
 8048d69:	83 ec 0c             	sub    $0xc,%esp
 8048d6c:	ff 75 08             	pushl  0x8(%ebp)
 8048d6f:	e8 af 09 00 00       	call   8049723 <strlen>
 8048d74:	83 c4 10             	add    $0x10,%esp
 8048d77:	8d 50 01             	lea    0x1(%eax),%edx
 8048d7a:	83 ec 04             	sub    $0x4,%esp
 8048d7d:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8048d80:	50                   	push   %eax
 8048d81:	52                   	push   %edx
 8048d82:	ff 75 08             	pushl  0x8(%ebp)
 8048d85:	e8 4c 0f 00 00       	call   8049cd6 <serialize_ary>
 8048d8a:	83 c4 10             	add    $0x10,%esp
  serialize_int(pid,&state);
 8048d8d:	83 ec 08             	sub    $0x8,%esp
 8048d90:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8048d93:	50                   	push   %eax
 8048d94:	ff 75 0c             	pushl  0xc(%ebp)
 8048d97:	e8 a6 0e 00 00       	call   8049c42 <serialize_int>
 8048d9c:	83 c4 10             	add    $0x10,%esp
  rpc_call(2,"register_fs",state.buf,state.sizeorpos);
 8048d9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048da2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048da5:	52                   	push   %edx
 8048da6:	50                   	push   %eax
 8048da7:	68 c0 9f 04 08       	push   $0x8049fc0
 8048dac:	6a 02                	push   $0x2
 8048dae:	e8 e8 0d 00 00       	call   8049b9b <rpc_call>
 8048db3:	83 c4 10             	add    $0x10,%esp
}
 8048db6:	90                   	nop
 8048db7:	c9                   	leave  
 8048db8:	c3                   	ret    

08048db9 <mount>:

int mount(char* file,char* type,char* path) {
 8048db9:	55                   	push   %ebp
 8048dba:	89 e5                	mov    %esp,%ebp
 8048dbc:	83 ec 18             	sub    $0x18,%esp
  serdes_state state={0};
 8048dbf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 8048dc6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  serialize_str(type,&state);
 8048dcd:	83 ec 0c             	sub    $0xc,%esp
 8048dd0:	ff 75 0c             	pushl  0xc(%ebp)
 8048dd3:	e8 4b 09 00 00       	call   8049723 <strlen>
 8048dd8:	83 c4 10             	add    $0x10,%esp
 8048ddb:	40                   	inc    %eax
 8048ddc:	89 c2                	mov    %eax,%edx
 8048dde:	83 ec 08             	sub    $0x8,%esp
 8048de1:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8048de4:	50                   	push   %eax
 8048de5:	52                   	push   %edx
 8048de6:	e8 57 0e 00 00       	call   8049c42 <serialize_int>
 8048deb:	83 c4 10             	add    $0x10,%esp
 8048dee:	83 ec 0c             	sub    $0xc,%esp
 8048df1:	ff 75 0c             	pushl  0xc(%ebp)
 8048df4:	e8 2a 09 00 00       	call   8049723 <strlen>
 8048df9:	83 c4 10             	add    $0x10,%esp
 8048dfc:	8d 50 01             	lea    0x1(%eax),%edx
 8048dff:	83 ec 04             	sub    $0x4,%esp
 8048e02:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8048e05:	50                   	push   %eax
 8048e06:	52                   	push   %edx
 8048e07:	ff 75 0c             	pushl  0xc(%ebp)
 8048e0a:	e8 c7 0e 00 00       	call   8049cd6 <serialize_ary>
 8048e0f:	83 c4 10             	add    $0x10,%esp
  serialize_str(file,&state);
 8048e12:	83 ec 0c             	sub    $0xc,%esp
 8048e15:	ff 75 08             	pushl  0x8(%ebp)
 8048e18:	e8 06 09 00 00       	call   8049723 <strlen>
 8048e1d:	83 c4 10             	add    $0x10,%esp
 8048e20:	40                   	inc    %eax
 8048e21:	89 c2                	mov    %eax,%edx
 8048e23:	83 ec 08             	sub    $0x8,%esp
 8048e26:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8048e29:	50                   	push   %eax
 8048e2a:	52                   	push   %edx
 8048e2b:	e8 12 0e 00 00       	call   8049c42 <serialize_int>
 8048e30:	83 c4 10             	add    $0x10,%esp
 8048e33:	83 ec 0c             	sub    $0xc,%esp
 8048e36:	ff 75 08             	pushl  0x8(%ebp)
 8048e39:	e8 e5 08 00 00       	call   8049723 <strlen>
 8048e3e:	83 c4 10             	add    $0x10,%esp
 8048e41:	8d 50 01             	lea    0x1(%eax),%edx
 8048e44:	83 ec 04             	sub    $0x4,%esp
 8048e47:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8048e4a:	50                   	push   %eax
 8048e4b:	52                   	push   %edx
 8048e4c:	ff 75 08             	pushl  0x8(%ebp)
 8048e4f:	e8 82 0e 00 00       	call   8049cd6 <serialize_ary>
 8048e54:	83 c4 10             	add    $0x10,%esp
  serialize_str(path,&state);
 8048e57:	83 ec 0c             	sub    $0xc,%esp
 8048e5a:	ff 75 10             	pushl  0x10(%ebp)
 8048e5d:	e8 c1 08 00 00       	call   8049723 <strlen>
 8048e62:	83 c4 10             	add    $0x10,%esp
 8048e65:	40                   	inc    %eax
 8048e66:	89 c2                	mov    %eax,%edx
 8048e68:	83 ec 08             	sub    $0x8,%esp
 8048e6b:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8048e6e:	50                   	push   %eax
 8048e6f:	52                   	push   %edx
 8048e70:	e8 cd 0d 00 00       	call   8049c42 <serialize_int>
 8048e75:	83 c4 10             	add    $0x10,%esp
 8048e78:	83 ec 0c             	sub    $0xc,%esp
 8048e7b:	ff 75 10             	pushl  0x10(%ebp)
 8048e7e:	e8 a0 08 00 00       	call   8049723 <strlen>
 8048e83:	83 c4 10             	add    $0x10,%esp
 8048e86:	8d 50 01             	lea    0x1(%eax),%edx
 8048e89:	83 ec 04             	sub    $0x4,%esp
 8048e8c:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8048e8f:	50                   	push   %eax
 8048e90:	52                   	push   %edx
 8048e91:	ff 75 10             	pushl  0x10(%ebp)
 8048e94:	e8 3d 0e 00 00       	call   8049cd6 <serialize_ary>
 8048e99:	83 c4 10             	add    $0x10,%esp
  int* err=rpc_call(2,"mount",state.buf,state.sizeorpos);
 8048e9c:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048e9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8048ea2:	52                   	push   %edx
 8048ea3:	50                   	push   %eax
 8048ea4:	68 cc 9f 04 08       	push   $0x8049fcc
 8048ea9:	6a 02                	push   $0x2
 8048eab:	e8 eb 0c 00 00       	call   8049b9b <rpc_call>
 8048eb0:	83 c4 10             	add    $0x10,%esp
 8048eb3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return *err;
 8048eb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048eb9:	8b 00                	mov    (%eax),%eax
}
 8048ebb:	c9                   	leave  
 8048ebc:	c3                   	ret    

08048ebd <vfprintf>:

int vfprintf(FILE* stream,const char* format,va_list arg) {
 8048ebd:	55                   	push   %ebp
 8048ebe:	89 e5                	mov    %esp,%ebp
 8048ec0:	83 ec 38             	sub    $0x38,%esp
  int c;
	for(;*format!='\0';format++) {
 8048ec3:	e9 7d 01 00 00       	jmp    8049045 <vfprintf+0x188>
    if(*format!='%') {
 8048ec8:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048ecb:	8a 00                	mov    (%eax),%al
 8048ecd:	3c 25                	cmp    $0x25,%al
 8048ecf:	74 1f                	je     8048ef0 <vfprintf+0x33>
  		c=fputc(*format,stream);
 8048ed1:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048ed4:	8a 00                	mov    (%eax),%al
 8048ed6:	0f be c0             	movsbl %al,%eax
 8048ed9:	83 ec 08             	sub    $0x8,%esp
 8048edc:	ff 75 08             	pushl  0x8(%ebp)
 8048edf:	50                   	push   %eax
 8048ee0:	e8 e3 fa ff ff       	call   80489c8 <fputc>
 8048ee5:	83 c4 10             	add    $0x10,%esp
 8048ee8:	89 45 ec             	mov    %eax,-0x14(%ebp)
      continue;
 8048eeb:	e9 52 01 00 00       	jmp    8049042 <vfprintf+0x185>
  	}
    format++;
 8048ef0:	ff 45 0c             	incl   0xc(%ebp)
		switch(*format) {
 8048ef3:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048ef6:	8a 00                	mov    (%eax),%al
 8048ef8:	0f be c0             	movsbl %al,%eax
 8048efb:	83 f8 78             	cmp    $0x78,%eax
 8048efe:	0f 84 f1 00 00 00    	je     8048ff5 <vfprintf+0x138>
 8048f04:	83 f8 78             	cmp    $0x78,%eax
 8048f07:	0f 8f 35 01 00 00    	jg     8049042 <vfprintf+0x185>
 8048f0d:	83 f8 73             	cmp    $0x73,%eax
 8048f10:	0f 84 b0 00 00 00    	je     8048fc6 <vfprintf+0x109>
 8048f16:	83 f8 73             	cmp    $0x73,%eax
 8048f19:	0f 8f 23 01 00 00    	jg     8049042 <vfprintf+0x185>
 8048f1f:	83 f8 63             	cmp    $0x63,%eax
 8048f22:	74 0a                	je     8048f2e <vfprintf+0x71>
 8048f24:	83 f8 64             	cmp    $0x64,%eax
 8048f27:	74 3b                	je     8048f64 <vfprintf+0xa7>
 8048f29:	e9 14 01 00 00       	jmp    8049042 <vfprintf+0x185>
			case 'c': {
        int i=va_arg(arg,int);
 8048f2e:	8b 45 10             	mov    0x10(%ebp),%eax
 8048f31:	8d 50 04             	lea    0x4(%eax),%edx
 8048f34:	89 55 10             	mov    %edx,0x10(%ebp)
 8048f37:	8b 00                	mov    (%eax),%eax
 8048f39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				c=fputc(i,stream);
 8048f3c:	83 ec 08             	sub    $0x8,%esp
 8048f3f:	ff 75 08             	pushl  0x8(%ebp)
 8048f42:	ff 75 e4             	pushl  -0x1c(%ebp)
 8048f45:	e8 7e fa ff ff       	call   80489c8 <fputc>
 8048f4a:	83 c4 10             	add    $0x10,%esp
 8048f4d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (c==EOF) {
 8048f50:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 8048f54:	0f 85 e1 00 00 00    	jne    804903b <vfprintf+0x17e>
          return EOF;
 8048f5a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048f5f:	e9 f3 00 00 00       	jmp    8049057 <vfprintf+0x19a>
        }
				break;
      }
			case 'd': {
        int i=va_arg(arg,int); 		//Fetch Decimal/Integer argument
 8048f64:	8b 45 10             	mov    0x10(%ebp),%eax
 8048f67:	8d 50 04             	lea    0x4(%eax),%edx
 8048f6a:	89 55 10             	mov    %edx,0x10(%ebp)
 8048f6d:	8b 00                	mov    (%eax),%eax
 8048f6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
				if(i<0) {
 8048f72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8048f76:	79 13                	jns    8048f8b <vfprintf+0xce>
					i=-i;
 8048f78:	f7 5d f4             	negl   -0xc(%ebp)
					fputc('-',stream);
 8048f7b:	83 ec 08             	sub    $0x8,%esp
 8048f7e:	ff 75 08             	pushl  0x8(%ebp)
 8048f81:	6a 2d                	push   $0x2d
 8048f83:	e8 40 fa ff ff       	call   80489c8 <fputc>
 8048f88:	83 c4 10             	add    $0x10,%esp
				}
        char str[11];
        int_to_ascii(i,str);
 8048f8b:	83 ec 08             	sub    $0x8,%esp
 8048f8e:	8d 45 d9             	lea    -0x27(%ebp),%eax
 8048f91:	50                   	push   %eax
 8048f92:	ff 75 f4             	pushl  -0xc(%ebp)
 8048f95:	e8 53 08 00 00       	call   80497ed <int_to_ascii>
 8048f9a:	83 c4 10             	add    $0x10,%esp
				c=fputs(str,stream);
 8048f9d:	83 ec 08             	sub    $0x8,%esp
 8048fa0:	ff 75 08             	pushl  0x8(%ebp)
 8048fa3:	8d 45 d9             	lea    -0x27(%ebp),%eax
 8048fa6:	50                   	push   %eax
 8048fa7:	e8 60 fc ff ff       	call   8048c0c <fputs>
 8048fac:	83 c4 10             	add    $0x10,%esp
 8048faf:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (c==EOF) {
 8048fb2:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 8048fb6:	0f 85 82 00 00 00    	jne    804903e <vfprintf+0x181>
          return EOF;
 8048fbc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048fc1:	e9 91 00 00 00       	jmp    8049057 <vfprintf+0x19a>
      //   int i=va_arg(arg,unsigned int); //Fetch Octal representation
			// 	puts(convert(i,8));
			// 	break;
      // }
			case 's': {
        char* s=va_arg(arg,char*);
 8048fc6:	8b 45 10             	mov    0x10(%ebp),%eax
 8048fc9:	8d 50 04             	lea    0x4(%eax),%edx
 8048fcc:	89 55 10             	mov    %edx,0x10(%ebp)
 8048fcf:	8b 00                	mov    (%eax),%eax
 8048fd1:	89 45 e8             	mov    %eax,-0x18(%ebp)
				c=fputs(s,stream);
 8048fd4:	83 ec 08             	sub    $0x8,%esp
 8048fd7:	ff 75 08             	pushl  0x8(%ebp)
 8048fda:	ff 75 e8             	pushl  -0x18(%ebp)
 8048fdd:	e8 2a fc ff ff       	call   8048c0c <fputs>
 8048fe2:	83 c4 10             	add    $0x10,%esp
 8048fe5:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (c==EOF) {
 8048fe8:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 8048fec:	75 53                	jne    8049041 <vfprintf+0x184>
          return EOF;
 8048fee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048ff3:	eb 62                	jmp    8049057 <vfprintf+0x19a>
        }
				break;
      }
			case 'x': {
        unsigned int i=va_arg(arg, unsigned int);
 8048ff5:	8b 45 10             	mov    0x10(%ebp),%eax
 8048ff8:	8d 50 04             	lea    0x4(%eax),%edx
 8048ffb:	89 55 10             	mov    %edx,0x10(%ebp)
 8048ffe:	8b 00                	mov    (%eax),%eax
 8049000:	89 45 f0             	mov    %eax,-0x10(%ebp)
        char str[11];
        str[0]='\0';
 8049003:	c6 45 ce 00          	movb   $0x0,-0x32(%ebp)
        hex_to_ascii(i,str);
 8049007:	83 ec 08             	sub    $0x8,%esp
 804900a:	8d 45 ce             	lea    -0x32(%ebp),%eax
 804900d:	50                   	push   %eax
 804900e:	ff 75 f0             	pushl  -0x10(%ebp)
 8049011:	e8 68 08 00 00       	call   804987e <hex_to_ascii>
 8049016:	83 c4 10             	add    $0x10,%esp
				c=fputs(str,stream);
 8049019:	83 ec 08             	sub    $0x8,%esp
 804901c:	ff 75 08             	pushl  0x8(%ebp)
 804901f:	8d 45 ce             	lea    -0x32(%ebp),%eax
 8049022:	50                   	push   %eax
 8049023:	e8 e4 fb ff ff       	call   8048c0c <fputs>
 8049028:	83 c4 10             	add    $0x10,%esp
 804902b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (c==EOF) {
 804902e:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 8049032:	75 0e                	jne    8049042 <vfprintf+0x185>
          return EOF;
 8049034:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8049039:	eb 1c                	jmp    8049057 <vfprintf+0x19a>
				break;
 804903b:	90                   	nop
 804903c:	eb 04                	jmp    8049042 <vfprintf+0x185>
				break;
 804903e:	90                   	nop
 804903f:	eb 01                	jmp    8049042 <vfprintf+0x185>
				break;
 8049041:	90                   	nop
	for(;*format!='\0';format++) {
 8049042:	ff 45 0c             	incl   0xc(%ebp)
 8049045:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049048:	8a 00                	mov    (%eax),%al
 804904a:	84 c0                	test   %al,%al
 804904c:	0f 85 76 fe ff ff    	jne    8048ec8 <vfprintf+0xb>
        }
				break;
      }
		}
	}
  return 1;
 8049052:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8049057:	c9                   	leave  
 8049058:	c3                   	ret    

08049059 <fprintf>:

int fprintf(FILE* stream,const char* format,...) {
 8049059:	55                   	push   %ebp
 804905a:	89 e5                	mov    %esp,%ebp
 804905c:	83 ec 18             	sub    $0x18,%esp
  va_list arg;
  int code;
  va_start(arg,format);
 804905f:	8d 45 10             	lea    0x10(%ebp),%eax
 8049062:	89 45 f0             	mov    %eax,-0x10(%ebp)
  code=vfprintf(stream,format,arg);
 8049065:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049068:	83 ec 04             	sub    $0x4,%esp
 804906b:	50                   	push   %eax
 804906c:	ff 75 0c             	pushl  0xc(%ebp)
 804906f:	ff 75 08             	pushl  0x8(%ebp)
 8049072:	e8 46 fe ff ff       	call   8048ebd <vfprintf>
 8049077:	83 c4 10             	add    $0x10,%esp
 804907a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end(arg);
  if (code) {
 804907d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049081:	74 10                	je     8049093 <fprintf+0x3a>
    return strlen(format);
 8049083:	83 ec 0c             	sub    $0xc,%esp
 8049086:	ff 75 0c             	pushl  0xc(%ebp)
 8049089:	e8 95 06 00 00       	call   8049723 <strlen>
 804908e:	83 c4 10             	add    $0x10,%esp
 8049091:	eb 05                	jmp    8049098 <fprintf+0x3f>
  } else {
    return EOF;
 8049093:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
}
 8049098:	c9                   	leave  
 8049099:	c3                   	ret    

0804909a <printf>:

int printf(const char* format,...) {
 804909a:	55                   	push   %ebp
 804909b:	89 e5                	mov    %esp,%ebp
 804909d:	83 ec 18             	sub    $0x18,%esp
  va_list arg;
  int code;
  va_start(arg,format);
 80490a0:	8d 45 0c             	lea    0xc(%ebp),%eax
 80490a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  code=vfprintf(stdout,format,arg);
 80490a6:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80490a9:	a1 44 b0 04 08       	mov    0x804b044,%eax
 80490ae:	83 ec 04             	sub    $0x4,%esp
 80490b1:	52                   	push   %edx
 80490b2:	ff 75 08             	pushl  0x8(%ebp)
 80490b5:	50                   	push   %eax
 80490b6:	e8 02 fe ff ff       	call   8048ebd <vfprintf>
 80490bb:	83 c4 10             	add    $0x10,%esp
 80490be:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end(arg);
  if (code) {
 80490c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 80490c5:	74 10                	je     80490d7 <printf+0x3d>
    return strlen(format);
 80490c7:	83 ec 0c             	sub    $0xc,%esp
 80490ca:	ff 75 08             	pushl  0x8(%ebp)
 80490cd:	e8 51 06 00 00       	call   8049723 <strlen>
 80490d2:	83 c4 10             	add    $0x10,%esp
 80490d5:	eb 05                	jmp    80490dc <printf+0x42>
  } else {
    return EOF;
 80490d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
}
 80490dc:	c9                   	leave  
 80490dd:	c3                   	ret    

080490de <fseek>:

int fseek(FILE* stream,long offset,int origin) {
 80490de:	55                   	push   %ebp
 80490df:	89 e5                	mov    %esp,%ebp
  switch (origin) {
 80490e1:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
 80490e5:	74 14                	je     80490fb <fseek+0x1d>
 80490e7:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
 80490eb:	7f 2c                	jg     8049119 <fseek+0x3b>
 80490ed:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
 80490f1:	74 13                	je     8049106 <fseek+0x28>
 80490f3:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
 80490f7:	74 23                	je     804911c <fseek+0x3e>
    stream->pos+=offset;
    break;
  case SEEK_END:
    break;
  default:
    break;
 80490f9:	eb 1e                	jmp    8049119 <fseek+0x3b>
    stream->pos=offset;
 80490fb:	8b 45 08             	mov    0x8(%ebp),%eax
 80490fe:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049101:	89 50 08             	mov    %edx,0x8(%eax)
    break;
 8049104:	eb 17                	jmp    804911d <fseek+0x3f>
    stream->pos+=offset;
 8049106:	8b 45 08             	mov    0x8(%ebp),%eax
 8049109:	8b 50 08             	mov    0x8(%eax),%edx
 804910c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804910f:	01 c2                	add    %eax,%edx
 8049111:	8b 45 08             	mov    0x8(%ebp),%eax
 8049114:	89 50 08             	mov    %edx,0x8(%eax)
    break;
 8049117:	eb 04                	jmp    804911d <fseek+0x3f>
    break;
 8049119:	90                   	nop
 804911a:	eb 01                	jmp    804911d <fseek+0x3f>
    break;
 804911c:	90                   	nop
  }
  return 0;
 804911d:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049122:	5d                   	pop    %ebp
 8049123:	c3                   	ret    

08049124 <get_bmap_bit>:
 * Get a bit in a bitmap
 * \param bmap The bitmap
 * \param index The index in the bitmap
 * \return the bit
*/
static char get_bmap_bit(char* bmap,size_t index) {
 8049124:	55                   	push   %ebp
 8049125:	89 e5                	mov    %esp,%ebp
 8049127:	53                   	push   %ebx
 8049128:	83 ec 10             	sub    $0x10,%esp
  size_t byte=index/8;
 804912b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804912e:	c1 e8 03             	shr    $0x3,%eax
 8049131:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=index%8;
 8049134:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049137:	83 e0 07             	and    $0x7,%eax
 804913a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char entry=bmap[byte];
 804913d:	8b 55 08             	mov    0x8(%ebp),%edx
 8049140:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049143:	01 d0                	add    %edx,%eax
 8049145:	8a 00                	mov    (%eax),%al
 8049147:	88 45 f3             	mov    %al,-0xd(%ebp)
  return (entry&(1<<bit))>0;
 804914a:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
 804914e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049151:	bb 01 00 00 00       	mov    $0x1,%ebx
 8049156:	88 c1                	mov    %al,%cl
 8049158:	d3 e3                	shl    %cl,%ebx
 804915a:	89 d8                	mov    %ebx,%eax
 804915c:	21 d0                	and    %edx,%eax
 804915e:	85 c0                	test   %eax,%eax
 8049160:	0f 9f c0             	setg   %al
}
 8049163:	83 c4 10             	add    $0x10,%esp
 8049166:	5b                   	pop    %ebx
 8049167:	5d                   	pop    %ebp
 8049168:	c3                   	ret    

08049169 <set_bmap_bit>:
/**
 * Set a bit in a bitmap
 * \param bmap The bitmap
 * \param index The index in the bitmap
*/
static void set_bmap_bit(char* bmap,size_t index) {
 8049169:	55                   	push   %ebp
 804916a:	89 e5                	mov    %esp,%ebp
 804916c:	53                   	push   %ebx
 804916d:	83 ec 10             	sub    $0x10,%esp
  size_t byte=index/8;
 8049170:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049173:	c1 e8 03             	shr    $0x3,%eax
 8049176:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=index%8;
 8049179:	8b 45 0c             	mov    0xc(%ebp),%eax
 804917c:	83 e0 07             	and    $0x7,%eax
 804917f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  bmap[byte]=bmap[byte]|(1<<bit);
 8049182:	8b 55 08             	mov    0x8(%ebp),%edx
 8049185:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049188:	01 d0                	add    %edx,%eax
 804918a:	8a 10                	mov    (%eax),%dl
 804918c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804918f:	bb 01 00 00 00       	mov    $0x1,%ebx
 8049194:	88 c1                	mov    %al,%cl
 8049196:	d3 e3                	shl    %cl,%ebx
 8049198:	89 d8                	mov    %ebx,%eax
 804919a:	88 c3                	mov    %al,%bl
 804919c:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804919f:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80491a2:	01 c8                	add    %ecx,%eax
 80491a4:	09 da                	or     %ebx,%edx
 80491a6:	88 10                	mov    %dl,(%eax)
}
 80491a8:	90                   	nop
 80491a9:	83 c4 10             	add    $0x10,%esp
 80491ac:	5b                   	pop    %ebx
 80491ad:	5d                   	pop    %ebp
 80491ae:	c3                   	ret    

080491af <clear_bmap_bit>:
/**
 * Clear a bit in a bitmap
 * \param bmap The bitmap
 * \param index The index in the bitmap
*/
static void clear_bmap_bit(char* bmap,size_t index) {
 80491af:	55                   	push   %ebp
 80491b0:	89 e5                	mov    %esp,%ebp
 80491b2:	53                   	push   %ebx
 80491b3:	83 ec 10             	sub    $0x10,%esp
  size_t byte=index/8;
 80491b6:	8b 45 0c             	mov    0xc(%ebp),%eax
 80491b9:	c1 e8 03             	shr    $0x3,%eax
 80491bc:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=index%8;
 80491bf:	8b 45 0c             	mov    0xc(%ebp),%eax
 80491c2:	83 e0 07             	and    $0x7,%eax
 80491c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  bmap[byte]=bmap[byte]&(~(1<<bit));
 80491c8:	8b 55 08             	mov    0x8(%ebp),%edx
 80491cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80491ce:	01 d0                	add    %edx,%eax
 80491d0:	8a 10                	mov    (%eax),%dl
 80491d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80491d5:	bb 01 00 00 00       	mov    $0x1,%ebx
 80491da:	88 c1                	mov    %al,%cl
 80491dc:	d3 e3                	shl    %cl,%ebx
 80491de:	89 d8                	mov    %ebx,%eax
 80491e0:	f7 d0                	not    %eax
 80491e2:	88 c3                	mov    %al,%bl
 80491e4:	8b 4d 08             	mov    0x8(%ebp),%ecx
 80491e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80491ea:	01 c8                	add    %ecx,%eax
 80491ec:	21 da                	and    %ebx,%edx
 80491ee:	88 10                	mov    %dl,(%eax)
}
 80491f0:	90                   	nop
 80491f1:	83 c4 10             	add    $0x10,%esp
 80491f4:	5b                   	pop    %ebx
 80491f5:	5d                   	pop    %ebp
 80491f6:	c3                   	ret    

080491f7 <reserve_block>:

/**
 * Add a block to the heap
 * \param mem_blks The number of pages that this block will use
*/
static void reserve_block(size_t mem_blks) {
 80491f7:	55                   	push   %ebp
 80491f8:	89 e5                	mov    %esp,%ebp
 80491fa:	53                   	push   %ebx
 80491fb:	83 ec 24             	sub    $0x24,%esp
  size_t bmap_byts=((mem_blks*BLK_SZ)/4)/8;
 80491fe:	8b 45 08             	mov    0x8(%ebp),%eax
 8049201:	c1 e0 0c             	shl    $0xc,%eax
 8049204:	c1 e8 05             	shr    $0x5,%eax
 8049207:	89 45 f0             	mov    %eax,-0x10(%ebp)
  entries[num_used_entries].bitmap=alloc_memory((size_t)ceilf((double)bmap_byts/BLK_SZ));
 804920a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804920d:	ba 00 00 00 00       	mov    $0x0,%edx
 8049212:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8049215:	89 55 dc             	mov    %edx,-0x24(%ebp)
 8049218:	df 6d d8             	fildll -0x28(%ebp)
 804921b:	dd 05 d8 9f 04 08    	fldl   0x8049fd8
 8049221:	de f9                	fdivrp %st,%st(1)
 8049223:	d9 5d d8             	fstps  -0x28(%ebp)
 8049226:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049229:	83 ec 0c             	sub    $0xc,%esp
 804922c:	50                   	push   %eax
 804922d:	e8 c0 0b 00 00       	call   8049df2 <ceilf>
 8049232:	83 c4 10             	add    $0x10,%esp
 8049235:	d9 7d e6             	fnstcw -0x1a(%ebp)
 8049238:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804923c:	80 cc 0c             	or     $0xc,%ah
 804923f:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 8049243:	d9 6d e4             	fldcw  -0x1c(%ebp)
 8049246:	df 7d d8             	fistpll -0x28(%ebp)
 8049249:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804924c:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804924f:	8b 1d 60 d8 04 08    	mov    0x804d860,%ebx
 8049255:	83 ec 0c             	sub    $0xc,%esp
 8049258:	50                   	push   %eax
 8049259:	e8 7b f5 ff ff       	call   80487d9 <alloc_memory>
 804925e:	83 c4 10             	add    $0x10,%esp
 8049261:	89 c2                	mov    %eax,%edx
 8049263:	89 d8                	mov    %ebx,%eax
 8049265:	c1 e0 02             	shl    $0x2,%eax
 8049268:	01 d8                	add    %ebx,%eax
 804926a:	c1 e0 02             	shl    $0x2,%eax
 804926d:	05 60 b0 04 08       	add    $0x804b060,%eax
 8049272:	89 10                	mov    %edx,(%eax)
  entries[num_used_entries].bitmap_byt_size=bmap_byts;
 8049274:	8b 15 60 d8 04 08    	mov    0x804d860,%edx
 804927a:	89 d0                	mov    %edx,%eax
 804927c:	c1 e0 02             	shl    $0x2,%eax
 804927f:	01 d0                	add    %edx,%eax
 8049281:	c1 e0 02             	shl    $0x2,%eax
 8049284:	8d 90 64 b0 04 08    	lea    0x804b064(%eax),%edx
 804928a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804928d:	89 02                	mov    %eax,(%edx)
  entries[num_used_entries].bitmap_bit_size=bmap_byts*8;
 804928f:	8b 15 60 d8 04 08    	mov    0x804d860,%edx
 8049295:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049298:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
 804929f:	89 d0                	mov    %edx,%eax
 80492a1:	c1 e0 02             	shl    $0x2,%eax
 80492a4:	01 d0                	add    %edx,%eax
 80492a6:	c1 e0 02             	shl    $0x2,%eax
 80492a9:	05 68 b0 04 08       	add    $0x804b068,%eax
 80492ae:	89 08                	mov    %ecx,(%eax)
  char* bmap=entries[num_used_entries].bitmap;
 80492b0:	8b 15 60 d8 04 08    	mov    0x804d860,%edx
 80492b6:	89 d0                	mov    %edx,%eax
 80492b8:	c1 e0 02             	shl    $0x2,%eax
 80492bb:	01 d0                	add    %edx,%eax
 80492bd:	c1 e0 02             	shl    $0x2,%eax
 80492c0:	05 60 b0 04 08       	add    $0x804b060,%eax
 80492c5:	8b 00                	mov    (%eax),%eax
 80492c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  size_t bmap_byt_sz=entries[num_used_entries].bitmap_byt_size;
 80492ca:	8b 15 60 d8 04 08    	mov    0x804d860,%edx
 80492d0:	89 d0                	mov    %edx,%eax
 80492d2:	c1 e0 02             	shl    $0x2,%eax
 80492d5:	01 d0                	add    %edx,%eax
 80492d7:	c1 e0 02             	shl    $0x2,%eax
 80492da:	05 64 b0 04 08       	add    $0x804b064,%eax
 80492df:	8b 00                	mov    (%eax),%eax
 80492e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(size_t i=0;i<bmap_byt_sz;i++) {
 80492e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 80492eb:	eb 0e                	jmp    80492fb <reserve_block+0x104>
    bmap[i]=0;
 80492ed:	8b 55 ec             	mov    -0x14(%ebp),%edx
 80492f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80492f3:	01 d0                	add    %edx,%eax
 80492f5:	c6 00 00             	movb   $0x0,(%eax)
  for(size_t i=0;i<bmap_byt_sz;i++) {
 80492f8:	ff 45 f4             	incl   -0xc(%ebp)
 80492fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80492fe:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 8049301:	72 ea                	jb     80492ed <reserve_block+0xf6>
  }
  entries[num_used_entries].avail_data_size=mem_blks*BLK_SZ;
 8049303:	8b 15 60 d8 04 08    	mov    0x804d860,%edx
 8049309:	8b 45 08             	mov    0x8(%ebp),%eax
 804930c:	c1 e0 0c             	shl    $0xc,%eax
 804930f:	89 c1                	mov    %eax,%ecx
 8049311:	89 d0                	mov    %edx,%eax
 8049313:	c1 e0 02             	shl    $0x2,%eax
 8049316:	01 d0                	add    %edx,%eax
 8049318:	c1 e0 02             	shl    $0x2,%eax
 804931b:	05 6c b0 04 08       	add    $0x804b06c,%eax
 8049320:	89 08                	mov    %ecx,(%eax)
  entries[num_used_entries].data_block=alloc_memory(mem_blks);
 8049322:	8b 45 08             	mov    0x8(%ebp),%eax
 8049325:	8b 1d 60 d8 04 08    	mov    0x804d860,%ebx
 804932b:	83 ec 0c             	sub    $0xc,%esp
 804932e:	50                   	push   %eax
 804932f:	e8 a5 f4 ff ff       	call   80487d9 <alloc_memory>
 8049334:	83 c4 10             	add    $0x10,%esp
 8049337:	89 c2                	mov    %eax,%edx
 8049339:	89 d8                	mov    %ebx,%eax
 804933b:	c1 e0 02             	shl    $0x2,%eax
 804933e:	01 d8                	add    %ebx,%eax
 8049340:	c1 e0 02             	shl    $0x2,%eax
 8049343:	05 70 b0 04 08       	add    $0x804b070,%eax
 8049348:	89 10                	mov    %edx,(%eax)
  num_used_entries++;
 804934a:	a1 60 d8 04 08       	mov    0x804d860,%eax
 804934f:	40                   	inc    %eax
 8049350:	a3 60 d8 04 08       	mov    %eax,0x804d860
}
 8049355:	90                   	nop
 8049356:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8049359:	c9                   	leave  
 804935a:	c3                   	ret    

0804935b <malloc>:

void* malloc(size_t size) {
 804935b:	55                   	push   %ebp
 804935c:	89 e5                	mov    %esp,%ebp
 804935e:	57                   	push   %edi
 804935f:	56                   	push   %esi
 8049360:	53                   	push   %ebx
 8049361:	83 ec 6c             	sub    $0x6c,%esp
  size_t num_4b_grps=(size_t)ceilf((float)size/4);
 8049364:	8b 45 08             	mov    0x8(%ebp),%eax
 8049367:	ba 00 00 00 00       	mov    $0x0,%edx
 804936c:	89 45 88             	mov    %eax,-0x78(%ebp)
 804936f:	89 55 8c             	mov    %edx,-0x74(%ebp)
 8049372:	df 6d 88             	fildll -0x78(%ebp)
 8049375:	d9 05 e0 9f 04 08    	flds   0x8049fe0
 804937b:	de f9                	fdivrp %st,%st(1)
 804937d:	83 ec 0c             	sub    $0xc,%esp
 8049380:	8d 64 24 fc          	lea    -0x4(%esp),%esp
 8049384:	d9 1c 24             	fstps  (%esp)
 8049387:	e8 66 0a 00 00       	call   8049df2 <ceilf>
 804938c:	83 c4 10             	add    $0x10,%esp
 804938f:	d9 7d 96             	fnstcw -0x6a(%ebp)
 8049392:	66 8b 45 96          	mov    -0x6a(%ebp),%ax
 8049396:	80 cc 0c             	or     $0xc,%ah
 8049399:	66 89 45 94          	mov    %ax,-0x6c(%ebp)
 804939d:	d9 6d 94             	fldcw  -0x6c(%ebp)
 80493a0:	df 7d 88             	fistpll -0x78(%ebp)
 80493a3:	d9 6d 96             	fldcw  -0x6a(%ebp)
 80493a6:	8b 45 88             	mov    -0x78(%ebp),%eax
 80493a9:	89 45 c0             	mov    %eax,-0x40(%ebp)
  num_4b_grps+=3;
 80493ac:	83 45 c0 03          	addl   $0x3,-0x40(%ebp)
  int blk_indx=-1;
 80493b0:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
  size_t bmap_index;
  heap_block entry;
  for (size_t i=0;i<num_used_entries;i++) {
 80493b7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 80493be:	e9 ec 00 00 00       	jmp    80494af <malloc+0x154>
    size_t remaining_blks;
    entry=entries[i];
 80493c3:	8b 55 dc             	mov    -0x24(%ebp),%edx
 80493c6:	89 d0                	mov    %edx,%eax
 80493c8:	c1 e0 02             	shl    $0x2,%eax
 80493cb:	01 d0                	add    %edx,%eax
 80493cd:	c1 e0 02             	shl    $0x2,%eax
 80493d0:	8d 90 60 b0 04 08    	lea    0x804b060(%eax),%edx
 80493d6:	8d 45 98             	lea    -0x68(%ebp),%eax
 80493d9:	89 d3                	mov    %edx,%ebx
 80493db:	ba 05 00 00 00       	mov    $0x5,%edx
 80493e0:	89 c7                	mov    %eax,%edi
 80493e2:	89 de                	mov    %ebx,%esi
 80493e4:	89 d1                	mov    %edx,%ecx
 80493e6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    if (entry.avail_data_size>=size) {
 80493e8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 80493eb:	39 45 08             	cmp    %eax,0x8(%ebp)
 80493ee:	0f 87 aa 00 00 00    	ja     804949e <malloc+0x143>
      char* bmap=entry.bitmap;
 80493f4:	8b 45 98             	mov    -0x68(%ebp),%eax
 80493f7:	89 45 bc             	mov    %eax,-0x44(%ebp)
      size_t bmap_byt_sz=entry.bitmap_byt_size;
 80493fa:	8b 45 9c             	mov    -0x64(%ebp),%eax
 80493fd:	89 45 b8             	mov    %eax,-0x48(%ebp)
      for(size_t i=0;i<bmap_byt_sz;i++) {
 8049400:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
 8049407:	e9 83 00 00 00       	jmp    804948f <malloc+0x134>
        char got_0=0;
 804940c:	c6 45 d3 00          	movb   $0x0,-0x2d(%ebp)
        remaining_blks=num_4b_grps;
 8049410:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049413:	89 45 d8             	mov    %eax,-0x28(%ebp)
        size_t old_j;
        for (size_t j=i*8;;j++) {
 8049416:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049419:	c1 e0 03             	shl    $0x3,%eax
 804941c:	89 45 c8             	mov    %eax,-0x38(%ebp)
          char bit=get_bmap_bit(bmap,j);
 804941f:	83 ec 08             	sub    $0x8,%esp
 8049422:	ff 75 c8             	pushl  -0x38(%ebp)
 8049425:	ff 75 bc             	pushl  -0x44(%ebp)
 8049428:	e8 f7 fc ff ff       	call   8049124 <get_bmap_bit>
 804942d:	83 c4 10             	add    $0x10,%esp
 8049430:	88 45 b7             	mov    %al,-0x49(%ebp)
          if (got_0) {
 8049433:	80 7d d3 00          	cmpb   $0x0,-0x2d(%ebp)
 8049437:	74 27                	je     8049460 <malloc+0x105>
            if (bit) {
 8049439:	80 7d b7 00          	cmpb   $0x0,-0x49(%ebp)
 804943d:	74 1c                	je     804945b <malloc+0x100>
              if (remaining_blks==0) {
 804943f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 8049443:	75 08                	jne    804944d <malloc+0xf2>
                  bmap_index=old_j;
 8049445:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8049448:	89 45 e0             	mov    %eax,-0x20(%ebp)
                  break;
 804944b:	eb 39                	jmp    8049486 <malloc+0x12b>
              } else {
                i+=j/8;
 804944d:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8049450:	c1 e8 03             	shr    $0x3,%eax
 8049453:	01 45 d4             	add    %eax,-0x2c(%ebp)
                i--;
 8049456:	ff 4d d4             	decl   -0x2c(%ebp)
                break;
 8049459:	eb 2b                	jmp    8049486 <malloc+0x12b>
              }
            } else {
              remaining_blks--;
 804945b:	ff 4d d8             	decl   -0x28(%ebp)
 804945e:	eb 13                	jmp    8049473 <malloc+0x118>
            }
          } else {
            if (!bit) {
 8049460:	80 7d b7 00          	cmpb   $0x0,-0x49(%ebp)
 8049464:	75 0d                	jne    8049473 <malloc+0x118>
              got_0=1;
 8049466:	c6 45 d3 01          	movb   $0x1,-0x2d(%ebp)
              old_j=j;
 804946a:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804946d:	89 45 cc             	mov    %eax,-0x34(%ebp)
              remaining_blks--;
 8049470:	ff 4d d8             	decl   -0x28(%ebp)
            }
          }
          if (remaining_blks==0) {
 8049473:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 8049477:	75 08                	jne    8049481 <malloc+0x126>
            bmap_index=old_j;
 8049479:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804947c:	89 45 e0             	mov    %eax,-0x20(%ebp)
            break;
 804947f:	eb 05                	jmp    8049486 <malloc+0x12b>
        for (size_t j=i*8;;j++) {
 8049481:	ff 45 c8             	incl   -0x38(%ebp)
 8049484:	eb 99                	jmp    804941f <malloc+0xc4>
          }
        }
        if (remaining_blks==0) {
 8049486:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 804948a:	74 11                	je     804949d <malloc+0x142>
      for(size_t i=0;i<bmap_byt_sz;i++) {
 804948c:	ff 45 d4             	incl   -0x2c(%ebp)
 804948f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049492:	3b 45 b8             	cmp    -0x48(%ebp),%eax
 8049495:	0f 82 71 ff ff ff    	jb     804940c <malloc+0xb1>
 804949b:	eb 01                	jmp    804949e <malloc+0x143>
          break;
 804949d:	90                   	nop
        }
      }
    }
    if (remaining_blks==0) {
 804949e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 80494a2:	75 08                	jne    80494ac <malloc+0x151>
      blk_indx=i;
 80494a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
 80494a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      break;
 80494aa:	eb 11                	jmp    80494bd <malloc+0x162>
  for (size_t i=0;i<num_used_entries;i++) {
 80494ac:	ff 45 dc             	incl   -0x24(%ebp)
 80494af:	a1 60 d8 04 08       	mov    0x804d860,%eax
 80494b4:	39 45 dc             	cmp    %eax,-0x24(%ebp)
 80494b7:	0f 82 06 ff ff ff    	jb     80493c3 <malloc+0x68>
    }
  }
  if (blk_indx==-1) {
 80494bd:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
 80494c1:	75 20                	jne    80494e3 <malloc+0x188>
    // reserve_block((size_t)ceilf((double)size/BLK_SZ));
    reserve_block(1024);
 80494c3:	83 ec 0c             	sub    $0xc,%esp
 80494c6:	68 00 04 00 00       	push   $0x400
 80494cb:	e8 27 fd ff ff       	call   80491f7 <reserve_block>
 80494d0:	83 c4 10             	add    $0x10,%esp
    return malloc(size);
 80494d3:	83 ec 0c             	sub    $0xc,%esp
 80494d6:	ff 75 08             	pushl  0x8(%ebp)
 80494d9:	e8 7d fe ff ff       	call   804935b <malloc>
 80494de:	83 c4 10             	add    $0x10,%esp
 80494e1:	eb 78                	jmp    804955b <malloc+0x200>
  }
  for (size_t i=0;i<num_4b_grps;i++) {
 80494e3:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
 80494ea:	eb 1b                	jmp    8049507 <malloc+0x1ac>
    set_bmap_bit(entry.bitmap,bmap_index+i);
 80494ec:	8b 55 e0             	mov    -0x20(%ebp),%edx
 80494ef:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 80494f2:	01 c2                	add    %eax,%edx
 80494f4:	8b 45 98             	mov    -0x68(%ebp),%eax
 80494f7:	83 ec 08             	sub    $0x8,%esp
 80494fa:	52                   	push   %edx
 80494fb:	50                   	push   %eax
 80494fc:	e8 68 fc ff ff       	call   8049169 <set_bmap_bit>
 8049501:	83 c4 10             	add    $0x10,%esp
  for (size_t i=0;i<num_4b_grps;i++) {
 8049504:	ff 45 c4             	incl   -0x3c(%ebp)
 8049507:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804950a:	3b 45 c0             	cmp    -0x40(%ebp),%eax
 804950d:	72 dd                	jb     80494ec <malloc+0x191>
  }
  size_t data_offset=(bmap_index*8)+12;
 804950f:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049512:	c1 e0 03             	shl    $0x3,%eax
 8049515:	83 c0 0c             	add    $0xc,%eax
 8049518:	89 45 b0             	mov    %eax,-0x50(%ebp)
  size_t* info=(void*)(((char*)entry.data_block)+data_offset-12);
 804951b:	8b 45 a8             	mov    -0x58(%ebp),%eax
 804951e:	8b 55 b0             	mov    -0x50(%ebp),%edx
 8049521:	83 ea 0c             	sub    $0xc,%edx
 8049524:	01 d0                	add    %edx,%eax
 8049526:	89 45 ac             	mov    %eax,-0x54(%ebp)
  info[0]=num_4b_grps;
 8049529:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804952c:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804952f:	89 10                	mov    %edx,(%eax)
  info[1]=bmap_index;
 8049531:	8b 45 ac             	mov    -0x54(%ebp),%eax
 8049534:	8d 50 04             	lea    0x4(%eax),%edx
 8049537:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804953a:	89 02                	mov    %eax,(%edx)
  info[2]=blk_indx;
 804953c:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804953f:	8d 50 08             	lea    0x8(%eax),%edx
 8049542:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049545:	89 02                	mov    %eax,(%edx)
  entry.avail_data_size-=size+12;
 8049547:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804954a:	2b 45 08             	sub    0x8(%ebp),%eax
 804954d:	83 e8 0c             	sub    $0xc,%eax
 8049550:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  return (void*)(((char*)entry.data_block)+data_offset);
 8049553:	8b 55 a8             	mov    -0x58(%ebp),%edx
 8049556:	8b 45 b0             	mov    -0x50(%ebp),%eax
 8049559:	01 d0                	add    %edx,%eax

}
 804955b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804955e:	5b                   	pop    %ebx
 804955f:	5e                   	pop    %esi
 8049560:	5f                   	pop    %edi
 8049561:	5d                   	pop    %ebp
 8049562:	c3                   	ret    

08049563 <realloc>:

void* realloc(void *mem, size_t new_sz) {
 8049563:	55                   	push   %ebp
 8049564:	89 e5                	mov    %esp,%ebp
 8049566:	83 ec 18             	sub    $0x18,%esp
  void* ptr=malloc(new_sz);
 8049569:	83 ec 0c             	sub    $0xc,%esp
 804956c:	ff 75 0c             	pushl  0xc(%ebp)
 804956f:	e8 e7 fd ff ff       	call   804935b <malloc>
 8049574:	83 c4 10             	add    $0x10,%esp
 8049577:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (mem==NULL) {
 804957a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804957e:	75 05                	jne    8049585 <realloc+0x22>
    return ptr;
 8049580:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049583:	eb 38                	jmp    80495bd <realloc+0x5a>
  }
  size_t num_4b_grps=*((size_t*)((char*)mem-12));
 8049585:	8b 45 08             	mov    0x8(%ebp),%eax
 8049588:	8b 40 f4             	mov    -0xc(%eax),%eax
 804958b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  memcpy(ptr,mem,num_4b_grps*4);
 804958e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049591:	c1 e0 02             	shl    $0x2,%eax
 8049594:	83 ec 04             	sub    $0x4,%esp
 8049597:	50                   	push   %eax
 8049598:	ff 75 08             	pushl  0x8(%ebp)
 804959b:	ff 75 f4             	pushl  -0xc(%ebp)
 804959e:	e8 b0 00 00 00       	call   8049653 <memcpy>
 80495a3:	83 c4 10             	add    $0x10,%esp
  free(mem);
 80495a6:	83 ec 0c             	sub    $0xc,%esp
 80495a9:	ff 75 08             	pushl  0x8(%ebp)
 80495ac:	e8 0e 00 00 00       	call   80495bf <free>
 80495b1:	83 c4 10             	add    $0x10,%esp
  mem=ptr;
 80495b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80495b7:	89 45 08             	mov    %eax,0x8(%ebp)
  return ptr;
 80495ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80495bd:	c9                   	leave  
 80495be:	c3                   	ret    

080495bf <free>:

void free(void* mem) {
 80495bf:	55                   	push   %ebp
 80495c0:	89 e5                	mov    %esp,%ebp
 80495c2:	57                   	push   %edi
 80495c3:	56                   	push   %esi
 80495c4:	53                   	push   %ebx
 80495c5:	83 ec 30             	sub    $0x30,%esp
  size_t* info=(size_t*)((char*)mem-12);
 80495c8:	8b 45 08             	mov    0x8(%ebp),%eax
 80495cb:	83 e8 0c             	sub    $0xc,%eax
 80495ce:	89 45 ec             	mov    %eax,-0x14(%ebp)
  size_t num_4b_grps=info[0];
 80495d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80495d4:	8b 00                	mov    (%eax),%eax
 80495d6:	89 45 e8             	mov    %eax,-0x18(%ebp)
  size_t bmap_index=info[1];
 80495d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80495dc:	8b 40 04             	mov    0x4(%eax),%eax
 80495df:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  size_t blk_indx=info[2];
 80495e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80495e5:	8b 40 08             	mov    0x8(%eax),%eax
 80495e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  heap_block entry=entries[blk_indx];
 80495eb:	8b 55 e0             	mov    -0x20(%ebp),%edx
 80495ee:	89 d0                	mov    %edx,%eax
 80495f0:	c1 e0 02             	shl    $0x2,%eax
 80495f3:	01 d0                	add    %edx,%eax
 80495f5:	c1 e0 02             	shl    $0x2,%eax
 80495f8:	8d 90 60 b0 04 08    	lea    0x804b060(%eax),%edx
 80495fe:	8d 45 cc             	lea    -0x34(%ebp),%eax
 8049601:	89 d3                	mov    %edx,%ebx
 8049603:	ba 05 00 00 00       	mov    $0x5,%edx
 8049608:	89 c7                	mov    %eax,%edi
 804960a:	89 de                	mov    %ebx,%esi
 804960c:	89 d1                	mov    %edx,%ecx
 804960e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  for (size_t i=0;i<num_4b_grps;i++) {
 8049610:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 8049617:	eb 18                	jmp    8049631 <free+0x72>
    clear_bmap_bit(entry.bitmap,bmap_index+i);
 8049619:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804961c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804961f:	01 c2                	add    %eax,%edx
 8049621:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8049624:	52                   	push   %edx
 8049625:	50                   	push   %eax
 8049626:	e8 84 fb ff ff       	call   80491af <clear_bmap_bit>
 804962b:	83 c4 08             	add    $0x8,%esp
  for (size_t i=0;i<num_4b_grps;i++) {
 804962e:	ff 45 f0             	incl   -0x10(%ebp)
 8049631:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049634:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 8049637:	72 e0                	jb     8049619 <free+0x5a>
  }
  entry.avail_data_size+=(num_4b_grps*4)+12;
 8049639:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804963c:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804963f:	83 c2 03             	add    $0x3,%edx
 8049642:	c1 e2 02             	shl    $0x2,%edx
 8049645:	01 d0                	add    %edx,%eax
 8049647:	89 45 d8             	mov    %eax,-0x28(%ebp)
}
 804964a:	90                   	nop
 804964b:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804964e:	5b                   	pop    %ebx
 804964f:	5e                   	pop    %esi
 8049650:	5f                   	pop    %edi
 8049651:	5d                   	pop    %ebp
 8049652:	c3                   	ret    

08049653 <memcpy>:
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

void* memcpy(void* dest_ptr,const void* source_ptr,size_t len) {
 8049653:	55                   	push   %ebp
 8049654:	89 e5                	mov    %esp,%ebp
 8049656:	83 ec 10             	sub    $0x10,%esp
    char* source=(char*)source_ptr;
 8049659:	8b 45 0c             	mov    0xc(%ebp),%eax
 804965c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char* dest=(char*)dest_ptr;
 804965f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049662:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(size_t i=0;i<len;i++) {
 8049665:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 804966c:	eb 17                	jmp    8049685 <memcpy+0x32>
      dest[i]=source[i];
 804966e:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8049671:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049674:	01 d0                	add    %edx,%eax
 8049676:	8b 4d f4             	mov    -0xc(%ebp),%ecx
 8049679:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804967c:	01 ca                	add    %ecx,%edx
 804967e:	8a 00                	mov    (%eax),%al
 8049680:	88 02                	mov    %al,(%edx)
    for(size_t i=0;i<len;i++) {
 8049682:	ff 45 fc             	incl   -0x4(%ebp)
 8049685:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049688:	3b 45 10             	cmp    0x10(%ebp),%eax
 804968b:	72 e1                	jb     804966e <memcpy+0x1b>
    }
    return dest_ptr;
 804968d:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8049690:	c9                   	leave  
 8049691:	c3                   	ret    

08049692 <memset>:

void* memset(void *dest_ptr,int val,size_t len) {
 8049692:	55                   	push   %ebp
 8049693:	89 e5                	mov    %esp,%ebp
 8049695:	83 ec 10             	sub    $0x10,%esp
    char* dest=(char*)dest_ptr;
 8049698:	8b 45 08             	mov    0x8(%ebp),%eax
 804969b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (size_t i=0;i<len;i++){
 804969e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 80496a5:	eb 10                	jmp    80496b7 <memset+0x25>
      dest[i]=(char)val;
 80496a7:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80496aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80496ad:	01 d0                	add    %edx,%eax
 80496af:	8b 55 0c             	mov    0xc(%ebp),%edx
 80496b2:	88 10                	mov    %dl,(%eax)
    for (size_t i=0;i<len;i++){
 80496b4:	ff 45 fc             	incl   -0x4(%ebp)
 80496b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80496ba:	3b 45 10             	cmp    0x10(%ebp),%eax
 80496bd:	72 e8                	jb     80496a7 <memset+0x15>
    }
    return dest_ptr;
 80496bf:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80496c2:	c9                   	leave  
 80496c3:	c3                   	ret    

080496c4 <strcmp>:

int strcmp(const char* s1,const char* s2) {
 80496c4:	55                   	push   %ebp
 80496c5:	89 e5                	mov    %esp,%ebp
 80496c7:	83 ec 10             	sub    $0x10,%esp
    int i;
    for (i = 0; s1[i] == s2[i]; i++) {
 80496ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 80496d1:	eb 18                	jmp    80496eb <strcmp+0x27>
        if (s1[i] == '\0') return 0;
 80496d3:	8b 55 fc             	mov    -0x4(%ebp),%edx
 80496d6:	8b 45 08             	mov    0x8(%ebp),%eax
 80496d9:	01 d0                	add    %edx,%eax
 80496db:	8a 00                	mov    (%eax),%al
 80496dd:	84 c0                	test   %al,%al
 80496df:	75 07                	jne    80496e8 <strcmp+0x24>
 80496e1:	b8 00 00 00 00       	mov    $0x0,%eax
 80496e6:	eb 39                	jmp    8049721 <strcmp+0x5d>
    for (i = 0; s1[i] == s2[i]; i++) {
 80496e8:	ff 45 fc             	incl   -0x4(%ebp)
 80496eb:	8b 55 fc             	mov    -0x4(%ebp),%edx
 80496ee:	8b 45 08             	mov    0x8(%ebp),%eax
 80496f1:	01 d0                	add    %edx,%eax
 80496f3:	8a 10                	mov    (%eax),%dl
 80496f5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
 80496f8:	8b 45 0c             	mov    0xc(%ebp),%eax
 80496fb:	01 c8                	add    %ecx,%eax
 80496fd:	8a 00                	mov    (%eax),%al
 80496ff:	38 c2                	cmp    %al,%dl
 8049701:	74 d0                	je     80496d3 <strcmp+0xf>
    }
    return s1[i] - s2[i];
 8049703:	8b 55 fc             	mov    -0x4(%ebp),%edx
 8049706:	8b 45 08             	mov    0x8(%ebp),%eax
 8049709:	01 d0                	add    %edx,%eax
 804970b:	8a 00                	mov    (%eax),%al
 804970d:	0f be d0             	movsbl %al,%edx
 8049710:	8b 4d fc             	mov    -0x4(%ebp),%ecx
 8049713:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049716:	01 c8                	add    %ecx,%eax
 8049718:	8a 00                	mov    (%eax),%al
 804971a:	0f be c0             	movsbl %al,%eax
 804971d:	29 c2                	sub    %eax,%edx
 804971f:	89 d0                	mov    %edx,%eax
}
 8049721:	c9                   	leave  
 8049722:	c3                   	ret    

08049723 <strlen>:

size_t strlen(const char* str) {
 8049723:	55                   	push   %ebp
 8049724:	89 e5                	mov    %esp,%ebp
 8049726:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for (i=0;str[i]!='\0';i++);
 8049729:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 8049730:	eb 03                	jmp    8049735 <strlen+0x12>
 8049732:	ff 45 fc             	incl   -0x4(%ebp)
 8049735:	8b 55 08             	mov    0x8(%ebp),%edx
 8049738:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804973b:	01 d0                	add    %edx,%eax
 804973d:	8a 00                	mov    (%eax),%al
 804973f:	84 c0                	test   %al,%al
 8049741:	75 ef                	jne    8049732 <strlen+0xf>
  return i;
 8049743:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 8049746:	c9                   	leave  
 8049747:	c3                   	ret    

08049748 <strcpy>:

char* strcpy(char* dest,const char* src) {
 8049748:	55                   	push   %ebp
 8049749:	89 e5                	mov    %esp,%ebp
 804974b:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for (i=0;i<strlen(src);i++) {
 804974e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 8049755:	eb 17                	jmp    804976e <strcpy+0x26>
    dest[i]=src[i];
 8049757:	8b 55 0c             	mov    0xc(%ebp),%edx
 804975a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804975d:	01 d0                	add    %edx,%eax
 804975f:	8b 4d 08             	mov    0x8(%ebp),%ecx
 8049762:	8b 55 fc             	mov    -0x4(%ebp),%edx
 8049765:	01 ca                	add    %ecx,%edx
 8049767:	8a 00                	mov    (%eax),%al
 8049769:	88 02                	mov    %al,(%edx)
  for (i=0;i<strlen(src);i++) {
 804976b:	ff 45 fc             	incl   -0x4(%ebp)
 804976e:	ff 75 0c             	pushl  0xc(%ebp)
 8049771:	e8 ad ff ff ff       	call   8049723 <strlen>
 8049776:	83 c4 04             	add    $0x4,%esp
 8049779:	39 45 fc             	cmp    %eax,-0x4(%ebp)
 804977c:	72 d9                	jb     8049757 <strcpy+0xf>
  }
  dest[i]='\0';
 804977e:	8b 55 08             	mov    0x8(%ebp),%edx
 8049781:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049784:	01 d0                	add    %edx,%eax
 8049786:	c6 00 00             	movb   $0x0,(%eax)
  return dest;
 8049789:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804978c:	c9                   	leave  
 804978d:	c3                   	ret    

0804978e <strrev>:

char* strrev(char* str) {
 804978e:	55                   	push   %ebp
 804978f:	89 e5                	mov    %esp,%ebp
 8049791:	83 ec 10             	sub    $0x10,%esp
    char chr;
    int i,j;
    for (i=0,j=strlen(str)-1;i<j;i++,j--) {
 8049794:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 804979b:	ff 75 08             	pushl  0x8(%ebp)
 804979e:	e8 80 ff ff ff       	call   8049723 <strlen>
 80497a3:	83 c4 04             	add    $0x4,%esp
 80497a6:	48                   	dec    %eax
 80497a7:	89 45 f8             	mov    %eax,-0x8(%ebp)
 80497aa:	eb 34                	jmp    80497e0 <strrev+0x52>
      chr=str[i];
 80497ac:	8b 55 fc             	mov    -0x4(%ebp),%edx
 80497af:	8b 45 08             	mov    0x8(%ebp),%eax
 80497b2:	01 d0                	add    %edx,%eax
 80497b4:	8a 00                	mov    (%eax),%al
 80497b6:	88 45 f7             	mov    %al,-0x9(%ebp)
      str[i]=str[j];
 80497b9:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80497bc:	8b 45 08             	mov    0x8(%ebp),%eax
 80497bf:	01 d0                	add    %edx,%eax
 80497c1:	8b 4d fc             	mov    -0x4(%ebp),%ecx
 80497c4:	8b 55 08             	mov    0x8(%ebp),%edx
 80497c7:	01 ca                	add    %ecx,%edx
 80497c9:	8a 00                	mov    (%eax),%al
 80497cb:	88 02                	mov    %al,(%edx)
      str[j]=chr;
 80497cd:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80497d0:	8b 45 08             	mov    0x8(%ebp),%eax
 80497d3:	01 c2                	add    %eax,%edx
 80497d5:	8a 45 f7             	mov    -0x9(%ebp),%al
 80497d8:	88 02                	mov    %al,(%edx)
    for (i=0,j=strlen(str)-1;i<j;i++,j--) {
 80497da:	ff 45 fc             	incl   -0x4(%ebp)
 80497dd:	ff 4d f8             	decl   -0x8(%ebp)
 80497e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80497e3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
 80497e6:	7c c4                	jl     80497ac <strrev+0x1e>
    }
    return str;
 80497e8:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80497eb:	c9                   	leave  
 80497ec:	c3                   	ret    

080497ed <int_to_ascii>:

void int_to_ascii(int n,char* str) {
 80497ed:	55                   	push   %ebp
 80497ee:	89 e5                	mov    %esp,%ebp
 80497f0:	83 ec 10             	sub    $0x10,%esp
    int i;
    int sign;
    if ((sign = n)<0) {
 80497f3:	8b 45 08             	mov    0x8(%ebp),%eax
 80497f6:	89 45 f8             	mov    %eax,-0x8(%ebp)
 80497f9:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
 80497fd:	79 03                	jns    8049802 <int_to_ascii+0x15>
      n=-n;
 80497ff:	f7 5d 08             	negl   0x8(%ebp)
    }
    i=0;
 8049802:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    do {
      str[i++]=n%10+'0';
 8049809:	8b 45 08             	mov    0x8(%ebp),%eax
 804980c:	b9 0a 00 00 00       	mov    $0xa,%ecx
 8049811:	99                   	cltd   
 8049812:	f7 f9                	idiv   %ecx
 8049814:	89 d0                	mov    %edx,%eax
 8049816:	8d 48 30             	lea    0x30(%eax),%ecx
 8049819:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804981c:	8d 50 01             	lea    0x1(%eax),%edx
 804981f:	89 55 fc             	mov    %edx,-0x4(%ebp)
 8049822:	89 c2                	mov    %eax,%edx
 8049824:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049827:	01 d0                	add    %edx,%eax
 8049829:	88 ca                	mov    %cl,%dl
 804982b:	88 10                	mov    %dl,(%eax)
    } while ((n /= 10) > 0);
 804982d:	8b 4d 08             	mov    0x8(%ebp),%ecx
 8049830:	b8 67 66 66 66       	mov    $0x66666667,%eax
 8049835:	f7 e9                	imul   %ecx
 8049837:	c1 fa 02             	sar    $0x2,%edx
 804983a:	89 c8                	mov    %ecx,%eax
 804983c:	c1 f8 1f             	sar    $0x1f,%eax
 804983f:	29 c2                	sub    %eax,%edx
 8049841:	89 d0                	mov    %edx,%eax
 8049843:	89 45 08             	mov    %eax,0x8(%ebp)
 8049846:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804984a:	7f bd                	jg     8049809 <int_to_ascii+0x1c>
    if (sign < 0) {
 804984c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
 8049850:	79 13                	jns    8049865 <int_to_ascii+0x78>
      str[i++] = '-';
 8049852:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049855:	8d 50 01             	lea    0x1(%eax),%edx
 8049858:	89 55 fc             	mov    %edx,-0x4(%ebp)
 804985b:	89 c2                	mov    %eax,%edx
 804985d:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049860:	01 d0                	add    %edx,%eax
 8049862:	c6 00 2d             	movb   $0x2d,(%eax)
    }
    str[i]='\0';
 8049865:	8b 55 fc             	mov    -0x4(%ebp),%edx
 8049868:	8b 45 0c             	mov    0xc(%ebp),%eax
 804986b:	01 d0                	add    %edx,%eax
 804986d:	c6 00 00             	movb   $0x0,(%eax)
    strrev(str);
 8049870:	ff 75 0c             	pushl  0xc(%ebp)
 8049873:	e8 16 ff ff ff       	call   804978e <strrev>
 8049878:	83 c4 04             	add    $0x4,%esp
}
 804987b:	90                   	nop
 804987c:	c9                   	leave  
 804987d:	c3                   	ret    

0804987e <hex_to_ascii>:

void hex_to_ascii(unsigned int n, char* str) {
 804987e:	55                   	push   %ebp
 804987f:	89 e5                	mov    %esp,%ebp
 8049881:	83 ec 18             	sub    $0x18,%esp
    str[0]='\0'; 
 8049884:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049887:	c6 00 00             	movb   $0x0,(%eax)
    append(str, '0');
 804988a:	83 ec 08             	sub    $0x8,%esp
 804988d:	6a 30                	push   $0x30
 804988f:	ff 75 0c             	pushl  0xc(%ebp)
 8049892:	e8 cb 00 00 00       	call   8049962 <append>
 8049897:	83 c4 10             	add    $0x10,%esp
    append(str, 'x');
 804989a:	83 ec 08             	sub    $0x8,%esp
 804989d:	6a 78                	push   $0x78
 804989f:	ff 75 0c             	pushl  0xc(%ebp)
 80498a2:	e8 bb 00 00 00       	call   8049962 <append>
 80498a7:	83 c4 10             	add    $0x10,%esp
    char zeros = 0;
 80498aa:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

    unsigned int tmp;
    int i;
    for (i = 28; i > 0; i -= 4) {
 80498ae:	c7 45 f0 1c 00 00 00 	movl   $0x1c,-0x10(%ebp)
 80498b5:	eb 61                	jmp    8049918 <hex_to_ascii+0x9a>
        tmp = (n >> i) & 0xF;
 80498b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80498ba:	8b 55 08             	mov    0x8(%ebp),%edx
 80498bd:	88 c1                	mov    %al,%cl
 80498bf:	d3 ea                	shr    %cl,%edx
 80498c1:	89 d0                	mov    %edx,%eax
 80498c3:	83 e0 0f             	and    $0xf,%eax
 80498c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (tmp == 0 && zeros == 0) continue;
 80498c9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 80498cd:	75 06                	jne    80498d5 <hex_to_ascii+0x57>
 80498cf:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
 80498d3:	74 3e                	je     8049913 <hex_to_ascii+0x95>
        zeros = 1;
 80498d5:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
        if (tmp >= 0xA) append(str, tmp - 0xA + 'a');
 80498d9:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
 80498dd:	76 1a                	jbe    80498f9 <hex_to_ascii+0x7b>
 80498df:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80498e2:	83 c0 57             	add    $0x57,%eax
 80498e5:	0f be c0             	movsbl %al,%eax
 80498e8:	83 ec 08             	sub    $0x8,%esp
 80498eb:	50                   	push   %eax
 80498ec:	ff 75 0c             	pushl  0xc(%ebp)
 80498ef:	e8 6e 00 00 00       	call   8049962 <append>
 80498f4:	83 c4 10             	add    $0x10,%esp
 80498f7:	eb 1b                	jmp    8049914 <hex_to_ascii+0x96>
        else append(str, tmp + '0');
 80498f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80498fc:	83 c0 30             	add    $0x30,%eax
 80498ff:	0f be c0             	movsbl %al,%eax
 8049902:	83 ec 08             	sub    $0x8,%esp
 8049905:	50                   	push   %eax
 8049906:	ff 75 0c             	pushl  0xc(%ebp)
 8049909:	e8 54 00 00 00       	call   8049962 <append>
 804990e:	83 c4 10             	add    $0x10,%esp
 8049911:	eb 01                	jmp    8049914 <hex_to_ascii+0x96>
        if (tmp == 0 && zeros == 0) continue;
 8049913:	90                   	nop
    for (i = 28; i > 0; i -= 4) {
 8049914:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
 8049918:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804991c:	7f 99                	jg     80498b7 <hex_to_ascii+0x39>
    }

    tmp = n & 0xF;
 804991e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049921:	83 e0 0f             	and    $0xf,%eax
 8049924:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (tmp >= 0xA) append(str, tmp - 0xA + 'a');
 8049927:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
 804992b:	76 1a                	jbe    8049947 <hex_to_ascii+0xc9>
 804992d:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049930:	83 c0 57             	add    $0x57,%eax
 8049933:	0f be c0             	movsbl %al,%eax
 8049936:	83 ec 08             	sub    $0x8,%esp
 8049939:	50                   	push   %eax
 804993a:	ff 75 0c             	pushl  0xc(%ebp)
 804993d:	e8 20 00 00 00       	call   8049962 <append>
 8049942:	83 c4 10             	add    $0x10,%esp
    else append(str, tmp + '0');
}
 8049945:	eb 18                	jmp    804995f <hex_to_ascii+0xe1>
    else append(str, tmp + '0');
 8049947:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804994a:	83 c0 30             	add    $0x30,%eax
 804994d:	0f be c0             	movsbl %al,%eax
 8049950:	83 ec 08             	sub    $0x8,%esp
 8049953:	50                   	push   %eax
 8049954:	ff 75 0c             	pushl  0xc(%ebp)
 8049957:	e8 06 00 00 00       	call   8049962 <append>
 804995c:	83 c4 10             	add    $0x10,%esp
}
 804995f:	90                   	nop
 8049960:	c9                   	leave  
 8049961:	c3                   	ret    

08049962 <append>:

void append(char* s, char n) {
 8049962:	55                   	push   %ebp
 8049963:	89 e5                	mov    %esp,%ebp
 8049965:	83 ec 14             	sub    $0x14,%esp
 8049968:	8b 45 0c             	mov    0xc(%ebp),%eax
 804996b:	88 45 ec             	mov    %al,-0x14(%ebp)
    int len = strlen(s);
 804996e:	ff 75 08             	pushl  0x8(%ebp)
 8049971:	e8 ad fd ff ff       	call   8049723 <strlen>
 8049976:	83 c4 04             	add    $0x4,%esp
 8049979:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s[len] = n;
 804997c:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804997f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049982:	01 c2                	add    %eax,%edx
 8049984:	8a 45 ec             	mov    -0x14(%ebp),%al
 8049987:	88 02                	mov    %al,(%edx)
    s[len+1] = '\0';
 8049989:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804998c:	8d 50 01             	lea    0x1(%eax),%edx
 804998f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049992:	01 d0                	add    %edx,%eax
 8049994:	c6 00 00             	movb   $0x0,(%eax)
}
 8049997:	90                   	nop
 8049998:	c9                   	leave  
 8049999:	c3                   	ret    

0804999a <backspace>:

void backspace(char* s) {
 804999a:	55                   	push   %ebp
 804999b:	89 e5                	mov    %esp,%ebp
 804999d:	83 ec 10             	sub    $0x10,%esp
    int len = strlen(s);
 80499a0:	ff 75 08             	pushl  0x8(%ebp)
 80499a3:	e8 7b fd ff ff       	call   8049723 <strlen>
 80499a8:	83 c4 04             	add    $0x4,%esp
 80499ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s[len-1] = '\0';
 80499ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80499b1:	8d 50 ff             	lea    -0x1(%eax),%edx
 80499b4:	8b 45 08             	mov    0x8(%ebp),%eax
 80499b7:	01 d0                	add    %edx,%eax
 80499b9:	c6 00 00             	movb   $0x0,(%eax)
}
 80499bc:	90                   	nop
 80499bd:	c9                   	leave  
 80499be:	c3                   	ret    

080499bf <strtok_delim_check>:

static const char* strtok_str=NULL;
static size_t strtok_index;

static char strtok_delim_check(const char* delim) {
 80499bf:	55                   	push   %ebp
 80499c0:	89 e5                	mov    %esp,%ebp
 80499c2:	83 ec 10             	sub    $0x10,%esp
  for (size_t i=0;i<strlen(delim);i++) {
 80499c5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 80499cc:	eb 37                	jmp    8049a05 <strtok_delim_check+0x46>
    if (strtok_str[strtok_index]==delim[i]||strtok_str[strtok_index]=='\0') {
 80499ce:	8b 15 64 d8 04 08    	mov    0x804d864,%edx
 80499d4:	a1 68 d8 04 08       	mov    0x804d868,%eax
 80499d9:	01 d0                	add    %edx,%eax
 80499db:	8a 10                	mov    (%eax),%dl
 80499dd:	8b 4d 08             	mov    0x8(%ebp),%ecx
 80499e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80499e3:	01 c8                	add    %ecx,%eax
 80499e5:	8a 00                	mov    (%eax),%al
 80499e7:	38 c2                	cmp    %al,%dl
 80499e9:	74 13                	je     80499fe <strtok_delim_check+0x3f>
 80499eb:	8b 15 64 d8 04 08    	mov    0x804d864,%edx
 80499f1:	a1 68 d8 04 08       	mov    0x804d868,%eax
 80499f6:	01 d0                	add    %edx,%eax
 80499f8:	8a 00                	mov    (%eax),%al
 80499fa:	84 c0                	test   %al,%al
 80499fc:	75 04                	jne    8049a02 <strtok_delim_check+0x43>
      return 0;
 80499fe:	b0 00                	mov    $0x0,%al
 8049a00:	eb 15                	jmp    8049a17 <strtok_delim_check+0x58>
  for (size_t i=0;i<strlen(delim);i++) {
 8049a02:	ff 45 fc             	incl   -0x4(%ebp)
 8049a05:	ff 75 08             	pushl  0x8(%ebp)
 8049a08:	e8 16 fd ff ff       	call   8049723 <strlen>
 8049a0d:	83 c4 04             	add    $0x4,%esp
 8049a10:	39 45 fc             	cmp    %eax,-0x4(%ebp)
 8049a13:	72 b9                	jb     80499ce <strtok_delim_check+0xf>
    }
  }
  return 1;
 8049a15:	b0 01                	mov    $0x1,%al
}
 8049a17:	c9                   	leave  
 8049a18:	c3                   	ret    

08049a19 <strtok>:

char* strtok(const char* str, const char* delim) {
 8049a19:	55                   	push   %ebp
 8049a1a:	89 e5                	mov    %esp,%ebp
 8049a1c:	83 ec 18             	sub    $0x18,%esp
  if (str!=NULL) {
 8049a1f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8049a23:	74 12                	je     8049a37 <strtok+0x1e>
    strtok_str=str;
 8049a25:	8b 45 08             	mov    0x8(%ebp),%eax
 8049a28:	a3 64 d8 04 08       	mov    %eax,0x804d864
    strtok_index=0;
 8049a2d:	c7 05 68 d8 04 08 00 	movl   $0x0,0x804d868
 8049a34:	00 00 00 
  }
  if (!strtok_str || strtok_index>strlen(strtok_str)) {
 8049a37:	a1 64 d8 04 08       	mov    0x804d864,%eax
 8049a3c:	85 c0                	test   %eax,%eax
 8049a3e:	74 18                	je     8049a58 <strtok+0x3f>
 8049a40:	a1 64 d8 04 08       	mov    0x804d864,%eax
 8049a45:	50                   	push   %eax
 8049a46:	e8 d8 fc ff ff       	call   8049723 <strlen>
 8049a4b:	83 c4 04             	add    $0x4,%esp
 8049a4e:	8b 15 68 d8 04 08    	mov    0x804d868,%edx
 8049a54:	39 d0                	cmp    %edx,%eax
 8049a56:	73 0a                	jae    8049a62 <strtok+0x49>
    return NULL;
 8049a58:	b8 00 00 00 00       	mov    $0x0,%eax
 8049a5d:	e9 9b 00 00 00       	jmp    8049afd <strtok+0xe4>
  }
  char* tok=malloc(sizeof(char)*32);
 8049a62:	83 ec 0c             	sub    $0xc,%esp
 8049a65:	6a 20                	push   $0x20
 8049a67:	e8 ef f8 ff ff       	call   804935b <malloc>
 8049a6c:	83 c4 10             	add    $0x10,%esp
 8049a6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  tok[0]='\0';
 8049a72:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049a75:	c6 00 00             	movb   $0x0,(%eax)
  size_t max_len=32;
 8049a78:	c7 45 f0 20 00 00 00 	movl   $0x20,-0x10(%ebp)
  for (;strtok_delim_check(delim);strtok_index++) {
 8049a7f:	eb 5c                	jmp    8049add <strtok+0xc4>
    if (strlen(tok)+1==max_len) {
 8049a81:	83 ec 0c             	sub    $0xc,%esp
 8049a84:	ff 75 f4             	pushl  -0xc(%ebp)
 8049a87:	e8 97 fc ff ff       	call   8049723 <strlen>
 8049a8c:	83 c4 10             	add    $0x10,%esp
 8049a8f:	40                   	inc    %eax
 8049a90:	39 45 f0             	cmp    %eax,-0x10(%ebp)
 8049a93:	75 1c                	jne    8049ab1 <strtok+0x98>
      tok=realloc(tok,sizeof(char)*(max_len+32));
 8049a95:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049a98:	83 c0 20             	add    $0x20,%eax
 8049a9b:	83 ec 08             	sub    $0x8,%esp
 8049a9e:	50                   	push   %eax
 8049a9f:	ff 75 f4             	pushl  -0xc(%ebp)
 8049aa2:	e8 bc fa ff ff       	call   8049563 <realloc>
 8049aa7:	83 c4 10             	add    $0x10,%esp
 8049aaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
      max_len+=32;
 8049aad:	83 45 f0 20          	addl   $0x20,-0x10(%ebp)
    }
    append(tok,strtok_str[strtok_index]);
 8049ab1:	8b 15 64 d8 04 08    	mov    0x804d864,%edx
 8049ab7:	a1 68 d8 04 08       	mov    0x804d868,%eax
 8049abc:	01 d0                	add    %edx,%eax
 8049abe:	8a 00                	mov    (%eax),%al
 8049ac0:	0f be c0             	movsbl %al,%eax
 8049ac3:	83 ec 08             	sub    $0x8,%esp
 8049ac6:	50                   	push   %eax
 8049ac7:	ff 75 f4             	pushl  -0xc(%ebp)
 8049aca:	e8 93 fe ff ff       	call   8049962 <append>
 8049acf:	83 c4 10             	add    $0x10,%esp
  for (;strtok_delim_check(delim);strtok_index++) {
 8049ad2:	a1 68 d8 04 08       	mov    0x804d868,%eax
 8049ad7:	40                   	inc    %eax
 8049ad8:	a3 68 d8 04 08       	mov    %eax,0x804d868
 8049add:	83 ec 0c             	sub    $0xc,%esp
 8049ae0:	ff 75 0c             	pushl  0xc(%ebp)
 8049ae3:	e8 d7 fe ff ff       	call   80499bf <strtok_delim_check>
 8049ae8:	83 c4 10             	add    $0x10,%esp
 8049aeb:	84 c0                	test   %al,%al
 8049aed:	75 92                	jne    8049a81 <strtok+0x68>
  }
  strtok_index++;
 8049aef:	a1 68 d8 04 08       	mov    0x804d868,%eax
 8049af4:	40                   	inc    %eax
 8049af5:	a3 68 d8 04 08       	mov    %eax,0x804d868
  return tok;
 8049afa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8049afd:	c9                   	leave  
 8049afe:	c3                   	ret    

08049aff <yield>:
#include <tasking.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void yield() {
 8049aff:	55                   	push   %ebp
 8049b00:	89 e5                	mov    %esp,%ebp
 8049b02:	53                   	push   %ebx
  asm volatile("  \
 8049b03:	b8 00 00 00 00       	mov    $0x0,%eax
 8049b08:	89 c3                	mov    %eax,%ebx
 8049b0a:	b8 01 00 00 00       	mov    $0x1,%eax
 8049b0f:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_YIELD) ", %%eax; \
    int $80; \
  "::"b"(0));
}
 8049b11:	90                   	nop
 8049b12:	5b                   	pop    %ebx
 8049b13:	5d                   	pop    %ebp
 8049b14:	c3                   	ret    

08049b15 <create_proc>:

void create_proc(void* start,void* address_space,void* param1,void* param2) {
 8049b15:	55                   	push   %ebp
 8049b16:	89 e5                	mov    %esp,%ebp
 8049b18:	56                   	push   %esi
 8049b19:	53                   	push   %ebx
  asm volatile("  \
 8049b1a:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b1d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8049b20:	8b 55 10             	mov    0x10(%ebp),%edx
 8049b23:	8b 75 14             	mov    0x14(%ebp),%esi
 8049b26:	89 c3                	mov    %eax,%ebx
 8049b28:	b8 00 00 00 00       	mov    $0x0,%eax
 8049b2d:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_CREATEPROC) ", %%eax; \
    int $80; \
  "::"b"(start),"c"(address_space),"d"(param1),"S"(param2));
}
 8049b2f:	90                   	nop
 8049b30:	5b                   	pop    %ebx
 8049b31:	5e                   	pop    %esi
 8049b32:	5d                   	pop    %ebp
 8049b33:	c3                   	ret    

08049b34 <exit>:

__attribute__((noreturn)) void exit(int code) {
 8049b34:	55                   	push   %ebp
 8049b35:	89 e5                	mov    %esp,%ebp
 8049b37:	53                   	push   %ebx
  code=code&0xff;
 8049b38:	81 65 08 ff 00 00 00 	andl   $0xff,0x8(%ebp)
  asm volatile("  \
 8049b3f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b42:	89 c3                	mov    %eax,%ebx
 8049b44:	b8 04 00 00 00       	mov    $0x4,%eax
 8049b49:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_EXIT) ", %%eax; \
    int $80; \
  "::"b"(code));
  for(;;);
 8049b4b:	eb fe                	jmp    8049b4b <exit+0x17>

08049b4d <block_thread>:
}


void block_thread(thread_state state) {
 8049b4d:	55                   	push   %ebp
 8049b4e:	89 e5                	mov    %esp,%ebp
 8049b50:	53                   	push   %ebx
  asm volatile("  \
 8049b51:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b54:	89 c3                	mov    %eax,%ebx
 8049b56:	b8 02 00 00 00       	mov    $0x2,%eax
 8049b5b:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_BLOCK) ", %%eax; \
    int $80; \
  "::"b"(state));
}
 8049b5d:	90                   	nop
 8049b5e:	5b                   	pop    %ebx
 8049b5f:	5d                   	pop    %ebp
 8049b60:	c3                   	ret    

08049b61 <unblock_thread>:

void unblock_thread(pid_t pid,pid_t tid) {
 8049b61:	55                   	push   %ebp
 8049b62:	89 e5                	mov    %esp,%ebp
 8049b64:	53                   	push   %ebx
  asm volatile("  \
 8049b65:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b68:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049b6b:	89 c3                	mov    %eax,%ebx
 8049b6d:	89 d1                	mov    %edx,%ecx
 8049b6f:	b8 03 00 00 00       	mov    $0x3,%eax
 8049b74:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_UNBLOCK) ", %%eax; \
    int $80; \
  "::"b"(pid),"c"(tid));
}
 8049b76:	90                   	nop
 8049b77:	5b                   	pop    %ebx
 8049b78:	5d                   	pop    %ebp
 8049b79:	c3                   	ret    

08049b7a <check_proc_exists>:

char check_proc_exists(pid_t pid) {
 8049b7a:	55                   	push   %ebp
 8049b7b:	89 e5                	mov    %esp,%ebp
 8049b7d:	53                   	push   %ebx
 8049b7e:	83 ec 10             	sub    $0x10,%esp
  char exists;
  asm volatile("  \
 8049b81:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b84:	89 c3                	mov    %eax,%ebx
 8049b86:	b8 14 00 00 00       	mov    $0x14,%eax
 8049b8b:	cd 50                	int    $0x50
 8049b8d:	88 c8                	mov    %cl,%al
 8049b8f:	88 45 fb             	mov    %al,-0x5(%ebp)
    mov $" QU(SYSCALL_CHECK_PROC_EXISTS) ", %%eax; \
    int $80; \
  ":"=c"(exists):"b"(pid));
  return exists;
 8049b92:	8a 45 fb             	mov    -0x5(%ebp),%al
}
 8049b95:	83 c4 10             	add    $0x10,%esp
 8049b98:	5b                   	pop    %ebx
 8049b99:	5d                   	pop    %ebp
 8049b9a:	c3                   	ret    

08049b9b <rpc_call>:

#define QUAUX(X) #X
#define QU(X) QUAUX(X)


void* rpc_call(pid_t pid,char* name,void* buf,size_t size) {
 8049b9b:	55                   	push   %ebp
 8049b9c:	89 e5                	mov    %esp,%ebp
 8049b9e:	57                   	push   %edi
 8049b9f:	56                   	push   %esi
 8049ba0:	53                   	push   %ebx
 8049ba1:	83 ec 10             	sub    $0x10,%esp
  void* retbuf;
  asm volatile("  \
 8049ba4:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ba7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8049baa:	8b 55 10             	mov    0x10(%ebp),%edx
 8049bad:	8b 75 14             	mov    0x14(%ebp),%esi
 8049bb0:	89 c3                	mov    %eax,%ebx
 8049bb2:	b8 0f 00 00 00       	mov    $0xf,%eax
 8049bb7:	cd 50                	int    $0x50
 8049bb9:	89 f8                	mov    %edi,%eax
 8049bbb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mov $" QU(SYSCALL_CALL_RPC) ", %%eax; \
    int $80; \
  ":"=D"(retbuf):"b"(pid),"c"(name),"d"(buf),"S"(size));
  return retbuf;
 8049bbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049bc1:	83 c4 10             	add    $0x10,%esp
 8049bc4:	5b                   	pop    %ebx
 8049bc5:	5e                   	pop    %esi
 8049bc6:	5f                   	pop    %edi
 8049bc7:	5d                   	pop    %ebp
 8049bc8:	c3                   	ret    

08049bc9 <rpc_register_func>:

void rpc_register_func(char* name,rpc_func code) {
 8049bc9:	55                   	push   %ebp
 8049bca:	89 e5                	mov    %esp,%ebp
 8049bcc:	53                   	push   %ebx
  asm volatile("  \
 8049bcd:	8b 45 08             	mov    0x8(%ebp),%eax
 8049bd0:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049bd3:	89 c3                	mov    %eax,%ebx
 8049bd5:	89 d1                	mov    %edx,%ecx
 8049bd7:	b8 10 00 00 00       	mov    $0x10,%eax
 8049bdc:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_REGISTER_RPC) ", %%eax; \
    int $80; \
  "::"b"(name),"c"(code));
}
 8049bde:	90                   	nop
 8049bdf:	5b                   	pop    %ebx
 8049be0:	5d                   	pop    %ebp
 8049be1:	c3                   	ret    

08049be2 <rpc_deallocate_buf>:

void rpc_deallocate_buf(void* buf,size_t size) {
 8049be2:	55                   	push   %ebp
 8049be3:	89 e5                	mov    %esp,%ebp
 8049be5:	53                   	push   %ebx
  asm volatile("  \
 8049be6:	8b 45 08             	mov    0x8(%ebp),%eax
 8049be9:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049bec:	89 c3                	mov    %eax,%ebx
 8049bee:	89 d1                	mov    %edx,%ecx
 8049bf0:	b8 11 00 00 00       	mov    $0x11,%eax
 8049bf5:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_DEALLOCTATE_RPC_RET) ", %%eax; \
    int $80; \
  "::"b"(buf),"c"(size));
}
 8049bf7:	90                   	nop
 8049bf8:	5b                   	pop    %ebx
 8049bf9:	5d                   	pop    %ebp
 8049bfa:	c3                   	ret    

08049bfb <rpc_return>:

void rpc_return(void* buf,size_t size) {
 8049bfb:	55                   	push   %ebp
 8049bfc:	89 e5                	mov    %esp,%ebp
 8049bfe:	53                   	push   %ebx
  asm volatile("  \
 8049bff:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c02:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049c05:	89 c3                	mov    %eax,%ebx
 8049c07:	89 d1                	mov    %edx,%ecx
 8049c09:	b8 12 00 00 00       	mov    $0x12,%eax
 8049c0e:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_RPC_RET) ", %%eax; \
    int $80; \
  "::"b"(buf),"c"(size));
}
 8049c10:	90                   	nop
 8049c11:	5b                   	pop    %ebx
 8049c12:	5d                   	pop    %ebp
 8049c13:	c3                   	ret    

08049c14 <rpc_mark_as_init>:

void rpc_mark_as_init() {
 8049c14:	55                   	push   %ebp
 8049c15:	89 e5                	mov    %esp,%ebp
  asm volatile("  \
 8049c17:	b8 15 00 00 00       	mov    $0x15,%eax
 8049c1c:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_RPC_MARK_AS_INIT) ", %%eax; \
    int $80; \
  "::);
}
 8049c1e:	90                   	nop
 8049c1f:	5d                   	pop    %ebp
 8049c20:	c3                   	ret    

08049c21 <rpc_is_init>:
char rpc_is_init(pid_t pid) {
 8049c21:	55                   	push   %ebp
 8049c22:	89 e5                	mov    %esp,%ebp
 8049c24:	53                   	push   %ebx
 8049c25:	83 ec 10             	sub    $0x10,%esp
  char is_init;
  asm volatile("  \
 8049c28:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c2b:	89 c3                	mov    %eax,%ebx
 8049c2d:	b8 16 00 00 00       	mov    $0x16,%eax
 8049c32:	cd 50                	int    $0x50
 8049c34:	88 c8                	mov    %cl,%al
 8049c36:	88 45 fb             	mov    %al,-0x5(%ebp)
    mov $" QU(SYSCALL_RPC_IS_INIT) ", %%eax; \
    int $80; \
  ":"=c"(is_init):"b"(pid));
  return is_init;
 8049c39:	8a 45 fb             	mov    -0x5(%ebp),%al
}
 8049c3c:	83 c4 10             	add    $0x10,%esp
 8049c3f:	5b                   	pop    %ebx
 8049c40:	5d                   	pop    %ebp
 8049c41:	c3                   	ret    

08049c42 <serialize_int>:
#include <serdes.h>
#include <stdlib.h>
#include <string.h>

void serialize_int(int num,serdes_state* state) {
 8049c42:	55                   	push   %ebp
 8049c43:	89 e5                	mov    %esp,%ebp
 8049c45:	83 ec 08             	sub    $0x8,%esp
  state->buf=realloc(state->buf,state->sizeorpos+sizeof(int));
 8049c48:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049c4b:	8b 40 04             	mov    0x4(%eax),%eax
 8049c4e:	8d 50 04             	lea    0x4(%eax),%edx
 8049c51:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049c54:	8b 00                	mov    (%eax),%eax
 8049c56:	83 ec 08             	sub    $0x8,%esp
 8049c59:	52                   	push   %edx
 8049c5a:	50                   	push   %eax
 8049c5b:	e8 03 f9 ff ff       	call   8049563 <realloc>
 8049c60:	83 c4 10             	add    $0x10,%esp
 8049c63:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049c66:	89 02                	mov    %eax,(%edx)
  *((int*)(state->buf+state->sizeorpos))=num;
 8049c68:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049c6b:	8b 10                	mov    (%eax),%edx
 8049c6d:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049c70:	8b 40 04             	mov    0x4(%eax),%eax
 8049c73:	01 c2                	add    %eax,%edx
 8049c75:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c78:	89 02                	mov    %eax,(%edx)
  state->sizeorpos+=sizeof(int);
 8049c7a:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049c7d:	8b 40 04             	mov    0x4(%eax),%eax
 8049c80:	8d 50 04             	lea    0x4(%eax),%edx
 8049c83:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049c86:	89 50 04             	mov    %edx,0x4(%eax)
}
 8049c89:	90                   	nop
 8049c8a:	c9                   	leave  
 8049c8b:	c3                   	ret    

08049c8c <serialize_ptr>:

void serialize_ptr(void* ptr,serdes_state* state) {
 8049c8c:	55                   	push   %ebp
 8049c8d:	89 e5                	mov    %esp,%ebp
 8049c8f:	83 ec 08             	sub    $0x8,%esp
  state->buf=realloc(state->buf,state->sizeorpos+sizeof(void*));
 8049c92:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049c95:	8b 40 04             	mov    0x4(%eax),%eax
 8049c98:	8d 50 04             	lea    0x4(%eax),%edx
 8049c9b:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049c9e:	8b 00                	mov    (%eax),%eax
 8049ca0:	83 ec 08             	sub    $0x8,%esp
 8049ca3:	52                   	push   %edx
 8049ca4:	50                   	push   %eax
 8049ca5:	e8 b9 f8 ff ff       	call   8049563 <realloc>
 8049caa:	83 c4 10             	add    $0x10,%esp
 8049cad:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049cb0:	89 02                	mov    %eax,(%edx)
  *((void**)(state->buf+state->sizeorpos))=ptr;
 8049cb2:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049cb5:	8b 10                	mov    (%eax),%edx
 8049cb7:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049cba:	8b 40 04             	mov    0x4(%eax),%eax
 8049cbd:	01 c2                	add    %eax,%edx
 8049cbf:	8b 45 08             	mov    0x8(%ebp),%eax
 8049cc2:	89 02                	mov    %eax,(%edx)
  state->sizeorpos+=sizeof(void*);
 8049cc4:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049cc7:	8b 40 04             	mov    0x4(%eax),%eax
 8049cca:	8d 50 04             	lea    0x4(%eax),%edx
 8049ccd:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049cd0:	89 50 04             	mov    %edx,0x4(%eax)
}
 8049cd3:	90                   	nop
 8049cd4:	c9                   	leave  
 8049cd5:	c3                   	ret    

08049cd6 <serialize_ary>:

void serialize_ary(void* ary,size_t len,serdes_state* state) {
 8049cd6:	55                   	push   %ebp
 8049cd7:	89 e5                	mov    %esp,%ebp
 8049cd9:	83 ec 08             	sub    $0x8,%esp
  state->buf=realloc(state->buf,state->sizeorpos+len);
 8049cdc:	8b 45 10             	mov    0x10(%ebp),%eax
 8049cdf:	8b 50 04             	mov    0x4(%eax),%edx
 8049ce2:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049ce5:	01 c2                	add    %eax,%edx
 8049ce7:	8b 45 10             	mov    0x10(%ebp),%eax
 8049cea:	8b 00                	mov    (%eax),%eax
 8049cec:	83 ec 08             	sub    $0x8,%esp
 8049cef:	52                   	push   %edx
 8049cf0:	50                   	push   %eax
 8049cf1:	e8 6d f8 ff ff       	call   8049563 <realloc>
 8049cf6:	83 c4 10             	add    $0x10,%esp
 8049cf9:	8b 55 10             	mov    0x10(%ebp),%edx
 8049cfc:	89 02                	mov    %eax,(%edx)
  memcpy(state->buf+state->sizeorpos,ary,len);
 8049cfe:	8b 45 10             	mov    0x10(%ebp),%eax
 8049d01:	8b 10                	mov    (%eax),%edx
 8049d03:	8b 45 10             	mov    0x10(%ebp),%eax
 8049d06:	8b 40 04             	mov    0x4(%eax),%eax
 8049d09:	01 d0                	add    %edx,%eax
 8049d0b:	83 ec 04             	sub    $0x4,%esp
 8049d0e:	ff 75 0c             	pushl  0xc(%ebp)
 8049d11:	ff 75 08             	pushl  0x8(%ebp)
 8049d14:	50                   	push   %eax
 8049d15:	e8 39 f9 ff ff       	call   8049653 <memcpy>
 8049d1a:	83 c4 10             	add    $0x10,%esp
  state->sizeorpos+=len;
 8049d1d:	8b 45 10             	mov    0x10(%ebp),%eax
 8049d20:	8b 50 04             	mov    0x4(%eax),%edx
 8049d23:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049d26:	01 c2                	add    %eax,%edx
 8049d28:	8b 45 10             	mov    0x10(%ebp),%eax
 8049d2b:	89 50 04             	mov    %edx,0x4(%eax)
}
 8049d2e:	90                   	nop
 8049d2f:	c9                   	leave  
 8049d30:	c3                   	ret    

08049d31 <start_deserialize>:


void start_deserialize(char* buf,serdes_state* state) {
 8049d31:	55                   	push   %ebp
 8049d32:	89 e5                	mov    %esp,%ebp
  state->buf=buf;
 8049d34:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049d37:	8b 55 08             	mov    0x8(%ebp),%edx
 8049d3a:	89 10                	mov    %edx,(%eax)
  state->sizeorpos=0;
 8049d3c:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049d3f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
 8049d46:	90                   	nop
 8049d47:	5d                   	pop    %ebp
 8049d48:	c3                   	ret    

08049d49 <deserialize_int>:

int deserialize_int(serdes_state* state) {
 8049d49:	55                   	push   %ebp
 8049d4a:	89 e5                	mov    %esp,%ebp
 8049d4c:	83 ec 10             	sub    $0x10,%esp
  int num=*((int*)(state->buf+state->sizeorpos));
 8049d4f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d52:	8b 10                	mov    (%eax),%edx
 8049d54:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d57:	8b 40 04             	mov    0x4(%eax),%eax
 8049d5a:	01 d0                	add    %edx,%eax
 8049d5c:	8b 00                	mov    (%eax),%eax
 8049d5e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  state->sizeorpos+=sizeof(int);
 8049d61:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d64:	8b 40 04             	mov    0x4(%eax),%eax
 8049d67:	8d 50 04             	lea    0x4(%eax),%edx
 8049d6a:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d6d:	89 50 04             	mov    %edx,0x4(%eax)
  return num;
 8049d70:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 8049d73:	c9                   	leave  
 8049d74:	c3                   	ret    

08049d75 <deserialize_ptr>:

void* deserialize_ptr(serdes_state* state) {
 8049d75:	55                   	push   %ebp
 8049d76:	89 e5                	mov    %esp,%ebp
 8049d78:	83 ec 10             	sub    $0x10,%esp
  void* ptr=*((void**)(state->buf+state->sizeorpos));
 8049d7b:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d7e:	8b 10                	mov    (%eax),%edx
 8049d80:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d83:	8b 40 04             	mov    0x4(%eax),%eax
 8049d86:	01 d0                	add    %edx,%eax
 8049d88:	8b 00                	mov    (%eax),%eax
 8049d8a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  state->sizeorpos+=sizeof(void*);
 8049d8d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d90:	8b 40 04             	mov    0x4(%eax),%eax
 8049d93:	8d 50 04             	lea    0x4(%eax),%edx
 8049d96:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d99:	89 50 04             	mov    %edx,0x4(%eax)
  return ptr;
 8049d9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 8049d9f:	c9                   	leave  
 8049da0:	c3                   	ret    

08049da1 <deserialize_ary>:

void* deserialize_ary(size_t len,serdes_state* state) {
 8049da1:	55                   	push   %ebp
 8049da2:	89 e5                	mov    %esp,%ebp
 8049da4:	83 ec 18             	sub    $0x18,%esp
  void* ary_in_buf=((void*)(state->buf+state->sizeorpos));
 8049da7:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049daa:	8b 10                	mov    (%eax),%edx
 8049dac:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049daf:	8b 40 04             	mov    0x4(%eax),%eax
 8049db2:	01 d0                	add    %edx,%eax
 8049db4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  state->sizeorpos+=len;
 8049db7:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049dba:	8b 50 04             	mov    0x4(%eax),%edx
 8049dbd:	8b 45 08             	mov    0x8(%ebp),%eax
 8049dc0:	01 c2                	add    %eax,%edx
 8049dc2:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049dc5:	89 50 04             	mov    %edx,0x4(%eax)
  void* ary=malloc(len);
 8049dc8:	83 ec 0c             	sub    $0xc,%esp
 8049dcb:	ff 75 08             	pushl  0x8(%ebp)
 8049dce:	e8 88 f5 ff ff       	call   804935b <malloc>
 8049dd3:	83 c4 10             	add    $0x10,%esp
 8049dd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  memcpy(ary,ary_in_buf,len);
 8049dd9:	83 ec 04             	sub    $0x4,%esp
 8049ddc:	ff 75 08             	pushl  0x8(%ebp)
 8049ddf:	ff 75 f4             	pushl  -0xc(%ebp)
 8049de2:	ff 75 f0             	pushl  -0x10(%ebp)
 8049de5:	e8 69 f8 ff ff       	call   8049653 <memcpy>
 8049dea:	83 c4 10             	add    $0x10,%esp
  return ary;
 8049ded:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049df0:	c9                   	leave  
 8049df1:	c3                   	ret    

08049df2 <ceilf>:
float ceilf(float num) {
 8049df2:	55                   	push   %ebp
 8049df3:	89 e5                	mov    %esp,%ebp
 8049df5:	83 ec 18             	sub    $0x18,%esp
  int inum=(int)num;
 8049df8:	d9 45 08             	flds   0x8(%ebp)
 8049dfb:	d9 7d ee             	fnstcw -0x12(%ebp)
 8049dfe:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
 8049e02:	80 cc 0c             	or     $0xc,%ah
 8049e05:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
 8049e09:	d9 6d ec             	fldcw  -0x14(%ebp)
 8049e0c:	db 5d fc             	fistpl -0x4(%ebp)
 8049e0f:	d9 6d ee             	fldcw  -0x12(%ebp)
  if (num==(float)inum) {
 8049e12:	db 45 fc             	fildl  -0x4(%ebp)
 8049e15:	d9 45 08             	flds   0x8(%ebp)
 8049e18:	da e9                	fucompp 
 8049e1a:	df e0                	fnstsw %ax
 8049e1c:	80 e4 45             	and    $0x45,%ah
 8049e1f:	80 f4 40             	xor    $0x40,%ah
 8049e22:	75 05                	jne    8049e29 <ceilf+0x37>
    return (float)inum;
 8049e24:	db 45 fc             	fildl  -0x4(%ebp)
 8049e27:	eb 0a                	jmp    8049e33 <ceilf+0x41>
  }
  return (float)(inum+1);
 8049e29:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049e2c:	40                   	inc    %eax
 8049e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8049e30:	db 45 e8             	fildl  -0x18(%ebp)
}
 8049e33:	c9                   	leave  
 8049e34:	c3                   	ret    

08049e35 <ceil>:

double ceil(double num) {
 8049e35:	55                   	push   %ebp
 8049e36:	89 e5                	mov    %esp,%ebp
 8049e38:	83 ec 20             	sub    $0x20,%esp
 8049e3b:	8b 45 08             	mov    0x8(%ebp),%eax
 8049e3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8049e41:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049e44:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int inum=(int)num;
 8049e47:	dd 45 e8             	fldl   -0x18(%ebp)
 8049e4a:	d9 7d e6             	fnstcw -0x1a(%ebp)
 8049e4d:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 8049e51:	80 cc 0c             	or     $0xc,%ah
 8049e54:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 8049e58:	d9 6d e4             	fldcw  -0x1c(%ebp)
 8049e5b:	db 5d fc             	fistpl -0x4(%ebp)
 8049e5e:	d9 6d e6             	fldcw  -0x1a(%ebp)
  if (num==(double)inum) {
 8049e61:	db 45 fc             	fildl  -0x4(%ebp)
 8049e64:	dd 45 e8             	fldl   -0x18(%ebp)
 8049e67:	da e9                	fucompp 
 8049e69:	df e0                	fnstsw %ax
 8049e6b:	80 e4 45             	and    $0x45,%ah
 8049e6e:	80 f4 40             	xor    $0x40,%ah
 8049e71:	75 05                	jne    8049e78 <ceil+0x43>
    return (double)inum;
 8049e73:	db 45 fc             	fildl  -0x4(%ebp)
 8049e76:	eb 0a                	jmp    8049e82 <ceil+0x4d>
  }
  return (double)(inum+1);
 8049e78:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049e7b:	40                   	inc    %eax
 8049e7c:	89 45 e0             	mov    %eax,-0x20(%ebp)
 8049e7f:	db 45 e0             	fildl  -0x20(%ebp)
}
 8049e82:	c9                   	leave  
 8049e83:	c3                   	ret    

08049e84 <__do_global_ctors_aux>:
 8049e84:	a1 00 b0 04 08       	mov    0x804b000,%eax
 8049e89:	83 f8 ff             	cmp    $0xffffffff,%eax
 8049e8c:	74 1a                	je     8049ea8 <__do_global_ctors_aux+0x24>
 8049e8e:	55                   	push   %ebp
 8049e8f:	89 e5                	mov    %esp,%ebp
 8049e91:	53                   	push   %ebx
 8049e92:	52                   	push   %edx
 8049e93:	bb 00 b0 04 08       	mov    $0x804b000,%ebx
 8049e98:	ff d0                	call   *%eax
 8049e9a:	83 eb 04             	sub    $0x4,%ebx
 8049e9d:	8b 03                	mov    (%ebx),%eax
 8049e9f:	83 f8 ff             	cmp    $0xffffffff,%eax
 8049ea2:	75 f4                	jne    8049e98 <__do_global_ctors_aux+0x14>
 8049ea4:	58                   	pop    %eax
 8049ea5:	5b                   	pop    %ebx
 8049ea6:	5d                   	pop    %ebp
 8049ea7:	c3                   	ret    
 8049ea8:	c3                   	ret    

Disassembly of section .fini:

08049ea9 <_fini>:
 8049ea9:	e8 5a e2 ff ff       	call   8048108 <__do_global_dtors_aux>
 8049eae:	c2 00 00             	ret    $0x0
