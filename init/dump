
init:     file format elf32-i386


Disassembly of section .init:

08048074 <.init>:
 8048074:	e8 d0 00 00 00       	call   8048149 <_start+0xb9>
 8048079:	e8 fc ff ff ff       	call   804807a <_start-0x16>
 804807e:	c2 00 00             	ret    $0x0

Disassembly of section .text:

08048090 <_start>:
 8048090:	e8 0a 16 00 00       	call   804969f <__stdio_init>
 8048095:	e8 ad 03 00 00       	call   8048447 <main>
 804809a:	6a 00                	push   $0x0
 804809c:	e8 d4 23 00 00       	call   804a475 <exit>
 80480a1:	c3                   	ret    
 80480a2:	66 90                	xchg   %ax,%ax
 80480a4:	b8 00 00 00 00       	mov    $0x0,%eax
 80480a9:	3d 00 00 00 00       	cmp    $0x0,%eax
 80480ae:	74 1c                	je     80480cc <_start+0x3c>
 80480b0:	b8 00 00 00 00       	mov    $0x0,%eax
 80480b5:	85 c0                	test   %eax,%eax
 80480b7:	74 13                	je     80480cc <_start+0x3c>
 80480b9:	55                   	push   %ebp
 80480ba:	89 e5                	mov    %esp,%ebp
 80480bc:	83 ec 14             	sub    $0x14,%esp
 80480bf:	68 00 00 00 00       	push   $0x0
 80480c4:	ff d0                	call   *%eax
 80480c6:	83 c4 10             	add    $0x10,%esp
 80480c9:	c9                   	leave  
 80480ca:	c3                   	ret    
 80480cb:	90                   	nop
 80480cc:	c3                   	ret    
 80480cd:	8d 76 00             	lea    0x0(%esi),%esi
 80480d0:	b8 00 00 00 00       	mov    $0x0,%eax
 80480d5:	2d 00 00 00 00       	sub    $0x0,%eax
 80480da:	89 c2                	mov    %eax,%edx
 80480dc:	c1 fa 02             	sar    $0x2,%edx
 80480df:	c1 e8 1f             	shr    $0x1f,%eax
 80480e2:	01 d0                	add    %edx,%eax
 80480e4:	d1 f8                	sar    %eax
 80480e6:	74 1c                	je     8048104 <_start+0x74>
 80480e8:	ba 00 00 00 00       	mov    $0x0,%edx
 80480ed:	85 d2                	test   %edx,%edx
 80480ef:	74 13                	je     8048104 <_start+0x74>
 80480f1:	55                   	push   %ebp
 80480f2:	89 e5                	mov    %esp,%ebp
 80480f4:	83 ec 10             	sub    $0x10,%esp
 80480f7:	50                   	push   %eax
 80480f8:	68 00 00 00 00       	push   $0x0
 80480fd:	ff d2                	call   *%edx
 80480ff:	83 c4 10             	add    $0x10,%esp
 8048102:	c9                   	leave  
 8048103:	c3                   	ret    
 8048104:	c3                   	ret    
 8048105:	8d 76 00             	lea    0x0(%esi),%esi
 8048108:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0
 804810f:	75 63                	jne    8048174 <_start+0xe4>
 8048111:	55                   	push   %ebp
 8048112:	89 e5                	mov    %esp,%ebp
 8048114:	56                   	push   %esi
 8048115:	53                   	push   %ebx
 8048116:	bb 00 00 00 00       	mov    $0x0,%ebx
 804811b:	81 eb 00 00 00 00    	sub    $0x0,%ebx
 8048121:	c1 fb 02             	sar    $0x2,%ebx
 8048124:	4b                   	dec    %ebx
 8048125:	be 00 00 00 00       	mov    $0x0,%esi
 804812a:	a1 04 00 00 00       	mov    0x4,%eax
 804812f:	39 d8                	cmp    %ebx,%eax
 8048131:	73 13                	jae    8048146 <_start+0xb6>
 8048133:	90                   	nop
 8048134:	40                   	inc    %eax
 8048135:	a3 04 00 00 00       	mov    %eax,0x4
 804813a:	ff 14 86             	call   *(%esi,%eax,4)
 804813d:	a1 04 00 00 00       	mov    0x4,%eax
 8048142:	39 d8                	cmp    %ebx,%eax
 8048144:	72 ee                	jb     8048134 <_start+0xa4>
 8048146:	e8 59 ff ff ff       	call   80480a4 <_start+0x14>
 804814b:	b8 00 00 00 00       	mov    $0x0,%eax
 8048150:	85 c0                	test   %eax,%eax
 8048152:	74 10                	je     8048164 <_start+0xd4>
 8048154:	83 ec 0c             	sub    $0xc,%esp
 8048157:	68 00 00 00 00       	push   $0x0
 804815c:	e8 fc ff ff ff       	call   804815d <_start+0xcd>
 8048161:	83 c4 10             	add    $0x10,%esp
 8048164:	c6 05 00 00 00 00 01 	movb   $0x1,0x0
 804816b:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804816e:	5b                   	pop    %ebx
 804816f:	5e                   	pop    %esi
 8048170:	5d                   	pop    %ebp
 8048171:	c3                   	ret    
 8048172:	66 90                	xchg   %ax,%ax
 8048174:	c3                   	ret    
 8048175:	8d 76 00             	lea    0x0(%esi),%esi
 8048178:	b8 00 00 00 00       	mov    $0x0,%eax
 804817d:	85 c0                	test   %eax,%eax
 804817f:	74 1f                	je     80481a0 <_start+0x110>
 8048181:	55                   	push   %ebp
 8048182:	89 e5                	mov    %esp,%ebp
 8048184:	83 ec 10             	sub    $0x10,%esp
 8048187:	68 08 00 00 00       	push   $0x8
 804818c:	68 00 00 00 00       	push   $0x0
 8048191:	e8 fc ff ff ff       	call   8048192 <_start+0x102>
 8048196:	83 c4 10             	add    $0x10,%esp
 8048199:	c9                   	leave  
 804819a:	e9 31 ff ff ff       	jmp    80480d0 <_start+0x40>
 804819f:	90                   	nop
 80481a0:	e9 2b ff ff ff       	jmp    80480d0 <_start+0x40>

080481a5 <getsize>:
   uint32_t eflags; //!< Pushed by the processor automatically
   uint32_t useresp; //!< Pushed by the processor automatically
   uint32_t ss; //!< Pushed by the processor automatically
} registers_t;

size_t getsize(const char *in) {
 80481a5:	55                   	push   %ebp
 80481a6:	89 e5                	mov    %esp,%ebp
 80481a8:	83 ec 10             	sub    $0x10,%esp
    size_t size=0;
 80481ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    size_t j;
    size_t count=1;
 80481b2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    for (j=11;j>0;j--,count*=8) {
 80481b9:	c7 45 f8 0b 00 00 00 	movl   $0xb,-0x8(%ebp)
 80481c0:	eb 21                	jmp    80481e3 <getsize+0x3e>
        size+=((in[j-1]-'0')*count);
 80481c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80481c5:	8d 50 ff             	lea    -0x1(%eax),%edx
 80481c8:	8b 45 08             	mov    0x8(%ebp),%eax
 80481cb:	01 d0                	add    %edx,%eax
 80481cd:	8a 00                	mov    (%eax),%al
 80481cf:	0f be c0             	movsbl %al,%eax
 80481d2:	83 e8 30             	sub    $0x30,%eax
 80481d5:	0f af 45 f4          	imul   -0xc(%ebp),%eax
 80481d9:	01 45 fc             	add    %eax,-0x4(%ebp)
    for (j=11;j>0;j--,count*=8) {
 80481dc:	ff 4d f8             	decl   -0x8(%ebp)
 80481df:	c1 65 f4 03          	shll   $0x3,-0xc(%ebp)
 80481e3:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
 80481e7:	75 d9                	jne    80481c2 <getsize+0x1d>
    }
    return size;
 80481e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 80481ec:	c9                   	leave  
 80481ed:	c3                   	ret    

080481ee <find_loc>:

size_t find_loc(char* name,char* initrd) {
 80481ee:	55                   	push   %ebp
 80481ef:	89 e5                	mov    %esp,%ebp
 80481f1:	81 ec c8 00 00 00    	sub    $0xc8,%esp
  size_t pos=0;
 80481f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  tar_header tar_hdr;
  for (int i=0;;i++) {
 80481fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    char* tar_hdr_ptr=(char*)&tar_hdr;
 8048205:	8d 85 47 ff ff ff    	lea    -0xb9(%ebp),%eax
 804820b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for (size_t i=0;i<sizeof(tar_hdr);i++) {
 804820e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 8048215:	eb 1c                	jmp    8048233 <find_loc+0x45>
      tar_hdr_ptr[i]=initrd[pos+i];
 8048217:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804821a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804821d:	01 c2                	add    %eax,%edx
 804821f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048222:	01 d0                	add    %edx,%eax
 8048224:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 8048227:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804822a:	01 ca                	add    %ecx,%edx
 804822c:	8a 00                	mov    (%eax),%al
 804822e:	88 02                	mov    %al,(%edx)
    for (size_t i=0;i<sizeof(tar_hdr);i++) {
 8048230:	ff 45 ec             	incl   -0x14(%ebp)
 8048233:	81 7d ec 9c 00 00 00 	cmpl   $0x9c,-0x14(%ebp)
 804823a:	76 db                	jbe    8048217 <find_loc+0x29>
    }
    if (tar_hdr.filename[0]=='\0') break;
 804823c:	8a 85 47 ff ff ff    	mov    -0xb9(%ebp),%al
 8048242:	84 c0                	test   %al,%al
 8048244:	74 64                	je     80482aa <find_loc+0xbc>
    size_t size=getsize(tar_hdr.size);
 8048246:	8d 85 47 ff ff ff    	lea    -0xb9(%ebp),%eax
 804824c:	83 c0 7c             	add    $0x7c,%eax
 804824f:	50                   	push   %eax
 8048250:	e8 50 ff ff ff       	call   80481a5 <getsize>
 8048255:	83 c4 04             	add    $0x4,%esp
 8048258:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pos+=512;
 804825b:	81 45 f4 00 02 00 00 	addl   $0x200,-0xc(%ebp)
    if (strcmp(tar_hdr.filename,name)==0) {
 8048262:	83 ec 08             	sub    $0x8,%esp
 8048265:	ff 75 08             	push   0x8(%ebp)
 8048268:	8d 85 47 ff ff ff    	lea    -0xb9(%ebp),%eax
 804826e:	50                   	push   %eax
 804826f:	e8 91 1d 00 00       	call   804a005 <strcmp>
 8048274:	83 c4 10             	add    $0x10,%esp
 8048277:	85 c0                	test   %eax,%eax
 8048279:	75 05                	jne    8048280 <find_loc+0x92>
      return pos;
 804827b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804827e:	eb 30                	jmp    80482b0 <find_loc+0xc2>
      break;
    }
    pos+=size;
 8048280:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048283:	01 45 f4             	add    %eax,-0xc(%ebp)
    if (pos%512!=0) {
 8048286:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048289:	25 ff 01 00 00       	and    $0x1ff,%eax
 804828e:	85 c0                	test   %eax,%eax
 8048290:	74 10                	je     80482a2 <find_loc+0xb4>
      pos+=512-(pos%512);
 8048292:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048295:	25 00 fe ff ff       	and    $0xfffffe00,%eax
 804829a:	05 00 02 00 00       	add    $0x200,%eax
 804829f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (int i=0;;i++) {
 80482a2:	ff 45 f0             	incl   -0x10(%ebp)
 80482a5:	e9 5b ff ff ff       	jmp    8048205 <find_loc+0x17>
    if (tar_hdr.filename[0]=='\0') break;
 80482aa:	90                   	nop
    }
  }
  return 0;
 80482ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
 80482b0:	c9                   	leave  
 80482b1:	c3                   	ret    

080482b2 <load_proc>:

char load_proc(size_t datapos,char* initrd) {
 80482b2:	55                   	push   %ebp
 80482b3:	89 e5                	mov    %esp,%ebp
 80482b5:	81 ec 88 00 00 00    	sub    $0x88,%esp
  int pos=0;
 80482bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  elf_header header;
  pos=datapos;
 80482c2:	8b 45 08             	mov    0x8(%ebp),%eax
 80482c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char* hdr_ptr=(char*)&header;
 80482c8:	8d 45 a0             	lea    -0x60(%ebp),%eax
 80482cb:	89 45 e0             	mov    %eax,-0x20(%ebp)
  for (size_t i=0;i<sizeof(elf_header);i++) {
 80482ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 80482d5:	eb 1a                	jmp    80482f1 <load_proc+0x3f>
    hdr_ptr[i]=initrd[pos];
 80482d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80482da:	8b 45 0c             	mov    0xc(%ebp),%eax
 80482dd:	01 d0                	add    %edx,%eax
 80482df:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 80482e2:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80482e5:	01 ca                	add    %ecx,%edx
 80482e7:	8a 00                	mov    (%eax),%al
 80482e9:	88 02                	mov    %al,(%edx)
    pos++;
 80482eb:	ff 45 f4             	incl   -0xc(%ebp)
  for (size_t i=0;i<sizeof(elf_header);i++) {
 80482ee:	ff 45 f0             	incl   -0x10(%ebp)
 80482f1:	83 7d f0 33          	cmpl   $0x33,-0x10(%ebp)
 80482f5:	76 e0                	jbe    80482d7 <load_proc+0x25>
  }
  if (header.magic!=ELF_MAGIC) {
 80482f7:	8b 45 a0             	mov    -0x60(%ebp),%eax
 80482fa:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
 80482ff:	74 07                	je     8048308 <load_proc+0x56>
    return 0;
 8048301:	b0 00                	mov    $0x0,%al
 8048303:	e9 01 01 00 00       	jmp    8048409 <load_proc+0x157>
  } else {
    void* address_space=new_address_space();
 8048308:	e8 5f 10 00 00       	call   804936c <new_address_space>
 804830d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    for (int i=0;i<header.pheader_ent_nm;i++) {
 8048310:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 8048317:	e9 c9 00 00 00       	jmp    80483e5 <load_proc+0x133>
      elf_pheader pheader;
      pos=(header.prog_hdr)+(header.pheader_ent_sz*i)+datapos;
 804831c:	8b 55 bc             	mov    -0x44(%ebp),%edx
 804831f:	66 8b 45 ca          	mov    -0x36(%ebp),%ax
 8048323:	0f b7 c0             	movzwl %ax,%eax
 8048326:	0f af 45 ec          	imul   -0x14(%ebp),%eax
 804832a:	01 c2                	add    %eax,%edx
 804832c:	8b 45 08             	mov    0x8(%ebp),%eax
 804832f:	01 d0                	add    %edx,%eax
 8048331:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char* phdr_ptr=(char*)&pheader;
 8048334:	8d 45 80             	lea    -0x80(%ebp),%eax
 8048337:	89 45 d8             	mov    %eax,-0x28(%ebp)
      for (size_t i=0;i<sizeof(elf_pheader);i++) {
 804833a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 8048341:	eb 1a                	jmp    804835d <load_proc+0xab>
        phdr_ptr[i]=initrd[pos];
 8048343:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048346:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048349:	01 d0                	add    %edx,%eax
 804834b:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 804834e:	8b 55 e8             	mov    -0x18(%ebp),%edx
 8048351:	01 ca                	add    %ecx,%edx
 8048353:	8a 00                	mov    (%eax),%al
 8048355:	88 02                	mov    %al,(%edx)
        pos++;
 8048357:	ff 45 f4             	incl   -0xc(%ebp)
      for (size_t i=0;i<sizeof(elf_pheader);i++) {
 804835a:	ff 45 e8             	incl   -0x18(%ebp)
 804835d:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%ebp)
 8048361:	76 e0                	jbe    8048343 <load_proc+0x91>
      }
      char* ptr=alloc_memory(((pheader.memsz)/4096)+1);
 8048363:	8b 45 94             	mov    -0x6c(%ebp),%eax
 8048366:	c1 e8 0c             	shr    $0xc,%eax
 8048369:	40                   	inc    %eax
 804836a:	83 ec 0c             	sub    $0xc,%esp
 804836d:	50                   	push   %eax
 804836e:	e8 b8 0f 00 00       	call   804932b <alloc_memory>
 8048373:	83 c4 10             	add    $0x10,%esp
 8048376:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      memset(ptr,0,pheader.memsz);
 8048379:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804837c:	83 ec 04             	sub    $0x4,%esp
 804837f:	50                   	push   %eax
 8048380:	6a 00                	push   $0x0
 8048382:	ff 75 d4             	push   -0x2c(%ebp)
 8048385:	e8 49 1c 00 00       	call   8049fd3 <memset>
 804838a:	83 c4 10             	add    $0x10,%esp
      if (pheader.filesz>0) {
 804838d:	8b 45 90             	mov    -0x70(%ebp),%eax
 8048390:	85 c0                	test   %eax,%eax
 8048392:	74 36                	je     80483ca <load_proc+0x118>
        pos=pheader.offset+datapos;
 8048394:	8b 55 84             	mov    -0x7c(%ebp),%edx
 8048397:	8b 45 08             	mov    0x8(%ebp),%eax
 804839a:	01 d0                	add    %edx,%eax
 804839c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for (size_t i=0;i<pheader.filesz;i++) {
 804839f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 80483a6:	eb 1a                	jmp    80483c2 <load_proc+0x110>
          ptr[i]=initrd[pos];
 80483a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80483ab:	8b 45 0c             	mov    0xc(%ebp),%eax
 80483ae:	01 d0                	add    %edx,%eax
 80483b0:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 80483b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 80483b6:	01 ca                	add    %ecx,%edx
 80483b8:	8a 00                	mov    (%eax),%al
 80483ba:	88 02                	mov    %al,(%edx)
          pos++;
 80483bc:	ff 45 f4             	incl   -0xc(%ebp)
        for (size_t i=0;i<pheader.filesz;i++) {
 80483bf:	ff 45 e4             	incl   -0x1c(%ebp)
 80483c2:	8b 45 90             	mov    -0x70(%ebp),%eax
 80483c5:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
 80483c8:	72 de                	jb     80483a8 <load_proc+0xf6>
        }
      }
      copy_data(address_space,ptr,pheader.memsz,(void*)pheader.vaddr);
 80483ca:	8b 45 88             	mov    -0x78(%ebp),%eax
 80483cd:	89 c2                	mov    %eax,%edx
 80483cf:	8b 45 94             	mov    -0x6c(%ebp),%eax
 80483d2:	52                   	push   %edx
 80483d3:	50                   	push   %eax
 80483d4:	ff 75 d4             	push   -0x2c(%ebp)
 80483d7:	ff 75 dc             	push   -0x24(%ebp)
 80483da:	e8 a9 0f 00 00       	call   8049388 <copy_data>
 80483df:	83 c4 10             	add    $0x10,%esp
    for (int i=0;i<header.pheader_ent_nm;i++) {
 80483e2:	ff 45 ec             	incl   -0x14(%ebp)
 80483e5:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80483e8:	0f b7 c0             	movzwl %ax,%eax
 80483eb:	39 45 ec             	cmp    %eax,-0x14(%ebp)
 80483ee:	0f 8c 28 ff ff ff    	jl     804831c <load_proc+0x6a>
    }
    create_proc((void*)header.entry,address_space,NULL,NULL);
 80483f4:	8b 45 b8             	mov    -0x48(%ebp),%eax
 80483f7:	6a 00                	push   $0x0
 80483f9:	6a 00                	push   $0x0
 80483fb:	ff 75 dc             	push   -0x24(%ebp)
 80483fe:	50                   	push   %eax
 80483ff:	e8 52 20 00 00       	call   804a456 <create_proc>
 8048404:	83 c4 10             	add    $0x10,%esp
  }
  return 1;
 8048407:	b0 01                	mov    $0x1,%al
}
 8048409:	c9                   	leave  
 804840a:	c3                   	ret    

0804840b <getDebugChar>:

char getDebugChar() {
 804840b:	55                   	push   %ebp
 804840c:	89 e5                	mov    %esp,%ebp
 804840e:	83 ec 08             	sub    $0x8,%esp
  return user_serial_getc(1);
 8048411:	83 ec 0c             	sub    $0xc,%esp
 8048414:	6a 01                	push   $0x1
 8048416:	e8 7e 02 00 00       	call   8048699 <user_serial_getc>
 804841b:	83 c4 10             	add    $0x10,%esp
}
 804841e:	c9                   	leave  
 804841f:	c3                   	ret    

08048420 <putDebugChar>:

void putDebugChar(char c) {
 8048420:	55                   	push   %ebp
 8048421:	89 e5                	mov    %esp,%ebp
 8048423:	83 ec 18             	sub    $0x18,%esp
 8048426:	8b 45 08             	mov    0x8(%ebp),%eax
 8048429:	88 45 f4             	mov    %al,-0xc(%ebp)
  user_serial_putc(c, 1);
 804842c:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
 8048430:	83 ec 08             	sub    $0x8,%esp
 8048433:	6a 01                	push   $0x1
 8048435:	50                   	push   %eax
 8048436:	e8 39 02 00 00       	call   8048674 <user_serial_putc>
 804843b:	83 c4 10             	add    $0x10,%esp
}
 804843e:	90                   	nop
 804843f:	c9                   	leave  
 8048440:	c3                   	ret    

08048441 <exceptionHandler>:

void exceptionHandler(int exception_number, void *exception_address) {
 8048441:	55                   	push   %ebp
 8048442:	89 e5                	mov    %esp,%ebp
  

}
 8048444:	90                   	nop
 8048445:	5d                   	pop    %ebp
 8048446:	c3                   	ret    

08048447 <main>:
/*   registers[15]=0x10; */
/*   handle_exception(r->int_no); */
/*   exception_return(); */
/* } */

int main() {
 8048447:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 804844b:	83 e4 f0             	and    $0xfffffff0,%esp
 804844e:	ff 71 fc             	push   -0x4(%ecx)
 8048451:	55                   	push   %ebp
 8048452:	89 e5                	mov    %esp,%ebp
 8048454:	51                   	push   %ecx
 8048455:	83 ec 14             	sub    $0x14,%esp
  /* buf[1]=user_serial_getc(1); */
  /* buf[2]='\0'; */
  /* serial_print(buf); */
  /* register_exception_handler(user_handler); */
  /* breakpoint(); */
  long size=initrd_sz();
 8048458:	e8 5d 02 00 00       	call   80486ba <initrd_sz>
 804845d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char* initrd=malloc(size);
 8048460:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048463:	83 ec 0c             	sub    $0xc,%esp
 8048466:	50                   	push   %eax
 8048467:	e8 f9 03 00 00       	call   8048865 <malloc>
 804846c:	83 c4 10             	add    $0x10,%esp
 804846f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  initrd_get(initrd);
 8048472:	83 ec 0c             	sub    $0xc,%esp
 8048475:	ff 75 f0             	push   -0x10(%ebp)
 8048478:	e8 59 02 00 00       	call   80486d6 <initrd_get>
 804847d:	83 c4 10             	add    $0x10,%esp
  size_t datapos=find_loc("vfs",initrd);
 8048480:	83 ec 08             	sub    $0x8,%esp
 8048483:	ff 75 f0             	push   -0x10(%ebp)
 8048486:	68 ac a6 04 08       	push   $0x804a6ac
 804848b:	e8 5e fd ff ff       	call   80481ee <find_loc>
 8048490:	83 c4 10             	add    $0x10,%esp
 8048493:	89 45 ec             	mov    %eax,-0x14(%ebp)
  load_proc(datapos,initrd);
 8048496:	83 ec 08             	sub    $0x8,%esp
 8048499:	ff 75 f0             	push   -0x10(%ebp)
 804849c:	ff 75 ec             	push   -0x14(%ebp)
 804849f:	e8 0e fe ff ff       	call   80482b2 <load_proc>
 80484a4:	83 c4 10             	add    $0x10,%esp
  while(rpc_is_init(2)==0);
 80484a7:	90                   	nop
 80484a8:	83 ec 0c             	sub    $0xc,%esp
 80484ab:	6a 02                	push   $0x2
 80484ad:	e8 52 10 00 00       	call   8049504 <rpc_is_init>
 80484b2:	83 c4 10             	add    $0x10,%esp
 80484b5:	84 c0                	test   %al,%al
 80484b7:	74 ef                	je     80484a8 <main+0x61>
  datapos=find_loc("devfs",initrd);
 80484b9:	83 ec 08             	sub    $0x8,%esp
 80484bc:	ff 75 f0             	push   -0x10(%ebp)
 80484bf:	68 b0 a6 04 08       	push   $0x804a6b0
 80484c4:	e8 25 fd ff ff       	call   80481ee <find_loc>
 80484c9:	83 c4 10             	add    $0x10,%esp
 80484cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  load_proc(datapos,initrd);
 80484cf:	83 ec 08             	sub    $0x8,%esp
 80484d2:	ff 75 f0             	push   -0x10(%ebp)
 80484d5:	ff 75 ec             	push   -0x14(%ebp)
 80484d8:	e8 d5 fd ff ff       	call   80482b2 <load_proc>
 80484dd:	83 c4 10             	add    $0x10,%esp
  while(rpc_is_init(3)==0);
 80484e0:	90                   	nop
 80484e1:	83 ec 0c             	sub    $0xc,%esp
 80484e4:	6a 03                	push   $0x3
 80484e6:	e8 19 10 00 00       	call   8049504 <rpc_is_init>
 80484eb:	83 c4 10             	add    $0x10,%esp
 80484ee:	84 c0                	test   %al,%al
 80484f0:	74 ef                	je     80484e1 <main+0x9a>
  int err=mount("","devfs","/dev");
 80484f2:	83 ec 04             	sub    $0x4,%esp
 80484f5:	68 b6 a6 04 08       	push   $0x804a6b6
 80484fa:	68 b0 a6 04 08       	push   $0x804a6b0
 80484ff:	68 bb a6 04 08       	push   $0x804a6bb
 8048504:	e8 20 17 00 00       	call   8049c29 <mount>
 8048509:	83 c4 10             	add    $0x10,%esp
 804850c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if (err) {
 804850f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 8048513:	74 1a                	je     804852f <main+0xe8>
    serial_print("Failed to mount devfs\n");
 8048515:	83 ec 0c             	sub    $0xc,%esp
 8048518:	68 bc a6 04 08       	push   $0x804a6bc
 804851d:	e8 3e 01 00 00       	call   8048660 <serial_print>
 8048522:	83 c4 10             	add    $0x10,%esp
    exit(1);
 8048525:	83 ec 0c             	sub    $0xc,%esp
 8048528:	6a 01                	push   $0x1
 804852a:	e8 46 1f 00 00       	call   804a475 <exit>
  }
  datapos=find_loc("initrd_drv",initrd);
 804852f:	83 ec 08             	sub    $0x8,%esp
 8048532:	ff 75 f0             	push   -0x10(%ebp)
 8048535:	68 d3 a6 04 08       	push   $0x804a6d3
 804853a:	e8 af fc ff ff       	call   80481ee <find_loc>
 804853f:	83 c4 10             	add    $0x10,%esp
 8048542:	89 45 ec             	mov    %eax,-0x14(%ebp)
  load_proc(datapos,initrd);
 8048545:	83 ec 08             	sub    $0x8,%esp
 8048548:	ff 75 f0             	push   -0x10(%ebp)
 804854b:	ff 75 ec             	push   -0x14(%ebp)
 804854e:	e8 5f fd ff ff       	call   80482b2 <load_proc>
 8048553:	83 c4 10             	add    $0x10,%esp
  while(rpc_is_init(4)==0);
 8048556:	90                   	nop
 8048557:	83 ec 0c             	sub    $0xc,%esp
 804855a:	6a 04                	push   $0x4
 804855c:	e8 a3 0f 00 00       	call   8049504 <rpc_is_init>
 8048561:	83 c4 10             	add    $0x10,%esp
 8048564:	84 c0                	test   %al,%al
 8048566:	74 ef                	je     8048557 <main+0x110>
  datapos=find_loc("tar_fs",initrd);
 8048568:	83 ec 08             	sub    $0x8,%esp
 804856b:	ff 75 f0             	push   -0x10(%ebp)
 804856e:	68 de a6 04 08       	push   $0x804a6de
 8048573:	e8 76 fc ff ff       	call   80481ee <find_loc>
 8048578:	83 c4 10             	add    $0x10,%esp
 804857b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  load_proc(datapos,initrd);
 804857e:	83 ec 08             	sub    $0x8,%esp
 8048581:	ff 75 f0             	push   -0x10(%ebp)
 8048584:	ff 75 ec             	push   -0x14(%ebp)
 8048587:	e8 26 fd ff ff       	call   80482b2 <load_proc>
 804858c:	83 c4 10             	add    $0x10,%esp
  while(rpc_is_init(5)==0);
 804858f:	90                   	nop
 8048590:	83 ec 0c             	sub    $0xc,%esp
 8048593:	6a 05                	push   $0x5
 8048595:	e8 6a 0f 00 00       	call   8049504 <rpc_is_init>
 804859a:	83 c4 10             	add    $0x10,%esp
 804859d:	84 c0                	test   %al,%al
 804859f:	74 ef                	je     8048590 <main+0x149>
  serial_print("Mounting initrd\n");
 80485a1:	83 ec 0c             	sub    $0xc,%esp
 80485a4:	68 e5 a6 04 08       	push   $0x804a6e5
 80485a9:	e8 b2 00 00 00       	call   8048660 <serial_print>
 80485ae:	83 c4 10             	add    $0x10,%esp
  mount("/dev/initrd","tarfs","/initrd");
 80485b1:	83 ec 04             	sub    $0x4,%esp
 80485b4:	68 f6 a6 04 08       	push   $0x804a6f6
 80485b9:	68 fe a6 04 08       	push   $0x804a6fe
 80485be:	68 04 a7 04 08       	push   $0x804a704
 80485c3:	e8 61 16 00 00       	call   8049c29 <mount>
 80485c8:	83 c4 10             	add    $0x10,%esp
  posix_spawn(NULL,"/initrd/vga_drv",NULL,NULL,NULL,NULL);
 80485cb:	83 ec 08             	sub    $0x8,%esp
 80485ce:	6a 00                	push   $0x0
 80485d0:	6a 00                	push   $0x0
 80485d2:	6a 00                	push   $0x0
 80485d4:	6a 00                	push   $0x0
 80485d6:	68 10 a7 04 08       	push   $0x804a710
 80485db:	6a 00                	push   $0x0
 80485dd:	e8 43 0f 00 00       	call   8049525 <posix_spawn>
 80485e2:	83 c4 20             	add    $0x20,%esp
  while(rpc_is_init(6)==0);
 80485e5:	90                   	nop
 80485e6:	83 ec 0c             	sub    $0xc,%esp
 80485e9:	6a 06                	push   $0x6
 80485eb:	e8 14 0f 00 00       	call   8049504 <rpc_is_init>
 80485f0:	83 c4 10             	add    $0x10,%esp
 80485f3:	84 c0                	test   %al,%al
 80485f5:	74 ef                	je     80485e6 <main+0x19f>
  stdout=fopen("/dev/vga","w");
 80485f7:	83 ec 08             	sub    $0x8,%esp
 80485fa:	68 20 a7 04 08       	push   $0x804a720
 80485ff:	68 22 a7 04 08       	push   $0x804a722
 8048604:	e8 9c 10 00 00       	call   80496a5 <fopen>
 8048609:	83 c4 10             	add    $0x10,%esp
 804860c:	a3 14 c3 04 08       	mov    %eax,0x804c314
  if (!stdout) {
 8048611:	a1 14 c3 04 08       	mov    0x804c314,%eax
 8048616:	85 c0                	test   %eax,%eax
 8048618:	75 1a                	jne    8048634 <main+0x1ed>
    serial_print("Could not open the VGA device file!\n");
 804861a:	83 ec 0c             	sub    $0xc,%esp
 804861d:	68 2c a7 04 08       	push   $0x804a72c
 8048622:	e8 39 00 00 00       	call   8048660 <serial_print>
 8048627:	83 c4 10             	add    $0x10,%esp
    exit(1);
 804862a:	83 ec 0c             	sub    $0xc,%esp
 804862d:	6a 01                	push   $0x1
 804862f:	e8 41 1e 00 00       	call   804a475 <exit>
  } else {
    printf("VGA OK\n");
 8048634:	83 ec 0c             	sub    $0xc,%esp
 8048637:	68 51 a7 04 08       	push   $0x804a751
 804863c:	e8 ab 13 00 00       	call   80499ec <puts>
 8048641:	83 c4 10             	add    $0x10,%esp
  }
  posix_spawn(NULL,"/initrd/ps2",NULL,NULL,NULL,NULL);
 8048644:	83 ec 08             	sub    $0x8,%esp
 8048647:	6a 00                	push   $0x0
 8048649:	6a 00                	push   $0x0
 804864b:	6a 00                	push   $0x0
 804864d:	6a 00                	push   $0x0
 804864f:	68 58 a7 04 08       	push   $0x804a758
 8048654:	6a 00                	push   $0x0
 8048656:	e8 ca 0e 00 00       	call   8049525 <posix_spawn>
 804865b:	83 c4 20             	add    $0x20,%esp
  // posix_spawn(NULL,"/initrd/pci",NULL,NULL,NULL,NULL);
  for(;;);
 804865e:	eb fe                	jmp    804865e <main+0x217>

08048660 <serial_print>:
#include <sys/syscalls.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void serial_print(char* str) {
 8048660:	55                   	push   %ebp
 8048661:	89 e5                	mov    %esp,%ebp
 8048663:	53                   	push   %ebx
  asm volatile("  \
 8048664:	8b 45 08             	mov    0x8(%ebp),%eax
 8048667:	89 c3                	mov    %eax,%ebx
 8048669:	b8 0b 00 00 00       	mov    $0xb,%eax
 804866e:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_SERIAL_PRINT) ", %%eax; \
    int $80; \
  "::"b"(str));
}
 8048670:	90                   	nop
 8048671:	5b                   	pop    %ebx
 8048672:	5d                   	pop    %ebp
 8048673:	c3                   	ret    

08048674 <user_serial_putc>:

void user_serial_putc(char c, int port) {
 8048674:	55                   	push   %ebp
 8048675:	89 e5                	mov    %esp,%ebp
 8048677:	53                   	push   %ebx
 8048678:	83 ec 04             	sub    $0x4,%esp
 804867b:	8b 45 08             	mov    0x8(%ebp),%eax
 804867e:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile("  \
 8048681:	8a 45 f8             	mov    -0x8(%ebp),%al
 8048684:	8b 55 0c             	mov    0xc(%ebp),%edx
 8048687:	88 c3                	mov    %al,%bl
 8048689:	89 d1                	mov    %edx,%ecx
 804868b:	b8 18 00 00 00       	mov    $0x18,%eax
 8048690:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_SERIAL_PUTC) ", %%eax; \
    int $80; \
  "::"b"(c),"c"(port));
}
 8048692:	90                   	nop
 8048693:	83 c4 04             	add    $0x4,%esp
 8048696:	5b                   	pop    %ebx
 8048697:	5d                   	pop    %ebp
 8048698:	c3                   	ret    

08048699 <user_serial_getc>:

char user_serial_getc(int port) {
 8048699:	55                   	push   %ebp
 804869a:	89 e5                	mov    %esp,%ebp
 804869c:	53                   	push   %ebx
 804869d:	83 ec 10             	sub    $0x10,%esp
  char c;
  asm volatile("  \
 80486a0:	8b 45 08             	mov    0x8(%ebp),%eax
 80486a3:	89 c3                	mov    %eax,%ebx
 80486a5:	b8 19 00 00 00       	mov    $0x19,%eax
 80486aa:	cd 50                	int    $0x50
 80486ac:	88 d8                	mov    %bl,%al
 80486ae:	88 45 fb             	mov    %al,-0x5(%ebp)
    mov $" QU(SYSCALL_SERIAL_GETC) ", %%eax; \
    int $80; \
  ":"=b"(c):"b"(port));
  return c;
 80486b1:	8a 45 fb             	mov    -0x5(%ebp),%al
}
 80486b4:	83 c4 10             	add    $0x10,%esp
 80486b7:	5b                   	pop    %ebx
 80486b8:	5d                   	pop    %ebp
 80486b9:	c3                   	ret    

080486ba <initrd_sz>:
#include <sys/syscalls.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

long initrd_sz() {
 80486ba:	55                   	push   %ebp
 80486bb:	89 e5                	mov    %esp,%ebp
 80486bd:	53                   	push   %ebx
 80486be:	83 ec 10             	sub    $0x10,%esp
  long size;
  asm volatile("  \
 80486c1:	b8 0c 00 00 00       	mov    $0xc,%eax
 80486c6:	cd 50                	int    $0x50
 80486c8:	89 d8                	mov    %ebx,%eax
 80486ca:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_GET_INITRD_SZ) ", %%eax; \
    int $80; \
  ":"=b"(size));
  return size;
 80486cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 80486d0:	83 c4 10             	add    $0x10,%esp
 80486d3:	5b                   	pop    %ebx
 80486d4:	5d                   	pop    %ebp
 80486d5:	c3                   	ret    

080486d6 <initrd_get>:

void initrd_get(char* initrd) {
 80486d6:	55                   	push   %ebp
 80486d7:	89 e5                	mov    %esp,%ebp
 80486d9:	53                   	push   %ebx
  asm volatile("  \
 80486da:	8b 45 08             	mov    0x8(%ebp),%eax
 80486dd:	89 c3                	mov    %eax,%ebx
 80486df:	b8 0d 00 00 00       	mov    $0xd,%eax
 80486e4:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_COPY_INITRD) ", %%eax; \
    int $80; \
  "::"b"(initrd));
}
 80486e6:	90                   	nop
 80486e7:	5b                   	pop    %ebx
 80486e8:	5d                   	pop    %ebp
 80486e9:	c3                   	ret    

080486ea <liballoc_memset>:


// ***********   HELPER FUNCTIONS  *******************************

static void *liballoc_memset(void* s, int c, size_t n)
{
 80486ea:	55                   	push   %ebp
 80486eb:	89 e5                	mov    %esp,%ebp
 80486ed:	83 ec 10             	sub    $0x10,%esp
	unsigned int i;
	for ( i = 0; i < n ; i++)
 80486f0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 80486f7:	eb 10                	jmp    8048709 <liballoc_memset+0x1f>
		((char*)s)[i] = c;
 80486f9:	8b 55 08             	mov    0x8(%ebp),%edx
 80486fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80486ff:	01 d0                	add    %edx,%eax
 8048701:	8b 55 0c             	mov    0xc(%ebp),%edx
 8048704:	88 10                	mov    %dl,(%eax)
	for ( i = 0; i < n ; i++)
 8048706:	ff 45 fc             	incl   -0x4(%ebp)
 8048709:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804870c:	3b 45 10             	cmp    0x10(%ebp),%eax
 804870f:	72 e8                	jb     80486f9 <liballoc_memset+0xf>
	
	return s;
 8048711:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8048714:	c9                   	leave  
 8048715:	c3                   	ret    

08048716 <liballoc_memcpy>:
static void* liballoc_memcpy(void* s1, const void* s2, size_t n)
{
 8048716:	55                   	push   %ebp
 8048717:	89 e5                	mov    %esp,%ebp
 8048719:	83 ec 10             	sub    $0x10,%esp
  char *cdest;
  char *csrc;
  unsigned int *ldest = (unsigned int*)s1;
 804871c:	8b 45 08             	mov    0x8(%ebp),%eax
 804871f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int *lsrc  = (unsigned int*)s2;
 8048722:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048725:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while ( n >= sizeof(unsigned int) )
 8048728:	eb 1a                	jmp    8048744 <liballoc_memcpy+0x2e>
  {
      *ldest++ = *lsrc++;
 804872a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804872d:	8d 42 04             	lea    0x4(%edx),%eax
 8048730:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8048733:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048736:	8d 48 04             	lea    0x4(%eax),%ecx
 8048739:	89 4d f4             	mov    %ecx,-0xc(%ebp)
 804873c:	8b 12                	mov    (%edx),%edx
 804873e:	89 10                	mov    %edx,(%eax)
	  n -= sizeof(unsigned int);
 8048740:	83 6d 10 04          	subl   $0x4,0x10(%ebp)
  while ( n >= sizeof(unsigned int) )
 8048744:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
 8048748:	77 e0                	ja     804872a <liballoc_memcpy+0x14>
  }

  cdest = (char*)ldest;
 804874a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804874d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  csrc  = (char*)lsrc;
 8048750:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048753:	89 45 f8             	mov    %eax,-0x8(%ebp)
  
  while ( n > 0 )
 8048756:	eb 19                	jmp    8048771 <liballoc_memcpy+0x5b>
  {
      *cdest++ = *csrc++;
 8048758:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804875b:	8d 42 01             	lea    0x1(%edx),%eax
 804875e:	89 45 f8             	mov    %eax,-0x8(%ebp)
 8048761:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048764:	8d 48 01             	lea    0x1(%eax),%ecx
 8048767:	89 4d fc             	mov    %ecx,-0x4(%ebp)
 804876a:	8a 12                	mov    (%edx),%dl
 804876c:	88 10                	mov    %dl,(%eax)
	  n -= 1;
 804876e:	ff 4d 10             	decl   0x10(%ebp)
  while ( n > 0 )
 8048771:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 8048775:	75 e1                	jne    8048758 <liballoc_memcpy+0x42>
  }
  
  return s1;
 8048777:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804877a:	c9                   	leave  
 804877b:	c3                   	ret    

0804877c <allocate_new_page>:


// ***************************************************************

static struct liballoc_major *allocate_new_page( unsigned int size )
{
 804877c:	55                   	push   %ebp
 804877d:	89 e5                	mov    %esp,%ebp
 804877f:	53                   	push   %ebx
 8048780:	83 ec 14             	sub    $0x14,%esp
	unsigned int st;
	struct liballoc_major *maj;

		// This is how much space is required.
		st  = size + sizeof(struct liballoc_major);
 8048783:	8b 45 08             	mov    0x8(%ebp),%eax
 8048786:	83 c0 18             	add    $0x18,%eax
 8048789:	89 45 f4             	mov    %eax,-0xc(%ebp)
		st += sizeof(struct liballoc_minor);
 804878c:	83 45 f4 18          	addl   $0x18,-0xc(%ebp)

				// Perfect amount of space?
		if ( (st % l_pageSize) == 0 )
 8048790:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048793:	25 ff 0f 00 00       	and    $0xfff,%eax
 8048798:	85 c0                	test   %eax,%eax
 804879a:	75 0b                	jne    80487a7 <allocate_new_page+0x2b>
			st  = st / (l_pageSize);
 804879c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804879f:	c1 e8 0c             	shr    $0xc,%eax
 80487a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
 80487a5:	eb 0a                	jmp    80487b1 <allocate_new_page+0x35>
		else
			st  = st / (l_pageSize) + 1;
 80487a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80487aa:	c1 e8 0c             	shr    $0xc,%eax
 80487ad:	40                   	inc    %eax
 80487ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
							// No, add the buffer. 

		
		// Make sure it's >= the minimum size.
		if ( st < l_pageCount ) st = l_pageCount;
 80487b1:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
 80487b5:	77 07                	ja     80487be <allocate_new_page+0x42>
 80487b7:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
		
		maj = (struct liballoc_major*)liballoc_alloc( st );
 80487be:	83 ec 0c             	sub    $0xc,%esp
 80487c1:	ff 75 f4             	push   -0xc(%ebp)
 80487c4:	e8 41 0b 00 00       	call   804930a <liballoc_alloc>
 80487c9:	83 c4 10             	add    $0x10,%esp
 80487cc:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if ( maj == NULL ) 
 80487cf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 80487d3:	75 23                	jne    80487f8 <allocate_new_page+0x7c>
		{
			l_warningCount += 1;
 80487d5:	a1 f8 c2 04 08       	mov    0x804c2f8,%eax
 80487da:	8b 15 fc c2 04 08    	mov    0x804c2fc,%edx
 80487e0:	83 c0 01             	add    $0x1,%eax
 80487e3:	83 d2 00             	adc    $0x0,%edx
 80487e6:	a3 f8 c2 04 08       	mov    %eax,0x804c2f8
 80487eb:	89 15 fc c2 04 08    	mov    %edx,0x804c2fc
			#if defined DEBUG || defined INFO
			serial_printf( "liballoc: WARNING: liballoc_alloc( %d ) return NULL\n", st );
			FLUSH();
			#endif
			return NULL;	// uh oh, we ran out of memory.
 80487f1:	b8 00 00 00 00       	mov    $0x0,%eax
 80487f6:	eb 68                	jmp    8048860 <allocate_new_page+0xe4>
		}
		
		maj->prev 	= NULL;
 80487f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80487fb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		maj->next 	= NULL;
 8048801:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048804:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		maj->pages 	= st;
 804880b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804880e:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048811:	89 50 08             	mov    %edx,0x8(%eax)
		maj->size 	= st * l_pageSize;
 8048814:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048817:	c1 e0 0c             	shl    $0xc,%eax
 804881a:	89 c2                	mov    %eax,%edx
 804881c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804881f:	89 50 0c             	mov    %edx,0xc(%eax)
		maj->usage 	= sizeof(struct liballoc_major);
 8048822:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048825:	c7 40 10 18 00 00 00 	movl   $0x18,0x10(%eax)
		maj->first 	= NULL;
 804882c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804882f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

		l_allocated += maj->size;
 8048836:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048839:	8b 40 0c             	mov    0xc(%eax),%eax
 804883c:	89 c1                	mov    %eax,%ecx
 804883e:	bb 00 00 00 00       	mov    $0x0,%ebx
 8048843:	a1 e8 c2 04 08       	mov    0x804c2e8,%eax
 8048848:	8b 15 ec c2 04 08    	mov    0x804c2ec,%edx
 804884e:	01 c8                	add    %ecx,%eax
 8048850:	11 da                	adc    %ebx,%edx
 8048852:	a3 e8 c2 04 08       	mov    %eax,0x804c2e8
 8048857:	89 15 ec c2 04 08    	mov    %edx,0x804c2ec
		serial_printf( "liballoc: Total memory usage = %d KB\n",  (int)((l_allocated / (1024))) );
		FLUSH();
		#endif
	
		
      return maj;
 804885d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8048860:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8048863:	c9                   	leave  
 8048864:	c3                   	ret    

08048865 <malloc>:

	


void *PREFIX(malloc)(size_t req_size)
{
 8048865:	55                   	push   %ebp
 8048866:	89 e5                	mov    %esp,%ebp
 8048868:	53                   	push   %ebx
 8048869:	83 ec 44             	sub    $0x44,%esp
	int startedBet = 0;
 804886c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	unsigned long long bestSize = 0;
 8048873:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 804887a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	void *p = NULL;
 8048881:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uintptr_t diff;
	struct liballoc_major *maj;
	struct liballoc_minor *min;
	struct liballoc_minor *new_min;
	unsigned long size = req_size;
 8048888:	8b 45 08             	mov    0x8(%ebp),%eax
 804888b:	89 45 c8             	mov    %eax,-0x38(%ebp)

	// For alignment, we adjust size so there's enough space to align.
	if ( ALIGNMENT > 1 )
	{
		size += ALIGNMENT + ALIGN_INFO;
 804888e:	83 45 c8 20          	addl   $0x20,-0x38(%ebp)
	}
				// So, ideally, we really want an alignment of 0 or 1 in order
				// to save space.
	
	liballoc_lock();
 8048892:	e8 43 0a 00 00       	call   80492da <liballoc_lock>

	if ( size == 0 )
 8048897:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804889b:	75 33                	jne    80488d0 <malloc+0x6b>
	{
		l_warningCount += 1;
 804889d:	a1 f8 c2 04 08       	mov    0x804c2f8,%eax
 80488a2:	8b 15 fc c2 04 08    	mov    0x804c2fc,%edx
 80488a8:	83 c0 01             	add    $0x1,%eax
 80488ab:	83 d2 00             	adc    $0x0,%edx
 80488ae:	a3 f8 c2 04 08       	mov    %eax,0x804c2f8
 80488b3:	89 15 fc c2 04 08    	mov    %edx,0x804c2fc
		#if defined DEBUG || defined INFO
		serial_printf( "liballoc: WARNING: alloc( 0 ) called from %x\n",
							__builtin_return_address(0) );
		FLUSH();
		#endif
		liballoc_unlock();
 80488b9:	e8 34 0a 00 00       	call   80492f2 <liballoc_unlock>
		return PREFIX(malloc)(1);
 80488be:	83 ec 0c             	sub    $0xc,%esp
 80488c1:	6a 01                	push   $0x1
 80488c3:	e8 9d ff ff ff       	call   8048865 <malloc>
 80488c8:	83 c4 10             	add    $0x10,%esp
 80488cb:	e9 1c 06 00 00       	jmp    8048eec <malloc+0x687>
	}
	

	if ( l_memRoot == NULL )
 80488d0:	a1 e0 c2 04 08       	mov    0x804c2e0,%eax
 80488d5:	85 c0                	test   %eax,%eax
 80488d7:	75 2b                	jne    8048904 <malloc+0x9f>
		//atexit( liballoc_dump );
		FLUSH();
		#endif
			
		// This is the first time we are being used.
		l_memRoot = allocate_new_page( size );
 80488d9:	83 ec 0c             	sub    $0xc,%esp
 80488dc:	ff 75 c8             	push   -0x38(%ebp)
 80488df:	e8 98 fe ff ff       	call   804877c <allocate_new_page>
 80488e4:	83 c4 10             	add    $0x10,%esp
 80488e7:	a3 e0 c2 04 08       	mov    %eax,0x804c2e0
		if ( l_memRoot == NULL )
 80488ec:	a1 e0 c2 04 08       	mov    0x804c2e0,%eax
 80488f1:	85 c0                	test   %eax,%eax
 80488f3:	75 0f                	jne    8048904 <malloc+0x9f>
		{
		  liballoc_unlock();
 80488f5:	e8 f8 09 00 00       	call   80492f2 <liballoc_unlock>
		  #ifdef DEBUG
		  serial_printf( "liballoc: initial l_memRoot initialization failed\n", p); 
		  FLUSH();
		  #endif
		  return NULL;
 80488fa:	b8 00 00 00 00       	mov    $0x0,%eax
 80488ff:	e9 e8 05 00 00       	jmp    8048eec <malloc+0x687>
	FLUSH();
	#endif

	// Now we need to bounce through every major and find enough space....

	maj = l_memRoot;
 8048904:	a1 e0 c2 04 08       	mov    0x804c2e0,%eax
 8048909:	89 45 e0             	mov    %eax,-0x20(%ebp)
	startedBet = 0;
 804890c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	
	// Start at the best bet....
	if ( l_bestBet != NULL )
 8048913:	a1 e4 c2 04 08       	mov    0x804c2e4,%eax
 8048918:	85 c0                	test   %eax,%eax
 804891a:	0f 84 b2 05 00 00    	je     8048ed2 <malloc+0x66d>
	{
		bestSize = l_bestBet->size - l_bestBet->usage;
 8048920:	a1 e4 c2 04 08       	mov    0x804c2e4,%eax
 8048925:	8b 50 0c             	mov    0xc(%eax),%edx
 8048928:	a1 e4 c2 04 08       	mov    0x804c2e4,%eax
 804892d:	8b 40 10             	mov    0x10(%eax),%eax
 8048930:	29 c2                	sub    %eax,%edx
 8048932:	89 d0                	mov    %edx,%eax
 8048934:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048937:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		if ( bestSize > (size + sizeof(struct liballoc_minor)))
 804893e:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048941:	83 c0 18             	add    $0x18,%eax
 8048944:	ba 00 00 00 00       	mov    $0x0,%edx
 8048949:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 804894c:	89 d0                	mov    %edx,%eax
 804894e:	1b 45 ec             	sbb    -0x14(%ebp),%eax
 8048951:	0f 83 7b 05 00 00    	jae    8048ed2 <malloc+0x66d>
		{
			maj = l_bestBet;
 8048957:	a1 e4 c2 04 08       	mov    0x804c2e4,%eax
 804895c:	89 45 e0             	mov    %eax,-0x20(%ebp)
			startedBet = 1;
 804895f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
	}
	
	while ( maj != NULL )
 8048966:	e9 67 05 00 00       	jmp    8048ed2 <malloc+0x66d>
	{
		diff  = maj->size - maj->usage;	
 804896b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804896e:	8b 50 0c             	mov    0xc(%eax),%edx
 8048971:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048974:	8b 40 10             	mov    0x10(%eax),%eax
 8048977:	29 c2                	sub    %eax,%edx
 8048979:	89 d0                	mov    %edx,%eax
 804897b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
										// free memory in the block

		if ( bestSize < diff )
 804897e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8048981:	ba 00 00 00 00       	mov    $0x0,%edx
 8048986:	8b 4d ec             	mov    -0x14(%ebp),%ecx
 8048989:	39 45 e8             	cmp    %eax,-0x18(%ebp)
 804898c:	19 d1                	sbb    %edx,%ecx
 804898e:	73 15                	jae    80489a5 <malloc+0x140>
		{
			// Hmm.. this one has more memory then our bestBet. Remember!
			l_bestBet = maj;
 8048990:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048993:	a3 e4 c2 04 08       	mov    %eax,0x804c2e4
			bestSize = diff;
 8048998:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804899b:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804899e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		
		
#ifdef USE_CASE1
			
		// CASE 1:  There is not enough space in this major block.
		if ( diff < (size + sizeof( struct liballoc_minor )) )
 80489a5:	8b 45 c8             	mov    -0x38(%ebp),%eax
 80489a8:	83 c0 18             	add    $0x18,%eax
 80489ab:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 80489ae:	73 68                	jae    8048a18 <malloc+0x1b3>
			serial_printf( "CASE 1: Insufficient space in block %x\n", maj);
			FLUSH();
			#endif
				
				// Another major block next to this one?
			if ( maj->next != NULL ) 
 80489b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 80489b3:	8b 40 04             	mov    0x4(%eax),%eax
 80489b6:	85 c0                	test   %eax,%eax
 80489b8:	74 0e                	je     80489c8 <malloc+0x163>
			{
				maj = maj->next;		// Hop to that one.
 80489ba:	8b 45 e0             	mov    -0x20(%ebp),%eax
 80489bd:	8b 40 04             	mov    0x4(%eax),%eax
 80489c0:	89 45 e0             	mov    %eax,-0x20(%ebp)
				continue;
 80489c3:	e9 0a 05 00 00       	jmp    8048ed2 <malloc+0x66d>
			}

			if ( startedBet == 1 )		// If we started at the best bet,
 80489c8:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
 80489cc:	75 14                	jne    80489e2 <malloc+0x17d>
			{							// let's start all over again.
				maj = l_memRoot;
 80489ce:	a1 e0 c2 04 08       	mov    0x804c2e0,%eax
 80489d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
				startedBet = 0;
 80489d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				continue;
 80489dd:	e9 f0 04 00 00       	jmp    8048ed2 <malloc+0x66d>
			}

			// Create a new major block next to this one and...
			maj->next = allocate_new_page( size );	// next one will be okay.
 80489e2:	83 ec 0c             	sub    $0xc,%esp
 80489e5:	ff 75 c8             	push   -0x38(%ebp)
 80489e8:	e8 8f fd ff ff       	call   804877c <allocate_new_page>
 80489ed:	83 c4 10             	add    $0x10,%esp
 80489f0:	8b 55 e0             	mov    -0x20(%ebp),%edx
 80489f3:	89 42 04             	mov    %eax,0x4(%edx)
			if ( maj->next == NULL ) break;			// no more memory.
 80489f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
 80489f9:	8b 40 04             	mov    0x4(%eax),%eax
 80489fc:	85 c0                	test   %eax,%eax
 80489fe:	0f 84 da 04 00 00    	je     8048ede <malloc+0x679>
			maj->next->prev = maj;
 8048a04:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a07:	8b 40 04             	mov    0x4(%eax),%eax
 8048a0a:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8048a0d:	89 10                	mov    %edx,(%eax)
			maj = maj->next;
 8048a0f:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a12:	8b 40 04             	mov    0x4(%eax),%eax
 8048a15:	89 45 e0             	mov    %eax,-0x20(%ebp)
#endif

#ifdef USE_CASE2
		
		// CASE 2: It's a brand new block.
		if ( maj->first == NULL )
 8048a18:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a1b:	8b 40 14             	mov    0x14(%eax),%eax
 8048a1e:	85 c0                	test   %eax,%eax
 8048a20:	0f 85 e3 00 00 00    	jne    8048b09 <malloc+0x2a4>
		{
			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
 8048a26:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a29:	83 c0 18             	add    $0x18,%eax
 8048a2c:	89 c2                	mov    %eax,%edx
 8048a2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a31:	89 50 14             	mov    %edx,0x14(%eax)

			
			maj->first->magic 		= LIBALLOC_MAGIC;
 8048a34:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a37:	8b 40 14             	mov    0x14(%eax),%eax
 8048a3a:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
			maj->first->prev 		= NULL;
 8048a41:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a44:	8b 40 14             	mov    0x14(%eax),%eax
 8048a47:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			maj->first->next 		= NULL;
 8048a4d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a50:	8b 40 14             	mov    0x14(%eax),%eax
 8048a53:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			maj->first->block 		= maj;
 8048a5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a5d:	8b 40 14             	mov    0x14(%eax),%eax
 8048a60:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8048a63:	89 50 08             	mov    %edx,0x8(%eax)
			maj->first->size 		= size;
 8048a66:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a69:	8b 40 14             	mov    0x14(%eax),%eax
 8048a6c:	8b 55 c8             	mov    -0x38(%ebp),%edx
 8048a6f:	89 50 10             	mov    %edx,0x10(%eax)
			maj->first->req_size 	= req_size;
 8048a72:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a75:	8b 40 14             	mov    0x14(%eax),%eax
 8048a78:	8b 55 08             	mov    0x8(%ebp),%edx
 8048a7b:	89 50 14             	mov    %edx,0x14(%eax)
			maj->usage 	+= size + sizeof( struct liballoc_minor );
 8048a7e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a81:	8b 50 10             	mov    0x10(%eax),%edx
 8048a84:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048a87:	01 d0                	add    %edx,%eax
 8048a89:	8d 50 18             	lea    0x18(%eax),%edx
 8048a8c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048a8f:	89 50 10             	mov    %edx,0x10(%eax)


			l_inuse += size;
 8048a92:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 8048a95:	bb 00 00 00 00       	mov    $0x0,%ebx
 8048a9a:	a1 f0 c2 04 08       	mov    0x804c2f0,%eax
 8048a9f:	8b 15 f4 c2 04 08    	mov    0x804c2f4,%edx
 8048aa5:	01 c8                	add    %ecx,%eax
 8048aa7:	11 da                	adc    %ebx,%edx
 8048aa9:	a3 f0 c2 04 08       	mov    %eax,0x804c2f0
 8048aae:	89 15 f4 c2 04 08    	mov    %edx,0x804c2f4
			
			
			p = (void*)((uintptr_t)(maj->first) + sizeof( struct liballoc_minor ));
 8048ab4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048ab7:	8b 40 14             	mov    0x14(%eax),%eax
 8048aba:	83 c0 18             	add    $0x18,%eax
 8048abd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			ALIGN( p );
 8048ac0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048ac3:	83 c0 10             	add    $0x10,%eax
 8048ac6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8048ac9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048acc:	83 e0 0f             	and    $0xf,%eax
 8048acf:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048ad2:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 8048ad6:	74 16                	je     8048aee <malloc+0x289>
 8048ad8:	b8 10 00 00 00       	mov    $0x10,%eax
 8048add:	2b 45 d8             	sub    -0x28(%ebp),%eax
 8048ae0:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8048ae3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8048ae6:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048ae9:	01 d0                	add    %edx,%eax
 8048aeb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8048aee:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048af1:	8d 50 10             	lea    0x10(%eax),%edx
 8048af4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048af7:	83 e8 10             	sub    $0x10,%eax
 8048afa:	88 10                	mov    %dl,(%eax)
			
			#ifdef DEBUG
			serial_printf( "CASE 2: returning %x\n", p); 
			FLUSH();
			#endif
			liballoc_unlock();		// release the lock
 8048afc:	e8 f1 07 00 00       	call   80492f2 <liballoc_unlock>
			return p;
 8048b01:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048b04:	e9 e3 03 00 00       	jmp    8048eec <malloc+0x687>
#endif
				
#ifdef USE_CASE3

		// CASE 3: Block in use and enough space at the start of the block.
		diff =  (uintptr_t)(maj->first);
 8048b09:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b0c:	8b 40 14             	mov    0x14(%eax),%eax
 8048b0f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		diff -= (uintptr_t)maj;
 8048b12:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b15:	29 45 c4             	sub    %eax,-0x3c(%ebp)
		diff -= sizeof(struct liballoc_major);
 8048b18:	83 6d c4 18          	subl   $0x18,-0x3c(%ebp)

		if ( diff >= (size + sizeof(struct liballoc_minor)) )
 8048b1c:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048b1f:	83 c0 18             	add    $0x18,%eax
 8048b22:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 8048b25:	0f 82 f5 00 00 00    	jb     8048c20 <malloc+0x3bb>
		{
			// Yes, space in front. Squeeze in.
			maj->first->prev = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
 8048b2b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b2e:	8d 50 18             	lea    0x18(%eax),%edx
 8048b31:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b34:	8b 40 14             	mov    0x14(%eax),%eax
 8048b37:	89 10                	mov    %edx,(%eax)
			maj->first->prev->next = maj->first;
 8048b39:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b3c:	8b 40 14             	mov    0x14(%eax),%eax
 8048b3f:	8b 00                	mov    (%eax),%eax
 8048b41:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8048b44:	8b 52 14             	mov    0x14(%edx),%edx
 8048b47:	89 50 04             	mov    %edx,0x4(%eax)
			maj->first = maj->first->prev;
 8048b4a:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b4d:	8b 40 14             	mov    0x14(%eax),%eax
 8048b50:	8b 10                	mov    (%eax),%edx
 8048b52:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b55:	89 50 14             	mov    %edx,0x14(%eax)
				
			maj->first->magic 	= LIBALLOC_MAGIC;
 8048b58:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b5b:	8b 40 14             	mov    0x14(%eax),%eax
 8048b5e:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
			maj->first->prev 	= NULL;
 8048b65:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b68:	8b 40 14             	mov    0x14(%eax),%eax
 8048b6b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			maj->first->block 	= maj;
 8048b71:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b74:	8b 40 14             	mov    0x14(%eax),%eax
 8048b77:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8048b7a:	89 50 08             	mov    %edx,0x8(%eax)
			maj->first->size 	= size;
 8048b7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b80:	8b 40 14             	mov    0x14(%eax),%eax
 8048b83:	8b 55 c8             	mov    -0x38(%ebp),%edx
 8048b86:	89 50 10             	mov    %edx,0x10(%eax)
			maj->first->req_size 	= req_size;
 8048b89:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b8c:	8b 40 14             	mov    0x14(%eax),%eax
 8048b8f:	8b 55 08             	mov    0x8(%ebp),%edx
 8048b92:	89 50 14             	mov    %edx,0x14(%eax)
			maj->usage 			+= size + sizeof( struct liballoc_minor );
 8048b95:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048b98:	8b 50 10             	mov    0x10(%eax),%edx
 8048b9b:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048b9e:	01 d0                	add    %edx,%eax
 8048ba0:	8d 50 18             	lea    0x18(%eax),%edx
 8048ba3:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048ba6:	89 50 10             	mov    %edx,0x10(%eax)

			l_inuse += size;
 8048ba9:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 8048bac:	bb 00 00 00 00       	mov    $0x0,%ebx
 8048bb1:	a1 f0 c2 04 08       	mov    0x804c2f0,%eax
 8048bb6:	8b 15 f4 c2 04 08    	mov    0x804c2f4,%edx
 8048bbc:	01 c8                	add    %ecx,%eax
 8048bbe:	11 da                	adc    %ebx,%edx
 8048bc0:	a3 f0 c2 04 08       	mov    %eax,0x804c2f0
 8048bc5:	89 15 f4 c2 04 08    	mov    %edx,0x804c2f4

			p = (void*)((uintptr_t)(maj->first) + sizeof( struct liballoc_minor ));
 8048bcb:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048bce:	8b 40 14             	mov    0x14(%eax),%eax
 8048bd1:	83 c0 18             	add    $0x18,%eax
 8048bd4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			ALIGN( p );
 8048bd7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048bda:	83 c0 10             	add    $0x10,%eax
 8048bdd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8048be0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048be3:	83 e0 0f             	and    $0xf,%eax
 8048be6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048be9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 8048bed:	74 16                	je     8048c05 <malloc+0x3a0>
 8048bef:	b8 10 00 00 00       	mov    $0x10,%eax
 8048bf4:	2b 45 d4             	sub    -0x2c(%ebp),%eax
 8048bf7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8048bfa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8048bfd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048c00:	01 d0                	add    %edx,%eax
 8048c02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8048c05:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048c08:	8d 50 10             	lea    0x10(%eax),%edx
 8048c0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048c0e:	83 e8 10             	sub    $0x10,%eax
 8048c11:	88 10                	mov    %dl,(%eax)

			#ifdef DEBUG
			serial_printf( "CASE 3: returning %x\n", p); 
			FLUSH();
			#endif
			liballoc_unlock();		// release the lock
 8048c13:	e8 da 06 00 00       	call   80492f2 <liballoc_unlock>
			return p;
 8048c18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048c1b:	e9 cc 02 00 00       	jmp    8048eec <malloc+0x687>


#ifdef USE_CASE4

		// CASE 4: There is enough space in this block. But is it contiguous?
		min = maj->first;
 8048c20:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048c23:	8b 40 14             	mov    0x14(%eax),%eax
 8048c26:	89 45 dc             	mov    %eax,-0x24(%ebp)
		
			// Looping within the block now...
		while ( min != NULL )
 8048c29:	e9 47 02 00 00       	jmp    8048e75 <malloc+0x610>
		{
				// CASE 4.1: End of minors in a block. Space from last and end?
				if ( min->next == NULL )
 8048c2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048c31:	8b 40 04             	mov    0x4(%eax),%eax
 8048c34:	85 c0                	test   %eax,%eax
 8048c36:	0f 85 11 01 00 00    	jne    8048d4d <malloc+0x4e8>
				{
					// the rest of this block is free...  is it big enough?
					diff = (uintptr_t)(maj) + maj->size;
 8048c3c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048c3f:	8b 50 0c             	mov    0xc(%eax),%edx
 8048c42:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048c45:	01 d0                	add    %edx,%eax
 8048c47:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					diff -= (uintptr_t)min;
 8048c4a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048c4d:	29 45 c4             	sub    %eax,-0x3c(%ebp)
					diff -= sizeof( struct liballoc_minor );
 8048c50:	83 6d c4 18          	subl   $0x18,-0x3c(%ebp)
					diff -= min->size; 
 8048c54:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048c57:	8b 40 10             	mov    0x10(%eax),%eax
 8048c5a:	29 45 c4             	sub    %eax,-0x3c(%ebp)
						// minus already existing usage..

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
 8048c5d:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048c60:	83 c0 18             	add    $0x18,%eax
 8048c63:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 8048c66:	0f 82 e1 00 00 00    	jb     8048d4d <malloc+0x4e8>
					{
						// yay....
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
 8048c6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048c6f:	8b 50 10             	mov    0x10(%eax),%edx
 8048c72:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048c75:	01 d0                	add    %edx,%eax
 8048c77:	83 c0 18             	add    $0x18,%eax
 8048c7a:	89 c2                	mov    %eax,%edx
 8048c7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048c7f:	89 50 04             	mov    %edx,0x4(%eax)
						min->next->prev = min;
 8048c82:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048c85:	8b 40 04             	mov    0x4(%eax),%eax
 8048c88:	8b 55 dc             	mov    -0x24(%ebp),%edx
 8048c8b:	89 10                	mov    %edx,(%eax)
						min = min->next;
 8048c8d:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048c90:	8b 40 04             	mov    0x4(%eax),%eax
 8048c93:	89 45 dc             	mov    %eax,-0x24(%ebp)
						min->next = NULL;
 8048c96:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048c99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
						min->magic = LIBALLOC_MAGIC;
 8048ca0:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048ca3:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
						min->block = maj;
 8048caa:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048cad:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8048cb0:	89 50 08             	mov    %edx,0x8(%eax)
						min->size = size;
 8048cb3:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048cb6:	8b 55 c8             	mov    -0x38(%ebp),%edx
 8048cb9:	89 50 10             	mov    %edx,0x10(%eax)
						min->req_size = req_size;
 8048cbc:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048cbf:	8b 55 08             	mov    0x8(%ebp),%edx
 8048cc2:	89 50 14             	mov    %edx,0x14(%eax)
						maj->usage += size + sizeof( struct liballoc_minor );
 8048cc5:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048cc8:	8b 50 10             	mov    0x10(%eax),%edx
 8048ccb:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048cce:	01 d0                	add    %edx,%eax
 8048cd0:	8d 50 18             	lea    0x18(%eax),%edx
 8048cd3:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048cd6:	89 50 10             	mov    %edx,0x10(%eax)

						l_inuse += size;
 8048cd9:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 8048cdc:	bb 00 00 00 00       	mov    $0x0,%ebx
 8048ce1:	a1 f0 c2 04 08       	mov    0x804c2f0,%eax
 8048ce6:	8b 15 f4 c2 04 08    	mov    0x804c2f4,%edx
 8048cec:	01 c8                	add    %ecx,%eax
 8048cee:	11 da                	adc    %ebx,%edx
 8048cf0:	a3 f0 c2 04 08       	mov    %eax,0x804c2f0
 8048cf5:	89 15 f4 c2 04 08    	mov    %edx,0x804c2f4
						
						p = (void*)((uintptr_t)min + sizeof( struct liballoc_minor ));
 8048cfb:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048cfe:	83 c0 18             	add    $0x18,%eax
 8048d01:	89 45 e4             	mov    %eax,-0x1c(%ebp)
						ALIGN( p );
 8048d04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048d07:	83 c0 10             	add    $0x10,%eax
 8048d0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8048d0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048d10:	83 e0 0f             	and    $0xf,%eax
 8048d13:	89 45 d0             	mov    %eax,-0x30(%ebp)
 8048d16:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 8048d1a:	74 16                	je     8048d32 <malloc+0x4cd>
 8048d1c:	b8 10 00 00 00       	mov    $0x10,%eax
 8048d21:	2b 45 d0             	sub    -0x30(%ebp),%eax
 8048d24:	89 45 d0             	mov    %eax,-0x30(%ebp)
 8048d27:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8048d2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8048d2d:	01 d0                	add    %edx,%eax
 8048d2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8048d32:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8048d35:	8d 50 10             	lea    0x10(%eax),%edx
 8048d38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048d3b:	83 e8 10             	sub    $0x10,%eax
 8048d3e:	88 10                	mov    %dl,(%eax)

						#ifdef DEBUG
						serial_printf( "CASE 4.1: returning %x\n", p); 
						FLUSH();
						#endif
						liballoc_unlock();		// release the lock
 8048d40:	e8 ad 05 00 00       	call   80492f2 <liballoc_unlock>
						return p;
 8048d45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048d48:	e9 9f 01 00 00       	jmp    8048eec <malloc+0x687>
				}



				// CASE 4.2: Is there space between two minors?
				if ( min->next != NULL )
 8048d4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048d50:	8b 40 04             	mov    0x4(%eax),%eax
 8048d53:	85 c0                	test   %eax,%eax
 8048d55:	0f 84 11 01 00 00    	je     8048e6c <malloc+0x607>
				{
					// is the difference between here and next big enough?
					diff  = (uintptr_t)(min->next);
 8048d5b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048d5e:	8b 40 04             	mov    0x4(%eax),%eax
 8048d61:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					diff -= (uintptr_t)min;
 8048d64:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048d67:	29 45 c4             	sub    %eax,-0x3c(%ebp)
					diff -= sizeof( struct liballoc_minor );
 8048d6a:	83 6d c4 18          	subl   $0x18,-0x3c(%ebp)
					diff -= min->size;
 8048d6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048d71:	8b 40 10             	mov    0x10(%eax),%eax
 8048d74:	29 45 c4             	sub    %eax,-0x3c(%ebp)
										// minus our existing usage.

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
 8048d77:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048d7a:	83 c0 18             	add    $0x18,%eax
 8048d7d:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 8048d80:	0f 82 e6 00 00 00    	jb     8048e6c <malloc+0x607>
					{
						// yay......
						new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
 8048d86:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048d89:	8b 50 10             	mov    0x10(%eax),%edx
 8048d8c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048d8f:	01 d0                	add    %edx,%eax
 8048d91:	83 c0 18             	add    $0x18,%eax
 8048d94:	89 45 c0             	mov    %eax,-0x40(%ebp)

						new_min->magic = LIBALLOC_MAGIC;
 8048d97:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8048d9a:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
						new_min->next = min->next;
 8048da1:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048da4:	8b 50 04             	mov    0x4(%eax),%edx
 8048da7:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8048daa:	89 50 04             	mov    %edx,0x4(%eax)
						new_min->prev = min;
 8048dad:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8048db0:	8b 55 dc             	mov    -0x24(%ebp),%edx
 8048db3:	89 10                	mov    %edx,(%eax)
						new_min->size = size;
 8048db5:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8048db8:	8b 55 c8             	mov    -0x38(%ebp),%edx
 8048dbb:	89 50 10             	mov    %edx,0x10(%eax)
						new_min->req_size = req_size;
 8048dbe:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8048dc1:	8b 55 08             	mov    0x8(%ebp),%edx
 8048dc4:	89 50 14             	mov    %edx,0x14(%eax)
						new_min->block = maj;
 8048dc7:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8048dca:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8048dcd:	89 50 08             	mov    %edx,0x8(%eax)
						min->next->prev = new_min;
 8048dd0:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048dd3:	8b 40 04             	mov    0x4(%eax),%eax
 8048dd6:	8b 55 c0             	mov    -0x40(%ebp),%edx
 8048dd9:	89 10                	mov    %edx,(%eax)
						min->next = new_min;
 8048ddb:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048dde:	8b 55 c0             	mov    -0x40(%ebp),%edx
 8048de1:	89 50 04             	mov    %edx,0x4(%eax)
						maj->usage += size + sizeof( struct liballoc_minor );
 8048de4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048de7:	8b 50 10             	mov    0x10(%eax),%edx
 8048dea:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8048ded:	01 d0                	add    %edx,%eax
 8048def:	8d 50 18             	lea    0x18(%eax),%edx
 8048df2:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048df5:	89 50 10             	mov    %edx,0x10(%eax)
						
						l_inuse += size;
 8048df8:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 8048dfb:	bb 00 00 00 00       	mov    $0x0,%ebx
 8048e00:	a1 f0 c2 04 08       	mov    0x804c2f0,%eax
 8048e05:	8b 15 f4 c2 04 08    	mov    0x804c2f4,%edx
 8048e0b:	01 c8                	add    %ecx,%eax
 8048e0d:	11 da                	adc    %ebx,%edx
 8048e0f:	a3 f0 c2 04 08       	mov    %eax,0x804c2f0
 8048e14:	89 15 f4 c2 04 08    	mov    %edx,0x804c2f4
						
						p = (void*)((uintptr_t)new_min + sizeof( struct liballoc_minor ));
 8048e1a:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8048e1d:	83 c0 18             	add    $0x18,%eax
 8048e20:	89 45 e4             	mov    %eax,-0x1c(%ebp)
						ALIGN( p );
 8048e23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048e26:	83 c0 10             	add    $0x10,%eax
 8048e29:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8048e2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048e2f:	83 e0 0f             	and    $0xf,%eax
 8048e32:	89 45 cc             	mov    %eax,-0x34(%ebp)
 8048e35:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 8048e39:	74 16                	je     8048e51 <malloc+0x5ec>
 8048e3b:	b8 10 00 00 00       	mov    $0x10,%eax
 8048e40:	2b 45 cc             	sub    -0x34(%ebp),%eax
 8048e43:	89 45 cc             	mov    %eax,-0x34(%ebp)
 8048e46:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8048e49:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8048e4c:	01 d0                	add    %edx,%eax
 8048e4e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8048e51:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8048e54:	8d 50 10             	lea    0x10(%eax),%edx
 8048e57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048e5a:	83 e8 10             	sub    $0x10,%eax
 8048e5d:	88 10                	mov    %dl,(%eax)
						#ifdef DEBUG
						serial_printf( "CASE 4.2: returning %x\n", p); 
						FLUSH();
						#endif
						
						liballoc_unlock();		// release the lock
 8048e5f:	e8 8e 04 00 00       	call   80492f2 <liballoc_unlock>
						return p;
 8048e64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048e67:	e9 80 00 00 00       	jmp    8048eec <malloc+0x687>
					}
				}	// min->next != NULL

				min = min->next;
 8048e6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048e6f:	8b 40 04             	mov    0x4(%eax),%eax
 8048e72:	89 45 dc             	mov    %eax,-0x24(%ebp)
		while ( min != NULL )
 8048e75:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 8048e79:	0f 85 af fd ff ff    	jne    8048c2e <malloc+0x3c9>
#endif

#ifdef USE_CASE5

		// CASE 5: Block full! Ensure next block and loop.
		if ( maj->next == NULL ) 
 8048e7f:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048e82:	8b 40 04             	mov    0x4(%eax),%eax
 8048e85:	85 c0                	test   %eax,%eax
 8048e87:	75 40                	jne    8048ec9 <malloc+0x664>
			#ifdef DEBUG
			serial_printf( "CASE 5: block full\n");
			FLUSH();
			#endif

			if ( startedBet == 1 )
 8048e89:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
 8048e8d:	75 11                	jne    8048ea0 <malloc+0x63b>
			{
				maj = l_memRoot;
 8048e8f:	a1 e0 c2 04 08       	mov    0x804c2e0,%eax
 8048e94:	89 45 e0             	mov    %eax,-0x20(%ebp)
				startedBet = 0;
 8048e97:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				continue;
 8048e9e:	eb 32                	jmp    8048ed2 <malloc+0x66d>
			}
				
			// we've run out. we need more...
			maj->next = allocate_new_page( size );		// next one guaranteed to be okay
 8048ea0:	83 ec 0c             	sub    $0xc,%esp
 8048ea3:	ff 75 c8             	push   -0x38(%ebp)
 8048ea6:	e8 d1 f8 ff ff       	call   804877c <allocate_new_page>
 8048eab:	83 c4 10             	add    $0x10,%esp
 8048eae:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8048eb1:	89 42 04             	mov    %eax,0x4(%edx)
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
 8048eb4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048eb7:	8b 40 04             	mov    0x4(%eax),%eax
 8048eba:	85 c0                	test   %eax,%eax
 8048ebc:	74 23                	je     8048ee1 <malloc+0x67c>
			maj->next->prev = maj;
 8048ebe:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048ec1:	8b 40 04             	mov    0x4(%eax),%eax
 8048ec4:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8048ec7:	89 10                	mov    %edx,(%eax)

		}

#endif

		maj = maj->next;
 8048ec9:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048ecc:	8b 40 04             	mov    0x4(%eax),%eax
 8048ecf:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while ( maj != NULL )
 8048ed2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 8048ed6:	0f 85 8f fa ff ff    	jne    804896b <malloc+0x106>
 8048edc:	eb 04                	jmp    8048ee2 <malloc+0x67d>
			if ( maj->next == NULL ) break;			// no more memory.
 8048ede:	90                   	nop
 8048edf:	eb 01                	jmp    8048ee2 <malloc+0x67d>
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
 8048ee1:	90                   	nop
	} // while (maj != NULL)


	
	liballoc_unlock();		// release the lock
 8048ee2:	e8 0b 04 00 00       	call   80492f2 <liballoc_unlock>
	#if defined DEBUG || defined INFO
	serial_printf( "liballoc: WARNING: PREFIX(malloc)( %d ) returning NULL.\n", size);
	liballoc_dump();
	FLUSH();
	#endif
	return NULL;
 8048ee7:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8048eec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 8048eef:	c9                   	leave  
 8048ef0:	c3                   	ret    

08048ef1 <free>:




void PREFIX(free)(void *ptr)
{
 8048ef1:	55                   	push   %ebp
 8048ef2:	89 e5                	mov    %esp,%ebp
 8048ef4:	53                   	push   %ebx
 8048ef5:	83 ec 24             	sub    $0x24,%esp
	struct liballoc_minor *min;
	struct liballoc_major *maj;

	if ( ptr == NULL ) 
 8048ef8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8048efc:	75 21                	jne    8048f1f <free+0x2e>
	{
		l_warningCount += 1;
 8048efe:	a1 f8 c2 04 08       	mov    0x804c2f8,%eax
 8048f03:	8b 15 fc c2 04 08    	mov    0x804c2fc,%edx
 8048f09:	83 c0 01             	add    $0x1,%eax
 8048f0c:	83 d2 00             	adc    $0x0,%edx
 8048f0f:	a3 f8 c2 04 08       	mov    %eax,0x804c2f8
 8048f14:	89 15 fc c2 04 08    	mov    %edx,0x804c2fc
		#if defined DEBUG || defined INFO
		serial_printf( "liballoc: WARNING: PREFIX(free)( NULL ) called from %x\n",
							__builtin_return_address(0) );
		FLUSH();
		#endif
		return;
 8048f1a:	e9 29 02 00 00       	jmp    8049148 <free+0x257>
	}

	UNALIGN( ptr );
 8048f1f:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f22:	83 e8 10             	sub    $0x10,%eax
 8048f25:	8a 00                	mov    (%eax),%al
 8048f27:	0f be c0             	movsbl %al,%eax
 8048f2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8048f2d:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
 8048f31:	77 09                	ja     8048f3c <free+0x4b>
 8048f33:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f36:	2b 45 f4             	sub    -0xc(%ebp),%eax
 8048f39:	89 45 08             	mov    %eax,0x8(%ebp)

	liballoc_lock();		// lockit
 8048f3c:	e8 99 03 00 00       	call   80492da <liballoc_lock>


	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
 8048f41:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f44:	83 e8 18             	sub    $0x18,%eax
 8048f47:	89 45 f0             	mov    %eax,-0x10(%ebp)

	
	if ( min->magic != LIBALLOC_MAGIC ) 
 8048f4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048f4d:	8b 40 0c             	mov    0xc(%eax),%eax
 8048f50:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
 8048f55:	74 74                	je     8048fcb <free+0xda>
	{
		l_errorCount += 1;
 8048f57:	a1 00 c3 04 08       	mov    0x804c300,%eax
 8048f5c:	8b 15 04 c3 04 08    	mov    0x804c304,%edx
 8048f62:	83 c0 01             	add    $0x1,%eax
 8048f65:	83 d2 00             	adc    $0x0,%edx
 8048f68:	a3 00 c3 04 08       	mov    %eax,0x804c300
 8048f6d:	89 15 04 c3 04 08    	mov    %edx,0x804c304

		// Check for overrun errors. For all bytes of LIBALLOC_MAGIC 
		if ( 
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
 8048f73:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048f76:	8b 40 0c             	mov    0xc(%eax),%eax
 8048f79:	25 ff ff ff 00       	and    $0xffffff,%eax
		if ( 
 8048f7e:	3d de c0 01 00       	cmp    $0x1c0de,%eax
 8048f83:	74 20                	je     8048fa5 <free+0xb4>
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
 8048f85:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048f88:	8b 40 0c             	mov    0xc(%eax),%eax
 8048f8b:	0f b7 c0             	movzwl %ax,%eax
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
 8048f8e:	3d de c0 00 00       	cmp    $0xc0de,%eax
 8048f93:	74 10                	je     8048fa5 <free+0xb4>
			((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF)) 
 8048f95:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048f98:	8b 40 0c             	mov    0xc(%eax),%eax
 8048f9b:	0f b6 c0             	movzbl %al,%eax
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
 8048f9e:	3d de 00 00 00       	cmp    $0xde,%eax
 8048fa3:	75 1c                	jne    8048fc1 <free+0xd0>
		   )
		{
			l_possibleOverruns += 1;
 8048fa5:	a1 08 c3 04 08       	mov    0x804c308,%eax
 8048faa:	8b 15 0c c3 04 08    	mov    0x804c30c,%edx
 8048fb0:	83 c0 01             	add    $0x1,%eax
 8048fb3:	83 d2 00             	adc    $0x0,%edx
 8048fb6:	a3 08 c3 04 08       	mov    %eax,0x804c308
 8048fbb:	89 15 0c c3 04 08    	mov    %edx,0x804c30c
			FLUSH();
			#endif
		}
			
		// being lied to...
		liballoc_unlock();		// release the lock
 8048fc1:	e8 2c 03 00 00       	call   80492f2 <liballoc_unlock>
		return;
 8048fc6:	e9 7d 01 00 00       	jmp    8049148 <free+0x257>
				ptr );
	FLUSH();
	#endif
	

		maj = min->block;
 8048fcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048fce:	8b 40 08             	mov    0x8(%eax),%eax
 8048fd1:	89 45 ec             	mov    %eax,-0x14(%ebp)

		l_inuse -= min->size;
 8048fd4:	a1 f0 c2 04 08       	mov    0x804c2f0,%eax
 8048fd9:	8b 15 f4 c2 04 08    	mov    0x804c2f4,%edx
 8048fdf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
 8048fe2:	8b 49 10             	mov    0x10(%ecx),%ecx
 8048fe5:	bb 00 00 00 00       	mov    $0x0,%ebx
 8048fea:	29 c8                	sub    %ecx,%eax
 8048fec:	19 da                	sbb    %ebx,%edx
 8048fee:	a3 f0 c2 04 08       	mov    %eax,0x804c2f0
 8048ff3:	89 15 f4 c2 04 08    	mov    %edx,0x804c2f4

		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
 8048ff9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8048ffc:	8b 50 10             	mov    0x10(%eax),%edx
 8048fff:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049002:	8b 40 10             	mov    0x10(%eax),%eax
 8049005:	29 c2                	sub    %eax,%edx
 8049007:	89 d0                	mov    %edx,%eax
 8049009:	8d 50 e8             	lea    -0x18(%eax),%edx
 804900c:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804900f:	89 50 10             	mov    %edx,0x10(%eax)
		min->magic  = LIBALLOC_DEAD;		// No mojo.
 8049012:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049015:	c7 40 0c ad de ad de 	movl   $0xdeaddead,0xc(%eax)

		if ( min->next != NULL ) min->next->prev = min->prev;
 804901c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804901f:	8b 40 04             	mov    0x4(%eax),%eax
 8049022:	85 c0                	test   %eax,%eax
 8049024:	74 0d                	je     8049033 <free+0x142>
 8049026:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049029:	8b 40 04             	mov    0x4(%eax),%eax
 804902c:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804902f:	8b 12                	mov    (%edx),%edx
 8049031:	89 10                	mov    %edx,(%eax)
		if ( min->prev != NULL ) min->prev->next = min->next;
 8049033:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049036:	8b 00                	mov    (%eax),%eax
 8049038:	85 c0                	test   %eax,%eax
 804903a:	74 0e                	je     804904a <free+0x159>
 804903c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804903f:	8b 00                	mov    (%eax),%eax
 8049041:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049044:	8b 52 04             	mov    0x4(%edx),%edx
 8049047:	89 50 04             	mov    %edx,0x4(%eax)

		if ( min->prev == NULL ) maj->first = min->next;	
 804904a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804904d:	8b 00                	mov    (%eax),%eax
 804904f:	85 c0                	test   %eax,%eax
 8049051:	75 0c                	jne    804905f <free+0x16e>
 8049053:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049056:	8b 50 04             	mov    0x4(%eax),%edx
 8049059:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804905c:	89 50 14             	mov    %edx,0x14(%eax)
							// minor.


	// We need to clean up after the majors now....

	if ( maj->first == NULL )	// Block completely unused.
 804905f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049062:	8b 40 14             	mov    0x14(%eax),%eax
 8049065:	85 c0                	test   %eax,%eax
 8049067:	0f 85 93 00 00 00    	jne    8049100 <free+0x20f>
	{
		if ( l_memRoot == maj ) l_memRoot = maj->next;
 804906d:	a1 e0 c2 04 08       	mov    0x804c2e0,%eax
 8049072:	39 45 ec             	cmp    %eax,-0x14(%ebp)
 8049075:	75 0b                	jne    8049082 <free+0x191>
 8049077:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804907a:	8b 40 04             	mov    0x4(%eax),%eax
 804907d:	a3 e0 c2 04 08       	mov    %eax,0x804c2e0
		if ( l_bestBet == maj ) l_bestBet = NULL;
 8049082:	a1 e4 c2 04 08       	mov    0x804c2e4,%eax
 8049087:	39 45 ec             	cmp    %eax,-0x14(%ebp)
 804908a:	75 0a                	jne    8049096 <free+0x1a5>
 804908c:	c7 05 e4 c2 04 08 00 	movl   $0x0,0x804c2e4
 8049093:	00 00 00 
		if ( maj->prev != NULL ) maj->prev->next = maj->next;
 8049096:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049099:	8b 00                	mov    (%eax),%eax
 804909b:	85 c0                	test   %eax,%eax
 804909d:	74 0e                	je     80490ad <free+0x1bc>
 804909f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80490a2:	8b 00                	mov    (%eax),%eax
 80490a4:	8b 55 ec             	mov    -0x14(%ebp),%edx
 80490a7:	8b 52 04             	mov    0x4(%edx),%edx
 80490aa:	89 50 04             	mov    %edx,0x4(%eax)
		if ( maj->next != NULL ) maj->next->prev = maj->prev;
 80490ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80490b0:	8b 40 04             	mov    0x4(%eax),%eax
 80490b3:	85 c0                	test   %eax,%eax
 80490b5:	74 0d                	je     80490c4 <free+0x1d3>
 80490b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80490ba:	8b 40 04             	mov    0x4(%eax),%eax
 80490bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
 80490c0:	8b 12                	mov    (%edx),%edx
 80490c2:	89 10                	mov    %edx,(%eax)
		l_allocated -= maj->size;
 80490c4:	a1 e8 c2 04 08       	mov    0x804c2e8,%eax
 80490c9:	8b 15 ec c2 04 08    	mov    0x804c2ec,%edx
 80490cf:	8b 4d ec             	mov    -0x14(%ebp),%ecx
 80490d2:	8b 49 0c             	mov    0xc(%ecx),%ecx
 80490d5:	bb 00 00 00 00       	mov    $0x0,%ebx
 80490da:	29 c8                	sub    %ecx,%eax
 80490dc:	19 da                	sbb    %ebx,%edx
 80490de:	a3 e8 c2 04 08       	mov    %eax,0x804c2e8
 80490e3:	89 15 ec c2 04 08    	mov    %edx,0x804c2ec

		liballoc_free( maj, maj->pages );
 80490e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80490ec:	8b 40 08             	mov    0x8(%eax),%eax
 80490ef:	83 ec 08             	sub    $0x8,%esp
 80490f2:	50                   	push   %eax
 80490f3:	ff 75 ec             	push   -0x14(%ebp)
 80490f6:	e8 26 02 00 00       	call   8049321 <liballoc_free>
 80490fb:	83 c4 10             	add    $0x10,%esp
 80490fe:	eb 43                	jmp    8049143 <free+0x252>
	}
	else
	{
		if ( l_bestBet != NULL )
 8049100:	a1 e4 c2 04 08       	mov    0x804c2e4,%eax
 8049105:	85 c0                	test   %eax,%eax
 8049107:	74 3a                	je     8049143 <free+0x252>
		{
			int bestSize = l_bestBet->size  - l_bestBet->usage;
 8049109:	a1 e4 c2 04 08       	mov    0x804c2e4,%eax
 804910e:	8b 50 0c             	mov    0xc(%eax),%edx
 8049111:	a1 e4 c2 04 08       	mov    0x804c2e4,%eax
 8049116:	8b 40 10             	mov    0x10(%eax),%eax
 8049119:	29 c2                	sub    %eax,%edx
 804911b:	89 d0                	mov    %edx,%eax
 804911d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			int majSize = maj->size - maj->usage;
 8049120:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049123:	8b 50 0c             	mov    0xc(%eax),%edx
 8049126:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049129:	8b 40 10             	mov    0x10(%eax),%eax
 804912c:	29 c2                	sub    %eax,%edx
 804912e:	89 d0                	mov    %edx,%eax
 8049130:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if ( majSize > bestSize ) l_bestBet = maj;
 8049133:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049136:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 8049139:	7e 08                	jle    8049143 <free+0x252>
 804913b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804913e:	a3 e4 c2 04 08       	mov    %eax,0x804c2e4
	#ifdef DEBUG
	serial_printf( "OK\n");
	FLUSH();
	#endif
	
	liballoc_unlock();		// release the lock
 8049143:	e8 aa 01 00 00       	call   80492f2 <liballoc_unlock>
}
 8049148:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804914b:	c9                   	leave  
 804914c:	c3                   	ret    

0804914d <calloc>:




void* PREFIX(calloc)(size_t nobj, size_t size)
{
 804914d:	55                   	push   %ebp
 804914e:	89 e5                	mov    %esp,%ebp
 8049150:	83 ec 18             	sub    $0x18,%esp
       int real_size;
       void *p;

       real_size = nobj * size;
 8049153:	8b 45 08             	mov    0x8(%ebp),%eax
 8049156:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804915a:	89 45 f4             	mov    %eax,-0xc(%ebp)
       
       p = PREFIX(malloc)( real_size );
 804915d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049160:	83 ec 0c             	sub    $0xc,%esp
 8049163:	50                   	push   %eax
 8049164:	e8 fc f6 ff ff       	call   8048865 <malloc>
 8049169:	83 c4 10             	add    $0x10,%esp
 804916c:	89 45 f0             	mov    %eax,-0x10(%ebp)

       liballoc_memset( p, 0, real_size );
 804916f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049172:	83 ec 04             	sub    $0x4,%esp
 8049175:	50                   	push   %eax
 8049176:	6a 00                	push   $0x0
 8049178:	ff 75 f0             	push   -0x10(%ebp)
 804917b:	e8 6a f5 ff ff       	call   80486ea <liballoc_memset>
 8049180:	83 c4 10             	add    $0x10,%esp

       return p;
 8049183:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049186:	c9                   	leave  
 8049187:	c3                   	ret    

08049188 <realloc>:



void*   PREFIX(realloc)(void *p, size_t size)
{
 8049188:	55                   	push   %ebp
 8049189:	89 e5                	mov    %esp,%ebp
 804918b:	83 ec 18             	sub    $0x18,%esp
	void *ptr;
	struct liballoc_minor *min;
	unsigned int real_size;
	
	// Honour the case of size == 0 => free old and return NULL
	if ( size == 0 )
 804918e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 8049192:	75 18                	jne    80491ac <realloc+0x24>
	{
		PREFIX(free)( p );
 8049194:	83 ec 0c             	sub    $0xc,%esp
 8049197:	ff 75 08             	push   0x8(%ebp)
 804919a:	e8 52 fd ff ff       	call   8048ef1 <free>
 804919f:	83 c4 10             	add    $0x10,%esp
		return NULL;
 80491a2:	b8 00 00 00 00       	mov    $0x0,%eax
 80491a7:	e9 2c 01 00 00       	jmp    80492d8 <realloc+0x150>
	}

	// In the case of a NULL pointer, return a simple malloc.
	if ( p == NULL ) return PREFIX(malloc)( size );
 80491ac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80491b0:	75 13                	jne    80491c5 <realloc+0x3d>
 80491b2:	83 ec 0c             	sub    $0xc,%esp
 80491b5:	ff 75 0c             	push   0xc(%ebp)
 80491b8:	e8 a8 f6 ff ff       	call   8048865 <malloc>
 80491bd:	83 c4 10             	add    $0x10,%esp
 80491c0:	e9 13 01 00 00       	jmp    80492d8 <realloc+0x150>

	// Unalign the pointer if required.
	ptr = p;
 80491c5:	8b 45 08             	mov    0x8(%ebp),%eax
 80491c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	UNALIGN(ptr);
 80491cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80491ce:	83 e8 10             	sub    $0x10,%eax
 80491d1:	8a 00                	mov    (%eax),%al
 80491d3:	0f be c0             	movsbl %al,%eax
 80491d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
 80491d9:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
 80491dd:	77 09                	ja     80491e8 <realloc+0x60>
 80491df:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80491e2:	2b 45 f0             	sub    -0x10(%ebp),%eax
 80491e5:	89 45 f4             	mov    %eax,-0xc(%ebp)

	liballoc_lock();		// lockit
 80491e8:	e8 ed 00 00 00       	call   80492da <liballoc_lock>

		min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
 80491ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80491f0:	83 e8 18             	sub    $0x18,%eax
 80491f3:	89 45 ec             	mov    %eax,-0x14(%ebp)

		// Ensure it is a valid structure.
		if ( min->magic != LIBALLOC_MAGIC ) 
 80491f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80491f9:	8b 40 0c             	mov    0xc(%eax),%eax
 80491fc:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
 8049201:	74 76                	je     8049279 <realloc+0xf1>
		{
			l_errorCount += 1;
 8049203:	a1 00 c3 04 08       	mov    0x804c300,%eax
 8049208:	8b 15 04 c3 04 08    	mov    0x804c304,%edx
 804920e:	83 c0 01             	add    $0x1,%eax
 8049211:	83 d2 00             	adc    $0x0,%edx
 8049214:	a3 00 c3 04 08       	mov    %eax,0x804c300
 8049219:	89 15 04 c3 04 08    	mov    %edx,0x804c304
	
			// Check for overrun errors. For all bytes of LIBALLOC_MAGIC 
			if ( 
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
 804921f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049222:	8b 40 0c             	mov    0xc(%eax),%eax
 8049225:	25 ff ff ff 00       	and    $0xffffff,%eax
			if ( 
 804922a:	3d de c0 01 00       	cmp    $0x1c0de,%eax
 804922f:	74 20                	je     8049251 <realloc+0xc9>
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
 8049231:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049234:	8b 40 0c             	mov    0xc(%eax),%eax
 8049237:	0f b7 c0             	movzwl %ax,%eax
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
 804923a:	3d de c0 00 00       	cmp    $0xc0de,%eax
 804923f:	74 10                	je     8049251 <realloc+0xc9>
				((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF)) 
 8049241:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049244:	8b 40 0c             	mov    0xc(%eax),%eax
 8049247:	0f b6 c0             	movzbl %al,%eax
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
 804924a:	3d de 00 00 00       	cmp    $0xde,%eax
 804924f:	75 1c                	jne    804926d <realloc+0xe5>
			   )
			{
				l_possibleOverruns += 1;
 8049251:	a1 08 c3 04 08       	mov    0x804c308,%eax
 8049256:	8b 15 0c c3 04 08    	mov    0x804c30c,%edx
 804925c:	83 c0 01             	add    $0x1,%eax
 804925f:	83 d2 00             	adc    $0x0,%edx
 8049262:	a3 08 c3 04 08       	mov    %eax,0x804c308
 8049267:	89 15 0c c3 04 08    	mov    %edx,0x804c30c
				FLUSH();
				#endif
			}
			
			// being lied to...
			liballoc_unlock();		// release the lock
 804926d:	e8 80 00 00 00       	call   80492f2 <liballoc_unlock>
			return NULL;
 8049272:	b8 00 00 00 00       	mov    $0x0,%eax
 8049277:	eb 5f                	jmp    80492d8 <realloc+0x150>
		}	
		
		// Definitely a memory block.
		
		real_size = min->req_size;
 8049279:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804927c:	8b 40 14             	mov    0x14(%eax),%eax
 804927f:	89 45 e8             	mov    %eax,-0x18(%ebp)

		if ( real_size >= size ) 
 8049282:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049285:	3b 45 0c             	cmp    0xc(%ebp),%eax
 8049288:	72 13                	jb     804929d <realloc+0x115>
		{
			min->req_size = size;
 804928a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804928d:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049290:	89 50 14             	mov    %edx,0x14(%eax)
			liballoc_unlock();
 8049293:	e8 5a 00 00 00       	call   80492f2 <liballoc_unlock>
			return p;
 8049298:	8b 45 08             	mov    0x8(%ebp),%eax
 804929b:	eb 3b                	jmp    80492d8 <realloc+0x150>
		}

	liballoc_unlock();
 804929d:	e8 50 00 00 00       	call   80492f2 <liballoc_unlock>

	// If we got here then we're reallocating to a block bigger than us.
	ptr = PREFIX(malloc)( size );					// We need to allocate new memory
 80492a2:	83 ec 0c             	sub    $0xc,%esp
 80492a5:	ff 75 0c             	push   0xc(%ebp)
 80492a8:	e8 b8 f5 ff ff       	call   8048865 <malloc>
 80492ad:	83 c4 10             	add    $0x10,%esp
 80492b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	liballoc_memcpy( ptr, p, real_size );
 80492b3:	83 ec 04             	sub    $0x4,%esp
 80492b6:	ff 75 e8             	push   -0x18(%ebp)
 80492b9:	ff 75 08             	push   0x8(%ebp)
 80492bc:	ff 75 f4             	push   -0xc(%ebp)
 80492bf:	e8 52 f4 ff ff       	call   8048716 <liballoc_memcpy>
 80492c4:	83 c4 10             	add    $0x10,%esp
	PREFIX(free)( p );
 80492c7:	83 ec 0c             	sub    $0xc,%esp
 80492ca:	ff 75 08             	push   0x8(%ebp)
 80492cd:	e8 1f fc ff ff       	call   8048ef1 <free>
 80492d2:	83 c4 10             	add    $0x10,%esp

	return ptr;
 80492d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80492d8:	c9                   	leave  
 80492d9:	c3                   	ret    

080492da <liballoc_lock>:
#include <memory.h>
#include <pthread.h>

pthread_spinlock_t lock;

int liballoc_lock() {
 80492da:	55                   	push   %ebp
 80492db:	89 e5                	mov    %esp,%ebp
 80492dd:	83 ec 08             	sub    $0x8,%esp
  return pthread_spin_lock(&lock);
 80492e0:	83 ec 0c             	sub    $0xc,%esp
 80492e3:	68 24 c3 04 08       	push   $0x804c324
 80492e8:	e8 59 01 00 00       	call   8049446 <pthread_spin_lock>
 80492ed:	83 c4 10             	add    $0x10,%esp
}
 80492f0:	c9                   	leave  
 80492f1:	c3                   	ret    

080492f2 <liballoc_unlock>:

extern int liballoc_unlock() {
 80492f2:	55                   	push   %ebp
 80492f3:	89 e5                	mov    %esp,%ebp
 80492f5:	83 ec 08             	sub    $0x8,%esp
  return pthread_spin_unlock(&lock);
 80492f8:	83 ec 0c             	sub    $0xc,%esp
 80492fb:	68 24 c3 04 08       	push   $0x804c324
 8049300:	e8 5c 01 00 00       	call   8049461 <pthread_spin_unlock>
 8049305:	83 c4 10             	add    $0x10,%esp
}
 8049308:	c9                   	leave  
 8049309:	c3                   	ret    

0804930a <liballoc_alloc>:

extern void* liballoc_alloc(size_t num_pages) {
 804930a:	55                   	push   %ebp
 804930b:	89 e5                	mov    %esp,%ebp
 804930d:	83 ec 08             	sub    $0x8,%esp
  return alloc_memory(num_pages);
 8049310:	8b 45 08             	mov    0x8(%ebp),%eax
 8049313:	83 ec 0c             	sub    $0xc,%esp
 8049316:	50                   	push   %eax
 8049317:	e8 0f 00 00 00       	call   804932b <alloc_memory>
 804931c:	83 c4 10             	add    $0x10,%esp
}
 804931f:	c9                   	leave  
 8049320:	c3                   	ret    

08049321 <liballoc_free>:

extern int liballoc_free(void* ptr,size_t num_pages) {
 8049321:	55                   	push   %ebp
 8049322:	89 e5                	mov    %esp,%ebp
  return 0;
 8049324:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049329:	5d                   	pop    %ebp
 804932a:	c3                   	ret    

0804932b <alloc_memory>:
#include <sys/syscalls.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void* alloc_memory(int num_pages) {
 804932b:	55                   	push   %ebp
 804932c:	89 e5                	mov    %esp,%ebp
 804932e:	53                   	push   %ebx
 804932f:	83 ec 10             	sub    $0x10,%esp
  void* address;
  asm volatile("  \
 8049332:	8b 45 08             	mov    0x8(%ebp),%eax
 8049335:	ba 00 00 00 00       	mov    $0x0,%edx
 804933a:	89 c3                	mov    %eax,%ebx
 804933c:	89 d1                	mov    %edx,%ecx
 804933e:	b8 07 00 00 00       	mov    $0x7,%eax
 8049343:	cd 50                	int    $0x50
 8049345:	89 d8                	mov    %ebx,%eax
 8049347:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_ALLOC_MEM) ", %%eax; \
    int $80; \
  ":"=b"(address):"b"(num_pages),"c"(NULL));
  return address;
 804934a:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 804934d:	83 c4 10             	add    $0x10,%esp
 8049350:	5b                   	pop    %ebx
 8049351:	5d                   	pop    %ebp
 8049352:	c3                   	ret    

08049353 <alloc_memory_virt>:

void alloc_memory_virt(int num_pages,void* addr) {
 8049353:	55                   	push   %ebp
 8049354:	89 e5                	mov    %esp,%ebp
 8049356:	53                   	push   %ebx
  asm volatile("  \
 8049357:	8b 45 08             	mov    0x8(%ebp),%eax
 804935a:	8b 55 0c             	mov    0xc(%ebp),%edx
 804935d:	89 c3                	mov    %eax,%ebx
 804935f:	89 d1                	mov    %edx,%ecx
 8049361:	b8 07 00 00 00       	mov    $0x7,%eax
 8049366:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_ALLOC_MEM) ", %%eax; \
    int $80; \
  "::"b"(num_pages),"c"(addr));
}
 8049368:	90                   	nop
 8049369:	5b                   	pop    %ebx
 804936a:	5d                   	pop    %ebp
 804936b:	c3                   	ret    

0804936c <new_address_space>:

void* new_address_space() {
 804936c:	55                   	push   %ebp
 804936d:	89 e5                	mov    %esp,%ebp
 804936f:	53                   	push   %ebx
 8049370:	83 ec 10             	sub    $0x10,%esp
  void* address_space;
  asm volatile("  \
 8049373:	b8 09 00 00 00       	mov    $0x9,%eax
 8049378:	cd 50                	int    $0x50
 804937a:	89 d8                	mov    %ebx,%eax
 804937c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_NEW_ADDR_SPACE) ", %%eax; \
    int $80; \
  ":"=b"(address_space));
  return address_space;
 804937f:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 8049382:	83 c4 10             	add    $0x10,%esp
 8049385:	5b                   	pop    %ebx
 8049386:	5d                   	pop    %ebp
 8049387:	c3                   	ret    

08049388 <copy_data>:

void copy_data(void* address_space, void* data,size_t size,void* virt_addr) {
 8049388:	55                   	push   %ebp
 8049389:	89 e5                	mov    %esp,%ebp
 804938b:	56                   	push   %esi
 804938c:	53                   	push   %ebx
  asm volatile("  \
 804938d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049390:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 8049393:	8b 55 10             	mov    0x10(%ebp),%edx
 8049396:	8b 75 14             	mov    0x14(%ebp),%esi
 8049399:	89 c3                	mov    %eax,%ebx
 804939b:	b8 0a 00 00 00       	mov    $0xa,%eax
 80493a0:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_ADDR_SPACES_COPY_DATA) ", %%eax; \
    int $80; \
  "::"b"(address_space),"c"(data),"d"(size),"S"(virt_addr));
}
 80493a2:	90                   	nop
 80493a3:	5b                   	pop    %ebx
 80493a4:	5e                   	pop    %esi
 80493a5:	5d                   	pop    %ebp
 80493a6:	c3                   	ret    

080493a7 <put_data>:

void* put_data(void* address_space, void* data,size_t size) {
 80493a7:	55                   	push   %ebp
 80493a8:	89 e5                	mov    %esp,%ebp
 80493aa:	56                   	push   %esi
 80493ab:	53                   	push   %ebx
 80493ac:	83 ec 10             	sub    $0x10,%esp
  void* virt_addr;
  asm volatile("  \
 80493af:	8b 45 08             	mov    0x8(%ebp),%eax
 80493b2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 80493b5:	8b 55 10             	mov    0x10(%ebp),%edx
 80493b8:	be 00 00 00 00       	mov    $0x0,%esi
 80493bd:	89 c3                	mov    %eax,%ebx
 80493bf:	b8 0a 00 00 00       	mov    $0xa,%eax
 80493c4:	cd 50                	int    $0x50
 80493c6:	89 d8                	mov    %ebx,%eax
 80493c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    mov $" QU(SYSCALL_ADDR_SPACES_COPY_DATA) ", %%eax; \
    int $80; \
  ":"=b"(virt_addr):"b"(address_space),"c"(data),"d"(size),"S"(NULL));
  return virt_addr;
 80493cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80493ce:	83 c4 10             	add    $0x10,%esp
 80493d1:	5b                   	pop    %ebx
 80493d2:	5e                   	pop    %esi
 80493d3:	5d                   	pop    %ebp
 80493d4:	c3                   	ret    

080493d5 <map_phys>:

void* map_phys(void* phys_addr,size_t num_pages) {
 80493d5:	55                   	push   %ebp
 80493d6:	89 e5                	mov    %esp,%ebp
 80493d8:	53                   	push   %ebx
 80493d9:	83 ec 10             	sub    $0x10,%esp
  void* virt_addr;
  asm volatile("  \
 80493dc:	8b 45 08             	mov    0x8(%ebp),%eax
 80493df:	8b 55 0c             	mov    0xc(%ebp),%edx
 80493e2:	89 c3                	mov    %eax,%ebx
 80493e4:	89 d1                	mov    %edx,%ecx
 80493e6:	b8 08 00 00 00       	mov    $0x8,%eax
 80493eb:	cd 50                	int    $0x50
 80493ed:	89 d8                	mov    %ebx,%eax
 80493ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_PRIV_MAP_PAGES) ", %%eax; \
    int $80; \
  ":"=b"(virt_addr):"b"(phys_addr),"c"(num_pages));
  return virt_addr;
 80493f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 80493f5:	83 c4 10             	add    $0x10,%esp
 80493f8:	5b                   	pop    %ebx
 80493f9:	5d                   	pop    %ebp
 80493fa:	c3                   	ret    

080493fb <pthread_create>:
#include <__helpers.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start_routine)(void*), void *restrict arg) {
 80493fb:	55                   	push   %ebp
 80493fc:	89 e5                	mov    %esp,%ebp
 80493fe:	53                   	push   %ebx
  if (thread==NULL) {
 80493ff:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8049403:	75 07                	jne    804940c <pthread_create+0x11>
    return 1;
 8049405:	b8 01 00 00 00       	mov    $0x1,%eax
 804940a:	eb 17                	jmp    8049423 <pthread_create+0x28>
  }
  asm volatile("  \
 804940c:	8b 45 10             	mov    0x10(%ebp),%eax
 804940f:	8b 4d 08             	mov    0x8(%ebp),%ecx
 8049412:	8b 55 14             	mov    0x14(%ebp),%edx
 8049415:	89 c3                	mov    %eax,%ebx
 8049417:	b8 0e 00 00 00       	mov    $0xe,%eax
 804941c:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_NEW_THREAD) ", %%eax; \
    int $80; \
  "::"b"(start_routine),"c"(thread),"d"(arg));
  return 0;
 804941e:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049423:	5b                   	pop    %ebx
 8049424:	5d                   	pop    %ebp
 8049425:	c3                   	ret    

08049426 <pthread_exit>:

void pthread_exit(void *value_ptr) {
 8049426:	55                   	push   %ebp
 8049427:	89 e5                	mov    %esp,%ebp
  asm volatile("  \
 8049429:	b8 13 00 00 00       	mov    $0x13,%eax
 804942e:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_THREAD_EXIT) ", %eax; \
    int $80;");
}
 8049430:	90                   	nop
 8049431:	5d                   	pop    %ebp
 8049432:	c3                   	ret    

08049433 <pthread_spin_init>:

int pthread_spin_init(pthread_spinlock_t *lock, int pshared) {
 8049433:	55                   	push   %ebp
 8049434:	89 e5                	mov    %esp,%ebp
  *lock=0;
 8049436:	8b 45 08             	mov    0x8(%ebp),%eax
 8049439:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  return 0;
 804943f:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049444:	5d                   	pop    %ebp
 8049445:	c3                   	ret    

08049446 <pthread_spin_lock>:

int pthread_spin_lock(pthread_spinlock_t *lock) {
 8049446:	55                   	push   %ebp
 8049447:	89 e5                	mov    %esp,%ebp
 8049449:	83 ec 08             	sub    $0x8,%esp
  __pthread_spin_lock_helper(lock);
 804944c:	83 ec 0c             	sub    $0xc,%esp
 804944f:	ff 75 08             	push   0x8(%ebp)
 8049452:	e8 89 10 00 00       	call   804a4e0 <__pthread_spin_lock_helper>
 8049457:	83 c4 10             	add    $0x10,%esp
  return 0;
 804945a:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804945f:	c9                   	leave  
 8049460:	c3                   	ret    

08049461 <pthread_spin_unlock>:

int pthread_spin_unlock(pthread_spinlock_t *lock) {
 8049461:	55                   	push   %ebp
 8049462:	89 e5                	mov    %esp,%ebp
  *lock=0;
 8049464:	8b 45 08             	mov    0x8(%ebp),%eax
 8049467:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  return 0;
 804946d:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049472:	5d                   	pop    %ebp
 8049473:	c3                   	ret    

08049474 <pthread_spin_destroy>:

int pthread_spin_destroy(pthread_spinlock_t *lock) {
 8049474:	55                   	push   %ebp
 8049475:	89 e5                	mov    %esp,%ebp
  return 0;
 8049477:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804947c:	5d                   	pop    %ebp
 804947d:	c3                   	ret    

0804947e <rpc_call>:

#define QUAUX(X) #X
#define QU(X) QUAUX(X)


void* rpc_call(pid_t pid,char* name,void* buf,size_t size) {
 804947e:	55                   	push   %ebp
 804947f:	89 e5                	mov    %esp,%ebp
 8049481:	57                   	push   %edi
 8049482:	56                   	push   %esi
 8049483:	53                   	push   %ebx
 8049484:	83 ec 10             	sub    $0x10,%esp
  void* retbuf;
  asm volatile("  \
 8049487:	8b 45 08             	mov    0x8(%ebp),%eax
 804948a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804948d:	8b 55 10             	mov    0x10(%ebp),%edx
 8049490:	8b 75 14             	mov    0x14(%ebp),%esi
 8049493:	89 c3                	mov    %eax,%ebx
 8049495:	b8 0f 00 00 00       	mov    $0xf,%eax
 804949a:	cd 50                	int    $0x50
 804949c:	89 f8                	mov    %edi,%eax
 804949e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mov $" QU(SYSCALL_CALL_RPC) ", %%eax; \
    int $80; \
  ":"=D"(retbuf):"b"(pid),"c"(name),"d"(buf),"S"(size));
  return retbuf;
 80494a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80494a4:	83 c4 10             	add    $0x10,%esp
 80494a7:	5b                   	pop    %ebx
 80494a8:	5e                   	pop    %esi
 80494a9:	5f                   	pop    %edi
 80494aa:	5d                   	pop    %ebp
 80494ab:	c3                   	ret    

080494ac <rpc_register_func>:

void rpc_register_func(char* name,rpc_func code) {
 80494ac:	55                   	push   %ebp
 80494ad:	89 e5                	mov    %esp,%ebp
 80494af:	53                   	push   %ebx
  asm volatile("  \
 80494b0:	8b 45 08             	mov    0x8(%ebp),%eax
 80494b3:	8b 55 0c             	mov    0xc(%ebp),%edx
 80494b6:	89 c3                	mov    %eax,%ebx
 80494b8:	89 d1                	mov    %edx,%ecx
 80494ba:	b8 10 00 00 00       	mov    $0x10,%eax
 80494bf:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_REGISTER_RPC) ", %%eax; \
    int $80; \
  "::"b"(name),"c"(code));
}
 80494c1:	90                   	nop
 80494c2:	5b                   	pop    %ebx
 80494c3:	5d                   	pop    %ebp
 80494c4:	c3                   	ret    

080494c5 <rpc_deallocate_buf>:

void rpc_deallocate_buf(void* buf,size_t size) {
 80494c5:	55                   	push   %ebp
 80494c6:	89 e5                	mov    %esp,%ebp
 80494c8:	53                   	push   %ebx
  asm volatile("  \
 80494c9:	8b 45 08             	mov    0x8(%ebp),%eax
 80494cc:	8b 55 0c             	mov    0xc(%ebp),%edx
 80494cf:	89 c3                	mov    %eax,%ebx
 80494d1:	89 d1                	mov    %edx,%ecx
 80494d3:	b8 11 00 00 00       	mov    $0x11,%eax
 80494d8:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_DEALLOCTATE_RPC_RET) ", %%eax; \
    int $80; \
  "::"b"(buf),"c"(size));
}
 80494da:	90                   	nop
 80494db:	5b                   	pop    %ebx
 80494dc:	5d                   	pop    %ebp
 80494dd:	c3                   	ret    

080494de <rpc_return>:

void rpc_return(void* buf,size_t size) {
 80494de:	55                   	push   %ebp
 80494df:	89 e5                	mov    %esp,%ebp
 80494e1:	53                   	push   %ebx
  asm volatile("  \
 80494e2:	8b 45 08             	mov    0x8(%ebp),%eax
 80494e5:	8b 55 0c             	mov    0xc(%ebp),%edx
 80494e8:	89 c3                	mov    %eax,%ebx
 80494ea:	89 d1                	mov    %edx,%ecx
 80494ec:	b8 12 00 00 00       	mov    $0x12,%eax
 80494f1:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_RPC_RET) ", %%eax; \
    int $80; \
  "::"b"(buf),"c"(size));
}
 80494f3:	90                   	nop
 80494f4:	5b                   	pop    %ebx
 80494f5:	5d                   	pop    %ebp
 80494f6:	c3                   	ret    

080494f7 <rpc_mark_as_init>:

void rpc_mark_as_init() {
 80494f7:	55                   	push   %ebp
 80494f8:	89 e5                	mov    %esp,%ebp
  asm volatile("  \
 80494fa:	b8 15 00 00 00       	mov    $0x15,%eax
 80494ff:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_RPC_MARK_AS_INIT) ", %%eax; \
    int $80; \
  "::);
}
 8049501:	90                   	nop
 8049502:	5d                   	pop    %ebp
 8049503:	c3                   	ret    

08049504 <rpc_is_init>:
char rpc_is_init(pid_t pid) {
 8049504:	55                   	push   %ebp
 8049505:	89 e5                	mov    %esp,%ebp
 8049507:	53                   	push   %ebx
 8049508:	83 ec 10             	sub    $0x10,%esp
  char is_init;
  asm volatile("  \
 804950b:	8b 45 08             	mov    0x8(%ebp),%eax
 804950e:	89 c3                	mov    %eax,%ebx
 8049510:	b8 16 00 00 00       	mov    $0x16,%eax
 8049515:	cd 50                	int    $0x50
 8049517:	88 c8                	mov    %cl,%al
 8049519:	88 45 fb             	mov    %al,-0x5(%ebp)
    mov $" QU(SYSCALL_RPC_IS_INIT) ", %%eax; \
    int $80; \
  ":"=c"(is_init):"b"(pid));
  return is_init;
 804951c:	8a 45 fb             	mov    -0x5(%ebp),%al
}
 804951f:	83 c4 10             	add    $0x10,%esp
 8049522:	5b                   	pop    %ebx
 8049523:	5d                   	pop    %ebp
 8049524:	c3                   	ret    

08049525 <posix_spawn>:
#include <stdio.h>
#include <string.h>
#include <dbg.h>

int posix_spawn(pid_t* pid, const char* path, const posix_spawn_file_actions_t* file_actions, const posix_spawnattr_t* attrp,
char* const argv[], char* const envp[]) {
 8049525:	55                   	push   %ebp
 8049526:	89 e5                	mov    %esp,%ebp
 8049528:	83 ec 78             	sub    $0x78,%esp
  FILE* image=fopen((char*)path,"r");
 804952b:	83 ec 08             	sub    $0x8,%esp
 804952e:	68 64 a7 04 08       	push   $0x804a764
 8049533:	ff 75 0c             	push   0xc(%ebp)
 8049536:	e8 6a 01 00 00       	call   80496a5 <fopen>
 804953b:	83 c4 10             	add    $0x10,%esp
 804953e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  elf_header header;
  serial_print("Read magic number\n");
 8049541:	83 ec 0c             	sub    $0xc,%esp
 8049544:	68 66 a7 04 08       	push   $0x804a766
 8049549:	e8 12 f1 ff ff       	call   8048660 <serial_print>
 804954e:	83 c4 10             	add    $0x10,%esp
  fread(&header,sizeof(elf_header),1,image);
 8049551:	ff 75 f0             	push   -0x10(%ebp)
 8049554:	6a 01                	push   $0x1
 8049556:	6a 34                	push   $0x34
 8049558:	8d 45 b4             	lea    -0x4c(%ebp),%eax
 804955b:	50                   	push   %eax
 804955c:	e8 76 03 00 00       	call   80498d7 <fread>
 8049561:	83 c4 10             	add    $0x10,%esp
  if (header.magic!=ELF_MAGIC) {
 8049564:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8049567:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
 804956c:	74 4c                	je     80495ba <posix_spawn+0x95>
    serial_print("Bad magic number (");
 804956e:	83 ec 0c             	sub    $0xc,%esp
 8049571:	68 79 a7 04 08       	push   $0x804a779
 8049576:	e8 e5 f0 ff ff       	call   8048660 <serial_print>
 804957b:	83 c4 10             	add    $0x10,%esp
    char str[32];
    hex_to_ascii(header.magic,str);
 804957e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8049581:	83 ec 08             	sub    $0x8,%esp
 8049584:	8d 55 94             	lea    -0x6c(%ebp),%edx
 8049587:	52                   	push   %edx
 8049588:	50                   	push   %eax
 8049589:	e8 31 0c 00 00       	call   804a1bf <hex_to_ascii>
 804958e:	83 c4 10             	add    $0x10,%esp
    serial_print(str);
 8049591:	83 ec 0c             	sub    $0xc,%esp
 8049594:	8d 45 94             	lea    -0x6c(%ebp),%eax
 8049597:	50                   	push   %eax
 8049598:	e8 c3 f0 ff ff       	call   8048660 <serial_print>
 804959d:	83 c4 10             	add    $0x10,%esp
    serial_print(")\n");
 80495a0:	83 ec 0c             	sub    $0xc,%esp
 80495a3:	68 8c a7 04 08       	push   $0x804a78c
 80495a8:	e8 b3 f0 ff ff       	call   8048660 <serial_print>
 80495ad:	83 c4 10             	add    $0x10,%esp
    return 0;
 80495b0:	b8 00 00 00 00       	mov    $0x0,%eax
 80495b5:	e9 e3 00 00 00       	jmp    804969d <posix_spawn+0x178>
  } else {
    void* address_space=new_address_space();
 80495ba:	e8 ad fd ff ff       	call   804936c <new_address_space>
 80495bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for (int i=0;i<header.pheader_ent_nm;i++) {
 80495c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 80495c9:	e9 a8 00 00 00       	jmp    8049676 <posix_spawn+0x151>
      elf_pheader pheader;
      fseek(image,(header.prog_hdr)+(header.pheader_ent_sz*i),SEEK_SET);
 80495ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
 80495d1:	66 8b 45 de          	mov    -0x22(%ebp),%ax
 80495d5:	0f b7 c0             	movzwl %ax,%eax
 80495d8:	0f af 45 f4          	imul   -0xc(%ebp),%eax
 80495dc:	01 d0                	add    %edx,%eax
 80495de:	83 ec 04             	sub    $0x4,%esp
 80495e1:	6a 03                	push   $0x3
 80495e3:	50                   	push   %eax
 80495e4:	ff 75 f0             	push   -0x10(%ebp)
 80495e7:	e8 62 09 00 00       	call   8049f4e <fseek>
 80495ec:	83 c4 10             	add    $0x10,%esp
      fread(&pheader,sizeof(elf_pheader),1,image);
 80495ef:	ff 75 f0             	push   -0x10(%ebp)
 80495f2:	6a 01                	push   $0x1
 80495f4:	6a 20                	push   $0x20
 80495f6:	8d 45 94             	lea    -0x6c(%ebp),%eax
 80495f9:	50                   	push   %eax
 80495fa:	e8 d8 02 00 00       	call   80498d7 <fread>
 80495ff:	83 c4 10             	add    $0x10,%esp
      char* ptr=alloc_memory(((pheader.memsz)/4096)+1);
 8049602:	8b 45 a8             	mov    -0x58(%ebp),%eax
 8049605:	c1 e8 0c             	shr    $0xc,%eax
 8049608:	40                   	inc    %eax
 8049609:	83 ec 0c             	sub    $0xc,%esp
 804960c:	50                   	push   %eax
 804960d:	e8 19 fd ff ff       	call   804932b <alloc_memory>
 8049612:	83 c4 10             	add    $0x10,%esp
 8049615:	89 45 e8             	mov    %eax,-0x18(%ebp)
      memset(ptr,0,pheader.memsz);
 8049618:	8b 45 a8             	mov    -0x58(%ebp),%eax
 804961b:	83 ec 04             	sub    $0x4,%esp
 804961e:	50                   	push   %eax
 804961f:	6a 00                	push   $0x0
 8049621:	ff 75 e8             	push   -0x18(%ebp)
 8049624:	e8 aa 09 00 00       	call   8049fd3 <memset>
 8049629:	83 c4 10             	add    $0x10,%esp
      if (pheader.filesz>0) {
 804962c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804962f:	85 c0                	test   %eax,%eax
 8049631:	74 28                	je     804965b <posix_spawn+0x136>
        fseek(image,pheader.offset,SEEK_SET);
 8049633:	8b 45 98             	mov    -0x68(%ebp),%eax
 8049636:	83 ec 04             	sub    $0x4,%esp
 8049639:	6a 03                	push   $0x3
 804963b:	50                   	push   %eax
 804963c:	ff 75 f0             	push   -0x10(%ebp)
 804963f:	e8 0a 09 00 00       	call   8049f4e <fseek>
 8049644:	83 c4 10             	add    $0x10,%esp
        fread(ptr,sizeof(char),pheader.filesz,image);
 8049647:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804964a:	ff 75 f0             	push   -0x10(%ebp)
 804964d:	50                   	push   %eax
 804964e:	6a 01                	push   $0x1
 8049650:	ff 75 e8             	push   -0x18(%ebp)
 8049653:	e8 7f 02 00 00       	call   80498d7 <fread>
 8049658:	83 c4 10             	add    $0x10,%esp
      }
      copy_data(address_space,ptr,pheader.memsz,(void*)pheader.vaddr);
 804965b:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804965e:	89 c2                	mov    %eax,%edx
 8049660:	8b 45 a8             	mov    -0x58(%ebp),%eax
 8049663:	52                   	push   %edx
 8049664:	50                   	push   %eax
 8049665:	ff 75 e8             	push   -0x18(%ebp)
 8049668:	ff 75 ec             	push   -0x14(%ebp)
 804966b:	e8 18 fd ff ff       	call   8049388 <copy_data>
 8049670:	83 c4 10             	add    $0x10,%esp
    for (int i=0;i<header.pheader_ent_nm;i++) {
 8049673:	ff 45 f4             	incl   -0xc(%ebp)
 8049676:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049679:	0f b7 c0             	movzwl %ax,%eax
 804967c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 804967f:	0f 8c 49 ff ff ff    	jl     80495ce <posix_spawn+0xa9>
    }
    create_proc((void*)header.entry,address_space,NULL,NULL);
 8049685:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8049688:	6a 00                	push   $0x0
 804968a:	6a 00                	push   $0x0
 804968c:	ff 75 ec             	push   -0x14(%ebp)
 804968f:	50                   	push   %eax
 8049690:	e8 c1 0d 00 00       	call   804a456 <create_proc>
 8049695:	83 c4 10             	add    $0x10,%esp
  }
  return 1;
 8049698:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804969d:	c9                   	leave  
 804969e:	c3                   	ret    

0804969f <__stdio_init>:

/** 
 * Initialize stdio.
 * Must not be called by user code.
 */
void __stdio_init() {
 804969f:	55                   	push   %ebp
 80496a0:	89 e5                	mov    %esp,%ebp
}
 80496a2:	90                   	nop
 80496a3:	5d                   	pop    %ebp
 80496a4:	c3                   	ret    

080496a5 <fopen>:

FILE* fopen(char* filename,char* mode) {
 80496a5:	55                   	push   %ebp
 80496a6:	89 e5                	mov    %esp,%ebp
 80496a8:	83 ec 28             	sub    $0x28,%esp
  serdes_state state={0};
 80496ab:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 80496b2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  serialize_str(filename,&state);
 80496b9:	83 ec 0c             	sub    $0xc,%esp
 80496bc:	ff 75 08             	push   0x8(%ebp)
 80496bf:	e8 a0 09 00 00       	call   804a064 <strlen>
 80496c4:	83 c4 10             	add    $0x10,%esp
 80496c7:	40                   	inc    %eax
 80496c8:	89 c2                	mov    %eax,%edx
 80496ca:	83 ec 08             	sub    $0x8,%esp
 80496cd:	8d 45 dc             	lea    -0x24(%ebp),%eax
 80496d0:	50                   	push   %eax
 80496d1:	52                   	push   %edx
 80496d2:	e8 19 0e 00 00       	call   804a4f0 <serialize_int>
 80496d7:	83 c4 10             	add    $0x10,%esp
 80496da:	83 ec 0c             	sub    $0xc,%esp
 80496dd:	ff 75 08             	push   0x8(%ebp)
 80496e0:	e8 7f 09 00 00       	call   804a064 <strlen>
 80496e5:	83 c4 10             	add    $0x10,%esp
 80496e8:	8d 50 01             	lea    0x1(%eax),%edx
 80496eb:	83 ec 04             	sub    $0x4,%esp
 80496ee:	8d 45 dc             	lea    -0x24(%ebp),%eax
 80496f1:	50                   	push   %eax
 80496f2:	52                   	push   %edx
 80496f3:	ff 75 08             	push   0x8(%ebp)
 80496f6:	e8 89 0e 00 00       	call   804a584 <serialize_ary>
 80496fb:	83 c4 10             	add    $0x10,%esp
  void* retval=rpc_call(2,"open",state.buf,state.sizeorpos);
 80496fe:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8049701:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8049704:	52                   	push   %edx
 8049705:	50                   	push   %eax
 8049706:	68 8f a7 04 08       	push   $0x804a78f
 804970b:	6a 02                	push   $0x2
 804970d:	e8 6c fd ff ff       	call   804947e <rpc_call>
 8049712:	83 c4 10             	add    $0x10,%esp
 8049715:	89 45 f4             	mov    %eax,-0xc(%ebp)
  free(state.buf);
 8049718:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804971b:	83 ec 0c             	sub    $0xc,%esp
 804971e:	50                   	push   %eax
 804971f:	e8 cd f7 ff ff       	call   8048ef1 <free>
 8049724:	83 c4 10             	add    $0x10,%esp
  start_deserialize(retval,&state);
 8049727:	83 ec 08             	sub    $0x8,%esp
 804972a:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804972d:	50                   	push   %eax
 804972e:	ff 75 f4             	push   -0xc(%ebp)
 8049731:	e8 a9 0e 00 00       	call   804a5df <start_deserialize>
 8049736:	83 c4 10             	add    $0x10,%esp
  int err=deserialize_int(&state);
 8049739:	83 ec 0c             	sub    $0xc,%esp
 804973c:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804973f:	50                   	push   %eax
 8049740:	e8 b2 0e 00 00       	call   804a5f7 <deserialize_int>
 8049745:	83 c4 10             	add    $0x10,%esp
 8049748:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void* fs_data=deserialize_ptr(&state);
 804974b:	83 ec 0c             	sub    $0xc,%esp
 804974e:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8049751:	50                   	push   %eax
 8049752:	e8 cc 0e 00 00       	call   804a623 <deserialize_ptr>
 8049757:	83 c4 10             	add    $0x10,%esp
 804975a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pid_t fs_pid=deserialize_int(&state);
 804975d:	83 ec 0c             	sub    $0xc,%esp
 8049760:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8049763:	50                   	push   %eax
 8049764:	e8 8e 0e 00 00       	call   804a5f7 <deserialize_int>
 8049769:	83 c4 10             	add    $0x10,%esp
 804976c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  rpc_deallocate_buf(retval,state.sizeorpos);
 804976f:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8049772:	83 ec 08             	sub    $0x8,%esp
 8049775:	50                   	push   %eax
 8049776:	ff 75 f4             	push   -0xc(%ebp)
 8049779:	e8 47 fd ff ff       	call   80494c5 <rpc_deallocate_buf>
 804977e:	83 c4 10             	add    $0x10,%esp
  if (err) {
 8049781:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 8049785:	74 07                	je     804978e <fopen+0xe9>
    return NULL;
 8049787:	b8 00 00 00 00       	mov    $0x0,%eax
 804978c:	eb 2e                	jmp    80497bc <fopen+0x117>
  } else {
    FILE* file=malloc(sizeof(FILE));
 804978e:	83 ec 0c             	sub    $0xc,%esp
 8049791:	6a 0c                	push   $0xc
 8049793:	e8 cd f0 ff ff       	call   8048865 <malloc>
 8049798:	83 c4 10             	add    $0x10,%esp
 804979b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    file->fs_pid=fs_pid;
 804979e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80497a1:	8b 55 e8             	mov    -0x18(%ebp),%edx
 80497a4:	89 10                	mov    %edx,(%eax)
    file->fs_data=fs_data;
 80497a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80497a9:	8b 55 ec             	mov    -0x14(%ebp),%edx
 80497ac:	89 50 04             	mov    %edx,0x4(%eax)
    file->pos=0;
 80497af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80497b2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return file;
 80497b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  }
}
 80497bc:	c9                   	leave  
 80497bd:	c3                   	ret    

080497be <fputc>:
 * \param stream The stream to write to
 * \returns the written character, or EOF on failure
 */
int putc(int c, FILE* stream) __attribute__ ((alias ("fputc")));

int fputc(int c, FILE* stream) {
 80497be:	55                   	push   %ebp
 80497bf:	89 e5                	mov    %esp,%ebp
 80497c1:	83 ec 18             	sub    $0x18,%esp
  char str[]={c,'\0'};
 80497c4:	8b 45 08             	mov    0x8(%ebp),%eax
 80497c7:	88 45 f6             	mov    %al,-0xa(%ebp)
 80497ca:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (fputs(str,stream)==0) {
 80497ce:	83 ec 08             	sub    $0x8,%esp
 80497d1:	ff 75 0c             	push   0xc(%ebp)
 80497d4:	8d 45 f6             	lea    -0xa(%ebp),%eax
 80497d7:	50                   	push   %eax
 80497d8:	e8 9f 02 00 00       	call   8049a7c <fputs>
 80497dd:	83 c4 10             	add    $0x10,%esp
 80497e0:	85 c0                	test   %eax,%eax
 80497e2:	75 07                	jne    80497eb <fputc+0x2d>
    return EOF;
 80497e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80497e9:	eb 03                	jmp    80497ee <fputc+0x30>
  } else {
    return c;
 80497eb:	8b 45 08             	mov    0x8(%ebp),%eax
  }
  return EOF;
}
 80497ee:	c9                   	leave  
 80497ef:	c3                   	ret    

080497f0 <fgetc>:
 * \param stream The file to read from
 * \returns the read character, or EOF if the read fails
 */
int getc(FILE* stream) __attribute__ ((alias ("fgetc"))); 

int fgetc(FILE* stream) {
 80497f0:	55                   	push   %ebp
 80497f1:	89 e5                	mov    %esp,%ebp
 80497f3:	83 ec 18             	sub    $0x18,%esp
  char c[2];
  if (fgets(&c[0],1,stream)==NULL) {
 80497f6:	83 ec 04             	sub    $0x4,%esp
 80497f9:	ff 75 08             	push   0x8(%ebp)
 80497fc:	6a 01                	push   $0x1
 80497fe:	8d 45 f6             	lea    -0xa(%ebp),%eax
 8049801:	50                   	push   %eax
 8049802:	e8 37 00 00 00       	call   804983e <fgets>
 8049807:	83 c4 10             	add    $0x10,%esp
 804980a:	85 c0                	test   %eax,%eax
 804980c:	75 07                	jne    8049815 <fgetc+0x25>
    return EOF;
 804980e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8049813:	eb 06                	jmp    804981b <fgetc+0x2b>
  } else {
    return c[0];
 8049815:	8a 45 f6             	mov    -0xa(%ebp),%al
 8049818:	0f be c0             	movsbl %al,%eax
  }
  return EOF;
}
 804981b:	c9                   	leave  
 804981c:	c3                   	ret    

0804981d <gets>:

char* gets(char* s) {
 804981d:	55                   	push   %ebp
 804981e:	89 e5                	mov    %esp,%ebp
 8049820:	83 ec 08             	sub    $0x8,%esp
  return fgets(s,INT_MAX,stdin);
 8049823:	a1 10 c3 04 08       	mov    0x804c310,%eax
 8049828:	83 ec 04             	sub    $0x4,%esp
 804982b:	50                   	push   %eax
 804982c:	68 ff ff ff 7f       	push   $0x7fffffff
 8049831:	ff 75 08             	push   0x8(%ebp)
 8049834:	e8 05 00 00 00       	call   804983e <fgets>
 8049839:	83 c4 10             	add    $0x10,%esp
}
 804983c:	c9                   	leave  
 804983d:	c3                   	ret    

0804983e <fgets>:

char* fgets(char* str,int count,FILE* stream) {
 804983e:	55                   	push   %ebp
 804983f:	89 e5                	mov    %esp,%ebp
 8049841:	83 ec 18             	sub    $0x18,%esp
  count=fread(str,1,count-1,stream)+1;
 8049844:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049847:	48                   	dec    %eax
 8049848:	ff 75 10             	push   0x10(%ebp)
 804984b:	50                   	push   %eax
 804984c:	6a 01                	push   $0x1
 804984e:	ff 75 08             	push   0x8(%ebp)
 8049851:	e8 81 00 00 00       	call   80498d7 <fread>
 8049856:	83 c4 10             	add    $0x10,%esp
 8049859:	40                   	inc    %eax
 804985a:	89 45 0c             	mov    %eax,0xc(%ebp)
  if (count==0) {
 804985d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 8049861:	75 07                	jne    804986a <fgets+0x2c>
    return NULL;
 8049863:	b8 00 00 00 00       	mov    $0x0,%eax
 8049868:	eb 6b                	jmp    80498d5 <fgets+0x97>
  }
  str[count]='\0';
 804986a:	8b 55 0c             	mov    0xc(%ebp),%edx
 804986d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049870:	01 d0                	add    %edx,%eax
 8049872:	c6 00 00             	movb   $0x0,(%eax)
  int newlinepos=-1;
 8049875:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
  for (int i=0;i<(count-1);i++) {
 804987c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 8049883:	eb 19                	jmp    804989e <fgets+0x60>
    if (str[i]=='\n') {
 8049885:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049888:	8b 45 08             	mov    0x8(%ebp),%eax
 804988b:	01 d0                	add    %edx,%eax
 804988d:	8a 00                	mov    (%eax),%al
 804988f:	3c 0a                	cmp    $0xa,%al
 8049891:	75 08                	jne    804989b <fgets+0x5d>
      newlinepos=i;
 8049893:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049896:	89 45 f4             	mov    %eax,-0xc(%ebp)
      break;
 8049899:	eb 0c                	jmp    80498a7 <fgets+0x69>
  for (int i=0;i<(count-1);i++) {
 804989b:	ff 45 f0             	incl   -0x10(%ebp)
 804989e:	8b 45 0c             	mov    0xc(%ebp),%eax
 80498a1:	48                   	dec    %eax
 80498a2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
 80498a5:	7c de                	jl     8049885 <fgets+0x47>
    }
  }
  if (newlinepos) {
 80498a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 80498ab:	74 25                	je     80498d2 <fgets+0x94>
    stream->pos-=(count-1);
 80498ad:	8b 45 10             	mov    0x10(%ebp),%eax
 80498b0:	8b 40 08             	mov    0x8(%eax),%eax
 80498b3:	8b 55 0c             	mov    0xc(%ebp),%edx
 80498b6:	4a                   	dec    %edx
 80498b7:	29 d0                	sub    %edx,%eax
 80498b9:	89 c2                	mov    %eax,%edx
 80498bb:	8b 45 10             	mov    0x10(%ebp),%eax
 80498be:	89 50 08             	mov    %edx,0x8(%eax)
    stream->pos+=newlinepos;
 80498c1:	8b 45 10             	mov    0x10(%ebp),%eax
 80498c4:	8b 50 08             	mov    0x8(%eax),%edx
 80498c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80498ca:	01 c2                	add    %eax,%edx
 80498cc:	8b 45 10             	mov    0x10(%ebp),%eax
 80498cf:	89 50 08             	mov    %edx,0x8(%eax)
  }
  return str;
 80498d2:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80498d5:	c9                   	leave  
 80498d6:	c3                   	ret    

080498d7 <fread>:

size_t fread(void* buffer_ptr,size_t size,size_t count,FILE* stream) {
 80498d7:	55                   	push   %ebp
 80498d8:	89 e5                	mov    %esp,%ebp
 80498da:	83 ec 28             	sub    $0x28,%esp
  serdes_state state={0};
 80498dd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 80498e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  serialize_ptr(stream->fs_data,&state);
 80498eb:	8b 45 14             	mov    0x14(%ebp),%eax
 80498ee:	8b 40 04             	mov    0x4(%eax),%eax
 80498f1:	83 ec 08             	sub    $0x8,%esp
 80498f4:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 80498f7:	52                   	push   %edx
 80498f8:	50                   	push   %eax
 80498f9:	e8 3c 0c 00 00       	call   804a53a <serialize_ptr>
 80498fe:	83 c4 10             	add    $0x10,%esp
  serialize_int(size*count,&state);
 8049901:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049904:	0f af 45 10          	imul   0x10(%ebp),%eax
 8049908:	89 c2                	mov    %eax,%edx
 804990a:	83 ec 08             	sub    $0x8,%esp
 804990d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049910:	50                   	push   %eax
 8049911:	52                   	push   %edx
 8049912:	e8 d9 0b 00 00       	call   804a4f0 <serialize_int>
 8049917:	83 c4 10             	add    $0x10,%esp
  serialize_int(stream->pos,&state);
 804991a:	8b 45 14             	mov    0x14(%ebp),%eax
 804991d:	8b 40 08             	mov    0x8(%eax),%eax
 8049920:	83 ec 08             	sub    $0x8,%esp
 8049923:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 8049926:	52                   	push   %edx
 8049927:	50                   	push   %eax
 8049928:	e8 c3 0b 00 00       	call   804a4f0 <serialize_int>
 804992d:	83 c4 10             	add    $0x10,%esp
  void* retbuf=rpc_call(stream->fs_pid,"read",state.buf,state.sizeorpos);
 8049930:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 8049933:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049936:	8b 45 14             	mov    0x14(%ebp),%eax
 8049939:	8b 00                	mov    (%eax),%eax
 804993b:	51                   	push   %ecx
 804993c:	52                   	push   %edx
 804993d:	68 94 a7 04 08       	push   $0x804a794
 8049942:	50                   	push   %eax
 8049943:	e8 36 fb ff ff       	call   804947e <rpc_call>
 8049948:	83 c4 10             	add    $0x10,%esp
 804994b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  free(state.buf);
 804994e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049951:	83 ec 0c             	sub    $0xc,%esp
 8049954:	50                   	push   %eax
 8049955:	e8 97 f5 ff ff       	call   8048ef1 <free>
 804995a:	83 c4 10             	add    $0x10,%esp
  state.buf=NULL;
 804995d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  state.sizeorpos=0;
 8049964:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  start_deserialize(retbuf,&state);
 804996b:	83 ec 08             	sub    $0x8,%esp
 804996e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049971:	50                   	push   %eax
 8049972:	ff 75 f4             	push   -0xc(%ebp)
 8049975:	e8 65 0c 00 00       	call   804a5df <start_deserialize>
 804997a:	83 c4 10             	add    $0x10,%esp
  int bytes_read=deserialize_int(&state);
 804997d:	83 ec 0c             	sub    $0xc,%esp
 8049980:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049983:	50                   	push   %eax
 8049984:	e8 6e 0c 00 00       	call   804a5f7 <deserialize_int>
 8049989:	83 c4 10             	add    $0x10,%esp
 804998c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (bytes_read) {
 804998f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 8049993:	74 2f                	je     80499c4 <fread+0xed>
    void* ary=deserialize_ary(bytes_read,&state);
 8049995:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049998:	83 ec 08             	sub    $0x8,%esp
 804999b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 804999e:	52                   	push   %edx
 804999f:	50                   	push   %eax
 80499a0:	e8 aa 0c 00 00       	call   804a64f <deserialize_ary>
 80499a5:	83 c4 10             	add    $0x10,%esp
 80499a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    memcpy(buffer_ptr,ary,size*count);
 80499ab:	8b 45 0c             	mov    0xc(%ebp),%eax
 80499ae:	0f af 45 10          	imul   0x10(%ebp),%eax
 80499b2:	83 ec 04             	sub    $0x4,%esp
 80499b5:	50                   	push   %eax
 80499b6:	ff 75 ec             	push   -0x14(%ebp)
 80499b9:	ff 75 08             	push   0x8(%ebp)
 80499bc:	e8 d3 05 00 00       	call   8049f94 <memcpy>
 80499c1:	83 c4 10             	add    $0x10,%esp
  }
  rpc_deallocate_buf(retbuf,state.sizeorpos);
 80499c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80499c7:	83 ec 08             	sub    $0x8,%esp
 80499ca:	50                   	push   %eax
 80499cb:	ff 75 f4             	push   -0xc(%ebp)
 80499ce:	e8 f2 fa ff ff       	call   80494c5 <rpc_deallocate_buf>
 80499d3:	83 c4 10             	add    $0x10,%esp
  stream->pos+=bytes_read;
 80499d6:	8b 45 14             	mov    0x14(%ebp),%eax
 80499d9:	8b 50 08             	mov    0x8(%eax),%edx
 80499dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80499df:	01 c2                	add    %eax,%edx
 80499e1:	8b 45 14             	mov    0x14(%ebp),%eax
 80499e4:	89 50 08             	mov    %edx,0x8(%eax)
  return bytes_read;
 80499e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80499ea:	c9                   	leave  
 80499eb:	c3                   	ret    

080499ec <puts>:

int puts(const char *s) {
 80499ec:	55                   	push   %ebp
 80499ed:	89 e5                	mov    %esp,%ebp
 80499ef:	83 ec 18             	sub    $0x18,%esp
  char* str=malloc(sizeof(char)*(strlen(s)+2));
 80499f2:	83 ec 0c             	sub    $0xc,%esp
 80499f5:	ff 75 08             	push   0x8(%ebp)
 80499f8:	e8 67 06 00 00       	call   804a064 <strlen>
 80499fd:	83 c4 10             	add    $0x10,%esp
 8049a00:	83 c0 02             	add    $0x2,%eax
 8049a03:	83 ec 0c             	sub    $0xc,%esp
 8049a06:	50                   	push   %eax
 8049a07:	e8 59 ee ff ff       	call   8048865 <malloc>
 8049a0c:	83 c4 10             	add    $0x10,%esp
 8049a0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  strcpy(str,s);
 8049a12:	83 ec 08             	sub    $0x8,%esp
 8049a15:	ff 75 08             	push   0x8(%ebp)
 8049a18:	ff 75 f4             	push   -0xc(%ebp)
 8049a1b:	e8 69 06 00 00       	call   804a089 <strcpy>
 8049a20:	83 c4 10             	add    $0x10,%esp
  str[strlen(s)]='\n';
 8049a23:	83 ec 0c             	sub    $0xc,%esp
 8049a26:	ff 75 08             	push   0x8(%ebp)
 8049a29:	e8 36 06 00 00       	call   804a064 <strlen>
 8049a2e:	83 c4 10             	add    $0x10,%esp
 8049a31:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049a34:	01 d0                	add    %edx,%eax
 8049a36:	c6 00 0a             	movb   $0xa,(%eax)
  str[strlen(s)+1]='\0';
 8049a39:	83 ec 0c             	sub    $0xc,%esp
 8049a3c:	ff 75 08             	push   0x8(%ebp)
 8049a3f:	e8 20 06 00 00       	call   804a064 <strlen>
 8049a44:	83 c4 10             	add    $0x10,%esp
 8049a47:	8d 50 01             	lea    0x1(%eax),%edx
 8049a4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049a4d:	01 d0                	add    %edx,%eax
 8049a4f:	c6 00 00             	movb   $0x0,(%eax)
  int code=fputs(str,stdout);
 8049a52:	a1 14 c3 04 08       	mov    0x804c314,%eax
 8049a57:	83 ec 08             	sub    $0x8,%esp
 8049a5a:	50                   	push   %eax
 8049a5b:	ff 75 f4             	push   -0xc(%ebp)
 8049a5e:	e8 19 00 00 00       	call   8049a7c <fputs>
 8049a63:	83 c4 10             	add    $0x10,%esp
 8049a66:	89 45 f0             	mov    %eax,-0x10(%ebp)
  free(str);
 8049a69:	83 ec 0c             	sub    $0xc,%esp
 8049a6c:	ff 75 f4             	push   -0xc(%ebp)
 8049a6f:	e8 7d f4 ff ff       	call   8048ef1 <free>
 8049a74:	83 c4 10             	add    $0x10,%esp
  return code;
 8049a77:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049a7a:	c9                   	leave  
 8049a7b:	c3                   	ret    

08049a7c <fputs>:

int fputs(const char* s, FILE* stream) {
 8049a7c:	55                   	push   %ebp
 8049a7d:	89 e5                	mov    %esp,%ebp
 8049a7f:	83 ec 18             	sub    $0x18,%esp
  size_t retval=fwrite((void*)s,strlen(s),1,stream);
 8049a82:	83 ec 0c             	sub    $0xc,%esp
 8049a85:	ff 75 08             	push   0x8(%ebp)
 8049a88:	e8 d7 05 00 00       	call   804a064 <strlen>
 8049a8d:	83 c4 10             	add    $0x10,%esp
 8049a90:	ff 75 0c             	push   0xc(%ebp)
 8049a93:	6a 01                	push   $0x1
 8049a95:	50                   	push   %eax
 8049a96:	ff 75 08             	push   0x8(%ebp)
 8049a99:	e8 1a 00 00 00       	call   8049ab8 <fwrite>
 8049a9e:	83 c4 10             	add    $0x10,%esp
 8049aa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (retval==0) {
 8049aa4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049aa8:	75 07                	jne    8049ab1 <fputs+0x35>
    return EOF;
 8049aaa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8049aaf:	eb 05                	jmp    8049ab6 <fputs+0x3a>
  } else {
    return 0;
 8049ab1:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
 8049ab6:	c9                   	leave  
 8049ab7:	c3                   	ret    

08049ab8 <fwrite>:

size_t fwrite(void* buffer_ptr,size_t size,size_t count,FILE* stream) {
 8049ab8:	55                   	push   %ebp
 8049ab9:	89 e5                	mov    %esp,%ebp
 8049abb:	83 ec 18             	sub    $0x18,%esp
  /* serial_print(buffer_ptr); */
  /* return size*count; */
  serdes_state state={0};
 8049abe:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 8049ac5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  serialize_ptr(stream->fs_data,&state);
 8049acc:	8b 45 14             	mov    0x14(%ebp),%eax
 8049acf:	8b 40 04             	mov    0x4(%eax),%eax
 8049ad2:	83 ec 08             	sub    $0x8,%esp
 8049ad5:	8d 55 e8             	lea    -0x18(%ebp),%edx
 8049ad8:	52                   	push   %edx
 8049ad9:	50                   	push   %eax
 8049ada:	e8 5b 0a 00 00       	call   804a53a <serialize_ptr>
 8049adf:	83 c4 10             	add    $0x10,%esp
  serialize_int(size*count,&state);
 8049ae2:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049ae5:	0f af 45 10          	imul   0x10(%ebp),%eax
 8049ae9:	89 c2                	mov    %eax,%edx
 8049aeb:	83 ec 08             	sub    $0x8,%esp
 8049aee:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8049af1:	50                   	push   %eax
 8049af2:	52                   	push   %edx
 8049af3:	e8 f8 09 00 00       	call   804a4f0 <serialize_int>
 8049af8:	83 c4 10             	add    $0x10,%esp
  serialize_int(stream->pos,&state);
 8049afb:	8b 45 14             	mov    0x14(%ebp),%eax
 8049afe:	8b 40 08             	mov    0x8(%eax),%eax
 8049b01:	83 ec 08             	sub    $0x8,%esp
 8049b04:	8d 55 e8             	lea    -0x18(%ebp),%edx
 8049b07:	52                   	push   %edx
 8049b08:	50                   	push   %eax
 8049b09:	e8 e2 09 00 00       	call   804a4f0 <serialize_int>
 8049b0e:	83 c4 10             	add    $0x10,%esp
  serialize_ary(buffer_ptr,size*count,&state);
 8049b11:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049b14:	0f af 45 10          	imul   0x10(%ebp),%eax
 8049b18:	83 ec 04             	sub    $0x4,%esp
 8049b1b:	8d 55 e8             	lea    -0x18(%ebp),%edx
 8049b1e:	52                   	push   %edx
 8049b1f:	50                   	push   %eax
 8049b20:	ff 75 08             	push   0x8(%ebp)
 8049b23:	e8 5c 0a 00 00       	call   804a584 <serialize_ary>
 8049b28:	83 c4 10             	add    $0x10,%esp
  void* retbuf=rpc_call(stream->fs_pid,"write",state.buf,state.sizeorpos);
 8049b2b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
 8049b2e:	8b 55 e8             	mov    -0x18(%ebp),%edx
 8049b31:	8b 45 14             	mov    0x14(%ebp),%eax
 8049b34:	8b 00                	mov    (%eax),%eax
 8049b36:	51                   	push   %ecx
 8049b37:	52                   	push   %edx
 8049b38:	68 99 a7 04 08       	push   $0x804a799
 8049b3d:	50                   	push   %eax
 8049b3e:	e8 3b f9 ff ff       	call   804947e <rpc_call>
 8049b43:	83 c4 10             	add    $0x10,%esp
 8049b46:	89 45 f4             	mov    %eax,-0xc(%ebp)
  free(state.buf);
 8049b49:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049b4c:	83 ec 0c             	sub    $0xc,%esp
 8049b4f:	50                   	push   %eax
 8049b50:	e8 9c f3 ff ff       	call   8048ef1 <free>
 8049b55:	83 c4 10             	add    $0x10,%esp
  start_deserialize(retbuf,&state);
 8049b58:	83 ec 08             	sub    $0x8,%esp
 8049b5b:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8049b5e:	50                   	push   %eax
 8049b5f:	ff 75 f4             	push   -0xc(%ebp)
 8049b62:	e8 78 0a 00 00       	call   804a5df <start_deserialize>
 8049b67:	83 c4 10             	add    $0x10,%esp
  int bytes_wrote=deserialize_int(&state);
 8049b6a:	83 ec 0c             	sub    $0xc,%esp
 8049b6d:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8049b70:	50                   	push   %eax
 8049b71:	e8 81 0a 00 00       	call   804a5f7 <deserialize_int>
 8049b76:	83 c4 10             	add    $0x10,%esp
 8049b79:	89 45 f0             	mov    %eax,-0x10(%ebp)
  rpc_deallocate_buf(retbuf,state.sizeorpos);
 8049b7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049b7f:	83 ec 08             	sub    $0x8,%esp
 8049b82:	50                   	push   %eax
 8049b83:	ff 75 f4             	push   -0xc(%ebp)
 8049b86:	e8 3a f9 ff ff       	call   80494c5 <rpc_deallocate_buf>
 8049b8b:	83 c4 10             	add    $0x10,%esp
  stream->pos+=bytes_wrote;
 8049b8e:	8b 45 14             	mov    0x14(%ebp),%eax
 8049b91:	8b 50 08             	mov    0x8(%eax),%edx
 8049b94:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049b97:	01 c2                	add    %eax,%edx
 8049b99:	8b 45 14             	mov    0x14(%ebp),%eax
 8049b9c:	89 50 08             	mov    %edx,0x8(%eax)
  return bytes_wrote;
 8049b9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 8049ba2:	c9                   	leave  
 8049ba3:	c3                   	ret    

08049ba4 <register_fs>:

void register_fs(const char* name,pid_t pid) {
 8049ba4:	55                   	push   %ebp
 8049ba5:	89 e5                	mov    %esp,%ebp
 8049ba7:	83 ec 18             	sub    $0x18,%esp
  serdes_state state={0};
 8049baa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 8049bb1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  serialize_str((char*)name,&state);
 8049bb8:	83 ec 0c             	sub    $0xc,%esp
 8049bbb:	ff 75 08             	push   0x8(%ebp)
 8049bbe:	e8 a1 04 00 00       	call   804a064 <strlen>
 8049bc3:	83 c4 10             	add    $0x10,%esp
 8049bc6:	40                   	inc    %eax
 8049bc7:	89 c2                	mov    %eax,%edx
 8049bc9:	83 ec 08             	sub    $0x8,%esp
 8049bcc:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8049bcf:	50                   	push   %eax
 8049bd0:	52                   	push   %edx
 8049bd1:	e8 1a 09 00 00       	call   804a4f0 <serialize_int>
 8049bd6:	83 c4 10             	add    $0x10,%esp
 8049bd9:	83 ec 0c             	sub    $0xc,%esp
 8049bdc:	ff 75 08             	push   0x8(%ebp)
 8049bdf:	e8 80 04 00 00       	call   804a064 <strlen>
 8049be4:	83 c4 10             	add    $0x10,%esp
 8049be7:	8d 50 01             	lea    0x1(%eax),%edx
 8049bea:	83 ec 04             	sub    $0x4,%esp
 8049bed:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8049bf0:	50                   	push   %eax
 8049bf1:	52                   	push   %edx
 8049bf2:	ff 75 08             	push   0x8(%ebp)
 8049bf5:	e8 8a 09 00 00       	call   804a584 <serialize_ary>
 8049bfa:	83 c4 10             	add    $0x10,%esp
  serialize_int(pid,&state);
 8049bfd:	83 ec 08             	sub    $0x8,%esp
 8049c00:	8d 45 f0             	lea    -0x10(%ebp),%eax
 8049c03:	50                   	push   %eax
 8049c04:	ff 75 0c             	push   0xc(%ebp)
 8049c07:	e8 e4 08 00 00       	call   804a4f0 <serialize_int>
 8049c0c:	83 c4 10             	add    $0x10,%esp
  rpc_call(2,"register_fs",state.buf,state.sizeorpos);
 8049c0f:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049c12:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049c15:	52                   	push   %edx
 8049c16:	50                   	push   %eax
 8049c17:	68 9f a7 04 08       	push   $0x804a79f
 8049c1c:	6a 02                	push   $0x2
 8049c1e:	e8 5b f8 ff ff       	call   804947e <rpc_call>
 8049c23:	83 c4 10             	add    $0x10,%esp
}
 8049c26:	90                   	nop
 8049c27:	c9                   	leave  
 8049c28:	c3                   	ret    

08049c29 <mount>:

int mount(char* file,char* type,char* path) {
 8049c29:	55                   	push   %ebp
 8049c2a:	89 e5                	mov    %esp,%ebp
 8049c2c:	83 ec 18             	sub    $0x18,%esp
  serdes_state state={0};
 8049c2f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 8049c36:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  serialize_str(type,&state);
 8049c3d:	83 ec 0c             	sub    $0xc,%esp
 8049c40:	ff 75 0c             	push   0xc(%ebp)
 8049c43:	e8 1c 04 00 00       	call   804a064 <strlen>
 8049c48:	83 c4 10             	add    $0x10,%esp
 8049c4b:	40                   	inc    %eax
 8049c4c:	89 c2                	mov    %eax,%edx
 8049c4e:	83 ec 08             	sub    $0x8,%esp
 8049c51:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8049c54:	50                   	push   %eax
 8049c55:	52                   	push   %edx
 8049c56:	e8 95 08 00 00       	call   804a4f0 <serialize_int>
 8049c5b:	83 c4 10             	add    $0x10,%esp
 8049c5e:	83 ec 0c             	sub    $0xc,%esp
 8049c61:	ff 75 0c             	push   0xc(%ebp)
 8049c64:	e8 fb 03 00 00       	call   804a064 <strlen>
 8049c69:	83 c4 10             	add    $0x10,%esp
 8049c6c:	8d 50 01             	lea    0x1(%eax),%edx
 8049c6f:	83 ec 04             	sub    $0x4,%esp
 8049c72:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8049c75:	50                   	push   %eax
 8049c76:	52                   	push   %edx
 8049c77:	ff 75 0c             	push   0xc(%ebp)
 8049c7a:	e8 05 09 00 00       	call   804a584 <serialize_ary>
 8049c7f:	83 c4 10             	add    $0x10,%esp
  serialize_str(file,&state);
 8049c82:	83 ec 0c             	sub    $0xc,%esp
 8049c85:	ff 75 08             	push   0x8(%ebp)
 8049c88:	e8 d7 03 00 00       	call   804a064 <strlen>
 8049c8d:	83 c4 10             	add    $0x10,%esp
 8049c90:	40                   	inc    %eax
 8049c91:	89 c2                	mov    %eax,%edx
 8049c93:	83 ec 08             	sub    $0x8,%esp
 8049c96:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8049c99:	50                   	push   %eax
 8049c9a:	52                   	push   %edx
 8049c9b:	e8 50 08 00 00       	call   804a4f0 <serialize_int>
 8049ca0:	83 c4 10             	add    $0x10,%esp
 8049ca3:	83 ec 0c             	sub    $0xc,%esp
 8049ca6:	ff 75 08             	push   0x8(%ebp)
 8049ca9:	e8 b6 03 00 00       	call   804a064 <strlen>
 8049cae:	83 c4 10             	add    $0x10,%esp
 8049cb1:	8d 50 01             	lea    0x1(%eax),%edx
 8049cb4:	83 ec 04             	sub    $0x4,%esp
 8049cb7:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8049cba:	50                   	push   %eax
 8049cbb:	52                   	push   %edx
 8049cbc:	ff 75 08             	push   0x8(%ebp)
 8049cbf:	e8 c0 08 00 00       	call   804a584 <serialize_ary>
 8049cc4:	83 c4 10             	add    $0x10,%esp
  serialize_str(path,&state);
 8049cc7:	83 ec 0c             	sub    $0xc,%esp
 8049cca:	ff 75 10             	push   0x10(%ebp)
 8049ccd:	e8 92 03 00 00       	call   804a064 <strlen>
 8049cd2:	83 c4 10             	add    $0x10,%esp
 8049cd5:	40                   	inc    %eax
 8049cd6:	89 c2                	mov    %eax,%edx
 8049cd8:	83 ec 08             	sub    $0x8,%esp
 8049cdb:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8049cde:	50                   	push   %eax
 8049cdf:	52                   	push   %edx
 8049ce0:	e8 0b 08 00 00       	call   804a4f0 <serialize_int>
 8049ce5:	83 c4 10             	add    $0x10,%esp
 8049ce8:	83 ec 0c             	sub    $0xc,%esp
 8049ceb:	ff 75 10             	push   0x10(%ebp)
 8049cee:	e8 71 03 00 00       	call   804a064 <strlen>
 8049cf3:	83 c4 10             	add    $0x10,%esp
 8049cf6:	8d 50 01             	lea    0x1(%eax),%edx
 8049cf9:	83 ec 04             	sub    $0x4,%esp
 8049cfc:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8049cff:	50                   	push   %eax
 8049d00:	52                   	push   %edx
 8049d01:	ff 75 10             	push   0x10(%ebp)
 8049d04:	e8 7b 08 00 00       	call   804a584 <serialize_ary>
 8049d09:	83 c4 10             	add    $0x10,%esp
  int* err=rpc_call(2,"mount",state.buf,state.sizeorpos);
 8049d0c:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049d0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049d12:	52                   	push   %edx
 8049d13:	50                   	push   %eax
 8049d14:	68 ab a7 04 08       	push   $0x804a7ab
 8049d19:	6a 02                	push   $0x2
 8049d1b:	e8 5e f7 ff ff       	call   804947e <rpc_call>
 8049d20:	83 c4 10             	add    $0x10,%esp
 8049d23:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return *err;
 8049d26:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049d29:	8b 00                	mov    (%eax),%eax
}
 8049d2b:	c9                   	leave  
 8049d2c:	c3                   	ret    

08049d2d <vfprintf>:

int vfprintf(FILE* stream,const char* format,va_list arg) {
 8049d2d:	55                   	push   %ebp
 8049d2e:	89 e5                	mov    %esp,%ebp
 8049d30:	83 ec 38             	sub    $0x38,%esp
  int c;
  for(;*format!='\0';format++) {
 8049d33:	e9 7d 01 00 00       	jmp    8049eb5 <vfprintf+0x188>
    if(*format!='%') {
 8049d38:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049d3b:	8a 00                	mov    (%eax),%al
 8049d3d:	3c 25                	cmp    $0x25,%al
 8049d3f:	74 1f                	je     8049d60 <vfprintf+0x33>
      c=fputc(*format,stream);
 8049d41:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049d44:	8a 00                	mov    (%eax),%al
 8049d46:	0f be c0             	movsbl %al,%eax
 8049d49:	83 ec 08             	sub    $0x8,%esp
 8049d4c:	ff 75 08             	push   0x8(%ebp)
 8049d4f:	50                   	push   %eax
 8049d50:	e8 69 fa ff ff       	call   80497be <fputc>
 8049d55:	83 c4 10             	add    $0x10,%esp
 8049d58:	89 45 ec             	mov    %eax,-0x14(%ebp)
      continue;
 8049d5b:	e9 52 01 00 00       	jmp    8049eb2 <vfprintf+0x185>
    }
    format++;
 8049d60:	ff 45 0c             	incl   0xc(%ebp)
    switch(*format) {
 8049d63:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049d66:	8a 00                	mov    (%eax),%al
 8049d68:	0f be c0             	movsbl %al,%eax
 8049d6b:	83 f8 78             	cmp    $0x78,%eax
 8049d6e:	0f 84 f1 00 00 00    	je     8049e65 <vfprintf+0x138>
 8049d74:	83 f8 78             	cmp    $0x78,%eax
 8049d77:	0f 8f 35 01 00 00    	jg     8049eb2 <vfprintf+0x185>
 8049d7d:	83 f8 73             	cmp    $0x73,%eax
 8049d80:	0f 84 b0 00 00 00    	je     8049e36 <vfprintf+0x109>
 8049d86:	83 f8 73             	cmp    $0x73,%eax
 8049d89:	0f 8f 23 01 00 00    	jg     8049eb2 <vfprintf+0x185>
 8049d8f:	83 f8 63             	cmp    $0x63,%eax
 8049d92:	74 0a                	je     8049d9e <vfprintf+0x71>
 8049d94:	83 f8 64             	cmp    $0x64,%eax
 8049d97:	74 3b                	je     8049dd4 <vfprintf+0xa7>
 8049d99:	e9 14 01 00 00       	jmp    8049eb2 <vfprintf+0x185>
      case 'c': {
                  int i=va_arg(arg,int);
 8049d9e:	8b 45 10             	mov    0x10(%ebp),%eax
 8049da1:	8d 50 04             	lea    0x4(%eax),%edx
 8049da4:	89 55 10             	mov    %edx,0x10(%ebp)
 8049da7:	8b 00                	mov    (%eax),%eax
 8049da9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                  c=fputc(i,stream);
 8049dac:	83 ec 08             	sub    $0x8,%esp
 8049daf:	ff 75 08             	push   0x8(%ebp)
 8049db2:	ff 75 e4             	push   -0x1c(%ebp)
 8049db5:	e8 04 fa ff ff       	call   80497be <fputc>
 8049dba:	83 c4 10             	add    $0x10,%esp
 8049dbd:	89 45 ec             	mov    %eax,-0x14(%ebp)
                  if (c==EOF) {
 8049dc0:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 8049dc4:	0f 85 e1 00 00 00    	jne    8049eab <vfprintf+0x17e>
                    return EOF;
 8049dca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8049dcf:	e9 f3 00 00 00       	jmp    8049ec7 <vfprintf+0x19a>
                  }
                  break;
                }
      case 'd': {
                  int i=va_arg(arg,int); 		//Fetch Decimal/Integer argument
 8049dd4:	8b 45 10             	mov    0x10(%ebp),%eax
 8049dd7:	8d 50 04             	lea    0x4(%eax),%edx
 8049dda:	89 55 10             	mov    %edx,0x10(%ebp)
 8049ddd:	8b 00                	mov    (%eax),%eax
 8049ddf:	89 45 f4             	mov    %eax,-0xc(%ebp)
                  if(i<0) {
 8049de2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049de6:	79 13                	jns    8049dfb <vfprintf+0xce>
                    i=-i;
 8049de8:	f7 5d f4             	negl   -0xc(%ebp)
                    fputc('-',stream);
 8049deb:	83 ec 08             	sub    $0x8,%esp
 8049dee:	ff 75 08             	push   0x8(%ebp)
 8049df1:	6a 2d                	push   $0x2d
 8049df3:	e8 c6 f9 ff ff       	call   80497be <fputc>
 8049df8:	83 c4 10             	add    $0x10,%esp
                  }
                  char str[11];
                  int_to_ascii(i,str);
 8049dfb:	83 ec 08             	sub    $0x8,%esp
 8049dfe:	8d 45 d9             	lea    -0x27(%ebp),%eax
 8049e01:	50                   	push   %eax
 8049e02:	ff 75 f4             	push   -0xc(%ebp)
 8049e05:	e8 24 03 00 00       	call   804a12e <int_to_ascii>
 8049e0a:	83 c4 10             	add    $0x10,%esp
                  c=fputs(str,stream);
 8049e0d:	83 ec 08             	sub    $0x8,%esp
 8049e10:	ff 75 08             	push   0x8(%ebp)
 8049e13:	8d 45 d9             	lea    -0x27(%ebp),%eax
 8049e16:	50                   	push   %eax
 8049e17:	e8 60 fc ff ff       	call   8049a7c <fputs>
 8049e1c:	83 c4 10             	add    $0x10,%esp
 8049e1f:	89 45 ec             	mov    %eax,-0x14(%ebp)
                  if (c==EOF) {
 8049e22:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 8049e26:	0f 85 82 00 00 00    	jne    8049eae <vfprintf+0x181>
                    return EOF;
 8049e2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8049e31:	e9 91 00 00 00       	jmp    8049ec7 <vfprintf+0x19a>
                //   int i=va_arg(arg,unsigned int); //Fetch Octal representation
                // 	puts(convert(i,8));
                // 	break;
                // }
      case 's': {
                  char* s=va_arg(arg,char*);
 8049e36:	8b 45 10             	mov    0x10(%ebp),%eax
 8049e39:	8d 50 04             	lea    0x4(%eax),%edx
 8049e3c:	89 55 10             	mov    %edx,0x10(%ebp)
 8049e3f:	8b 00                	mov    (%eax),%eax
 8049e41:	89 45 e8             	mov    %eax,-0x18(%ebp)
                  c=fputs(s,stream);
 8049e44:	83 ec 08             	sub    $0x8,%esp
 8049e47:	ff 75 08             	push   0x8(%ebp)
 8049e4a:	ff 75 e8             	push   -0x18(%ebp)
 8049e4d:	e8 2a fc ff ff       	call   8049a7c <fputs>
 8049e52:	83 c4 10             	add    $0x10,%esp
 8049e55:	89 45 ec             	mov    %eax,-0x14(%ebp)
                  if (c==EOF) {
 8049e58:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 8049e5c:	75 53                	jne    8049eb1 <vfprintf+0x184>
                    return EOF;
 8049e5e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8049e63:	eb 62                	jmp    8049ec7 <vfprintf+0x19a>
                  }
                  break;
                }
      case 'x': {
                  unsigned int i=va_arg(arg, unsigned int);
 8049e65:	8b 45 10             	mov    0x10(%ebp),%eax
 8049e68:	8d 50 04             	lea    0x4(%eax),%edx
 8049e6b:	89 55 10             	mov    %edx,0x10(%ebp)
 8049e6e:	8b 00                	mov    (%eax),%eax
 8049e70:	89 45 f0             	mov    %eax,-0x10(%ebp)
                  char str[11];
                  str[0]='\0';
 8049e73:	c6 45 ce 00          	movb   $0x0,-0x32(%ebp)
                  hex_to_ascii(i,str);
 8049e77:	83 ec 08             	sub    $0x8,%esp
 8049e7a:	8d 45 ce             	lea    -0x32(%ebp),%eax
 8049e7d:	50                   	push   %eax
 8049e7e:	ff 75 f0             	push   -0x10(%ebp)
 8049e81:	e8 39 03 00 00       	call   804a1bf <hex_to_ascii>
 8049e86:	83 c4 10             	add    $0x10,%esp
                  c=fputs(str,stream);
 8049e89:	83 ec 08             	sub    $0x8,%esp
 8049e8c:	ff 75 08             	push   0x8(%ebp)
 8049e8f:	8d 45 ce             	lea    -0x32(%ebp),%eax
 8049e92:	50                   	push   %eax
 8049e93:	e8 e4 fb ff ff       	call   8049a7c <fputs>
 8049e98:	83 c4 10             	add    $0x10,%esp
 8049e9b:	89 45 ec             	mov    %eax,-0x14(%ebp)
                  if (c==EOF) {
 8049e9e:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 8049ea2:	75 0e                	jne    8049eb2 <vfprintf+0x185>
                    return EOF;
 8049ea4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8049ea9:	eb 1c                	jmp    8049ec7 <vfprintf+0x19a>
                  break;
 8049eab:	90                   	nop
 8049eac:	eb 04                	jmp    8049eb2 <vfprintf+0x185>
                  break;
 8049eae:	90                   	nop
 8049eaf:	eb 01                	jmp    8049eb2 <vfprintf+0x185>
                  break;
 8049eb1:	90                   	nop
  for(;*format!='\0';format++) {
 8049eb2:	ff 45 0c             	incl   0xc(%ebp)
 8049eb5:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049eb8:	8a 00                	mov    (%eax),%al
 8049eba:	84 c0                	test   %al,%al
 8049ebc:	0f 85 76 fe ff ff    	jne    8049d38 <vfprintf+0xb>
                  }
                  break;
                }
    }
  }
  return 1;
 8049ec2:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8049ec7:	c9                   	leave  
 8049ec8:	c3                   	ret    

08049ec9 <fprintf>:

int fprintf(FILE* stream,const char* format,...) {
 8049ec9:	55                   	push   %ebp
 8049eca:	89 e5                	mov    %esp,%ebp
 8049ecc:	83 ec 18             	sub    $0x18,%esp
  va_list arg;
  int code;
  va_start(arg,format);
 8049ecf:	8d 45 10             	lea    0x10(%ebp),%eax
 8049ed2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  code=vfprintf(stream,format,arg);
 8049ed5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049ed8:	83 ec 04             	sub    $0x4,%esp
 8049edb:	50                   	push   %eax
 8049edc:	ff 75 0c             	push   0xc(%ebp)
 8049edf:	ff 75 08             	push   0x8(%ebp)
 8049ee2:	e8 46 fe ff ff       	call   8049d2d <vfprintf>
 8049ee7:	83 c4 10             	add    $0x10,%esp
 8049eea:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end(arg);
  if (code) {
 8049eed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049ef1:	74 10                	je     8049f03 <fprintf+0x3a>
    return strlen(format);
 8049ef3:	83 ec 0c             	sub    $0xc,%esp
 8049ef6:	ff 75 0c             	push   0xc(%ebp)
 8049ef9:	e8 66 01 00 00       	call   804a064 <strlen>
 8049efe:	83 c4 10             	add    $0x10,%esp
 8049f01:	eb 05                	jmp    8049f08 <fprintf+0x3f>
  } else {
    return EOF;
 8049f03:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
}
 8049f08:	c9                   	leave  
 8049f09:	c3                   	ret    

08049f0a <printf>:

int printf(const char* format,...) {
 8049f0a:	55                   	push   %ebp
 8049f0b:	89 e5                	mov    %esp,%ebp
 8049f0d:	83 ec 18             	sub    $0x18,%esp
  va_list arg;
  int code;
  va_start(arg,format);
 8049f10:	8d 45 0c             	lea    0xc(%ebp),%eax
 8049f13:	89 45 f0             	mov    %eax,-0x10(%ebp)
  code=vfprintf(stdout,format,arg);
 8049f16:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049f19:	a1 14 c3 04 08       	mov    0x804c314,%eax
 8049f1e:	83 ec 04             	sub    $0x4,%esp
 8049f21:	52                   	push   %edx
 8049f22:	ff 75 08             	push   0x8(%ebp)
 8049f25:	50                   	push   %eax
 8049f26:	e8 02 fe ff ff       	call   8049d2d <vfprintf>
 8049f2b:	83 c4 10             	add    $0x10,%esp
 8049f2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end(arg);
  if (code) {
 8049f31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049f35:	74 10                	je     8049f47 <printf+0x3d>
    return strlen(format);
 8049f37:	83 ec 0c             	sub    $0xc,%esp
 8049f3a:	ff 75 08             	push   0x8(%ebp)
 8049f3d:	e8 22 01 00 00       	call   804a064 <strlen>
 8049f42:	83 c4 10             	add    $0x10,%esp
 8049f45:	eb 05                	jmp    8049f4c <printf+0x42>
  } else {
    return EOF;
 8049f47:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
}
 8049f4c:	c9                   	leave  
 8049f4d:	c3                   	ret    

08049f4e <fseek>:

int fseek(FILE* stream,long offset,int origin) {
 8049f4e:	55                   	push   %ebp
 8049f4f:	89 e5                	mov    %esp,%ebp
  switch (origin) {
 8049f51:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
 8049f55:	74 14                	je     8049f6b <fseek+0x1d>
 8049f57:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
 8049f5b:	7f 2c                	jg     8049f89 <fseek+0x3b>
 8049f5d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
 8049f61:	74 13                	je     8049f76 <fseek+0x28>
 8049f63:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
 8049f67:	74 23                	je     8049f8c <fseek+0x3e>
      stream->pos+=offset;
      break;
    case SEEK_END:
      break;
    default:
      break;
 8049f69:	eb 1e                	jmp    8049f89 <fseek+0x3b>
      stream->pos=offset;
 8049f6b:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f6e:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049f71:	89 50 08             	mov    %edx,0x8(%eax)
      break;
 8049f74:	eb 17                	jmp    8049f8d <fseek+0x3f>
      stream->pos+=offset;
 8049f76:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f79:	8b 50 08             	mov    0x8(%eax),%edx
 8049f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049f7f:	01 c2                	add    %eax,%edx
 8049f81:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f84:	89 50 08             	mov    %edx,0x8(%eax)
      break;
 8049f87:	eb 04                	jmp    8049f8d <fseek+0x3f>
      break;
 8049f89:	90                   	nop
 8049f8a:	eb 01                	jmp    8049f8d <fseek+0x3f>
      break;
 8049f8c:	90                   	nop
  }
  return 0;
 8049f8d:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049f92:	5d                   	pop    %ebp
 8049f93:	c3                   	ret    

08049f94 <memcpy>:
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

void* memcpy(void* dest_ptr,const void* source_ptr,size_t len) {
 8049f94:	55                   	push   %ebp
 8049f95:	89 e5                	mov    %esp,%ebp
 8049f97:	83 ec 10             	sub    $0x10,%esp
    char* source=(char*)source_ptr;
 8049f9a:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049f9d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char* dest=(char*)dest_ptr;
 8049fa0:	8b 45 08             	mov    0x8(%ebp),%eax
 8049fa3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(size_t i=0;i<len;i++) {
 8049fa6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 8049fad:	eb 17                	jmp    8049fc6 <memcpy+0x32>
      dest[i]=source[i];
 8049faf:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8049fb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049fb5:	01 d0                	add    %edx,%eax
 8049fb7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
 8049fba:	8b 55 fc             	mov    -0x4(%ebp),%edx
 8049fbd:	01 ca                	add    %ecx,%edx
 8049fbf:	8a 00                	mov    (%eax),%al
 8049fc1:	88 02                	mov    %al,(%edx)
    for(size_t i=0;i<len;i++) {
 8049fc3:	ff 45 fc             	incl   -0x4(%ebp)
 8049fc6:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049fc9:	3b 45 10             	cmp    0x10(%ebp),%eax
 8049fcc:	72 e1                	jb     8049faf <memcpy+0x1b>
    }
    return dest_ptr;
 8049fce:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8049fd1:	c9                   	leave  
 8049fd2:	c3                   	ret    

08049fd3 <memset>:

void* memset(void *dest_ptr,int val,size_t len) {
 8049fd3:	55                   	push   %ebp
 8049fd4:	89 e5                	mov    %esp,%ebp
 8049fd6:	83 ec 10             	sub    $0x10,%esp
    char* dest=(char*)dest_ptr;
 8049fd9:	8b 45 08             	mov    0x8(%ebp),%eax
 8049fdc:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (size_t i=0;i<len;i++){
 8049fdf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 8049fe6:	eb 10                	jmp    8049ff8 <memset+0x25>
      dest[i]=(char)val;
 8049fe8:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8049feb:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049fee:	01 d0                	add    %edx,%eax
 8049ff0:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049ff3:	88 10                	mov    %dl,(%eax)
    for (size_t i=0;i<len;i++){
 8049ff5:	ff 45 fc             	incl   -0x4(%ebp)
 8049ff8:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049ffb:	3b 45 10             	cmp    0x10(%ebp),%eax
 8049ffe:	72 e8                	jb     8049fe8 <memset+0x15>
    }
    return dest_ptr;
 804a000:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804a003:	c9                   	leave  
 804a004:	c3                   	ret    

0804a005 <strcmp>:

int strcmp(const char* s1,const char* s2) {
 804a005:	55                   	push   %ebp
 804a006:	89 e5                	mov    %esp,%ebp
 804a008:	83 ec 10             	sub    $0x10,%esp
    int i;
    for (i = 0; s1[i] == s2[i]; i++) {
 804a00b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 804a012:	eb 18                	jmp    804a02c <strcmp+0x27>
        if (s1[i] == '\0') return 0;
 804a014:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804a017:	8b 45 08             	mov    0x8(%ebp),%eax
 804a01a:	01 d0                	add    %edx,%eax
 804a01c:	8a 00                	mov    (%eax),%al
 804a01e:	84 c0                	test   %al,%al
 804a020:	75 07                	jne    804a029 <strcmp+0x24>
 804a022:	b8 00 00 00 00       	mov    $0x0,%eax
 804a027:	eb 39                	jmp    804a062 <strcmp+0x5d>
    for (i = 0; s1[i] == s2[i]; i++) {
 804a029:	ff 45 fc             	incl   -0x4(%ebp)
 804a02c:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804a02f:	8b 45 08             	mov    0x8(%ebp),%eax
 804a032:	01 d0                	add    %edx,%eax
 804a034:	8a 10                	mov    (%eax),%dl
 804a036:	8b 4d fc             	mov    -0x4(%ebp),%ecx
 804a039:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a03c:	01 c8                	add    %ecx,%eax
 804a03e:	8a 00                	mov    (%eax),%al
 804a040:	38 c2                	cmp    %al,%dl
 804a042:	74 d0                	je     804a014 <strcmp+0xf>
    }
    return s1[i] - s2[i];
 804a044:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804a047:	8b 45 08             	mov    0x8(%ebp),%eax
 804a04a:	01 d0                	add    %edx,%eax
 804a04c:	8a 00                	mov    (%eax),%al
 804a04e:	0f be d0             	movsbl %al,%edx
 804a051:	8b 4d fc             	mov    -0x4(%ebp),%ecx
 804a054:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a057:	01 c8                	add    %ecx,%eax
 804a059:	8a 00                	mov    (%eax),%al
 804a05b:	0f be c0             	movsbl %al,%eax
 804a05e:	29 c2                	sub    %eax,%edx
 804a060:	89 d0                	mov    %edx,%eax
}
 804a062:	c9                   	leave  
 804a063:	c3                   	ret    

0804a064 <strlen>:

size_t strlen(const char* str) {
 804a064:	55                   	push   %ebp
 804a065:	89 e5                	mov    %esp,%ebp
 804a067:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for (i=0;str[i]!='\0';i++);
 804a06a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 804a071:	eb 03                	jmp    804a076 <strlen+0x12>
 804a073:	ff 45 fc             	incl   -0x4(%ebp)
 804a076:	8b 55 08             	mov    0x8(%ebp),%edx
 804a079:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a07c:	01 d0                	add    %edx,%eax
 804a07e:	8a 00                	mov    (%eax),%al
 804a080:	84 c0                	test   %al,%al
 804a082:	75 ef                	jne    804a073 <strlen+0xf>
  return i;
 804a084:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804a087:	c9                   	leave  
 804a088:	c3                   	ret    

0804a089 <strcpy>:

char* strcpy(char* dest,const char* src) {
 804a089:	55                   	push   %ebp
 804a08a:	89 e5                	mov    %esp,%ebp
 804a08c:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for (i=0;i<strlen(src);i++) {
 804a08f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 804a096:	eb 17                	jmp    804a0af <strcpy+0x26>
    dest[i]=src[i];
 804a098:	8b 55 0c             	mov    0xc(%ebp),%edx
 804a09b:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a09e:	01 d0                	add    %edx,%eax
 804a0a0:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804a0a3:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804a0a6:	01 ca                	add    %ecx,%edx
 804a0a8:	8a 00                	mov    (%eax),%al
 804a0aa:	88 02                	mov    %al,(%edx)
  for (i=0;i<strlen(src);i++) {
 804a0ac:	ff 45 fc             	incl   -0x4(%ebp)
 804a0af:	ff 75 0c             	push   0xc(%ebp)
 804a0b2:	e8 ad ff ff ff       	call   804a064 <strlen>
 804a0b7:	83 c4 04             	add    $0x4,%esp
 804a0ba:	39 45 fc             	cmp    %eax,-0x4(%ebp)
 804a0bd:	72 d9                	jb     804a098 <strcpy+0xf>
  }
  dest[i]='\0';
 804a0bf:	8b 55 08             	mov    0x8(%ebp),%edx
 804a0c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a0c5:	01 d0                	add    %edx,%eax
 804a0c7:	c6 00 00             	movb   $0x0,(%eax)
  return dest;
 804a0ca:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804a0cd:	c9                   	leave  
 804a0ce:	c3                   	ret    

0804a0cf <strrev>:

char* strrev(char* str) {
 804a0cf:	55                   	push   %ebp
 804a0d0:	89 e5                	mov    %esp,%ebp
 804a0d2:	83 ec 10             	sub    $0x10,%esp
    char chr;
    int i,j;
    for (i=0,j=strlen(str)-1;i<j;i++,j--) {
 804a0d5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 804a0dc:	ff 75 08             	push   0x8(%ebp)
 804a0df:	e8 80 ff ff ff       	call   804a064 <strlen>
 804a0e4:	83 c4 04             	add    $0x4,%esp
 804a0e7:	48                   	dec    %eax
 804a0e8:	89 45 f8             	mov    %eax,-0x8(%ebp)
 804a0eb:	eb 34                	jmp    804a121 <strrev+0x52>
      chr=str[i];
 804a0ed:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804a0f0:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0f3:	01 d0                	add    %edx,%eax
 804a0f5:	8a 00                	mov    (%eax),%al
 804a0f7:	88 45 f7             	mov    %al,-0x9(%ebp)
      str[i]=str[j];
 804a0fa:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804a0fd:	8b 45 08             	mov    0x8(%ebp),%eax
 804a100:	01 d0                	add    %edx,%eax
 804a102:	8b 4d fc             	mov    -0x4(%ebp),%ecx
 804a105:	8b 55 08             	mov    0x8(%ebp),%edx
 804a108:	01 ca                	add    %ecx,%edx
 804a10a:	8a 00                	mov    (%eax),%al
 804a10c:	88 02                	mov    %al,(%edx)
      str[j]=chr;
 804a10e:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804a111:	8b 45 08             	mov    0x8(%ebp),%eax
 804a114:	01 c2                	add    %eax,%edx
 804a116:	8a 45 f7             	mov    -0x9(%ebp),%al
 804a119:	88 02                	mov    %al,(%edx)
    for (i=0,j=strlen(str)-1;i<j;i++,j--) {
 804a11b:	ff 45 fc             	incl   -0x4(%ebp)
 804a11e:	ff 4d f8             	decl   -0x8(%ebp)
 804a121:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a124:	3b 45 f8             	cmp    -0x8(%ebp),%eax
 804a127:	7c c4                	jl     804a0ed <strrev+0x1e>
    }
    return str;
 804a129:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804a12c:	c9                   	leave  
 804a12d:	c3                   	ret    

0804a12e <int_to_ascii>:

void int_to_ascii(int n,char* str) {
 804a12e:	55                   	push   %ebp
 804a12f:	89 e5                	mov    %esp,%ebp
 804a131:	83 ec 10             	sub    $0x10,%esp
    int i;
    int sign;
    if ((sign = n)<0) {
 804a134:	8b 45 08             	mov    0x8(%ebp),%eax
 804a137:	89 45 f8             	mov    %eax,-0x8(%ebp)
 804a13a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
 804a13e:	79 03                	jns    804a143 <int_to_ascii+0x15>
      n=-n;
 804a140:	f7 5d 08             	negl   0x8(%ebp)
    }
    i=0;
 804a143:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    do {
      str[i++]=n%10+'0';
 804a14a:	8b 45 08             	mov    0x8(%ebp),%eax
 804a14d:	b9 0a 00 00 00       	mov    $0xa,%ecx
 804a152:	99                   	cltd   
 804a153:	f7 f9                	idiv   %ecx
 804a155:	89 d0                	mov    %edx,%eax
 804a157:	8d 48 30             	lea    0x30(%eax),%ecx
 804a15a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a15d:	8d 50 01             	lea    0x1(%eax),%edx
 804a160:	89 55 fc             	mov    %edx,-0x4(%ebp)
 804a163:	89 c2                	mov    %eax,%edx
 804a165:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a168:	01 d0                	add    %edx,%eax
 804a16a:	88 ca                	mov    %cl,%dl
 804a16c:	88 10                	mov    %dl,(%eax)
    } while ((n /= 10) > 0);
 804a16e:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804a171:	b8 67 66 66 66       	mov    $0x66666667,%eax
 804a176:	f7 e9                	imul   %ecx
 804a178:	c1 fa 02             	sar    $0x2,%edx
 804a17b:	89 c8                	mov    %ecx,%eax
 804a17d:	c1 f8 1f             	sar    $0x1f,%eax
 804a180:	29 c2                	sub    %eax,%edx
 804a182:	89 d0                	mov    %edx,%eax
 804a184:	89 45 08             	mov    %eax,0x8(%ebp)
 804a187:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804a18b:	7f bd                	jg     804a14a <int_to_ascii+0x1c>
    if (sign < 0) {
 804a18d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
 804a191:	79 13                	jns    804a1a6 <int_to_ascii+0x78>
      str[i++] = '-';
 804a193:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a196:	8d 50 01             	lea    0x1(%eax),%edx
 804a199:	89 55 fc             	mov    %edx,-0x4(%ebp)
 804a19c:	89 c2                	mov    %eax,%edx
 804a19e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a1a1:	01 d0                	add    %edx,%eax
 804a1a3:	c6 00 2d             	movb   $0x2d,(%eax)
    }
    str[i]='\0';
 804a1a6:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804a1a9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a1ac:	01 d0                	add    %edx,%eax
 804a1ae:	c6 00 00             	movb   $0x0,(%eax)
    strrev(str);
 804a1b1:	ff 75 0c             	push   0xc(%ebp)
 804a1b4:	e8 16 ff ff ff       	call   804a0cf <strrev>
 804a1b9:	83 c4 04             	add    $0x4,%esp
}
 804a1bc:	90                   	nop
 804a1bd:	c9                   	leave  
 804a1be:	c3                   	ret    

0804a1bf <hex_to_ascii>:

void hex_to_ascii(unsigned int n, char* str) {
 804a1bf:	55                   	push   %ebp
 804a1c0:	89 e5                	mov    %esp,%ebp
 804a1c2:	83 ec 18             	sub    $0x18,%esp
    str[0]='\0'; 
 804a1c5:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a1c8:	c6 00 00             	movb   $0x0,(%eax)
    append(str, '0');
 804a1cb:	83 ec 08             	sub    $0x8,%esp
 804a1ce:	6a 30                	push   $0x30
 804a1d0:	ff 75 0c             	push   0xc(%ebp)
 804a1d3:	e8 cb 00 00 00       	call   804a2a3 <append>
 804a1d8:	83 c4 10             	add    $0x10,%esp
    append(str, 'x');
 804a1db:	83 ec 08             	sub    $0x8,%esp
 804a1de:	6a 78                	push   $0x78
 804a1e0:	ff 75 0c             	push   0xc(%ebp)
 804a1e3:	e8 bb 00 00 00       	call   804a2a3 <append>
 804a1e8:	83 c4 10             	add    $0x10,%esp
    char zeros = 0;
 804a1eb:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

    unsigned int tmp;
    int i;
    for (i = 28; i > 0; i -= 4) {
 804a1ef:	c7 45 f0 1c 00 00 00 	movl   $0x1c,-0x10(%ebp)
 804a1f6:	eb 61                	jmp    804a259 <hex_to_ascii+0x9a>
        tmp = (n >> i) & 0xF;
 804a1f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a1fb:	8b 55 08             	mov    0x8(%ebp),%edx
 804a1fe:	88 c1                	mov    %al,%cl
 804a200:	d3 ea                	shr    %cl,%edx
 804a202:	89 d0                	mov    %edx,%eax
 804a204:	83 e0 0f             	and    $0xf,%eax
 804a207:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (tmp == 0 && zeros == 0) continue;
 804a20a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804a20e:	75 06                	jne    804a216 <hex_to_ascii+0x57>
 804a210:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
 804a214:	74 3e                	je     804a254 <hex_to_ascii+0x95>
        zeros = 1;
 804a216:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
        if (tmp >= 0xA) append(str, tmp - 0xA + 'a');
 804a21a:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
 804a21e:	76 1a                	jbe    804a23a <hex_to_ascii+0x7b>
 804a220:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a223:	83 c0 57             	add    $0x57,%eax
 804a226:	0f be c0             	movsbl %al,%eax
 804a229:	83 ec 08             	sub    $0x8,%esp
 804a22c:	50                   	push   %eax
 804a22d:	ff 75 0c             	push   0xc(%ebp)
 804a230:	e8 6e 00 00 00       	call   804a2a3 <append>
 804a235:	83 c4 10             	add    $0x10,%esp
 804a238:	eb 1b                	jmp    804a255 <hex_to_ascii+0x96>
        else append(str, tmp + '0');
 804a23a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a23d:	83 c0 30             	add    $0x30,%eax
 804a240:	0f be c0             	movsbl %al,%eax
 804a243:	83 ec 08             	sub    $0x8,%esp
 804a246:	50                   	push   %eax
 804a247:	ff 75 0c             	push   0xc(%ebp)
 804a24a:	e8 54 00 00 00       	call   804a2a3 <append>
 804a24f:	83 c4 10             	add    $0x10,%esp
 804a252:	eb 01                	jmp    804a255 <hex_to_ascii+0x96>
        if (tmp == 0 && zeros == 0) continue;
 804a254:	90                   	nop
    for (i = 28; i > 0; i -= 4) {
 804a255:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
 804a259:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804a25d:	7f 99                	jg     804a1f8 <hex_to_ascii+0x39>
    }

    tmp = n & 0xF;
 804a25f:	8b 45 08             	mov    0x8(%ebp),%eax
 804a262:	83 e0 0f             	and    $0xf,%eax
 804a265:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (tmp >= 0xA) append(str, tmp - 0xA + 'a');
 804a268:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
 804a26c:	76 1a                	jbe    804a288 <hex_to_ascii+0xc9>
 804a26e:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a271:	83 c0 57             	add    $0x57,%eax
 804a274:	0f be c0             	movsbl %al,%eax
 804a277:	83 ec 08             	sub    $0x8,%esp
 804a27a:	50                   	push   %eax
 804a27b:	ff 75 0c             	push   0xc(%ebp)
 804a27e:	e8 20 00 00 00       	call   804a2a3 <append>
 804a283:	83 c4 10             	add    $0x10,%esp
    else append(str, tmp + '0');
}
 804a286:	eb 18                	jmp    804a2a0 <hex_to_ascii+0xe1>
    else append(str, tmp + '0');
 804a288:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a28b:	83 c0 30             	add    $0x30,%eax
 804a28e:	0f be c0             	movsbl %al,%eax
 804a291:	83 ec 08             	sub    $0x8,%esp
 804a294:	50                   	push   %eax
 804a295:	ff 75 0c             	push   0xc(%ebp)
 804a298:	e8 06 00 00 00       	call   804a2a3 <append>
 804a29d:	83 c4 10             	add    $0x10,%esp
}
 804a2a0:	90                   	nop
 804a2a1:	c9                   	leave  
 804a2a2:	c3                   	ret    

0804a2a3 <append>:

void append(char* s, char n) {
 804a2a3:	55                   	push   %ebp
 804a2a4:	89 e5                	mov    %esp,%ebp
 804a2a6:	83 ec 14             	sub    $0x14,%esp
 804a2a9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a2ac:	88 45 ec             	mov    %al,-0x14(%ebp)
    int len = strlen(s);
 804a2af:	ff 75 08             	push   0x8(%ebp)
 804a2b2:	e8 ad fd ff ff       	call   804a064 <strlen>
 804a2b7:	83 c4 04             	add    $0x4,%esp
 804a2ba:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s[len] = n;
 804a2bd:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804a2c0:	8b 45 08             	mov    0x8(%ebp),%eax
 804a2c3:	01 c2                	add    %eax,%edx
 804a2c5:	8a 45 ec             	mov    -0x14(%ebp),%al
 804a2c8:	88 02                	mov    %al,(%edx)
    s[len+1] = '\0';
 804a2ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a2cd:	8d 50 01             	lea    0x1(%eax),%edx
 804a2d0:	8b 45 08             	mov    0x8(%ebp),%eax
 804a2d3:	01 d0                	add    %edx,%eax
 804a2d5:	c6 00 00             	movb   $0x0,(%eax)
}
 804a2d8:	90                   	nop
 804a2d9:	c9                   	leave  
 804a2da:	c3                   	ret    

0804a2db <backspace>:

void backspace(char* s) {
 804a2db:	55                   	push   %ebp
 804a2dc:	89 e5                	mov    %esp,%ebp
 804a2de:	83 ec 10             	sub    $0x10,%esp
    int len = strlen(s);
 804a2e1:	ff 75 08             	push   0x8(%ebp)
 804a2e4:	e8 7b fd ff ff       	call   804a064 <strlen>
 804a2e9:	83 c4 04             	add    $0x4,%esp
 804a2ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s[len-1] = '\0';
 804a2ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a2f2:	8d 50 ff             	lea    -0x1(%eax),%edx
 804a2f5:	8b 45 08             	mov    0x8(%ebp),%eax
 804a2f8:	01 d0                	add    %edx,%eax
 804a2fa:	c6 00 00             	movb   $0x0,(%eax)
}
 804a2fd:	90                   	nop
 804a2fe:	c9                   	leave  
 804a2ff:	c3                   	ret    

0804a300 <strtok_delim_check>:

static const char* strtok_str=NULL;
static size_t strtok_index;

static char strtok_delim_check(const char* delim) {
 804a300:	55                   	push   %ebp
 804a301:	89 e5                	mov    %esp,%ebp
 804a303:	83 ec 10             	sub    $0x10,%esp
  for (size_t i=0;i<strlen(delim);i++) {
 804a306:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 804a30d:	eb 37                	jmp    804a346 <strtok_delim_check+0x46>
    if (strtok_str[strtok_index]==delim[i]||strtok_str[strtok_index]=='\0') {
 804a30f:	8b 15 1c c3 04 08    	mov    0x804c31c,%edx
 804a315:	a1 20 c3 04 08       	mov    0x804c320,%eax
 804a31a:	01 d0                	add    %edx,%eax
 804a31c:	8a 10                	mov    (%eax),%dl
 804a31e:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804a321:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a324:	01 c8                	add    %ecx,%eax
 804a326:	8a 00                	mov    (%eax),%al
 804a328:	38 c2                	cmp    %al,%dl
 804a32a:	74 13                	je     804a33f <strtok_delim_check+0x3f>
 804a32c:	8b 15 1c c3 04 08    	mov    0x804c31c,%edx
 804a332:	a1 20 c3 04 08       	mov    0x804c320,%eax
 804a337:	01 d0                	add    %edx,%eax
 804a339:	8a 00                	mov    (%eax),%al
 804a33b:	84 c0                	test   %al,%al
 804a33d:	75 04                	jne    804a343 <strtok_delim_check+0x43>
      return 0;
 804a33f:	b0 00                	mov    $0x0,%al
 804a341:	eb 15                	jmp    804a358 <strtok_delim_check+0x58>
  for (size_t i=0;i<strlen(delim);i++) {
 804a343:	ff 45 fc             	incl   -0x4(%ebp)
 804a346:	ff 75 08             	push   0x8(%ebp)
 804a349:	e8 16 fd ff ff       	call   804a064 <strlen>
 804a34e:	83 c4 04             	add    $0x4,%esp
 804a351:	39 45 fc             	cmp    %eax,-0x4(%ebp)
 804a354:	72 b9                	jb     804a30f <strtok_delim_check+0xf>
    }
  }
  return 1;
 804a356:	b0 01                	mov    $0x1,%al
}
 804a358:	c9                   	leave  
 804a359:	c3                   	ret    

0804a35a <strtok>:

char* strtok(const char* str, const char* delim) {
 804a35a:	55                   	push   %ebp
 804a35b:	89 e5                	mov    %esp,%ebp
 804a35d:	83 ec 18             	sub    $0x18,%esp
  if (str!=NULL) {
 804a360:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804a364:	74 12                	je     804a378 <strtok+0x1e>
    strtok_str=str;
 804a366:	8b 45 08             	mov    0x8(%ebp),%eax
 804a369:	a3 1c c3 04 08       	mov    %eax,0x804c31c
    strtok_index=0;
 804a36e:	c7 05 20 c3 04 08 00 	movl   $0x0,0x804c320
 804a375:	00 00 00 
  }
  if (!strtok_str || strtok_index>strlen(strtok_str)) {
 804a378:	a1 1c c3 04 08       	mov    0x804c31c,%eax
 804a37d:	85 c0                	test   %eax,%eax
 804a37f:	74 18                	je     804a399 <strtok+0x3f>
 804a381:	a1 1c c3 04 08       	mov    0x804c31c,%eax
 804a386:	50                   	push   %eax
 804a387:	e8 d8 fc ff ff       	call   804a064 <strlen>
 804a38c:	83 c4 04             	add    $0x4,%esp
 804a38f:	8b 15 20 c3 04 08    	mov    0x804c320,%edx
 804a395:	39 d0                	cmp    %edx,%eax
 804a397:	73 0a                	jae    804a3a3 <strtok+0x49>
    return NULL;
 804a399:	b8 00 00 00 00       	mov    $0x0,%eax
 804a39e:	e9 9b 00 00 00       	jmp    804a43e <strtok+0xe4>
  }
  char* tok=malloc(sizeof(char)*32);
 804a3a3:	83 ec 0c             	sub    $0xc,%esp
 804a3a6:	6a 20                	push   $0x20
 804a3a8:	e8 b8 e4 ff ff       	call   8048865 <malloc>
 804a3ad:	83 c4 10             	add    $0x10,%esp
 804a3b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  tok[0]='\0';
 804a3b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a3b6:	c6 00 00             	movb   $0x0,(%eax)
  size_t max_len=32;
 804a3b9:	c7 45 f0 20 00 00 00 	movl   $0x20,-0x10(%ebp)
  for (;strtok_delim_check(delim);strtok_index++) {
 804a3c0:	eb 5c                	jmp    804a41e <strtok+0xc4>
    if (strlen(tok)+1==max_len) {
 804a3c2:	83 ec 0c             	sub    $0xc,%esp
 804a3c5:	ff 75 f4             	push   -0xc(%ebp)
 804a3c8:	e8 97 fc ff ff       	call   804a064 <strlen>
 804a3cd:	83 c4 10             	add    $0x10,%esp
 804a3d0:	40                   	inc    %eax
 804a3d1:	39 45 f0             	cmp    %eax,-0x10(%ebp)
 804a3d4:	75 1c                	jne    804a3f2 <strtok+0x98>
      tok=realloc(tok,sizeof(char)*(max_len+32));
 804a3d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a3d9:	83 c0 20             	add    $0x20,%eax
 804a3dc:	83 ec 08             	sub    $0x8,%esp
 804a3df:	50                   	push   %eax
 804a3e0:	ff 75 f4             	push   -0xc(%ebp)
 804a3e3:	e8 a0 ed ff ff       	call   8049188 <realloc>
 804a3e8:	83 c4 10             	add    $0x10,%esp
 804a3eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
      max_len+=32;
 804a3ee:	83 45 f0 20          	addl   $0x20,-0x10(%ebp)
    }
    append(tok,strtok_str[strtok_index]);
 804a3f2:	8b 15 1c c3 04 08    	mov    0x804c31c,%edx
 804a3f8:	a1 20 c3 04 08       	mov    0x804c320,%eax
 804a3fd:	01 d0                	add    %edx,%eax
 804a3ff:	8a 00                	mov    (%eax),%al
 804a401:	0f be c0             	movsbl %al,%eax
 804a404:	83 ec 08             	sub    $0x8,%esp
 804a407:	50                   	push   %eax
 804a408:	ff 75 f4             	push   -0xc(%ebp)
 804a40b:	e8 93 fe ff ff       	call   804a2a3 <append>
 804a410:	83 c4 10             	add    $0x10,%esp
  for (;strtok_delim_check(delim);strtok_index++) {
 804a413:	a1 20 c3 04 08       	mov    0x804c320,%eax
 804a418:	40                   	inc    %eax
 804a419:	a3 20 c3 04 08       	mov    %eax,0x804c320
 804a41e:	83 ec 0c             	sub    $0xc,%esp
 804a421:	ff 75 0c             	push   0xc(%ebp)
 804a424:	e8 d7 fe ff ff       	call   804a300 <strtok_delim_check>
 804a429:	83 c4 10             	add    $0x10,%esp
 804a42c:	84 c0                	test   %al,%al
 804a42e:	75 92                	jne    804a3c2 <strtok+0x68>
  }
  strtok_index++;
 804a430:	a1 20 c3 04 08       	mov    0x804c320,%eax
 804a435:	40                   	inc    %eax
 804a436:	a3 20 c3 04 08       	mov    %eax,0x804c320
  return tok;
 804a43b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804a43e:	c9                   	leave  
 804a43f:	c3                   	ret    

0804a440 <yield>:
#include <tasking.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void yield() {
 804a440:	55                   	push   %ebp
 804a441:	89 e5                	mov    %esp,%ebp
 804a443:	53                   	push   %ebx
  asm volatile("  \
 804a444:	b8 00 00 00 00       	mov    $0x0,%eax
 804a449:	89 c3                	mov    %eax,%ebx
 804a44b:	b8 01 00 00 00       	mov    $0x1,%eax
 804a450:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_YIELD) ", %%eax; \
    int $80; \
  "::"b"(0));
}
 804a452:	90                   	nop
 804a453:	5b                   	pop    %ebx
 804a454:	5d                   	pop    %ebp
 804a455:	c3                   	ret    

0804a456 <create_proc>:

void create_proc(void* start,void* address_space,void* param1,void* param2) {
 804a456:	55                   	push   %ebp
 804a457:	89 e5                	mov    %esp,%ebp
 804a459:	56                   	push   %esi
 804a45a:	53                   	push   %ebx
  asm volatile("  \
 804a45b:	8b 45 08             	mov    0x8(%ebp),%eax
 804a45e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804a461:	8b 55 10             	mov    0x10(%ebp),%edx
 804a464:	8b 75 14             	mov    0x14(%ebp),%esi
 804a467:	89 c3                	mov    %eax,%ebx
 804a469:	b8 00 00 00 00       	mov    $0x0,%eax
 804a46e:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_CREATEPROC) ", %%eax; \
    int $80; \
  "::"b"(start),"c"(address_space),"d"(param1),"S"(param2));
}
 804a470:	90                   	nop
 804a471:	5b                   	pop    %ebx
 804a472:	5e                   	pop    %esi
 804a473:	5d                   	pop    %ebp
 804a474:	c3                   	ret    

0804a475 <exit>:

__attribute__((noreturn)) void exit(int code) {
 804a475:	55                   	push   %ebp
 804a476:	89 e5                	mov    %esp,%ebp
 804a478:	53                   	push   %ebx
  code=code&0xff;
 804a479:	81 65 08 ff 00 00 00 	andl   $0xff,0x8(%ebp)
  asm volatile("  \
 804a480:	8b 45 08             	mov    0x8(%ebp),%eax
 804a483:	89 c3                	mov    %eax,%ebx
 804a485:	b8 04 00 00 00       	mov    $0x4,%eax
 804a48a:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_EXIT) ", %%eax; \
    int $80; \
  "::"b"(code));
  for(;;);
 804a48c:	eb fe                	jmp    804a48c <exit+0x17>

0804a48e <block_thread>:
}


void block_thread(thread_state state) {
 804a48e:	55                   	push   %ebp
 804a48f:	89 e5                	mov    %esp,%ebp
 804a491:	53                   	push   %ebx
  asm volatile("  \
 804a492:	8b 45 08             	mov    0x8(%ebp),%eax
 804a495:	89 c3                	mov    %eax,%ebx
 804a497:	b8 02 00 00 00       	mov    $0x2,%eax
 804a49c:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_BLOCK) ", %%eax; \
    int $80; \
  "::"b"(state));
}
 804a49e:	90                   	nop
 804a49f:	5b                   	pop    %ebx
 804a4a0:	5d                   	pop    %ebp
 804a4a1:	c3                   	ret    

0804a4a2 <unblock_thread>:

void unblock_thread(pid_t pid,pid_t tid) {
 804a4a2:	55                   	push   %ebp
 804a4a3:	89 e5                	mov    %esp,%ebp
 804a4a5:	53                   	push   %ebx
  asm volatile("  \
 804a4a6:	8b 45 08             	mov    0x8(%ebp),%eax
 804a4a9:	8b 55 0c             	mov    0xc(%ebp),%edx
 804a4ac:	89 c3                	mov    %eax,%ebx
 804a4ae:	89 d1                	mov    %edx,%ecx
 804a4b0:	b8 03 00 00 00       	mov    $0x3,%eax
 804a4b5:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_UNBLOCK) ", %%eax; \
    int $80; \
  "::"b"(pid),"c"(tid));
}
 804a4b7:	90                   	nop
 804a4b8:	5b                   	pop    %ebx
 804a4b9:	5d                   	pop    %ebp
 804a4ba:	c3                   	ret    

0804a4bb <check_proc_exists>:

char check_proc_exists(pid_t pid) {
 804a4bb:	55                   	push   %ebp
 804a4bc:	89 e5                	mov    %esp,%ebp
 804a4be:	53                   	push   %ebx
 804a4bf:	83 ec 10             	sub    $0x10,%esp
  char exists;
  asm volatile("  \
 804a4c2:	8b 45 08             	mov    0x8(%ebp),%eax
 804a4c5:	89 c3                	mov    %eax,%ebx
 804a4c7:	b8 14 00 00 00       	mov    $0x14,%eax
 804a4cc:	cd 50                	int    $0x50
 804a4ce:	88 c8                	mov    %cl,%al
 804a4d0:	88 45 fb             	mov    %al,-0x5(%ebp)
    mov $" QU(SYSCALL_CHECK_PROC_EXISTS) ", %%eax; \
    int $80; \
  ":"=c"(exists):"b"(pid));
  return exists;
 804a4d3:	8a 45 fb             	mov    -0x5(%ebp),%al
}
 804a4d6:	83 c4 10             	add    $0x10,%esp
 804a4d9:	5b                   	pop    %ebx
 804a4da:	5d                   	pop    %ebp
 804a4db:	c3                   	ret    
 804a4dc:	66 90                	xchg   %ax,%ax
 804a4de:	66 90                	xchg   %ax,%ax

0804a4e0 <__pthread_spin_lock_helper>:
 804a4e0:	8b 5c 24 04          	mov    0x4(%esp),%ebx
 804a4e4:	b8 01 00 00 00       	mov    $0x1,%eax
 804a4e9:	87 03                	xchg   %eax,(%ebx)
 804a4eb:	85 c0                	test   %eax,%eax
 804a4ed:	75 f1                	jne    804a4e0 <__pthread_spin_lock_helper>
 804a4ef:	c3                   	ret    

0804a4f0 <serialize_int>:
#include <serdes.h>
#include <stdlib.h>
#include <string.h>

void serialize_int(int num,serdes_state* state) {
 804a4f0:	55                   	push   %ebp
 804a4f1:	89 e5                	mov    %esp,%ebp
 804a4f3:	83 ec 08             	sub    $0x8,%esp
  state->buf=realloc(state->buf,state->sizeorpos+sizeof(int));
 804a4f6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a4f9:	8b 40 04             	mov    0x4(%eax),%eax
 804a4fc:	8d 50 04             	lea    0x4(%eax),%edx
 804a4ff:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a502:	8b 00                	mov    (%eax),%eax
 804a504:	83 ec 08             	sub    $0x8,%esp
 804a507:	52                   	push   %edx
 804a508:	50                   	push   %eax
 804a509:	e8 7a ec ff ff       	call   8049188 <realloc>
 804a50e:	83 c4 10             	add    $0x10,%esp
 804a511:	8b 55 0c             	mov    0xc(%ebp),%edx
 804a514:	89 02                	mov    %eax,(%edx)
  *((int*)(state->buf+state->sizeorpos))=num;
 804a516:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a519:	8b 10                	mov    (%eax),%edx
 804a51b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a51e:	8b 40 04             	mov    0x4(%eax),%eax
 804a521:	01 c2                	add    %eax,%edx
 804a523:	8b 45 08             	mov    0x8(%ebp),%eax
 804a526:	89 02                	mov    %eax,(%edx)
  state->sizeorpos+=sizeof(int);
 804a528:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a52b:	8b 40 04             	mov    0x4(%eax),%eax
 804a52e:	8d 50 04             	lea    0x4(%eax),%edx
 804a531:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a534:	89 50 04             	mov    %edx,0x4(%eax)
}
 804a537:	90                   	nop
 804a538:	c9                   	leave  
 804a539:	c3                   	ret    

0804a53a <serialize_ptr>:

void serialize_ptr(void* ptr,serdes_state* state) {
 804a53a:	55                   	push   %ebp
 804a53b:	89 e5                	mov    %esp,%ebp
 804a53d:	83 ec 08             	sub    $0x8,%esp
  state->buf=realloc(state->buf,state->sizeorpos+sizeof(void*));
 804a540:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a543:	8b 40 04             	mov    0x4(%eax),%eax
 804a546:	8d 50 04             	lea    0x4(%eax),%edx
 804a549:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a54c:	8b 00                	mov    (%eax),%eax
 804a54e:	83 ec 08             	sub    $0x8,%esp
 804a551:	52                   	push   %edx
 804a552:	50                   	push   %eax
 804a553:	e8 30 ec ff ff       	call   8049188 <realloc>
 804a558:	83 c4 10             	add    $0x10,%esp
 804a55b:	8b 55 0c             	mov    0xc(%ebp),%edx
 804a55e:	89 02                	mov    %eax,(%edx)
  *((void**)(state->buf+state->sizeorpos))=ptr;
 804a560:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a563:	8b 10                	mov    (%eax),%edx
 804a565:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a568:	8b 40 04             	mov    0x4(%eax),%eax
 804a56b:	01 c2                	add    %eax,%edx
 804a56d:	8b 45 08             	mov    0x8(%ebp),%eax
 804a570:	89 02                	mov    %eax,(%edx)
  state->sizeorpos+=sizeof(void*);
 804a572:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a575:	8b 40 04             	mov    0x4(%eax),%eax
 804a578:	8d 50 04             	lea    0x4(%eax),%edx
 804a57b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a57e:	89 50 04             	mov    %edx,0x4(%eax)
}
 804a581:	90                   	nop
 804a582:	c9                   	leave  
 804a583:	c3                   	ret    

0804a584 <serialize_ary>:

void serialize_ary(void* ary,size_t len,serdes_state* state) {
 804a584:	55                   	push   %ebp
 804a585:	89 e5                	mov    %esp,%ebp
 804a587:	83 ec 08             	sub    $0x8,%esp
  state->buf=realloc(state->buf,state->sizeorpos+len);
 804a58a:	8b 45 10             	mov    0x10(%ebp),%eax
 804a58d:	8b 50 04             	mov    0x4(%eax),%edx
 804a590:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a593:	01 c2                	add    %eax,%edx
 804a595:	8b 45 10             	mov    0x10(%ebp),%eax
 804a598:	8b 00                	mov    (%eax),%eax
 804a59a:	83 ec 08             	sub    $0x8,%esp
 804a59d:	52                   	push   %edx
 804a59e:	50                   	push   %eax
 804a59f:	e8 e4 eb ff ff       	call   8049188 <realloc>
 804a5a4:	83 c4 10             	add    $0x10,%esp
 804a5a7:	8b 55 10             	mov    0x10(%ebp),%edx
 804a5aa:	89 02                	mov    %eax,(%edx)
  memcpy(state->buf+state->sizeorpos,ary,len);
 804a5ac:	8b 45 10             	mov    0x10(%ebp),%eax
 804a5af:	8b 10                	mov    (%eax),%edx
 804a5b1:	8b 45 10             	mov    0x10(%ebp),%eax
 804a5b4:	8b 40 04             	mov    0x4(%eax),%eax
 804a5b7:	01 d0                	add    %edx,%eax
 804a5b9:	83 ec 04             	sub    $0x4,%esp
 804a5bc:	ff 75 0c             	push   0xc(%ebp)
 804a5bf:	ff 75 08             	push   0x8(%ebp)
 804a5c2:	50                   	push   %eax
 804a5c3:	e8 cc f9 ff ff       	call   8049f94 <memcpy>
 804a5c8:	83 c4 10             	add    $0x10,%esp
  state->sizeorpos+=len;
 804a5cb:	8b 45 10             	mov    0x10(%ebp),%eax
 804a5ce:	8b 50 04             	mov    0x4(%eax),%edx
 804a5d1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a5d4:	01 c2                	add    %eax,%edx
 804a5d6:	8b 45 10             	mov    0x10(%ebp),%eax
 804a5d9:	89 50 04             	mov    %edx,0x4(%eax)
}
 804a5dc:	90                   	nop
 804a5dd:	c9                   	leave  
 804a5de:	c3                   	ret    

0804a5df <start_deserialize>:


void start_deserialize(char* buf,serdes_state* state) {
 804a5df:	55                   	push   %ebp
 804a5e0:	89 e5                	mov    %esp,%ebp
  state->buf=buf;
 804a5e2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a5e5:	8b 55 08             	mov    0x8(%ebp),%edx
 804a5e8:	89 10                	mov    %edx,(%eax)
  state->sizeorpos=0;
 804a5ea:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a5ed:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
 804a5f4:	90                   	nop
 804a5f5:	5d                   	pop    %ebp
 804a5f6:	c3                   	ret    

0804a5f7 <deserialize_int>:

int deserialize_int(serdes_state* state) {
 804a5f7:	55                   	push   %ebp
 804a5f8:	89 e5                	mov    %esp,%ebp
 804a5fa:	83 ec 10             	sub    $0x10,%esp
  int num=*((int*)(state->buf+state->sizeorpos));
 804a5fd:	8b 45 08             	mov    0x8(%ebp),%eax
 804a600:	8b 10                	mov    (%eax),%edx
 804a602:	8b 45 08             	mov    0x8(%ebp),%eax
 804a605:	8b 40 04             	mov    0x4(%eax),%eax
 804a608:	01 d0                	add    %edx,%eax
 804a60a:	8b 00                	mov    (%eax),%eax
 804a60c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  state->sizeorpos+=sizeof(int);
 804a60f:	8b 45 08             	mov    0x8(%ebp),%eax
 804a612:	8b 40 04             	mov    0x4(%eax),%eax
 804a615:	8d 50 04             	lea    0x4(%eax),%edx
 804a618:	8b 45 08             	mov    0x8(%ebp),%eax
 804a61b:	89 50 04             	mov    %edx,0x4(%eax)
  return num;
 804a61e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804a621:	c9                   	leave  
 804a622:	c3                   	ret    

0804a623 <deserialize_ptr>:

void* deserialize_ptr(serdes_state* state) {
 804a623:	55                   	push   %ebp
 804a624:	89 e5                	mov    %esp,%ebp
 804a626:	83 ec 10             	sub    $0x10,%esp
  void* ptr=*((void**)(state->buf+state->sizeorpos));
 804a629:	8b 45 08             	mov    0x8(%ebp),%eax
 804a62c:	8b 10                	mov    (%eax),%edx
 804a62e:	8b 45 08             	mov    0x8(%ebp),%eax
 804a631:	8b 40 04             	mov    0x4(%eax),%eax
 804a634:	01 d0                	add    %edx,%eax
 804a636:	8b 00                	mov    (%eax),%eax
 804a638:	89 45 fc             	mov    %eax,-0x4(%ebp)
  state->sizeorpos+=sizeof(void*);
 804a63b:	8b 45 08             	mov    0x8(%ebp),%eax
 804a63e:	8b 40 04             	mov    0x4(%eax),%eax
 804a641:	8d 50 04             	lea    0x4(%eax),%edx
 804a644:	8b 45 08             	mov    0x8(%ebp),%eax
 804a647:	89 50 04             	mov    %edx,0x4(%eax)
  return ptr;
 804a64a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804a64d:	c9                   	leave  
 804a64e:	c3                   	ret    

0804a64f <deserialize_ary>:

void* deserialize_ary(size_t len,serdes_state* state) {
 804a64f:	55                   	push   %ebp
 804a650:	89 e5                	mov    %esp,%ebp
 804a652:	83 ec 10             	sub    $0x10,%esp
  void* ary=((void*)(state->buf+state->sizeorpos));
 804a655:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a658:	8b 10                	mov    (%eax),%edx
 804a65a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a65d:	8b 40 04             	mov    0x4(%eax),%eax
 804a660:	01 d0                	add    %edx,%eax
 804a662:	89 45 fc             	mov    %eax,-0x4(%ebp)
  state->sizeorpos+=len;
 804a665:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a668:	8b 50 04             	mov    0x4(%eax),%edx
 804a66b:	8b 45 08             	mov    0x8(%ebp),%eax
 804a66e:	01 c2                	add    %eax,%edx
 804a670:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a673:	89 50 04             	mov    %edx,0x4(%eax)
  return ary;
 804a676:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804a679:	c9                   	leave  
 804a67a:	c3                   	ret    
 804a67b:	90                   	nop
 804a67c:	a1 fc ff ff ff       	mov    0xfffffffc,%eax
 804a681:	83 f8 ff             	cmp    $0xffffffff,%eax
 804a684:	74 1a                	je     804a6a0 <deserialize_ary+0x51>
 804a686:	55                   	push   %ebp
 804a687:	89 e5                	mov    %esp,%ebp
 804a689:	53                   	push   %ebx
 804a68a:	52                   	push   %edx
 804a68b:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
 804a690:	ff d0                	call   *%eax
 804a692:	83 eb 04             	sub    $0x4,%ebx
 804a695:	8b 03                	mov    (%ebx),%eax
 804a697:	83 f8 ff             	cmp    $0xffffffff,%eax
 804a69a:	75 f4                	jne    804a690 <deserialize_ary+0x41>
 804a69c:	58                   	pop    %eax
 804a69d:	5b                   	pop    %ebx
 804a69e:	5d                   	pop    %ebp
 804a69f:	c3                   	ret    
 804a6a0:	c3                   	ret    

Disassembly of section .fini:

0804a6a1 <.fini>:
 804a6a1:	e8 60 00 00 00       	call   804a706 <deserialize_ary+0xb7>
 804a6a6:	c2 00 00             	ret    $0x0
