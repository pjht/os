
kernel/kernel.elf:	file format ELF32-i386

Disassembly of section .text:
header_start:
c0100000:	d6 	salc
c0100001:	50 	pushl	%eax
c0100002:	52 	pushl	%edx
c0100003:	e8 00 00 00 00 	calll	0 <header_start+0x8>
c0100008:	40 	incl	%eax
c0100009:	00 00 	addb	%al, (%eax)
c010000b:	00 ea 	addb	%ch, %dl
c010000d:	ae 	scasb	%es:(%edi), %al
c010000e:	ad 	lodsl	(%esi), %eax
c010000f:	17 	popl	%ss

info_tag_start:
c0100010:	01 00 	addl	%eax, (%eax)
c0100012:	00 00 	addb	%al, (%eax)
c0100014:	10 00 	adcb	%al, (%eax)
c0100016:	00 00 	addb	%al, (%eax)
c0100018:	04 00 	addb	$0, %al
c010001a:	00 00 	addb	%al, (%eax)
c010001c:	06 	pushl	%es
c010001d:	00 00 	addb	%al, (%eax)
c010001f:	00 03 	addb	%al, (%ebx)

info_tag_end:
c0100020:	03 00 	addl	(%eax), %eax
c0100022:	00 00 	addb	%al, (%eax)
c0100024:	0c 00 	orb	$0, %al
c0100026:	00 00 	addb	%al, (%eax)
c0100028:	e8 03 10 00 00 	calll	4099 <isr_handler+0x2c7>
c010002d:	00 00 	addb	%al, (%eax)
c010002f:	00 06 	addb	%al, (%esi)
c0100031:	00 00 	addb	%al, (%eax)
c0100033:	00 08 	addb	%cl, (%eax)
c0100035:	00 00 	addb	%al, (%eax)
c0100037:	00 00 	addb	%al, (%eax)
c0100039:	00 00 	addb	%al, (%eax)
c010003b:	00 08 	addb	%cl, (%eax)
c010003d:	00 00 	addb	%al, (%eax)
c010003f:	00 55 89 	addb	%dl, -119(%ebp)

read_initrd:
; static void read_initrd(struct multiboot_boot_header_tag* tags) {
c0100040:	55 	pushl	%ebp
c0100041:	89 e5 	movl	%esp, %ebp
c0100043:	83 ec 18 	subl	$24, %esp
; struct multiboot_tag* tag=(struct multiboot_tag*)(tags+1);
c0100046:	8b 45 08 	movl	8(%ebp), %eax
c0100049:	83 c0 08 	addl	$8, %eax
c010004c:	89 45 f4 	movl	%eax, -12(%ebp)
; while (tag->type!=0) {
c010004f:	e9 85 00 00 00 	jmp	133 <read_initrd+0x99>
; switch (tag->type) {
c0100054:	8b 45 f4 	movl	-12(%ebp), %eax
c0100057:	8b 00 	movl	(%eax), %eax
c0100059:	83 f8 03 	cmpl	$3, %eax
c010005c:	75 6c 	jne	108 <read_initrd+0x8a>
; struct multiboot_tag_module* mod=(struct multiboot_tag_module*) tag;
c010005e:	8b 45 f4 	movl	-12(%ebp), %eax
c0100061:	89 45 f0 	movl	%eax, -16(%ebp)
; initrd=malloc(sizeof(char)*(mod->mod_end-mod->mod_start));
c0100064:	8b 45 f0 	movl	-16(%ebp), %eax
c0100067:	8b 50 0c 	movl	12(%eax), %edx
c010006a:	8b 45 f0 	movl	-16(%ebp), %eax
c010006d:	8b 40 08 	movl	8(%eax), %eax
c0100070:	29 c2 	subl	%eax, %edx
c0100072:	89 d0 	movl	%edx, %eax
c0100074:	83 ec 0c 	subl	$12, %esp
c0100077:	50 	pushl	%eax
c0100078:	e8 19 2d 00 00 	calll	11545 <malloc>
c010007d:	83 c4 10 	addl	$16, %esp
c0100080:	a3 78 90 10 c0 	movl	%eax, 3222311032
; initrd_sz=mod->mod_end-mod->mod_start;
c0100085:	8b 45 f0 	movl	-16(%ebp), %eax
c0100088:	8b 50 0c 	movl	12(%eax), %edx
c010008b:	8b 45 f0 	movl	-16(%ebp), %eax
c010008e:	8b 40 08 	movl	8(%eax), %eax
c0100091:	29 c2 	subl	%eax, %edx
c0100093:	89 d0 	movl	%edx, %eax
c0100095:	a3 74 90 10 c0 	movl	%eax, 3222311028
; memcpy(initrd,(void*)(mod->mod_start+0xC0000000),mod->mod_end-mod->mod_start);
c010009a:	8b 45 f0 	movl	-16(%ebp), %eax
c010009d:	8b 50 0c 	movl	12(%eax), %edx
c01000a0:	8b 45 f0 	movl	-16(%ebp), %eax
c01000a3:	8b 40 08 	movl	8(%eax), %eax
c01000a6:	89 d1 	movl	%edx, %ecx
c01000a8:	29 c1 	subl	%eax, %ecx
c01000aa:	8b 45 f0 	movl	-16(%ebp), %eax
c01000ad:	8b 40 08 	movl	8(%eax), %eax
c01000b0:	2d 00 00 00 40 	subl	$1073741824, %eax
c01000b5:	89 c2 	movl	%eax, %edx
c01000b7:	a1 78 90 10 c0 	movl	3222311032, %eax
c01000bc:	83 ec 04 	subl	$4, %esp
c01000bf:	51 	pushl	%ecx
c01000c0:	52 	pushl	%edx
c01000c1:	50 	pushl	%eax
c01000c2:	e8 d0 2f 00 00 	calll	12240 <memcpy>
c01000c7:	83 c4 10 	addl	$16, %esp
; tag=(struct multiboot_tag*)((char*)tag+((tag->size+7)&0xFFFFFFF8));
c01000ca:	8b 45 f4 	movl	-12(%ebp), %eax
c01000cd:	8b 40 04 	movl	4(%eax), %eax
c01000d0:	83 c0 07 	addl	$7, %eax
c01000d3:	83 e0 f8 	andl	$-8, %eax
c01000d6:	01 45 f4 	addl	%eax, -12(%ebp)
; while (tag->type!=0) {
c01000d9:	8b 45 f4 	movl	-12(%ebp), %eax
c01000dc:	8b 00 	movl	(%eax), %eax
c01000de:	85 c0 	testl	%eax, %eax
c01000e0:	0f 85 6e ff ff ff 	jne	-146 <read_initrd+0x14>
; }
c01000e6:	90 	nop
c01000e7:	c9 	leave
c01000e8:	c3 	retl

getsize:
; uint32_t getsize(const char *in) {
c01000e9:	55 	pushl	%ebp
c01000ea:	89 e5 	movl	%esp, %ebp
c01000ec:	83 ec 10 	subl	$16, %esp
; uint32_t size=0;
c01000ef:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
; uint32_t count=1;
c01000f6:	c7 45 f4 01 00 00 00 	movl	$1, -12(%ebp)
; for (j=11;j>0;j--,count*=8) {
c01000fd:	c7 45 f8 0b 00 00 00 	movl	$11, -8(%ebp)
c0100104:	eb 21 	jmp	33 <getsize+0x3e>
; size+=((in[j-1]-'0')*count);
c0100106:	8b 45 f8 	movl	-8(%ebp), %eax
c0100109:	8d 50 ff 	leal	-1(%eax), %edx
c010010c:	8b 45 08 	movl	8(%ebp), %eax
c010010f:	01 d0 	addl	%edx, %eax
c0100111:	8a 00 	movb	(%eax), %al
c0100113:	0f be c0 	movsbl	%al, %eax
c0100116:	83 e8 30 	subl	$48, %eax
c0100119:	0f af 45 f4 	imull	-12(%ebp), %eax
c010011d:	01 45 fc 	addl	%eax, -4(%ebp)
; for (j=11;j>0;j--,count*=8) {
c0100120:	ff 4d f8 	decl	-8(%ebp)
c0100123:	c1 65 f4 03 	shll	$3, -12(%ebp)
c0100127:	83 7d f8 00 	cmpl	$0, -8(%ebp)
c010012b:	75 d9 	jne	-39 <getsize+0x1d>
; return size;
c010012d:	8b 45 fc 	movl	-4(%ebp), %eax
; }
c0100130:	c9 	leave
c0100131:	c3 	retl

kmain:
; void kmain(struct multiboot_boot_header_tag* hdr) {
c0100132:	55 	pushl	%ebp
c0100133:	89 e5 	movl	%esp, %ebp
c0100135:	81 ec 98 00 00 00 	subl	$152, %esp
; tags=hdr;
c010013b:	8b 45 08 	movl	8(%ebp), %eax
c010013e:	a3 7c 90 10 c0 	movl	%eax, 3222311036
; cpu_init(tags);
c0100143:	a1 7c 90 10 c0 	movl	3222311036, %eax
c0100148:	83 ec 0c 	subl	$12, %esp
c010014b:	50 	pushl	%eax
c010014c:	e8 9a 04 00 00 	calll	1178 <cpu_init>
c0100151:	83 c4 10 	addl	$16, %esp
; vga_init((char*)0xC00B8000);
c0100154:	83 ec 0c 	subl	$12, %esp
c0100157:	68 00 80 0b c0 	pushl	$3221979136
c010015c:	e8 4b 03 00 00 	calll	843 <vga_init>
c0100161:	83 c4 10 	addl	$16, %esp
; read_initrd(tags);
c0100164:	a1 7c 90 10 c0 	movl	3222311036, %eax
c0100169:	83 ec 0c 	subl	$12, %esp
c010016c:	50 	pushl	%eax
c010016d:	e8 ce fe ff ff 	calll	-306 <read_initrd>
c0100172:	83 c4 10 	addl	$16, %esp
; int pos=0;
c0100175:	c7 45 f4 00 00 00 00 	movl	$0, -12(%ebp)
; for (int i=0;;i++) {
c010017c:	c7 45 ec 00 00 00 00 	movl	$0, -20(%ebp)
; tar_hdr=(tar_header*)&initrd[pos];
c0100183:	8b 15 78 90 10 c0 	movl	-1072656264, %edx
c0100189:	8b 45 f4 	movl	-12(%ebp), %eax
c010018c:	01 d0 	addl	%edx, %eax
c010018e:	89 45 d8 	movl	%eax, -40(%ebp)
; if (tar_hdr->filename[0]=='\0') break;
c0100191:	8b 45 d8 	movl	-40(%ebp), %eax
c0100194:	8a 00 	movb	(%eax), %al
c0100196:	84 c0 	testb	%al, %al
c0100198:	74 7a 	je	122 <kmain+0xe2>
; uint32_t size=getsize(tar_hdr->size);
c010019a:	8b 45 d8 	movl	-40(%ebp), %eax
c010019d:	83 c0 7c 	addl	$124, %eax
c01001a0:	83 ec 0c 	subl	$12, %esp
c01001a3:	50 	pushl	%eax
c01001a4:	e8 40 ff ff ff 	calll	-192 <getsize>
c01001a9:	83 c4 10 	addl	$16, %esp
c01001ac:	89 45 d4 	movl	%eax, -44(%ebp)
; pos+=512;
c01001af:	81 45 f4 00 02 00 00 	addl	$512, -12(%ebp)
; if (strcmp(&tar_hdr->filename[0],"init")==0) {
c01001b6:	8b 45 d8 	movl	-40(%ebp), %eax
c01001b9:	83 ec 08 	subl	$8, %esp
c01001bc:	68 00 40 10 c0 	pushl	$3222290432
c01001c1:	50 	pushl	%eax
c01001c2:	e8 41 2f 00 00 	calll	12097 <strcmp>
c01001c7:	83 c4 10 	addl	$16, %esp
c01001ca:	85 c0 	testl	%eax, %eax
c01001cc:	75 08 	jne	8 <kmain+0xa4>
; datapos=pos;
c01001ce:	8b 45 f4 	movl	-12(%ebp), %eax
c01001d1:	89 45 f0 	movl	%eax, -16(%ebp)
; break;
c01001d4:	eb 3f 	jmp	63 <kmain+0xe3>
; pos+=size;
c01001d6:	8b 55 f4 	movl	-12(%ebp), %edx
c01001d9:	8b 45 d4 	movl	-44(%ebp), %eax
c01001dc:	01 d0 	addl	%edx, %eax
c01001de:	89 45 f4 	movl	%eax, -12(%ebp)
; if (pos%512!=0) {
c01001e1:	8b 45 f4 	movl	-12(%ebp), %eax
c01001e4:	25 ff 01 00 00 	andl	$511, %eax
c01001e9:	85 c0 	testl	%eax, %eax
c01001eb:	74 1f 	je	31 <kmain+0xda>
; pos+=512-(pos%512);
c01001ed:	8b 45 f4 	movl	-12(%ebp), %eax
c01001f0:	25 ff 01 00 80 	andl	$2147484159, %eax
c01001f5:	85 c0 	testl	%eax, %eax
c01001f7:	79 07 	jns	7 <kmain+0xce>
c01001f9:	48 	decl	%eax
c01001fa:	0d 00 fe ff ff 	orl	$4294966784, %eax
c01001ff:	40 	incl	%eax
c0100200:	ba 00 02 00 00 	movl	$512, %edx
c0100205:	29 c2 	subl	%eax, %edx
c0100207:	89 d0 	movl	%edx, %eax
c0100209:	01 45 f4 	addl	%eax, -12(%ebp)
; for (int i=0;;i++) {
c010020c:	ff 45 ec 	incl	-20(%ebp)
c010020f:	e9 6f ff ff ff 	jmp	-145 <kmain+0x51>
; if (tar_hdr->filename[0]=='\0') break;
c0100214:	90 	nop
; pos=datapos;
c0100215:	8b 45 f0 	movl	-16(%ebp), %eax
c0100218:	89 45 f4 	movl	%eax, -12(%ebp)
; char* hdr_ptr=(char*)&header;
c010021b:	8d 45 8c 	leal	-116(%ebp), %eax
c010021e:	89 45 d0 	movl	%eax, -48(%ebp)
; for (size_t i=0;i<sizeof(elf_header);i++) {
c0100221:	c7 45 e8 00 00 00 00 	movl	$0, -24(%ebp)
c0100228:	eb 1d 	jmp	29 <kmain+0x115>
; hdr_ptr[i]=initrd[pos];
c010022a:	8b 15 78 90 10 c0 	movl	-1072656264, %edx
c0100230:	8b 45 f4 	movl	-12(%ebp), %eax
c0100233:	01 d0 	addl	%edx, %eax
c0100235:	8b 4d d0 	movl	-48(%ebp), %ecx
c0100238:	8b 55 e8 	movl	-24(%ebp), %edx
c010023b:	01 ca 	addl	%ecx, %edx
c010023d:	8a 00 	movb	(%eax), %al
c010023f:	88 02 	movb	%al, (%edx)
; pos++;
c0100241:	ff 45 f4 	incl	-12(%ebp)
; for (size_t i=0;i<sizeof(elf_header);i++) {
c0100244:	ff 45 e8 	incl	-24(%ebp)
c0100247:	83 7d e8 33 	cmpl	$51, -24(%ebp)
c010024b:	76 dd 	jbe	-35 <kmain+0xf8>
; if (header.magic!=ELF_MAGIC) {
c010024d:	8b 45 8c 	movl	-116(%ebp), %eax
c0100250:	3d 7f 45 4c 46 	cmpl	$1179403647, %eax
c0100255:	74 15 	je	21 <kmain+0x13a>
; vga_write_string("[INFO] Invalid magic number for prog.elf\n");
c0100257:	83 ec 0c 	subl	$12, %esp
c010025a:	68 08 40 10 c0 	pushl	$3222290440
c010025f:	e8 56 02 00 00 	calll	598 <vga_write_string>
c0100264:	83 c4 10 	addl	$16, %esp
; }
c0100267:	e9 7a 01 00 00 	jmp	378 <kmain+0x2b4>
; void* cr3=new_address_space();
c010026c:	e8 5e 28 00 00 	calll	10334 <new_address_space>
c0100271:	89 45 cc 	movl	%eax, -52(%ebp)
; for (int i=0;i<header.pheader_ent_nm;i++) {
c0100274:	c7 45 e4 00 00 00 00 	movl	$0, -28(%ebp)
c010027b:	e9 de 00 00 00 	jmp	222 <kmain+0x22c>
; pos=(header.prog_hdr)+(header.pheader_ent_sz*i)+datapos;
c0100280:	8b 55 a8 	movl	-88(%ebp), %edx
c0100283:	66 8b 45 b6 	movw	-74(%ebp), %ax
c0100287:	0f b7 c0 	movzwl	%ax, %eax
c010028a:	0f af 45 e4 	imull	-28(%ebp), %eax
c010028e:	01 c2 	addl	%eax, %edx
c0100290:	8b 45 f0 	movl	-16(%ebp), %eax
c0100293:	01 d0 	addl	%edx, %eax
c0100295:	89 45 f4 	movl	%eax, -12(%ebp)
; char* phdr_ptr=(char*)&pheader;
c0100298:	8d 85 6c ff ff ff 	leal	-148(%ebp), %eax
c010029e:	89 45 c8 	movl	%eax, -56(%ebp)
; for (size_t i=0;i<sizeof(elf_pheader);i++) {
c01002a1:	c7 45 e0 00 00 00 00 	movl	$0, -32(%ebp)
c01002a8:	eb 1d 	jmp	29 <kmain+0x195>
; phdr_ptr[i]=initrd[pos];
c01002aa:	8b 15 78 90 10 c0 	movl	-1072656264, %edx
c01002b0:	8b 45 f4 	movl	-12(%ebp), %eax
c01002b3:	01 d0 	addl	%edx, %eax
c01002b5:	8b 4d c8 	movl	-56(%ebp), %ecx
c01002b8:	8b 55 e0 	movl	-32(%ebp), %edx
c01002bb:	01 ca 	addl	%ecx, %edx
c01002bd:	8a 00 	movb	(%eax), %al
c01002bf:	88 02 	movb	%al, (%edx)
; pos++;
c01002c1:	ff 45 f4 	incl	-12(%ebp)
; for (size_t i=0;i<sizeof(elf_pheader);i++) {
c01002c4:	ff 45 e0 	incl	-32(%ebp)
c01002c7:	83 7d e0 1f 	cmpl	$31, -32(%ebp)
c01002cb:	76 dd 	jbe	-35 <kmain+0x178>
; char* ptr=alloc_memory(((pheader.memsz)/4096)+1);
c01002cd:	8b 45 80 	movl	-128(%ebp), %eax
c01002d0:	c1 e8 0c 	shrl	$12, %eax
c01002d3:	40 	incl	%eax
c01002d4:	83 ec 0c 	subl	$12, %esp
c01002d7:	50 	pushl	%eax
c01002d8:	e8 b8 27 00 00 	calll	10168 <alloc_memory>
c01002dd:	83 c4 10 	addl	$16, %esp
c01002e0:	89 45 c4 	movl	%eax, -60(%ebp)
; memset(ptr,0,pheader.memsz);
c01002e3:	8b 45 80 	movl	-128(%ebp), %eax
c01002e6:	83 ec 04 	subl	$4, %esp
c01002e9:	50 	pushl	%eax
c01002ea:	6a 00 	pushl	$0
c01002ec:	ff 75 c4 	pushl	-60(%ebp)
c01002ef:	e8 e2 2d 00 00 	calll	11746 <memset>
c01002f4:	83 c4 10 	addl	$16, %esp
; if (pheader.filesz>0) {
c01002f7:	8b 85 7c ff ff ff 	movl	-132(%ebp), %eax
c01002fd:	85 c0 	testl	%eax, %eax
c01002ff:	74 3f 	je	63 <kmain+0x20e>
; pos=pheader.offset+datapos;
c0100301:	8b 95 70 ff ff ff 	movl	-144(%ebp), %edx
c0100307:	8b 45 f0 	movl	-16(%ebp), %eax
c010030a:	01 d0 	addl	%edx, %eax
c010030c:	89 45 f4 	movl	%eax, -12(%ebp)
; for (size_t i=0;i<pheader.filesz;i++) {
c010030f:	c7 45 dc 00 00 00 00 	movl	$0, -36(%ebp)
c0100316:	eb 1d 	jmp	29 <kmain+0x203>
; ptr[i]=initrd[pos];
c0100318:	8b 15 78 90 10 c0 	movl	-1072656264, %edx
c010031e:	8b 45 f4 	movl	-12(%ebp), %eax
c0100321:	01 d0 	addl	%edx, %eax
c0100323:	8b 4d c4 	movl	-60(%ebp), %ecx
c0100326:	8b 55 dc 	movl	-36(%ebp), %edx
c0100329:	01 ca 	addl	%ecx, %edx
c010032b:	8a 00 	movb	(%eax), %al
c010032d:	88 02 	movb	%al, (%edx)
; pos++;
c010032f:	ff 45 f4 	incl	-12(%ebp)
; for (size_t i=0;i<pheader.filesz;i++) {
c0100332:	ff 45 dc 	incl	-36(%ebp)
c0100335:	8b 85 7c ff ff ff 	movl	-132(%ebp), %eax
c010033b:	39 45 dc 	cmpl	%eax, -36(%ebp)
c010033e:	72 d8 	jb	-40 <kmain+0x1e6>
; copy_data(cr3,ptr,pheader.memsz,(void*)pheader.vaddr);
c0100340:	8b 85 74 ff ff ff 	movl	-140(%ebp), %eax
c0100346:	89 c2 	movl	%eax, %edx
c0100348:	8b 45 80 	movl	-128(%ebp), %eax
c010034b:	52 	pushl	%edx
c010034c:	50 	pushl	%eax
c010034d:	ff 75 c4 	pushl	-60(%ebp)
c0100350:	ff 75 cc 	pushl	-52(%ebp)
c0100353:	e8 93 27 00 00 	calll	10131 <copy_data>
c0100358:	83 c4 10 	addl	$16, %esp
; for (int i=0;i<header.pheader_ent_nm;i++) {
c010035b:	ff 45 e4 	incl	-28(%ebp)
c010035e:	8b 45 b8 	movl	-72(%ebp), %eax
c0100361:	0f b7 c0 	movzwl	%ax, %eax
c0100364:	39 45 e4 	cmpl	%eax, -28(%ebp)
c0100367:	0f 8c 13 ff ff ff 	jl	-237 <kmain+0x14e>
; char* initrd2=alloc_memory((initrd_sz/4096)+1);
c010036d:	a1 74 90 10 c0 	movl	3222311028, %eax
c0100372:	85 c0 	testl	%eax, %eax
c0100374:	79 05 	jns	5 <kmain+0x249>
c0100376:	05 ff 0f 00 00 	addl	$4095, %eax
c010037b:	c1 f8 0c 	sarl	$12, %eax
c010037e:	40 	incl	%eax
c010037f:	83 ec 0c 	subl	$12, %esp
c0100382:	50 	pushl	%eax
c0100383:	e8 0d 27 00 00 	calll	9997 <alloc_memory>
c0100388:	83 c4 10 	addl	$16, %esp
c010038b:	89 45 c0 	movl	%eax, -64(%ebp)
; memcpy(initrd2,initrd,initrd_sz);
c010038e:	a1 74 90 10 c0 	movl	3222311028, %eax
c0100393:	89 c2 	movl	%eax, %edx
c0100395:	a1 78 90 10 c0 	movl	3222311032, %eax
c010039a:	83 ec 04 	subl	$4, %esp
c010039d:	52 	pushl	%edx
c010039e:	50 	pushl	%eax
c010039f:	ff 75 c0 	pushl	-64(%ebp)
c01003a2:	e8 f0 2c 00 00 	calll	11504 <memcpy>
c01003a7:	83 c4 10 	addl	$16, %esp
; initrd2=put_data(cr3,initrd2,initrd_sz);
c01003aa:	a1 74 90 10 c0 	movl	3222311028, %eax
c01003af:	83 ec 04 	subl	$4, %esp
c01003b2:	50 	pushl	%eax
c01003b3:	ff 75 c0 	pushl	-64(%ebp)
c01003b6:	ff 75 cc 	pushl	-52(%ebp)
c01003b9:	e8 4c 27 00 00 	calll	10060 <put_data>
c01003be:	83 c4 10 	addl	$16, %esp
c01003c1:	89 45 c0 	movl	%eax, -64(%ebp)
; createTaskCr3Param((void*)header.entry,cr3,(uint32_t)initrd2,initrd_sz);
c01003c4:	a1 74 90 10 c0 	movl	3222311028, %eax
c01003c9:	89 c1 	movl	%eax, %ecx
c01003cb:	8b 45 c0 	movl	-64(%ebp), %eax
c01003ce:	8b 55 a4 	movl	-92(%ebp), %edx
c01003d1:	51 	pushl	%ecx
c01003d2:	50 	pushl	%eax
c01003d3:	ff 75 cc 	pushl	-52(%ebp)
c01003d6:	52 	pushl	%edx
c01003d7:	e8 9c 31 00 00 	calll	12700 <createTaskCr3Param>
c01003dc:	83 c4 10 	addl	$16, %esp
; yield();
c01003df:	e8 5a 31 00 00 	calll	12634 <yield>
c01003e4:	eb f9 	jmp	-7 <kmain+0x2ad>
; }
c01003e6:	c9 	leave
c01003e7:	c3 	retl

_start:
c01003e8:	3d 89 62 d7 36 	cmpl	$920085129, %eax
c01003ed:	0f 85 85 00 00 00 	jne	133 <no_multiboot>
c01003f3:	bf 00 b0 10 00 	movl	$1093632, %edi
c01003f8:	be 00 00 00 00 	movl	$0, %esi
c01003fd:	b9 00 08 00 00 	movl	$2048, %ecx
c0100402:	89 f2 	movl	%esi, %edx
c0100404:	83 ca 07 	orl	$7, %edx
c0100407:	89 17 	movl	%edx, (%edi)
c0100409:	81 c6 00 10 00 00 	addl	$4096, %esi
c010040f:	83 c7 04 	addl	$4, %edi
c0100412:	e2 ee 	loop	-18
c0100414:	c7 05 00 a0 10 00 07 b0 10 00 	movl	$1093639, 1089536
c010041e:	c7 05 00 ac 10 00 07 b0 10 00 	movl	$1093639, 1092608
c0100428:	c7 05 04 ac 10 00 07 c0 10 00 	movl	$1097735, 1092612
c0100432:	b9 00 a0 10 00 	movl	$1089536, %ecx
c0100437:	0f 22 d9 	movl	%ecx, %cr3
c010043a:	0f 20 c1 	movl	%cr0, %ecx
c010043d:	81 c9 00 00 01 80 	orl	$2147549184, %ecx
c0100443:	0f 22 c1 	movl	%ecx, %cr0
c0100446:	0f 20 e1 	movl	%cr4, %ecx
c0100449:	83 c9 10 	orl	$16, %ecx
c010044c:	0f 22 e1 	movl	%ecx, %cr4
c010044f:	8d 0d 57 04 10 c0 	leal	-1072692137, %ecx
c0100455:	ff e1 	jmpl	*%ecx
c0100457:	c7 05 00 a0 10 c0 00 00 00 00 	movl	$0, -1072652288
c0100461:	0f 20 d9 	movl	%cr3, %ecx
c0100464:	0f 22 d9 	movl	%ecx, %cr3
c0100467:	bc 2c c8 35 c0 	movl	$3224750124, %esp
c010046c:	81 c3 00 00 00 c0 	addl	$3221225472, %ebx
c0100472:	53 	pushl	%ebx
c0100473:	e8 ba fc ff ff 	calll	-838 <kmain>

no_multiboot:
c0100478:	eb fe 	jmp	-2 <no_multiboot>

set_char:
; static void set_char(int x,char c) {
c010047a:	55 	pushl	%ebp
c010047b:	89 e5 	movl	%esp, %ebp
c010047d:	83 ec 04 	subl	$4, %esp
c0100480:	8b 45 0c 	movl	12(%ebp), %eax
c0100483:	88 45 fc 	movb	%al, -4(%ebp)
; screen[x*2]=c;
c0100486:	8b 15 00 d0 10 c0 	movl	-1072640000, %edx
c010048c:	8b 45 08 	movl	8(%ebp), %eax
c010048f:	01 c0 	addl	%eax, %eax
c0100491:	01 c2 	addl	%eax, %edx
c0100493:	8a 45 fc 	movb	-4(%ebp), %al
c0100496:	88 02 	movb	%al, (%edx)
; screen[x*2+1]=(VGA_BLACK<<4)|VGA_WHITE;
c0100498:	8b 15 00 d0 10 c0 	movl	-1072640000, %edx
c010049e:	8b 45 08 	movl	8(%ebp), %eax
c01004a1:	01 c0 	addl	%eax, %eax
c01004a3:	40 	incl	%eax
c01004a4:	01 d0 	addl	%edx, %eax
c01004a6:	c6 00 0f 	movb	$15, (%eax)
; }
c01004a9:	90 	nop
c01004aa:	c9 	leave
c01004ab:	c3 	retl

vga_init:
; void vga_init(char* addr) {
c01004ac:	55 	pushl	%ebp
c01004ad:	89 e5 	movl	%esp, %ebp
; screen=addr;
c01004af:	8b 45 08 	movl	8(%ebp), %eax
c01004b2:	a3 00 d0 10 c0 	movl	%eax, 3222327296
; }
c01004b7:	90 	nop
c01004b8:	5d 	popl	%ebp
c01004b9:	c3 	retl

vga_write_string:
; void vga_write_string(const char* string) {
c01004ba:	55 	pushl	%ebp
c01004bb:	89 e5 	movl	%esp, %ebp
c01004bd:	83 ec 18 	subl	$24, %esp
; for (size_t i=0;i<strlen(string);i++) {
c01004c0:	c7 45 f4 00 00 00 00 	movl	$0, -12(%ebp)
c01004c7:	eb 3b 	jmp	59 <vga_write_string+0x4a>
; if (string[i]=='\n') continue;
c01004c9:	8b 55 08 	movl	8(%ebp), %edx
c01004cc:	8b 45 f4 	movl	-12(%ebp), %eax
c01004cf:	01 d0 	addl	%edx, %eax
c01004d1:	8a 00 	movb	(%eax), %al
c01004d3:	3c 0a 	cmpb	$10, %al
c01004d5:	74 29 	je	41 <vga_write_string+0x46>
; set_char(x,string[i]);
c01004d7:	8b 55 08 	movl	8(%ebp), %edx
c01004da:	8b 45 f4 	movl	-12(%ebp), %eax
c01004dd:	01 d0 	addl	%edx, %eax
c01004df:	8a 00 	movb	(%eax), %al
c01004e1:	0f be d0 	movsbl	%al, %edx
c01004e4:	a1 04 d0 10 c0 	movl	3222327300, %eax
c01004e9:	52 	pushl	%edx
c01004ea:	50 	pushl	%eax
c01004eb:	e8 8a ff ff ff 	calll	-118 <set_char>
c01004f0:	83 c4 08 	addl	$8, %esp
; x++;
c01004f3:	a1 04 d0 10 c0 	movl	3222327300, %eax
c01004f8:	40 	incl	%eax
c01004f9:	a3 04 d0 10 c0 	movl	%eax, 3222327300
c01004fe:	eb 01 	jmp	1 <vga_write_string+0x47>
; if (string[i]=='\n') continue;
c0100500:	90 	nop
; for (size_t i=0;i<strlen(string);i++) {
c0100501:	ff 45 f4 	incl	-12(%ebp)
c0100504:	83 ec 0c 	subl	$12, %esp
c0100507:	ff 75 08 	pushl	8(%ebp)
c010050a:	e8 58 2c 00 00 	calll	11352 <strlen>
c010050f:	83 c4 10 	addl	$16, %esp
c0100512:	39 45 f4 	cmpl	%eax, -12(%ebp)
c0100515:	72 b2 	jb	-78 <vga_write_string+0xf>
; }
c0100517:	90 	nop
c0100518:	c9 	leave
c0100519:	c3 	retl

address_spaces_copy_data:
; void address_spaces_copy_data(void* cr3, void* data,uint32_t size,void* virt_addr) {
c010051a:	55 	pushl	%ebp
c010051b:	89 e5 	movl	%esp, %ebp
c010051d:	83 ec 18 	subl	$24, %esp
; asm volatile("movl %%cr3, %%eax; movl %%eax, %0;":"=m"(old_cr3)::"%eax");
c0100520:	0f 20 d8 	movl	%cr3, %eax
c0100523:	89 45 f0 	movl	%eax, -16(%ebp)
; void* phys_addr=virt_to_phys(data);
c0100526:	83 ec 0c 	subl	$12, %esp
c0100529:	ff 75 0c 	pushl	12(%ebp)
c010052c:	e8 95 15 00 00 	calll	5525 <virt_to_phys>
c0100531:	83 c4 10 	addl	$16, %esp
c0100534:	89 45 f4 	movl	%eax, -12(%ebp)
; load_smap((uint32_t)cr3);
c0100537:	8b 45 08 	movl	8(%ebp), %eax
c010053a:	83 ec 0c 	subl	$12, %esp
c010053d:	50 	pushl	%eax
c010053e:	e8 26 17 00 00 	calll	5926 <load_smap>
c0100543:	83 c4 10 	addl	$16, %esp
; map_pages(virt_addr,phys_addr,(size/4096)+1,1,1);
c0100546:	8b 45 10 	movl	16(%ebp), %eax
c0100549:	c1 e8 0c 	shrl	$12, %eax
c010054c:	40 	incl	%eax
c010054d:	83 ec 0c 	subl	$12, %esp
c0100550:	6a 01 	pushl	$1
c0100552:	6a 01 	pushl	$1
c0100554:	50 	pushl	%eax
c0100555:	ff 75 f4 	pushl	-12(%ebp)
c0100558:	ff 75 14 	pushl	20(%ebp)
c010055b:	e8 fe 12 00 00 	calll	4862 <map_pages>
c0100560:	83 c4 20 	addl	$32, %esp
; load_smap(old_cr3);
c0100563:	8b 45 f0 	movl	-16(%ebp), %eax
c0100566:	83 ec 0c 	subl	$12, %esp
c0100569:	50 	pushl	%eax
c010056a:	e8 fa 16 00 00 	calll	5882 <load_smap>
c010056f:	83 c4 10 	addl	$16, %esp
; }
c0100572:	90 	nop
c0100573:	c9 	leave
c0100574:	c3 	retl

address_spaces_put_data:
; void* address_spaces_put_data(void* cr3, void* data,uint32_t size) {
c0100575:	55 	pushl	%ebp
c0100576:	89 e5 	movl	%esp, %ebp
c0100578:	83 ec 18 	subl	$24, %esp
; asm volatile("movl %%cr3, %%eax; movl %%eax, %0;":"=m"(old_cr3)::"%eax");
c010057b:	0f 20 d8 	movl	%cr3, %eax
c010057e:	89 45 ec 	movl	%eax, -20(%ebp)
; void* phys_addr=virt_to_phys(data);
c0100581:	83 ec 0c 	subl	$12, %esp
c0100584:	ff 75 0c 	pushl	12(%ebp)
c0100587:	e8 3a 15 00 00 	calll	5434 <virt_to_phys>
c010058c:	83 c4 10 	addl	$16, %esp
c010058f:	89 45 f4 	movl	%eax, -12(%ebp)
; load_smap((uint32_t)cr3);
c0100592:	8b 45 08 	movl	8(%ebp), %eax
c0100595:	83 ec 0c 	subl	$12, %esp
c0100598:	50 	pushl	%eax
c0100599:	e8 cb 16 00 00 	calll	5835 <load_smap>
c010059e:	83 c4 10 	addl	$16, %esp
; void* virt_addr=(void*)(find_free_pages((size/4096)+1)<<12);
c01005a1:	8b 45 10 	movl	16(%ebp), %eax
c01005a4:	c1 e8 0c 	shrl	$12, %eax
c01005a7:	40 	incl	%eax
c01005a8:	83 ec 0c 	subl	$12, %esp
c01005ab:	50 	pushl	%eax
c01005ac:	e8 15 14 00 00 	calll	5141 <find_free_pages>
c01005b1:	83 c4 10 	addl	$16, %esp
c01005b4:	c1 e0 0c 	shll	$12, %eax
c01005b7:	89 45 f0 	movl	%eax, -16(%ebp)
; map_pages(virt_addr,phys_addr,(size/4096)+1,1,1);
c01005ba:	8b 45 10 	movl	16(%ebp), %eax
c01005bd:	c1 e8 0c 	shrl	$12, %eax
c01005c0:	40 	incl	%eax
c01005c1:	83 ec 0c 	subl	$12, %esp
c01005c4:	6a 01 	pushl	$1
c01005c6:	6a 01 	pushl	$1
c01005c8:	50 	pushl	%eax
c01005c9:	ff 75 f4 	pushl	-12(%ebp)
c01005cc:	ff 75 f0 	pushl	-16(%ebp)
c01005cf:	e8 8a 12 00 00 	calll	4746 <map_pages>
c01005d4:	83 c4 20 	addl	$32, %esp
; load_smap(old_cr3);
c01005d7:	8b 45 ec 	movl	-20(%ebp), %eax
c01005da:	83 ec 0c 	subl	$12, %esp
c01005dd:	50 	pushl	%eax
c01005de:	e8 86 16 00 00 	calll	5766 <load_smap>
c01005e3:	83 c4 10 	addl	$16, %esp
; return virt_addr;
c01005e6:	8b 45 f0 	movl	-16(%ebp), %eax
; }
c01005e9:	c9 	leave
c01005ea:	c3 	retl

cpu_init:
; void cpu_init(struct multiboot_boot_header_tag* tags) {
c01005eb:	55 	pushl	%ebp
c01005ec:	89 e5 	movl	%esp, %ebp
c01005ee:	83 ec 08 	subl	$8, %esp
; gdt_init();
c01005f1:	e8 f8 01 00 00 	calll	504 <gdt_init>
; isr_install();
c01005f6:	e8 18 03 00 00 	calll	792 <isr_install>
; asm volatile("sti");
c01005fb:	fb 	sti
; pmem_init(tags);
c01005fc:	83 ec 0c 	subl	$12, %esp
c01005ff:	ff 75 08 	pushl	8(%ebp)
c0100602:	e8 68 1a 00 00 	calll	6760 <pmem_init>
c0100607:	83 c4 10 	addl	$16, %esp
; paging_init();
c010060a:	e8 7a 17 00 00 	calll	6010 <paging_init>
; tasking_init();
c010060f:	e8 4d 1d 00 00 	calll	7501 <tasking_init>
; }
c0100614:	90 	nop
c0100615:	c9 	leave
c0100616:	c3 	retl

tss_stack_reset:
; void tss_stack_reset() {
c0100617:	55 	pushl	%ebp
c0100618:	89 e5 	movl	%esp, %ebp
; tss.esp0=int_stack_top+0xC0000000;
c010061a:	a1 2c 08 36 c0 	movl	3224766508, %eax
c010061f:	2d 00 00 00 40 	subl	$1073741824, %eax
c0100624:	a3 04 70 10 c0 	movl	%eax, 3222302724
; }
c0100629:	90 	nop
c010062a:	5d 	popl	%ebp
c010062b:	c3 	retl

set_entry:
; static void set_entry(int i,uint32_t base,uint32_t limit,uint8_t access) {
c010062c:	55 	pushl	%ebp
c010062d:	89 e5 	movl	%esp, %ebp
c010062f:	83 ec 14 	subl	$20, %esp
c0100632:	8b 45 14 	movl	20(%ebp), %eax
c0100635:	88 45 ec 	movb	%al, -20(%ebp)
; gdt[i].limit_low16=limit&0xFFFF;
c0100638:	8b 45 10 	movl	16(%ebp), %eax
c010063b:	8b 55 08 	movl	8(%ebp), %edx
c010063e:	66 89 04 d5 20 d0 10 c0 	movw	%ax, -1072639968(,%edx,8)
; gdt[i].base_low16=base&0xFFFFF;
c0100646:	8b 45 0c 	movl	12(%ebp), %eax
c0100649:	8b 55 08 	movl	8(%ebp), %edx
c010064c:	66 89 04 d5 22 d0 10 c0 	movw	%ax, -1072639966(,%edx,8)
; gdt[i].base_mid8=(base&0xFF0000)>>16;
c0100654:	8b 45 0c 	movl	12(%ebp), %eax
c0100657:	c1 e8 10 	shrl	$16, %eax
c010065a:	88 c2 	movb	%al, %dl
c010065c:	8b 45 08 	movl	8(%ebp), %eax
c010065f:	88 14 c5 24 d0 10 c0 	movb	%dl, -1072639964(,%eax,8)
; gdt[i].access=access;
c0100666:	8b 45 08 	movl	8(%ebp), %eax
c0100669:	8a 55 ec 	movb	-20(%ebp), %dl
c010066c:	88 14 c5 25 d0 10 c0 	movb	%dl, -1072639963(,%eax,8)
; uint8_t limit_high4=(limit&0xF0000)>>16;
c0100673:	8b 45 10 	movl	16(%ebp), %eax
c0100676:	c1 e8 10 	shrl	$16, %eax
c0100679:	83 e0 0f 	andl	$15, %eax
c010067c:	88 45 ff 	movb	%al, -1(%ebp)
; gdt[i].limit_flags=0xC0|limit_high4;
c010067f:	8a 45 ff 	movb	-1(%ebp), %al
c0100682:	83 c8 c0 	orl	$-64, %eax
c0100685:	88 c2 	movb	%al, %dl
c0100687:	8b 45 08 	movl	8(%ebp), %eax
c010068a:	88 14 c5 26 d0 10 c0 	movb	%dl, -1072639962(,%eax,8)
; gdt[i].base_high8=(base&0xFF000000)>>24;
c0100691:	8b 45 0c 	movl	12(%ebp), %eax
c0100694:	c1 e8 18 	shrl	$24, %eax
c0100697:	88 c2 	movb	%al, %dl
c0100699:	8b 45 08 	movl	8(%ebp), %eax
c010069c:	88 14 c5 27 d0 10 c0 	movb	%dl, -1072639961(,%eax,8)
; }
c01006a3:	90 	nop
c01006a4:	c9 	leave
c01006a5:	c3 	retl

write_tss:
; static void write_tss(int32_t num, uint16_t ss0, uint32_t esp0) {
c01006a6:	55 	pushl	%ebp
c01006a7:	89 e5 	movl	%esp, %ebp
c01006a9:	83 ec 28 	subl	$40, %esp
c01006ac:	8b 45 0c 	movl	12(%ebp), %eax
c01006af:	66 89 45 e4 	movw	%ax, -28(%ebp)
; uint32_t base = (uint32_t) &tss;
c01006b3:	c7 45 f4 00 70 10 c0 	movl	$3222302720, -12(%ebp)
; uint32_t limit = base + sizeof(tss_entry);
c01006ba:	8b 45 f4 	movl	-12(%ebp), %eax
c01006bd:	05 69 20 00 00 	addl	$8297, %eax
c01006c2:	89 45 f0 	movl	%eax, -16(%ebp)
; gdt[num].limit_low16=limit&0xFFFF;
c01006c5:	8b 45 f0 	movl	-16(%ebp), %eax
c01006c8:	8b 55 08 	movl	8(%ebp), %edx
c01006cb:	66 89 04 d5 20 d0 10 c0 	movw	%ax, -1072639968(,%edx,8)
; gdt[num].base_low16=base&0xFFFFF;
c01006d3:	8b 45 f4 	movl	-12(%ebp), %eax
c01006d6:	8b 55 08 	movl	8(%ebp), %edx
c01006d9:	66 89 04 d5 22 d0 10 c0 	movw	%ax, -1072639966(,%edx,8)
; gdt[num].base_mid8=(base&0xFF0000)>>16;
c01006e1:	8b 45 f4 	movl	-12(%ebp), %eax
c01006e4:	c1 e8 10 	shrl	$16, %eax
c01006e7:	88 c2 	movb	%al, %dl
c01006e9:	8b 45 08 	movl	8(%ebp), %eax
c01006ec:	88 14 c5 24 d0 10 c0 	movb	%dl, -1072639964(,%eax,8)
; gdt[num].access=0xe9;
c01006f3:	8b 45 08 	movl	8(%ebp), %eax
c01006f6:	c6 04 c5 25 d0 10 c0 e9 	movb	$-23, -1072639963(,%eax,8)
; gdt[num].limit_flags=(limit&0xF0000)>>16;
c01006fe:	8b 45 f0 	movl	-16(%ebp), %eax
c0100701:	c1 e8 10 	shrl	$16, %eax
c0100704:	83 e0 0f 	andl	$15, %eax
c0100707:	88 c2 	movb	%al, %dl
c0100709:	8b 45 08 	movl	8(%ebp), %eax
c010070c:	88 14 c5 26 d0 10 c0 	movb	%dl, -1072639962(,%eax,8)
; gdt[num].base_high8=(base&0xFF000000)>>24;
c0100713:	8b 45 f4 	movl	-12(%ebp), %eax
c0100716:	c1 e8 18 	shrl	$24, %eax
c0100719:	88 c2 	movb	%al, %dl
c010071b:	8b 45 08 	movl	8(%ebp), %eax
c010071e:	88 14 c5 27 d0 10 c0 	movb	%dl, -1072639961(,%eax,8)
; memset((void*)&tss,0,sizeof(tss));
c0100725:	83 ec 04 	subl	$4, %esp
c0100728:	68 69 20 00 00 	pushl	$8297
c010072d:	6a 00 	pushl	$0
c010072f:	68 00 70 10 c0 	pushl	$3222302720
c0100734:	e8 9d 29 00 00 	calll	10653 <memset>
c0100739:	83 c4 10 	addl	$16, %esp
; tss.ss0  = ss0;  // Set the kernel stack segment.
c010073c:	0f b7 45 e4 	movzwl	-28(%ebp), %eax
c0100740:	a3 08 70 10 c0 	movl	%eax, 3222302728
; tss.esp0 = esp0; // Set the kernel stack pointer.
c0100745:	8b 45 10 	movl	16(%ebp), %eax
c0100748:	a3 04 70 10 c0 	movl	%eax, 3222302724
; tss.set_ff=0xFF;
c010074d:	c6 05 68 90 10 c0 ff 	movb	$-1, -1072656280
; tss.iomap_base=104;
c0100754:	66 c7 05 66 70 10 c0 68 00 	movw	$104, -1072664474
; tss.cs = 0x0b;
c010075d:	c7 05 4c 70 10 c0 0b 00 00 00 	movl	$11, -1072664500
; tss.ss = tss.ds = tss.es = tss.fs = tss.gs = 0x13;
c0100767:	c7 05 5c 70 10 c0 13 00 00 00 	movl	$19, -1072664484
c0100771:	a1 5c 70 10 c0 	movl	3222302812, %eax
c0100776:	a3 58 70 10 c0 	movl	%eax, 3222302808
c010077b:	a1 58 70 10 c0 	movl	3222302808, %eax
c0100780:	a3 48 70 10 c0 	movl	%eax, 3222302792
c0100785:	a1 48 70 10 c0 	movl	3222302792, %eax
c010078a:	a3 54 70 10 c0 	movl	%eax, 3222302804
c010078f:	a1 54 70 10 c0 	movl	3222302804, %eax
c0100794:	a3 50 70 10 c0 	movl	%eax, 3222302800
; }
c0100799:	90 	nop
c010079a:	c9 	leave
c010079b:	c3 	retl

allow_all_ports:
; void allow_all_ports() {
c010079c:	55 	pushl	%ebp
c010079d:	89 e5 	movl	%esp, %ebp
c010079f:	83 ec 10 	subl	$16, %esp
; for (int i=0;i<8192;i++) {
c01007a2:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
c01007a9:	eb 0e 	jmp	14 <allow_all_ports+0x1d>
; tss.iopb[i]=0;
c01007ab:	8b 45 fc 	movl	-4(%ebp), %eax
c01007ae:	05 68 70 10 c0 	addl	$3222302824, %eax
c01007b3:	c6 00 00 	movb	$0, (%eax)
; for (int i=0;i<8192;i++) {
c01007b6:	ff 45 fc 	incl	-4(%ebp)
c01007b9:	81 7d fc ff 1f 00 00 	cmpl	$8191, -4(%ebp)
c01007c0:	7e e9 	jle	-23 <allow_all_ports+0xf>
; }
c01007c2:	90 	nop
c01007c3:	c9 	leave
c01007c4:	c3 	retl

block_all_ports:
; void block_all_ports() {
c01007c5:	55 	pushl	%ebp
c01007c6:	89 e5 	movl	%esp, %ebp
c01007c8:	83 ec 10 	subl	$16, %esp
; for (int i=0;i<8192;i++) {
c01007cb:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
c01007d2:	eb 0e 	jmp	14 <block_all_ports+0x1d>
; tss.iopb[i]=0xFF;
c01007d4:	8b 45 fc 	movl	-4(%ebp), %eax
c01007d7:	05 68 70 10 c0 	addl	$3222302824, %eax
c01007dc:	c6 00 ff 	movb	$-1, (%eax)
; for (int i=0;i<8192;i++) {
c01007df:	ff 45 fc 	incl	-4(%ebp)
c01007e2:	81 7d fc ff 1f 00 00 	cmpl	$8191, -4(%ebp)
c01007e9:	7e e9 	jle	-23 <block_all_ports+0xf>
; }
c01007eb:	90 	nop
c01007ec:	c9 	leave
c01007ed:	c3 	retl

gdt_init:
; void gdt_init() {
c01007ee:	55 	pushl	%ebp
c01007ef:	89 e5 	movl	%esp, %ebp
c01007f1:	83 ec 08 	subl	$8, %esp
; set_entry(0,0,0,0);
c01007f4:	6a 00 	pushl	$0
c01007f6:	6a 00 	pushl	$0
c01007f8:	6a 00 	pushl	$0
c01007fa:	6a 00 	pushl	$0
c01007fc:	e8 2b fe ff ff 	calll	-469 <set_entry>
c0100801:	83 c4 10 	addl	$16, %esp
; set_entry(1,0,0xFFFFF,0x9A);
c0100804:	68 9a 00 00 00 	pushl	$154
c0100809:	68 ff ff 0f 00 	pushl	$1048575
c010080e:	6a 00 	pushl	$0
c0100810:	6a 01 	pushl	$1
c0100812:	e8 15 fe ff ff 	calll	-491 <set_entry>
c0100817:	83 c4 10 	addl	$16, %esp
; set_entry(2,0,0xFFFFF,0x92);
c010081a:	68 92 00 00 00 	pushl	$146
c010081f:	68 ff ff 0f 00 	pushl	$1048575
c0100824:	6a 00 	pushl	$0
c0100826:	6a 02 	pushl	$2
c0100828:	e8 ff fd ff ff 	calll	-513 <set_entry>
c010082d:	83 c4 10 	addl	$16, %esp
; set_entry(3,0,0xFFFFF,0xFA);
c0100830:	68 fa 00 00 00 	pushl	$250
c0100835:	68 ff ff 0f 00 	pushl	$1048575
c010083a:	6a 00 	pushl	$0
c010083c:	6a 03 	pushl	$3
c010083e:	e8 e9 fd ff ff 	calll	-535 <set_entry>
c0100843:	83 c4 10 	addl	$16, %esp
; set_entry(4,0,0xFFFFF,0xF2);
c0100846:	68 f2 00 00 00 	pushl	$242
c010084b:	68 ff ff 0f 00 	pushl	$1048575
c0100850:	6a 00 	pushl	$0
c0100852:	6a 04 	pushl	$4
c0100854:	e8 d3 fd ff ff 	calll	-557 <set_entry>
c0100859:	83 c4 10 	addl	$16, %esp
; write_tss(5,0x10,int_stack_top+0xC0000000);
c010085c:	a1 2c 08 36 c0 	movl	3224766508, %eax
c0100861:	2d 00 00 00 40 	subl	$1073741824, %eax
c0100866:	83 ec 04 	subl	$4, %esp
c0100869:	50 	pushl	%eax
c010086a:	6a 10 	pushl	$16
c010086c:	6a 05 	pushl	$5
c010086e:	e8 33 fe ff ff 	calll	-461 <write_tss>
c0100873:	83 c4 10 	addl	$16, %esp
; gdt_desc.size=(sizeof(gdt_entry)*NUM_ENTRIES)-1;
c0100876:	66 c7 05 50 d0 10 c0 2f 00 	movw	$47, -1072639920
; gdt_desc.address=gdt;
c010087f:	c7 05 52 d0 10 c0 20 d0 10 c0 	movl	$3222327328, -1072639918
; asm volatile("lgdt (%%eax)"::"a"((uint32_t)&gdt_desc));
c0100889:	b8 50 d0 10 c0 	movl	$3222327376, %eax
c010088e:	0f 01 10 	lgdtl	(%eax)
; seg_upd();
c0100891:	e8 fa 20 00 00 	calll	8442 <seg_upd>
; asm volatile("mov $0x2B, %ax; \
c0100896:	66 b8 2b 00 	movw	$43, %ax
c010089a:	0f 00 d8 	ltrw	%ax
; }
c010089d:	90 	nop
c010089e:	c9 	leave
c010089f:	c3 	retl

halt:
; void halt() {
c01008a0:	55 	pushl	%ebp
c01008a1:	89 e5 	movl	%esp, %ebp
; asm volatile("cli;\
c01008a3:	fa 	cli

hltlabel:
c01008a4:	f4 	hlt
c01008a5:	eb fd 	jmp	-3 <hltlabel>
; }
c01008a7:	90 	nop
c01008a8:	5d 	popl	%ebp
c01008a9:	c3 	retl

idt_set_gate:
; void idt_set_gate(int n,uint32_t handler) {
c01008aa:	55 	pushl	%ebp
c01008ab:	89 e5 	movl	%esp, %ebp
; idt[n].low_offset=low_16(handler);
c01008ad:	8b 45 0c 	movl	12(%ebp), %eax
c01008b0:	8b 55 08 	movl	8(%ebp), %edx
c01008b3:	66 89 04 d5 60 d0 10 c0 	movw	%ax, -1072639904(,%edx,8)
; idt[n].sel=0x08;
c01008bb:	8b 45 08 	movl	8(%ebp), %eax
c01008be:	66 c7 04 c5 62 d0 10 c0 08 00 	movw	$8, -1072639902(,%eax,8)
; idt[n].always0=0;
c01008c8:	8b 45 08 	movl	8(%ebp), %eax
c01008cb:	c6 04 c5 64 d0 10 c0 00 	movb	$0, -1072639900(,%eax,8)
; idt[n].flags=0xEE;
c01008d3:	8b 45 08 	movl	8(%ebp), %eax
c01008d6:	c6 04 c5 65 d0 10 c0 ee 	movb	$-18, -1072639899(,%eax,8)
; idt[n].high_offset=high_16(handler);
c01008de:	8b 45 0c 	movl	12(%ebp), %eax
c01008e1:	c1 e8 10 	shrl	$16, %eax
c01008e4:	8b 55 08 	movl	8(%ebp), %edx
c01008e7:	66 89 04 d5 66 d0 10 c0 	movw	%ax, -1072639898(,%edx,8)
; }
c01008ef:	90 	nop
c01008f0:	5d 	popl	%ebp
c01008f1:	c3 	retl

load_idt:
; void load_idt() {
c01008f2:	55 	pushl	%ebp
c01008f3:	89 e5 	movl	%esp, %ebp
; idt_reg.base=(uint32_t) &idt;
c01008f5:	b8 60 d0 10 c0 	movl	$3222327392, %eax
c01008fa:	a3 62 d8 10 c0 	movl	%eax, 3222329442
; idt_reg.limit=IDT_ENTRIES * sizeof(idt_gate_t) - 1;
c01008ff:	66 c7 05 60 d8 10 c0 ff 07 	movw	$2047, -1072637856
; asm volatile("lidtl (%0)":: "r" (&idt_reg));
c0100908:	b8 60 d8 10 c0 	movl	$3222329440, %eax
c010090d:	0f 01 18 	lidtl	(%eax)
; }
c0100910:	90 	nop
c0100911:	5d 	popl	%ebp
c0100912:	c3 	retl

isr_install:
; void isr_install() {
c0100913:	55 	pushl	%ebp
c0100914:	89 e5 	movl	%esp, %ebp
c0100916:	83 ec 08 	subl	$8, %esp
; idt_set_gate(0,(uint32_t)isr0);
c0100919:	b8 a9 27 10 c0 	movl	$3222284201, %eax
c010091e:	83 ec 08 	subl	$8, %esp
c0100921:	50 	pushl	%eax
c0100922:	6a 00 	pushl	$0
c0100924:	e8 81 ff ff ff 	calll	-127 <idt_set_gate>
c0100929:	83 c4 10 	addl	$16, %esp
; idt_set_gate(1,(uint32_t)isr1);
c010092c:	b8 b0 27 10 c0 	movl	$3222284208, %eax
c0100931:	83 ec 08 	subl	$8, %esp
c0100934:	50 	pushl	%eax
c0100935:	6a 01 	pushl	$1
c0100937:	e8 6e ff ff ff 	calll	-146 <idt_set_gate>
c010093c:	83 c4 10 	addl	$16, %esp
; idt_set_gate(2,(uint32_t)isr2);
c010093f:	b8 b7 27 10 c0 	movl	$3222284215, %eax
c0100944:	83 ec 08 	subl	$8, %esp
c0100947:	50 	pushl	%eax
c0100948:	6a 02 	pushl	$2
c010094a:	e8 5b ff ff ff 	calll	-165 <idt_set_gate>
c010094f:	83 c4 10 	addl	$16, %esp
; idt_set_gate(3,(uint32_t)isr3);
c0100952:	b8 be 27 10 c0 	movl	$3222284222, %eax
c0100957:	83 ec 08 	subl	$8, %esp
c010095a:	50 	pushl	%eax
c010095b:	6a 03 	pushl	$3
c010095d:	e8 48 ff ff ff 	calll	-184 <idt_set_gate>
c0100962:	83 c4 10 	addl	$16, %esp
; idt_set_gate(4,(uint32_t)isr4);
c0100965:	b8 c5 27 10 c0 	movl	$3222284229, %eax
c010096a:	83 ec 08 	subl	$8, %esp
c010096d:	50 	pushl	%eax
c010096e:	6a 04 	pushl	$4
c0100970:	e8 35 ff ff ff 	calll	-203 <idt_set_gate>
c0100975:	83 c4 10 	addl	$16, %esp
; idt_set_gate(5,(uint32_t)isr5);
c0100978:	b8 cc 27 10 c0 	movl	$3222284236, %eax
c010097d:	83 ec 08 	subl	$8, %esp
c0100980:	50 	pushl	%eax
c0100981:	6a 05 	pushl	$5
c0100983:	e8 22 ff ff ff 	calll	-222 <idt_set_gate>
c0100988:	83 c4 10 	addl	$16, %esp
; idt_set_gate(6,(uint32_t)isr6);
c010098b:	b8 d3 27 10 c0 	movl	$3222284243, %eax
c0100990:	83 ec 08 	subl	$8, %esp
c0100993:	50 	pushl	%eax
c0100994:	6a 06 	pushl	$6
c0100996:	e8 0f ff ff ff 	calll	-241 <idt_set_gate>
c010099b:	83 c4 10 	addl	$16, %esp
; idt_set_gate(7,(uint32_t)isr7);
c010099e:	b8 da 27 10 c0 	movl	$3222284250, %eax
c01009a3:	83 ec 08 	subl	$8, %esp
c01009a6:	50 	pushl	%eax
c01009a7:	6a 07 	pushl	$7
c01009a9:	e8 fc fe ff ff 	calll	-260 <idt_set_gate>
c01009ae:	83 c4 10 	addl	$16, %esp
; idt_set_gate(8,(uint32_t)isr8);
c01009b1:	b8 e4 27 10 c0 	movl	$3222284260, %eax
c01009b6:	83 ec 08 	subl	$8, %esp
c01009b9:	50 	pushl	%eax
c01009ba:	6a 08 	pushl	$8
c01009bc:	e8 e9 fe ff ff 	calll	-279 <idt_set_gate>
c01009c1:	83 c4 10 	addl	$16, %esp
; idt_set_gate(9,(uint32_t)isr9);
c01009c4:	b8 ec 27 10 c0 	movl	$3222284268, %eax
c01009c9:	83 ec 08 	subl	$8, %esp
c01009cc:	50 	pushl	%eax
c01009cd:	6a 09 	pushl	$9
c01009cf:	e8 d6 fe ff ff 	calll	-298 <idt_set_gate>
c01009d4:	83 c4 10 	addl	$16, %esp
; idt_set_gate(10,(uint32_t)isr10);
c01009d7:	b8 f6 27 10 c0 	movl	$3222284278, %eax
c01009dc:	83 ec 08 	subl	$8, %esp
c01009df:	50 	pushl	%eax
c01009e0:	6a 0a 	pushl	$10
c01009e2:	e8 c3 fe ff ff 	calll	-317 <idt_set_gate>
c01009e7:	83 c4 10 	addl	$16, %esp
; idt_set_gate(11,(uint32_t)isr11);
c01009ea:	b8 fe 27 10 c0 	movl	$3222284286, %eax
c01009ef:	83 ec 08 	subl	$8, %esp
c01009f2:	50 	pushl	%eax
c01009f3:	6a 0b 	pushl	$11
c01009f5:	e8 b0 fe ff ff 	calll	-336 <idt_set_gate>
c01009fa:	83 c4 10 	addl	$16, %esp
; idt_set_gate(12,(uint32_t)isr12);
c01009fd:	b8 06 28 10 c0 	movl	$3222284294, %eax
c0100a02:	83 ec 08 	subl	$8, %esp
c0100a05:	50 	pushl	%eax
c0100a06:	6a 0c 	pushl	$12
c0100a08:	e8 9d fe ff ff 	calll	-355 <idt_set_gate>
c0100a0d:	83 c4 10 	addl	$16, %esp
; idt_set_gate(13,(uint32_t)isr13);
c0100a10:	b8 0e 28 10 c0 	movl	$3222284302, %eax
c0100a15:	83 ec 08 	subl	$8, %esp
c0100a18:	50 	pushl	%eax
c0100a19:	6a 0d 	pushl	$13
c0100a1b:	e8 8a fe ff ff 	calll	-374 <idt_set_gate>
c0100a20:	83 c4 10 	addl	$16, %esp
; idt_set_gate(14,(uint32_t)isr14);
c0100a23:	b8 16 28 10 c0 	movl	$3222284310, %eax
c0100a28:	83 ec 08 	subl	$8, %esp
c0100a2b:	50 	pushl	%eax
c0100a2c:	6a 0e 	pushl	$14
c0100a2e:	e8 77 fe ff ff 	calll	-393 <idt_set_gate>
c0100a33:	83 c4 10 	addl	$16, %esp
; idt_set_gate(15,(uint32_t)isr15);
c0100a36:	b8 1e 28 10 c0 	movl	$3222284318, %eax
c0100a3b:	83 ec 08 	subl	$8, %esp
c0100a3e:	50 	pushl	%eax
c0100a3f:	6a 0f 	pushl	$15
c0100a41:	e8 64 fe ff ff 	calll	-412 <idt_set_gate>
c0100a46:	83 c4 10 	addl	$16, %esp
; idt_set_gate(16,(uint32_t)isr16);
c0100a49:	b8 28 28 10 c0 	movl	$3222284328, %eax
c0100a4e:	83 ec 08 	subl	$8, %esp
c0100a51:	50 	pushl	%eax
c0100a52:	6a 10 	pushl	$16
c0100a54:	e8 51 fe ff ff 	calll	-431 <idt_set_gate>
c0100a59:	83 c4 10 	addl	$16, %esp
; idt_set_gate(17,(uint32_t)isr17);
c0100a5c:	b8 32 28 10 c0 	movl	$3222284338, %eax
c0100a61:	83 ec 08 	subl	$8, %esp
c0100a64:	50 	pushl	%eax
c0100a65:	6a 11 	pushl	$17
c0100a67:	e8 3e fe ff ff 	calll	-450 <idt_set_gate>
c0100a6c:	83 c4 10 	addl	$16, %esp
; idt_set_gate(18,(uint32_t)isr18);
c0100a6f:	b8 3c 28 10 c0 	movl	$3222284348, %eax
c0100a74:	83 ec 08 	subl	$8, %esp
c0100a77:	50 	pushl	%eax
c0100a78:	6a 12 	pushl	$18
c0100a7a:	e8 2b fe ff ff 	calll	-469 <idt_set_gate>
c0100a7f:	83 c4 10 	addl	$16, %esp
; idt_set_gate(19,(uint32_t)isr19);
c0100a82:	b8 46 28 10 c0 	movl	$3222284358, %eax
c0100a87:	83 ec 08 	subl	$8, %esp
c0100a8a:	50 	pushl	%eax
c0100a8b:	6a 13 	pushl	$19
c0100a8d:	e8 18 fe ff ff 	calll	-488 <idt_set_gate>
c0100a92:	83 c4 10 	addl	$16, %esp
; idt_set_gate(20,(uint32_t)isr20);
c0100a95:	b8 50 28 10 c0 	movl	$3222284368, %eax
c0100a9a:	83 ec 08 	subl	$8, %esp
c0100a9d:	50 	pushl	%eax
c0100a9e:	6a 14 	pushl	$20
c0100aa0:	e8 05 fe ff ff 	calll	-507 <idt_set_gate>
c0100aa5:	83 c4 10 	addl	$16, %esp
; idt_set_gate(21,(uint32_t)isr21);
c0100aa8:	b8 5a 28 10 c0 	movl	$3222284378, %eax
c0100aad:	83 ec 08 	subl	$8, %esp
c0100ab0:	50 	pushl	%eax
c0100ab1:	6a 15 	pushl	$21
c0100ab3:	e8 f2 fd ff ff 	calll	-526 <idt_set_gate>
c0100ab8:	83 c4 10 	addl	$16, %esp
; idt_set_gate(22,(uint32_t)isr22);
c0100abb:	b8 64 28 10 c0 	movl	$3222284388, %eax
c0100ac0:	83 ec 08 	subl	$8, %esp
c0100ac3:	50 	pushl	%eax
c0100ac4:	6a 16 	pushl	$22
c0100ac6:	e8 df fd ff ff 	calll	-545 <idt_set_gate>
c0100acb:	83 c4 10 	addl	$16, %esp
; idt_set_gate(23,(uint32_t)isr23);
c0100ace:	b8 6e 28 10 c0 	movl	$3222284398, %eax
c0100ad3:	83 ec 08 	subl	$8, %esp
c0100ad6:	50 	pushl	%eax
c0100ad7:	6a 17 	pushl	$23
c0100ad9:	e8 cc fd ff ff 	calll	-564 <idt_set_gate>
c0100ade:	83 c4 10 	addl	$16, %esp
; idt_set_gate(24,(uint32_t)isr24);
c0100ae1:	b8 78 28 10 c0 	movl	$3222284408, %eax
c0100ae6:	83 ec 08 	subl	$8, %esp
c0100ae9:	50 	pushl	%eax
c0100aea:	6a 18 	pushl	$24
c0100aec:	e8 b9 fd ff ff 	calll	-583 <idt_set_gate>
c0100af1:	83 c4 10 	addl	$16, %esp
; idt_set_gate(25,(uint32_t)isr25);
c0100af4:	b8 82 28 10 c0 	movl	$3222284418, %eax
c0100af9:	83 ec 08 	subl	$8, %esp
c0100afc:	50 	pushl	%eax
c0100afd:	6a 19 	pushl	$25
c0100aff:	e8 a6 fd ff ff 	calll	-602 <idt_set_gate>
c0100b04:	83 c4 10 	addl	$16, %esp
; idt_set_gate(26,(uint32_t)isr26);
c0100b07:	b8 8c 28 10 c0 	movl	$3222284428, %eax
c0100b0c:	83 ec 08 	subl	$8, %esp
c0100b0f:	50 	pushl	%eax
c0100b10:	6a 1a 	pushl	$26
c0100b12:	e8 93 fd ff ff 	calll	-621 <idt_set_gate>
c0100b17:	83 c4 10 	addl	$16, %esp
; idt_set_gate(27,(uint32_t)isr27);
c0100b1a:	b8 96 28 10 c0 	movl	$3222284438, %eax
c0100b1f:	83 ec 08 	subl	$8, %esp
c0100b22:	50 	pushl	%eax
c0100b23:	6a 1b 	pushl	$27
c0100b25:	e8 80 fd ff ff 	calll	-640 <idt_set_gate>
c0100b2a:	83 c4 10 	addl	$16, %esp
; idt_set_gate(28,(uint32_t)isr28);
c0100b2d:	b8 a0 28 10 c0 	movl	$3222284448, %eax
c0100b32:	83 ec 08 	subl	$8, %esp
c0100b35:	50 	pushl	%eax
c0100b36:	6a 1c 	pushl	$28
c0100b38:	e8 6d fd ff ff 	calll	-659 <idt_set_gate>
c0100b3d:	83 c4 10 	addl	$16, %esp
; idt_set_gate(29,(uint32_t)isr29);
c0100b40:	b8 aa 28 10 c0 	movl	$3222284458, %eax
c0100b45:	83 ec 08 	subl	$8, %esp
c0100b48:	50 	pushl	%eax
c0100b49:	6a 1d 	pushl	$29
c0100b4b:	e8 5a fd ff ff 	calll	-678 <idt_set_gate>
c0100b50:	83 c4 10 	addl	$16, %esp
; idt_set_gate(30,(uint32_t)isr30);
c0100b53:	b8 b4 28 10 c0 	movl	$3222284468, %eax
c0100b58:	83 ec 08 	subl	$8, %esp
c0100b5b:	50 	pushl	%eax
c0100b5c:	6a 1e 	pushl	$30
c0100b5e:	e8 47 fd ff ff 	calll	-697 <idt_set_gate>
c0100b63:	83 c4 10 	addl	$16, %esp
; idt_set_gate(31,(uint32_t)isr31);
c0100b66:	b8 be 28 10 c0 	movl	$3222284478, %eax
c0100b6b:	83 ec 08 	subl	$8, %esp
c0100b6e:	50 	pushl	%eax
c0100b6f:	6a 1f 	pushl	$31
c0100b71:	e8 34 fd ff ff 	calll	-716 <idt_set_gate>
c0100b76:	83 c4 10 	addl	$16, %esp
; idt_set_gate(80,(uint32_t)isr80);
c0100b79:	b8 c8 28 10 c0 	movl	$3222284488, %eax
c0100b7e:	83 ec 08 	subl	$8, %esp
c0100b81:	50 	pushl	%eax
c0100b82:	6a 50 	pushl	$80
c0100b84:	e8 21 fd ff ff 	calll	-735 <idt_set_gate>
c0100b89:	83 c4 10 	addl	$16, %esp
; port_byte_out(0x20,0x11);
c0100b8c:	83 ec 08 	subl	$8, %esp
c0100b8f:	6a 11 	pushl	$17
c0100b91:	6a 20 	pushl	$32
c0100b93:	e8 3b 17 00 00 	calll	5947 <port_byte_out>
c0100b98:	83 c4 10 	addl	$16, %esp
; port_byte_out(0xA0,0x11);
c0100b9b:	83 ec 08 	subl	$8, %esp
c0100b9e:	6a 11 	pushl	$17
c0100ba0:	68 a0 00 00 00 	pushl	$160
c0100ba5:	e8 29 17 00 00 	calll	5929 <port_byte_out>
c0100baa:	83 c4 10 	addl	$16, %esp
; port_byte_out(0x21,0x20);
c0100bad:	83 ec 08 	subl	$8, %esp
c0100bb0:	6a 20 	pushl	$32
c0100bb2:	6a 21 	pushl	$33
c0100bb4:	e8 1a 17 00 00 	calll	5914 <port_byte_out>
c0100bb9:	83 c4 10 	addl	$16, %esp
; port_byte_out(0xA1,0x28);
c0100bbc:	83 ec 08 	subl	$8, %esp
c0100bbf:	6a 28 	pushl	$40
c0100bc1:	68 a1 00 00 00 	pushl	$161
c0100bc6:	e8 08 17 00 00 	calll	5896 <port_byte_out>
c0100bcb:	83 c4 10 	addl	$16, %esp
; port_byte_out(0x21,0x04);
c0100bce:	83 ec 08 	subl	$8, %esp
c0100bd1:	6a 04 	pushl	$4
c0100bd3:	6a 21 	pushl	$33
c0100bd5:	e8 f9 16 00 00 	calll	5881 <port_byte_out>
c0100bda:	83 c4 10 	addl	$16, %esp
; port_byte_out(0xA1,0x02);
c0100bdd:	83 ec 08 	subl	$8, %esp
c0100be0:	6a 02 	pushl	$2
c0100be2:	68 a1 00 00 00 	pushl	$161
c0100be7:	e8 e7 16 00 00 	calll	5863 <port_byte_out>
c0100bec:	83 c4 10 	addl	$16, %esp
; port_byte_out(0x21,0x01);
c0100bef:	83 ec 08 	subl	$8, %esp
c0100bf2:	6a 01 	pushl	$1
c0100bf4:	6a 21 	pushl	$33
c0100bf6:	e8 d8 16 00 00 	calll	5848 <port_byte_out>
c0100bfb:	83 c4 10 	addl	$16, %esp
; port_byte_out(0xA1,0x01);
c0100bfe:	83 ec 08 	subl	$8, %esp
c0100c01:	6a 01 	pushl	$1
c0100c03:	68 a1 00 00 00 	pushl	$161
c0100c08:	e8 c6 16 00 00 	calll	5830 <port_byte_out>
c0100c0d:	83 c4 10 	addl	$16, %esp
; port_byte_out(0x21,0x0);
c0100c10:	83 ec 08 	subl	$8, %esp
c0100c13:	6a 00 	pushl	$0
c0100c15:	6a 21 	pushl	$33
c0100c17:	e8 b7 16 00 00 	calll	5815 <port_byte_out>
c0100c1c:	83 c4 10 	addl	$16, %esp
; port_byte_out(0xA1,0x0);
c0100c1f:	83 ec 08 	subl	$8, %esp
c0100c22:	6a 00 	pushl	$0
c0100c24:	68 a1 00 00 00 	pushl	$161
c0100c29:	e8 a5 16 00 00 	calll	5797 <port_byte_out>
c0100c2e:	83 c4 10 	addl	$16, %esp
; idt_set_gate(32,(uint32_t)irq0);
c0100c31:	b8 d2 28 10 c0 	movl	$3222284498, %eax
c0100c36:	83 ec 08 	subl	$8, %esp
c0100c39:	50 	pushl	%eax
c0100c3a:	6a 20 	pushl	$32
c0100c3c:	e8 69 fc ff ff 	calll	-919 <idt_set_gate>
c0100c41:	83 c4 10 	addl	$16, %esp
; idt_set_gate(33,(uint32_t)irq1);
c0100c44:	b8 dc 28 10 c0 	movl	$3222284508, %eax
c0100c49:	83 ec 08 	subl	$8, %esp
c0100c4c:	50 	pushl	%eax
c0100c4d:	6a 21 	pushl	$33
c0100c4f:	e8 56 fc ff ff 	calll	-938 <idt_set_gate>
c0100c54:	83 c4 10 	addl	$16, %esp
; idt_set_gate(34,(uint32_t)irq2);
c0100c57:	b8 e6 28 10 c0 	movl	$3222284518, %eax
c0100c5c:	83 ec 08 	subl	$8, %esp
c0100c5f:	50 	pushl	%eax
c0100c60:	6a 22 	pushl	$34
c0100c62:	e8 43 fc ff ff 	calll	-957 <idt_set_gate>
c0100c67:	83 c4 10 	addl	$16, %esp
; idt_set_gate(35,(uint32_t)irq3);
c0100c6a:	b8 f0 28 10 c0 	movl	$3222284528, %eax
c0100c6f:	83 ec 08 	subl	$8, %esp
c0100c72:	50 	pushl	%eax
c0100c73:	6a 23 	pushl	$35
c0100c75:	e8 30 fc ff ff 	calll	-976 <idt_set_gate>
c0100c7a:	83 c4 10 	addl	$16, %esp
; idt_set_gate(36,(uint32_t)irq4);
c0100c7d:	b8 fa 28 10 c0 	movl	$3222284538, %eax
c0100c82:	83 ec 08 	subl	$8, %esp
c0100c85:	50 	pushl	%eax
c0100c86:	6a 24 	pushl	$36
c0100c88:	e8 1d fc ff ff 	calll	-995 <idt_set_gate>
c0100c8d:	83 c4 10 	addl	$16, %esp
; idt_set_gate(37,(uint32_t)irq5);
c0100c90:	b8 04 29 10 c0 	movl	$3222284548, %eax
c0100c95:	83 ec 08 	subl	$8, %esp
c0100c98:	50 	pushl	%eax
c0100c99:	6a 25 	pushl	$37
c0100c9b:	e8 0a fc ff ff 	calll	-1014 <idt_set_gate>
c0100ca0:	83 c4 10 	addl	$16, %esp
; idt_set_gate(38,(uint32_t)irq6);
c0100ca3:	b8 0e 29 10 c0 	movl	$3222284558, %eax
c0100ca8:	83 ec 08 	subl	$8, %esp
c0100cab:	50 	pushl	%eax
c0100cac:	6a 26 	pushl	$38
c0100cae:	e8 f7 fb ff ff 	calll	-1033 <idt_set_gate>
c0100cb3:	83 c4 10 	addl	$16, %esp
; idt_set_gate(39,(uint32_t)irq7);
c0100cb6:	b8 18 29 10 c0 	movl	$3222284568, %eax
c0100cbb:	83 ec 08 	subl	$8, %esp
c0100cbe:	50 	pushl	%eax
c0100cbf:	6a 27 	pushl	$39
c0100cc1:	e8 e4 fb ff ff 	calll	-1052 <idt_set_gate>
c0100cc6:	83 c4 10 	addl	$16, %esp
; idt_set_gate(40,(uint32_t)irq8);
c0100cc9:	b8 22 29 10 c0 	movl	$3222284578, %eax
c0100cce:	83 ec 08 	subl	$8, %esp
c0100cd1:	50 	pushl	%eax
c0100cd2:	6a 28 	pushl	$40
c0100cd4:	e8 d1 fb ff ff 	calll	-1071 <idt_set_gate>
c0100cd9:	83 c4 10 	addl	$16, %esp
; idt_set_gate(41,(uint32_t)irq9);
c0100cdc:	b8 2c 29 10 c0 	movl	$3222284588, %eax
c0100ce1:	83 ec 08 	subl	$8, %esp
c0100ce4:	50 	pushl	%eax
c0100ce5:	6a 29 	pushl	$41
c0100ce7:	e8 be fb ff ff 	calll	-1090 <idt_set_gate>
c0100cec:	83 c4 10 	addl	$16, %esp
; idt_set_gate(42,(uint32_t)irq10);
c0100cef:	b8 36 29 10 c0 	movl	$3222284598, %eax
c0100cf4:	83 ec 08 	subl	$8, %esp
c0100cf7:	50 	pushl	%eax
c0100cf8:	6a 2a 	pushl	$42
c0100cfa:	e8 ab fb ff ff 	calll	-1109 <idt_set_gate>
c0100cff:	83 c4 10 	addl	$16, %esp
; idt_set_gate(43,(uint32_t)irq11);
c0100d02:	b8 40 29 10 c0 	movl	$3222284608, %eax
c0100d07:	83 ec 08 	subl	$8, %esp
c0100d0a:	50 	pushl	%eax
c0100d0b:	6a 2b 	pushl	$43
c0100d0d:	e8 98 fb ff ff 	calll	-1128 <idt_set_gate>
c0100d12:	83 c4 10 	addl	$16, %esp
; idt_set_gate(44,(uint32_t)irq12);
c0100d15:	b8 4a 29 10 c0 	movl	$3222284618, %eax
c0100d1a:	83 ec 08 	subl	$8, %esp
c0100d1d:	50 	pushl	%eax
c0100d1e:	6a 2c 	pushl	$44
c0100d20:	e8 85 fb ff ff 	calll	-1147 <idt_set_gate>
c0100d25:	83 c4 10 	addl	$16, %esp
; idt_set_gate(45,(uint32_t)irq13);
c0100d28:	b8 54 29 10 c0 	movl	$3222284628, %eax
c0100d2d:	83 ec 08 	subl	$8, %esp
c0100d30:	50 	pushl	%eax
c0100d31:	6a 2d 	pushl	$45
c0100d33:	e8 72 fb ff ff 	calll	-1166 <idt_set_gate>
c0100d38:	83 c4 10 	addl	$16, %esp
; idt_set_gate(46,(uint32_t)irq14);
c0100d3b:	b8 5e 29 10 c0 	movl	$3222284638, %eax
c0100d40:	83 ec 08 	subl	$8, %esp
c0100d43:	50 	pushl	%eax
c0100d44:	6a 2e 	pushl	$46
c0100d46:	e8 5f fb ff ff 	calll	-1185 <idt_set_gate>
c0100d4b:	83 c4 10 	addl	$16, %esp
; idt_set_gate(47,(uint32_t)irq15);
c0100d4e:	b8 68 29 10 c0 	movl	$3222284648, %eax
c0100d53:	83 ec 08 	subl	$8, %esp
c0100d56:	50 	pushl	%eax
c0100d57:	6a 2f 	pushl	$47
c0100d59:	e8 4c fb ff ff 	calll	-1204 <idt_set_gate>
c0100d5e:	83 c4 10 	addl	$16, %esp
; load_idt();
c0100d61:	e8 8c fb ff ff 	calll	-1140 <load_idt>
; }
c0100d66:	90 	nop
c0100d67:	c9 	leave
c0100d68:	c3 	retl

isr_handler:
; void isr_handler(registers_t r) {
c0100d69:	55 	pushl	%ebp
c0100d6a:	89 e5 	movl	%esp, %ebp
c0100d6c:	57 	pushl	%edi
c0100d6d:	56 	pushl	%esi
c0100d6e:	53 	pushl	%ebx
c0100d6f:	83 ec 2c 	subl	$44, %esp
; switch (r.int_no) {
c0100d72:	8b 45 2c 	movl	44(%ebp), %eax
c0100d75:	83 f8 0e 	cmpl	$14, %eax
c0100d78:	74 0e 	je	14 <isr_handler+0x1f>
c0100d7a:	83 f8 50 	cmpl	$80, %eax
c0100d7d:	0f 84 d2 01 00 00 	je	466 <isr_handler+0x1ec>
c0100d83:	e9 eb 03 00 00 	jmp	1003 <isr_handler+0x40a>
; asm("movl %%cr2,%0": "=r"(addr));
c0100d88:	0f 20 d0 	movl	%cr2, %eax
c0100d8b:	89 45 e4 	movl	%eax, -28(%ebp)
; vga_write_string("In PID ");
c0100d8e:	83 ec 0c 	subl	$12, %esp
c0100d91:	68 70 41 10 c0 	pushl	$3222290800
c0100d96:	e8 1f f7 ff ff 	calll	-2273 <vga_write_string>
c0100d9b:	83 c4 10 	addl	$16, %esp
; int_to_ascii(getPID(),str);
c0100d9e:	e8 a3 19 00 00 	calll	6563 <getPID>
c0100da3:	89 c2 	movl	%eax, %edx
c0100da5:	83 ec 08 	subl	$8, %esp
c0100da8:	8d 45 d1 	leal	-47(%ebp), %eax
c0100dab:	50 	pushl	%eax
c0100dac:	52 	pushl	%edx
c0100dad:	e8 7f 24 00 00 	calll	9343 <int_to_ascii>
c0100db2:	83 c4 10 	addl	$16, %esp
; vga_write_string(str);
c0100db5:	83 ec 0c 	subl	$12, %esp
c0100db8:	8d 45 d1 	leal	-47(%ebp), %eax
c0100dbb:	50 	pushl	%eax
c0100dbc:	e8 f9 f6 ff ff 	calll	-2311 <vga_write_string>
c0100dc1:	83 c4 10 	addl	$16, %esp
; vga_write_string(" and address ");
c0100dc4:	83 ec 0c 	subl	$12, %esp
c0100dc7:	68 78 41 10 c0 	pushl	$3222290808
c0100dcc:	e8 e9 f6 ff ff 	calll	-2327 <vga_write_string>
c0100dd1:	83 c4 10 	addl	$16, %esp
; str[0]='\0';
c0100dd4:	c6 45 d1 00 	movb	$0, -47(%ebp)
; hex_to_ascii(r.eip,str);
c0100dd8:	8b 45 34 	movl	52(%ebp), %eax
c0100ddb:	89 c2 	movl	%eax, %edx
c0100ddd:	83 ec 08 	subl	$8, %esp
c0100de0:	8d 45 d1 	leal	-47(%ebp), %eax
c0100de3:	50 	pushl	%eax
c0100de4:	52 	pushl	%edx
c0100de5:	e8 d8 24 00 00 	calll	9432 <hex_to_ascii>
c0100dea:	83 c4 10 	addl	$16, %esp
; vga_write_string(str);
c0100ded:	83 ec 0c 	subl	$12, %esp
c0100df0:	8d 45 d1 	leal	-47(%ebp), %eax
c0100df3:	50 	pushl	%eax
c0100df4:	e8 c1 f6 ff ff 	calll	-2367 <vga_write_string>
c0100df9:	83 c4 10 	addl	$16, %esp
; if (r.err_code==0) {
c0100dfc:	8b 45 30 	movl	48(%ebp), %eax
c0100dff:	85 c0 	testl	%eax, %eax
c0100e01:	75 15 	jne	21 <isr_handler+0xaf>
; vga_write_string(", kernel process tried to read a non-present page entry at address ");
c0100e03:	83 ec 0c 	subl	$12, %esp
c0100e06:	68 88 41 10 c0 	pushl	$3222290824
c0100e0b:	e8 aa f6 ff ff 	calll	-2390 <vga_write_string>
c0100e10:	83 c4 10 	addl	$16, %esp
c0100e13:	e9 ba 00 00 00 	jmp	186 <isr_handler+0x169>
; } else if (r.err_code==1) {
c0100e18:	8b 45 30 	movl	48(%ebp), %eax
c0100e1b:	83 f8 01 	cmpl	$1, %eax
c0100e1e:	75 15 	jne	21 <isr_handler+0xcc>
; vga_write_string(", kernel process tried to read a page and caused a protection fault at address ");
c0100e20:	83 ec 0c 	subl	$12, %esp
c0100e23:	68 cc 41 10 c0 	pushl	$3222290892
c0100e28:	e8 8d f6 ff ff 	calll	-2419 <vga_write_string>
c0100e2d:	83 c4 10 	addl	$16, %esp
c0100e30:	e9 9d 00 00 00 	jmp	157 <isr_handler+0x169>
; } else if (r.err_code==2) {
c0100e35:	8b 45 30 	movl	48(%ebp), %eax
c0100e38:	83 f8 02 	cmpl	$2, %eax
c0100e3b:	75 15 	jne	21 <isr_handler+0xe9>
; vga_write_string(", kernel process tried to write to a non-present page entry at address ");
c0100e3d:	83 ec 0c 	subl	$12, %esp
c0100e40:	68 1c 42 10 c0 	pushl	$3222290972
c0100e45:	e8 70 f6 ff ff 	calll	-2448 <vga_write_string>
c0100e4a:	83 c4 10 	addl	$16, %esp
c0100e4d:	e9 80 00 00 00 	jmp	128 <isr_handler+0x169>
; } else if (r.err_code==3) {
c0100e52:	8b 45 30 	movl	48(%ebp), %eax
c0100e55:	83 f8 03 	cmpl	$3, %eax
c0100e58:	75 12 	jne	18 <isr_handler+0x103>
; vga_write_string(", kernel process tried to write a page and caused a protection fault at address ");
c0100e5a:	83 ec 0c 	subl	$12, %esp
c0100e5d:	68 64 42 10 c0 	pushl	$3222291044
c0100e62:	e8 53 f6 ff ff 	calll	-2477 <vga_write_string>
c0100e67:	83 c4 10 	addl	$16, %esp
c0100e6a:	eb 66 	jmp	102 <isr_handler+0x169>
; } else if (r.err_code==4) {
c0100e6c:	8b 45 30 	movl	48(%ebp), %eax
c0100e6f:	83 f8 04 	cmpl	$4, %eax
c0100e72:	75 12 	jne	18 <isr_handler+0x11d>
; vga_write_string(", user process tried to read a non-present page entry at address ");
c0100e74:	83 ec 0c 	subl	$12, %esp
c0100e77:	68 b8 42 10 c0 	pushl	$3222291128
c0100e7c:	e8 39 f6 ff ff 	calll	-2503 <vga_write_string>
c0100e81:	83 c4 10 	addl	$16, %esp
c0100e84:	eb 4c 	jmp	76 <isr_handler+0x169>
; } else if (r.err_code==5) {
c0100e86:	8b 45 30 	movl	48(%ebp), %eax
c0100e89:	83 f8 05 	cmpl	$5, %eax
c0100e8c:	75 12 	jne	18 <isr_handler+0x137>
; vga_write_string(", user process tried to read a page and caused a protection fault at address ");
c0100e8e:	83 ec 0c 	subl	$12, %esp
c0100e91:	68 fc 42 10 c0 	pushl	$3222291196
c0100e96:	e8 1f f6 ff ff 	calll	-2529 <vga_write_string>
c0100e9b:	83 c4 10 	addl	$16, %esp
c0100e9e:	eb 32 	jmp	50 <isr_handler+0x169>
; } else if (r.err_code==6) {
c0100ea0:	8b 45 30 	movl	48(%ebp), %eax
c0100ea3:	83 f8 06 	cmpl	$6, %eax
c0100ea6:	75 12 	jne	18 <isr_handler+0x151>
; vga_write_string(", user process tried to write to a non-present page entry at address ");
c0100ea8:	83 ec 0c 	subl	$12, %esp
c0100eab:	68 4c 43 10 c0 	pushl	$3222291276
c0100eb0:	e8 05 f6 ff ff 	calll	-2555 <vga_write_string>
c0100eb5:	83 c4 10 	addl	$16, %esp
c0100eb8:	eb 18 	jmp	24 <isr_handler+0x169>
; } else if (r.err_code==7) {
c0100eba:	8b 45 30 	movl	48(%ebp), %eax
c0100ebd:	83 f8 07 	cmpl	$7, %eax
c0100ec0:	75 10 	jne	16 <isr_handler+0x169>
; vga_write_string(", user process tried to write a page and caused a protection fault at address ");
c0100ec2:	83 ec 0c 	subl	$12, %esp
c0100ec5:	68 94 43 10 c0 	pushl	$3222291348
c0100eca:	e8 eb f5 ff ff 	calll	-2581 <vga_write_string>
c0100ecf:	83 c4 10 	addl	$16, %esp
; str[0]='\0';
c0100ed2:	c6 45 d1 00 	movb	$0, -47(%ebp)
; hex_to_ascii(addr,str);
c0100ed6:	8b 45 e4 	movl	-28(%ebp), %eax
c0100ed9:	83 ec 08 	subl	$8, %esp
c0100edc:	8d 55 d1 	leal	-47(%ebp), %edx
c0100edf:	52 	pushl	%edx
c0100ee0:	50 	pushl	%eax
c0100ee1:	e8 dc 23 00 00 	calll	9180 <hex_to_ascii>
c0100ee6:	83 c4 10 	addl	$16, %esp
; vga_write_string(str);
c0100ee9:	83 ec 0c 	subl	$12, %esp
c0100eec:	8d 45 d1 	leal	-47(%ebp), %eax
c0100eef:	50 	pushl	%eax
c0100ef0:	e8 c5 f5 ff ff 	calll	-2619 <vga_write_string>
c0100ef5:	83 c4 10 	addl	$16, %esp
; vga_write_string(".");
c0100ef8:	83 ec 0c 	subl	$12, %esp
c0100efb:	68 e3 43 10 c0 	pushl	$3222291427
c0100f00:	e8 b5 f5 ff ff 	calll	-2635 <vga_write_string>
c0100f05:	83 c4 10 	addl	$16, %esp
; vga_write_string(" Stack is at ");
c0100f08:	83 ec 0c 	subl	$12, %esp
c0100f0b:	68 e5 43 10 c0 	pushl	$3222291429
c0100f10:	e8 a5 f5 ff ff 	calll	-2651 <vga_write_string>
c0100f15:	83 c4 10 	addl	$16, %esp
; str[0]='\0';
c0100f18:	c6 45 d1 00 	movb	$0, -47(%ebp)
; hex_to_ascii(r.useresp,str);
c0100f1c:	8b 45 40 	movl	64(%ebp), %eax
c0100f1f:	89 c2 	movl	%eax, %edx
c0100f21:	83 ec 08 	subl	$8, %esp
c0100f24:	8d 45 d1 	leal	-47(%ebp), %eax
c0100f27:	50 	pushl	%eax
c0100f28:	52 	pushl	%edx
c0100f29:	e8 94 23 00 00 	calll	9108 <hex_to_ascii>
c0100f2e:	83 c4 10 	addl	$16, %esp
; vga_write_string(str);
c0100f31:	83 ec 0c 	subl	$12, %esp
c0100f34:	8d 45 d1 	leal	-47(%ebp), %eax
c0100f37:	50 	pushl	%eax
c0100f38:	e8 7d f5 ff ff 	calll	-2691 <vga_write_string>
c0100f3d:	83 c4 10 	addl	$16, %esp
; vga_write_string(".\n");
c0100f40:	83 ec 0c 	subl	$12, %esp
c0100f43:	68 f3 43 10 c0 	pushl	$3222291443
c0100f48:	e8 6d f5 ff ff 	calll	-2707 <vga_write_string>
c0100f4d:	83 c4 10 	addl	$16, %esp
; halt();
c0100f50:	e8 4b f9 ff ff 	calll	-1717 <halt>
; if (r.eax==1) {
c0100f55:	8b 45 28 	movl	40(%ebp), %eax
c0100f58:	83 f8 01 	cmpl	$1, %eax
c0100f5b:	75 29 	jne	41 <isr_handler+0x21d>
; tss_stack_reset();
c0100f5d:	e8 b5 f6 ff ff 	calll	-2379 <tss_stack_reset>
; tasking_yield(r);
c0100f62:	83 ec 40 	subl	$64, %esp
c0100f65:	89 e0 	movl	%esp, %eax
c0100f67:	89 c2 	movl	%eax, %edx
c0100f69:	8d 5d 08 	leal	8(%ebp), %ebx
c0100f6c:	b8 10 00 00 00 	movl	$16, %eax
c0100f71:	89 d7 	movl	%edx, %edi
c0100f73:	89 de 	movl	%ebx, %esi
c0100f75:	89 c1 	movl	%eax, %ecx
c0100f77:	f3 a5 	rep		movsl	(%esi), %es:(%edi)
c0100f79:	e8 86 17 00 00 	calll	6022 <tasking_yield>
c0100f7e:	83 c4 40 	addl	$64, %esp
c0100f81:	e9 ed 01 00 00 	jmp	493 <isr_handler+0x40a>
; } else if (r.eax==2) {
c0100f86:	8b 45 28 	movl	40(%ebp), %eax
c0100f89:	83 f8 02 	cmpl	$2, %eax
c0100f8c:	75 14 	jne	20 <isr_handler+0x239>
; tasking_createTask((void*)r.ebx);
c0100f8e:	8b 45 1c 	movl	28(%ebp), %eax
c0100f91:	83 ec 0c 	subl	$12, %esp
c0100f94:	50 	pushl	%eax
c0100f95:	e8 44 17 00 00 	calll	5956 <tasking_createTask>
c0100f9a:	83 c4 10 	addl	$16, %esp
c0100f9d:	e9 d1 01 00 00 	jmp	465 <isr_handler+0x40a>
; } else if (r.eax==3) {
c0100fa2:	8b 45 28 	movl	40(%ebp), %eax
c0100fa5:	83 f8 03 	cmpl	$3, %eax
c0100fa8:	75 17 	jne	23 <isr_handler+0x258>
; r.ebx=(uint32_t)alloc_pages(r.ebx);
c0100faa:	8b 45 1c 	movl	28(%ebp), %eax
c0100fad:	83 ec 0c 	subl	$12, %esp
c0100fb0:	50 	pushl	%eax
c0100fb1:	e8 c8 0a 00 00 	calll	2760 <alloc_pages>
c0100fb6:	83 c4 10 	addl	$16, %esp
c0100fb9:	89 45 1c 	movl	%eax, 28(%ebp)
c0100fbc:	e9 b2 01 00 00 	jmp	434 <isr_handler+0x40a>
; } else if (r.eax==4) {
c0100fc1:	8b 45 28 	movl	40(%ebp), %eax
c0100fc4:	83 f8 04 	cmpl	$4, %eax
c0100fc7:	75 1a 	jne	26 <isr_handler+0x27a>
; alloc_pages_virt(r.ebx,(void*)r.ecx);
c0100fc9:	8b 45 24 	movl	36(%ebp), %eax
c0100fcc:	89 c2 	movl	%eax, %edx
c0100fce:	8b 45 1c 	movl	28(%ebp), %eax
c0100fd1:	83 ec 08 	subl	$8, %esp
c0100fd4:	52 	pushl	%edx
c0100fd5:	50 	pushl	%eax
c0100fd6:	e8 a3 0b 00 00 	calll	2979 <alloc_pages_virt>
c0100fdb:	83 c4 10 	addl	$16, %esp
c0100fde:	e9 90 01 00 00 	jmp	400 <isr_handler+0x40a>
; } else if (r.eax==5) {
c0100fe3:	8b 45 28 	movl	40(%ebp), %eax
c0100fe6:	83 f8 05 	cmpl	$5, %eax
c0100fe9:	75 0d 	jne	13 <isr_handler+0x28f>
; r.ebx=(uint32_t)tasking_get_errno_address();
c0100feb:	e8 ab 16 00 00 	calll	5803 <tasking_get_errno_address>
c0100ff0:	89 45 1c 	movl	%eax, 28(%ebp)
c0100ff3:	e9 7b 01 00 00 	jmp	379 <isr_handler+0x40a>
; } else if (r.eax==6) {
c0100ff8:	8b 45 28 	movl	40(%ebp), %eax
c0100ffb:	83 f8 06 	cmpl	$6, %eax
c0100ffe:	75 1e 	jne	30 <isr_handler+0x2b5>
; kernel_mailbox_get_msg(r.ebx,(Message*)r.ecx,r.edx);
c0101000:	8b 55 20 	movl	32(%ebp), %edx
c0101003:	8b 45 24 	movl	36(%ebp), %eax
c0101006:	89 c1 	movl	%eax, %ecx
c0101008:	8b 45 1c 	movl	28(%ebp), %eax
c010100b:	83 ec 04 	subl	$4, %esp
c010100e:	52 	pushl	%edx
c010100f:	51 	pushl	%ecx
c0101010:	50 	pushl	%eax
c0101011:	e8 2b 06 00 00 	calll	1579 <kernel_mailbox_get_msg>
c0101016:	83 c4 10 	addl	$16, %esp
c0101019:	e9 55 01 00 00 	jmp	341 <isr_handler+0x40a>
; } else if (r.eax==7) {
c010101e:	8b 45 28 	movl	40(%ebp), %eax
c0101021:	83 f8 07 	cmpl	$7, %eax
c0101024:	75 14 	jne	20 <isr_handler+0x2d1>
; kernel_mailbox_send_msg((Message*)r.ebx);
c0101026:	8b 45 1c 	movl	28(%ebp), %eax
c0101029:	83 ec 0c 	subl	$12, %esp
c010102c:	50 	pushl	%eax
c010102d:	e8 20 05 00 00 	calll	1312 <kernel_mailbox_send_msg>
c0101032:	83 c4 10 	addl	$16, %esp
c0101035:	e9 39 01 00 00 	jmp	313 <isr_handler+0x40a>
; } else if (r.eax==8) {
c010103a:	8b 45 28 	movl	40(%ebp), %eax
c010103d:	83 f8 08 	cmpl	$8, %eax
c0101040:	75 0d 	jne	13 <isr_handler+0x2e6>
; r.ebx=(uint32_t)paging_new_address_space();
c0101042:	e8 75 0b 00 00 	calll	2933 <paging_new_address_space>
c0101047:	89 45 1c 	movl	%eax, 28(%ebp)
c010104a:	e9 24 01 00 00 	jmp	292 <isr_handler+0x40a>
; } else if (r.eax==9) {
c010104f:	8b 45 28 	movl	40(%ebp), %eax
c0101052:	83 f8 09 	cmpl	$9, %eax
c0101055:	75 24 	jne	36 <isr_handler+0x312>
; tasking_createTaskCr3KmodeParam((void*)r.ebx,(void*)r.ecx,0,0,0,0,0);
c0101057:	8b 45 24 	movl	36(%ebp), %eax
c010105a:	89 c2 	movl	%eax, %edx
c010105c:	8b 45 1c 	movl	28(%ebp), %eax
c010105f:	83 ec 04 	subl	$4, %esp
c0101062:	6a 00 	pushl	$0
c0101064:	6a 00 	pushl	$0
c0101066:	6a 00 	pushl	$0
c0101068:	6a 00 	pushl	$0
c010106a:	6a 00 	pushl	$0
c010106c:	52 	pushl	%edx
c010106d:	50 	pushl	%eax
c010106e:	e8 41 13 00 00 	calll	4929 <tasking_createTaskCr3KmodeParam>
c0101073:	83 c4 20 	addl	$32, %esp
c0101076:	e9 f8 00 00 00 	jmp	248 <isr_handler+0x40a>
; } else if (r.eax==10) {
c010107b:	8b 45 28 	movl	40(%ebp), %eax
c010107e:	83 f8 0a 	cmpl	$10, %eax
c0101081:	75 21 	jne	33 <isr_handler+0x33b>
; address_spaces_copy_data((void*)r.ebx,(void*)r.ecx,r.edx,(void*)r.esi);
c0101083:	8b 45 10 	movl	16(%ebp), %eax
c0101086:	89 c3 	movl	%eax, %ebx
c0101088:	8b 45 20 	movl	32(%ebp), %eax
c010108b:	8b 55 24 	movl	36(%ebp), %edx
c010108e:	89 d1 	movl	%edx, %ecx
c0101090:	8b 55 1c 	movl	28(%ebp), %edx
c0101093:	53 	pushl	%ebx
c0101094:	50 	pushl	%eax
c0101095:	51 	pushl	%ecx
c0101096:	52 	pushl	%edx
c0101097:	e8 7e f4 ff ff 	calll	-2946 <address_spaces_copy_data>
c010109c:	83 c4 10 	addl	$16, %esp
c010109f:	e9 cf 00 00 00 	jmp	207 <isr_handler+0x40a>
; } else if (r.eax==11) {
c01010a4:	8b 45 28 	movl	40(%ebp), %eax
c01010a7:	83 f8 0b 	cmpl	$11, %eax
c01010aa:	75 57 	jne	87 <isr_handler+0x39a>
; if (!currentTask->priv) {
c01010ac:	a1 6c 90 10 c0 	movl	3222311020, %eax
c01010b1:	8a 40 10 	movb	16(%eax), %al
c01010b4:	84 c0 	testb	%al, %al
c01010b6:	75 0c 	jne	12 <isr_handler+0x35b>
; r.ebx=0;
c01010b8:	c7 45 1c 00 00 00 00 	movl	$0, 28(%ebp)
c01010bf:	e9 af 00 00 00 	jmp	175 <isr_handler+0x40a>
; uint32_t page_idx=find_free_pages(r.ecx);
c01010c4:	8b 45 24 	movl	36(%ebp), %eax
c01010c7:	83 ec 0c 	subl	$12, %esp
c01010ca:	50 	pushl	%eax
c01010cb:	e8 f6 08 00 00 	calll	2294 <find_free_pages>
c01010d0:	83 c4 10 	addl	$16, %esp
c01010d3:	89 45 e0 	movl	%eax, -32(%ebp)
; void* virt_addr=(void*)(page_idx<<12);
c01010d6:	8b 45 e0 	movl	-32(%ebp), %eax
c01010d9:	c1 e0 0c 	shll	$12, %eax
c01010dc:	89 45 dc 	movl	%eax, -36(%ebp)
; map_pages(virt_addr,(void*)r.ebx,r.ecx,1,1);
c01010df:	8b 45 24 	movl	36(%ebp), %eax
c01010e2:	89 c2 	movl	%eax, %edx
c01010e4:	8b 45 1c 	movl	28(%ebp), %eax
c01010e7:	83 ec 0c 	subl	$12, %esp
c01010ea:	6a 01 	pushl	$1
c01010ec:	6a 01 	pushl	$1
c01010ee:	52 	pushl	%edx
c01010ef:	50 	pushl	%eax
c01010f0:	ff 75 dc 	pushl	-36(%ebp)
c01010f3:	e8 66 07 00 00 	calll	1894 <map_pages>
c01010f8:	83 c4 20 	addl	$32, %esp
; r.ebx=(uint32_t)virt_addr;
c01010fb:	8b 45 dc 	movl	-36(%ebp), %eax
c01010fe:	89 45 1c 	movl	%eax, 28(%ebp)
c0101101:	eb 70 	jmp	112 <isr_handler+0x40a>
; } else if (r.eax==12) {
c0101103:	8b 45 28 	movl	40(%ebp), %eax
c0101106:	83 f8 0c 	cmpl	$12, %eax
c0101109:	75 25 	jne	37 <isr_handler+0x3c7>
; tasking_createTaskCr3KmodeParam((void*)r.ebx,(void*)r.ecx,0,1,r.edx,1,r.esi);
c010110b:	8b 55 10 	movl	16(%ebp), %edx
c010110e:	8b 45 20 	movl	32(%ebp), %eax
c0101111:	8b 4d 24 	movl	36(%ebp), %ecx
c0101114:	89 cb 	movl	%ecx, %ebx
c0101116:	8b 4d 1c 	movl	28(%ebp), %ecx
c0101119:	83 ec 04 	subl	$4, %esp
c010111c:	52 	pushl	%edx
c010111d:	6a 01 	pushl	$1
c010111f:	50 	pushl	%eax
c0101120:	6a 01 	pushl	$1
c0101122:	6a 00 	pushl	$0
c0101124:	53 	pushl	%ebx
c0101125:	51 	pushl	%ecx
c0101126:	e8 89 12 00 00 	calll	4745 <tasking_createTaskCr3KmodeParam>
c010112b:	83 c4 20 	addl	$32, %esp
c010112e:	eb 43 	jmp	67 <isr_handler+0x40a>
; } else if (r.eax==13) {
c0101130:	8b 45 28 	movl	40(%ebp), %eax
c0101133:	83 f8 0d 	cmpl	$13, %eax
c0101136:	75 1e 	jne	30 <isr_handler+0x3ed>
; r.ebx=(uint32_t)address_spaces_put_data((void*)r.ebx,(void*)r.ecx,r.edx);
c0101138:	8b 45 20 	movl	32(%ebp), %eax
c010113b:	8b 55 24 	movl	36(%ebp), %edx
c010113e:	89 d1 	movl	%edx, %ecx
c0101140:	8b 55 1c 	movl	28(%ebp), %edx
c0101143:	83 ec 04 	subl	$4, %esp
c0101146:	50 	pushl	%eax
c0101147:	51 	pushl	%ecx
c0101148:	52 	pushl	%edx
c0101149:	e8 27 f4 ff ff 	calll	-3033 <address_spaces_put_data>
c010114e:	83 c4 10 	addl	$16, %esp
c0101151:	89 45 1c 	movl	%eax, 28(%ebp)
c0101154:	eb 1d 	jmp	29 <isr_handler+0x40a>
; } else if (r.eax==14) {
c0101156:	8b 45 28 	movl	40(%ebp), %eax
c0101159:	83 f8 0e 	cmpl	$14, %eax
c010115c:	75 15 	jne	21 <isr_handler+0x40a>
; r.ebx=kernel_mailbox_new((uint16_t)r.ebx);
c010115e:	8b 45 1c 	movl	28(%ebp), %eax
c0101161:	0f b7 c0 	movzwl	%ax, %eax
c0101164:	83 ec 0c 	subl	$12, %esp
c0101167:	50 	pushl	%eax
c0101168:	e8 1d 03 00 00 	calll	797 <kernel_mailbox_new>
c010116d:	83 c4 10 	addl	$16, %esp
c0101170:	89 45 1c 	movl	%eax, 28(%ebp)
; }
c0101173:	8d 65 f4 	leal	-12(%ebp), %esp
c0101176:	5b 	popl	%ebx
c0101177:	5e 	popl	%esi
c0101178:	5f 	popl	%edi
c0101179:	5d 	popl	%ebp
c010117a:	c3 	retl

isr_register_handler:
; void isr_register_handler(uint8_t n,isr_t handler) {
c010117b:	55 	pushl	%ebp
c010117c:	89 e5 	movl	%esp, %ebp
c010117e:	83 ec 04 	subl	$4, %esp
c0101181:	8b 45 08 	movl	8(%ebp), %eax
c0101184:	88 45 fc 	movb	%al, -4(%ebp)
; interrupt_handlers[n] = handler;
c0101187:	0f b6 45 fc 	movzbl	-4(%ebp), %eax
c010118b:	8b 55 0c 	movl	12(%ebp), %edx
c010118e:	89 14 85 80 d8 10 c0 	movl	%edx, -1072637824(,%eax,4)
; }
c0101195:	90 	nop
c0101196:	c9 	leave
c0101197:	c3 	retl

irq_handler:
; void irq_handler(registers_t r) {
c0101198:	55 	pushl	%ebp
c0101199:	89 e5 	movl	%esp, %ebp
c010119b:	57 	pushl	%edi
c010119c:	56 	pushl	%esi
c010119d:	53 	pushl	%ebx
c010119e:	83 ec 1c 	subl	$28, %esp
; if (r.int_no >= 40) port_byte_out(0xA0,0x20); /* slave */
c01011a1:	8b 45 2c 	movl	44(%ebp), %eax
c01011a4:	83 f8 27 	cmpl	$39, %eax
c01011a7:	76 12 	jbe	18 <irq_handler+0x23>
c01011a9:	83 ec 08 	subl	$8, %esp
c01011ac:	6a 20 	pushl	$32
c01011ae:	68 a0 00 00 00 	pushl	$160
c01011b3:	e8 1b 11 00 00 	calll	4379 <port_byte_out>
c01011b8:	83 c4 10 	addl	$16, %esp
; port_byte_out(0x20,0x20); /* master */
c01011bb:	83 ec 08 	subl	$8, %esp
c01011be:	6a 20 	pushl	$32
c01011c0:	6a 20 	pushl	$32
c01011c2:	e8 0c 11 00 00 	calll	4364 <port_byte_out>
c01011c7:	83 c4 10 	addl	$16, %esp
; if (interrupt_handlers[r.int_no] != 0) {
c01011ca:	8b 45 2c 	movl	44(%ebp), %eax
c01011cd:	8b 04 85 80 d8 10 c0 	movl	-1072637824(,%eax,4), %eax
c01011d4:	85 c0 	testl	%eax, %eax
c01011d6:	74 2c 	je	44 <irq_handler+0x6c>
; isr_t handler = interrupt_handlers[r.int_no];
c01011d8:	8b 45 2c 	movl	44(%ebp), %eax
c01011db:	8b 04 85 80 d8 10 c0 	movl	-1072637824(,%eax,4), %eax
c01011e2:	89 45 e4 	movl	%eax, -28(%ebp)
; handler(r);
c01011e5:	83 ec 40 	subl	$64, %esp
c01011e8:	89 e0 	movl	%esp, %eax
c01011ea:	89 c2 	movl	%eax, %edx
c01011ec:	8d 5d 08 	leal	8(%ebp), %ebx
c01011ef:	b8 10 00 00 00 	movl	$16, %eax
c01011f4:	89 d7 	movl	%edx, %edi
c01011f6:	89 de 	movl	%ebx, %esi
c01011f8:	89 c1 	movl	%eax, %ecx
c01011fa:	f3 a5 	rep		movsl	(%esi), %es:(%edi)
c01011fc:	8b 45 e4 	movl	-28(%ebp), %eax
c01011ff:	ff d0 	calll	*%eax
c0101201:	83 c4 40 	addl	$64, %esp
; }
c0101204:	90 	nop
c0101205:	8d 65 f4 	leal	-12(%ebp), %esp
c0101208:	5b 	popl	%ebx
c0101209:	5e 	popl	%esi
c010120a:	5f 	popl	%edi
c010120b:	5d 	popl	%ebp
c010120c:	c3 	retl

get_bmap_bit:
; static char get_bmap_bit(uint32_t index) {
c010120d:	55 	pushl	%ebp
c010120e:	89 e5 	movl	%esp, %ebp
c0101210:	53 	pushl	%ebx
c0101211:	83 ec 10 	subl	$16, %esp
; uint32_t byte=index/8;
c0101214:	8b 45 08 	movl	8(%ebp), %eax
c0101217:	c1 e8 03 	shrl	$3, %eax
c010121a:	89 45 f8 	movl	%eax, -8(%ebp)
; uint32_t bit=index%8;
c010121d:	8b 45 08 	movl	8(%ebp), %eax
c0101220:	83 e0 07 	andl	$7, %eax
c0101223:	89 45 f4 	movl	%eax, -12(%ebp)
; char entry=bitmap[byte];
c0101226:	8b 45 f8 	movl	-8(%ebp), %eax
c0101229:	05 80 dc 10 c0 	addl	$3222330496, %eax
c010122e:	8a 00 	movb	(%eax), %al
c0101230:	88 45 f3 	movb	%al, -13(%ebp)
; return (entry&(1<<bit))>0;
c0101233:	0f be 55 f3 	movsbl	-13(%ebp), %edx
c0101237:	8b 45 f4 	movl	-12(%ebp), %eax
c010123a:	bb 01 00 00 00 	movl	$1, %ebx
c010123f:	88 c1 	movb	%al, %cl
c0101241:	d3 e3 	shll	%cl, %ebx
c0101243:	89 d8 	movl	%ebx, %eax
c0101245:	21 d0 	andl	%edx, %eax
c0101247:	85 c0 	testl	%eax, %eax
c0101249:	0f 9f c0 	setg	%al
; }
c010124c:	83 c4 10 	addl	$16, %esp
c010124f:	5b 	popl	%ebx
c0101250:	5d 	popl	%ebp
c0101251:	c3 	retl

set_bmap_bit:
; static void set_bmap_bit(uint32_t index) {
c0101252:	55 	pushl	%ebp
c0101253:	89 e5 	movl	%esp, %ebp
c0101255:	53 	pushl	%ebx
c0101256:	83 ec 10 	subl	$16, %esp
; uint32_t byte=index/8;
c0101259:	8b 45 08 	movl	8(%ebp), %eax
c010125c:	c1 e8 03 	shrl	$3, %eax
c010125f:	89 45 f8 	movl	%eax, -8(%ebp)
; uint32_t bit=index%8;
c0101262:	8b 45 08 	movl	8(%ebp), %eax
c0101265:	83 e0 07 	andl	$7, %eax
c0101268:	89 45 f4 	movl	%eax, -12(%ebp)
; bitmap[byte]=bitmap[byte]|(1<<bit);
c010126b:	8b 45 f8 	movl	-8(%ebp), %eax
c010126e:	05 80 dc 10 c0 	addl	$3222330496, %eax
c0101273:	8a 10 	movb	(%eax), %dl
c0101275:	8b 45 f4 	movl	-12(%ebp), %eax
c0101278:	bb 01 00 00 00 	movl	$1, %ebx
c010127d:	88 c1 	movb	%al, %cl
c010127f:	d3 e3 	shll	%cl, %ebx
c0101281:	89 d8 	movl	%ebx, %eax
c0101283:	09 c2 	orl	%eax, %edx
c0101285:	8b 45 f8 	movl	-8(%ebp), %eax
c0101288:	05 80 dc 10 c0 	addl	$3222330496, %eax
c010128d:	88 10 	movb	%dl, (%eax)
; }
c010128f:	90 	nop
c0101290:	83 c4 10 	addl	$16, %esp
c0101293:	5b 	popl	%ebx
c0101294:	5d 	popl	%ebp
c0101295:	c3 	retl

clear_bmap_bit:
; static void clear_bmap_bit(uint32_t index) {
c0101296:	55 	pushl	%ebp
c0101297:	89 e5 	movl	%esp, %ebp
c0101299:	53 	pushl	%ebx
c010129a:	83 ec 10 	subl	$16, %esp
; uint32_t byte=index/8;
c010129d:	8b 45 08 	movl	8(%ebp), %eax
c01012a0:	c1 e8 03 	shrl	$3, %eax
c01012a3:	89 45 f8 	movl	%eax, -8(%ebp)
; uint32_t bit=index%8;
c01012a6:	8b 45 08 	movl	8(%ebp), %eax
c01012a9:	83 e0 07 	andl	$7, %eax
c01012ac:	89 45 f4 	movl	%eax, -12(%ebp)
; bitmap[byte]=bitmap[byte]&(~(1<<bit));
c01012af:	8b 45 f8 	movl	-8(%ebp), %eax
c01012b2:	05 80 dc 10 c0 	addl	$3222330496, %eax
c01012b7:	8a 10 	movb	(%eax), %dl
c01012b9:	8b 45 f4 	movl	-12(%ebp), %eax
c01012bc:	bb 01 00 00 00 	movl	$1, %ebx
c01012c1:	88 c1 	movb	%al, %cl
c01012c3:	d3 e3 	shll	%cl, %ebx
c01012c5:	89 d8 	movl	%ebx, %eax
c01012c7:	f7 d0 	notl	%eax
c01012c9:	21 c2 	andl	%eax, %edx
c01012cb:	8b 45 f8 	movl	-8(%ebp), %eax
c01012ce:	05 80 dc 10 c0 	addl	$3222330496, %eax
c01012d3:	88 10 	movb	%dl, (%eax)
; }
c01012d5:	90 	nop
c01012d6:	83 c4 10 	addl	$16, %esp
c01012d9:	5b 	popl	%ebx
c01012da:	5d 	popl	%ebp
c01012db:	c3 	retl

kmalloc:
; void* kmalloc(uint32_t size) {
c01012dc:	55 	pushl	%ebp
c01012dd:	89 e5 	movl	%esp, %ebp
c01012df:	83 ec 58 	subl	$88, %esp
; uint32_t num_4b_grps=(uint32_t)ceilf((float)size/4);
c01012e2:	8b 45 08 	movl	8(%ebp), %eax
c01012e5:	ba 00 00 00 00 	movl	$0, %edx
c01012ea:	89 45 b0 	movl	%eax, -80(%ebp)
c01012ed:	89 55 b4 	movl	%edx, -76(%ebp)
c01012f0:	df 6d b0 	fildll	-80(%ebp)
c01012f3:	d9 5d c4 	fstps	-60(%ebp)
c01012f6:	d9 45 c4 	flds	-60(%ebp)
c01012f9:	d9 05 f8 43 10 c0 	flds	-1072675848
c01012ff:	de f9 	fdivrp	%st(1)
c0101301:	83 ec 0c 	subl	$12, %esp
c0101304:	8d 64 24 fc 	leal	-4(%esp), %esp
c0101308:	d9 1c 24 	fstps	(%esp)
c010130b:	e8 f3 16 00 00 	calll	5875 <ceilf>
c0101310:	83 c4 10 	addl	$16, %esp
c0101313:	d9 7d c2 	fnstcw	-62(%ebp)
c0101316:	66 8b 45 c2 	movw	-62(%ebp), %ax
c010131a:	80 cc 0c 	orb	$12, %ah
c010131d:	66 89 45 c0 	movw	%ax, -64(%ebp)
c0101321:	d9 6d c0 	fldcw	-64(%ebp)
c0101324:	df 7d b8 	fistpll	-72(%ebp)
c0101327:	d9 6d c2 	fldcw	-62(%ebp)
c010132a:	8b 45 b8 	movl	-72(%ebp), %eax
c010132d:	8b 55 bc 	movl	-68(%ebp), %edx
c0101330:	89 45 d8 	movl	%eax, -40(%ebp)
; num_4b_grps+=2;
c0101333:	83 45 d8 02 	addl	$2, -40(%ebp)
; for(uint32_t i=0;i<2097152;i++) {
c0101337:	c7 45 ec 00 00 00 00 	movl	$0, -20(%ebp)
c010133e:	e9 80 00 00 00 	jmp	128 <kmalloc+0xe7>
; char got_0=0;
c0101343:	c6 45 eb 00 	movb	$0, -21(%ebp)
; remaining_blks=num_4b_grps;
c0101347:	8b 45 d8 	movl	-40(%ebp), %eax
c010134a:	89 45 f0 	movl	%eax, -16(%ebp)
; for (uint32_t j=i*8;;j++) {
c010134d:	8b 45 ec 	movl	-20(%ebp), %eax
c0101350:	c1 e0 03 	shll	$3, %eax
c0101353:	89 45 e0 	movl	%eax, -32(%ebp)
; char bit=get_bmap_bit(j);
c0101356:	83 ec 0c 	subl	$12, %esp
c0101359:	ff 75 e0 	pushl	-32(%ebp)
c010135c:	e8 ac fe ff ff 	calll	-340 <get_bmap_bit>
c0101361:	83 c4 10 	addl	$16, %esp
c0101364:	88 45 d7 	movb	%al, -41(%ebp)
; if (got_0) {
c0101367:	80 7d eb 00 	cmpb	$0, -21(%ebp)
c010136b:	74 27 	je	39 <kmalloc+0xb8>
; if (bit) {
c010136d:	80 7d d7 00 	cmpb	$0, -41(%ebp)
c0101371:	74 1c 	je	28 <kmalloc+0xb3>
; if (remaining_blks==0) {
c0101373:	83 7d f0 00 	cmpl	$0, -16(%ebp)
c0101377:	75 08 	jne	8 <kmalloc+0xa5>
; bmap_index=old_j;
c0101379:	8b 45 e4 	movl	-28(%ebp), %eax
c010137c:	89 45 f4 	movl	%eax, -12(%ebp)
; break;
c010137f:	eb 39 	jmp	57 <kmalloc+0xde>
; i+=j/8;
c0101381:	8b 45 e0 	movl	-32(%ebp), %eax
c0101384:	c1 e8 03 	shrl	$3, %eax
c0101387:	01 45 ec 	addl	%eax, -20(%ebp)
; i--;
c010138a:	ff 4d ec 	decl	-20(%ebp)
; break;
c010138d:	eb 2b 	jmp	43 <kmalloc+0xde>
; remaining_blks--;
c010138f:	ff 4d f0 	decl	-16(%ebp)
c0101392:	eb 13 	jmp	19 <kmalloc+0xcb>
; if (!bit) {
c0101394:	80 7d d7 00 	cmpb	$0, -41(%ebp)
c0101398:	75 0d 	jne	13 <kmalloc+0xcb>
; got_0=1;
c010139a:	c6 45 eb 01 	movb	$1, -21(%ebp)
; old_j=j;
c010139e:	8b 45 e0 	movl	-32(%ebp), %eax
c01013a1:	89 45 e4 	movl	%eax, -28(%ebp)
; remaining_blks--;
c01013a4:	ff 4d f0 	decl	-16(%ebp)
; if (remaining_blks==0) {
c01013a7:	83 7d f0 00 	cmpl	$0, -16(%ebp)
c01013ab:	75 08 	jne	8 <kmalloc+0xd9>
; bmap_index=old_j;
c01013ad:	8b 45 e4 	movl	-28(%ebp), %eax
c01013b0:	89 45 f4 	movl	%eax, -12(%ebp)
; break;
c01013b3:	eb 05 	jmp	5 <kmalloc+0xde>
; for (uint32_t j=i*8;;j++) {
c01013b5:	ff 45 e0 	incl	-32(%ebp)
c01013b8:	eb 9c 	jmp	-100 <kmalloc+0x7a>
; if (remaining_blks==0) {
c01013ba:	83 7d f0 00 	cmpl	$0, -16(%ebp)
c01013be:	74 12 	je	18 <kmalloc+0xf6>
; for(uint32_t i=0;i<2097152;i++) {
c01013c0:	ff 45 ec 	incl	-20(%ebp)
c01013c3:	81 7d ec ff ff 1f 00 	cmpl	$2097151, -20(%ebp)
c01013ca:	0f 86 73 ff ff ff 	jbe	-141 <kmalloc+0x67>
c01013d0:	eb 01 	jmp	1 <kmalloc+0xf7>
; break;
c01013d2:	90 	nop
; if (remaining_blks!=0) {
c01013d3:	83 7d f0 00 	cmpl	$0, -16(%ebp)
c01013d7:	74 07 	je	7 <kmalloc+0x104>
; return NULL;
c01013d9:	b8 00 00 00 00 	movl	$0, %eax
c01013de:	eb 60 	jmp	96 <kmalloc+0x164>
; for (uint32_t i=0;i<num_4b_grps;i++) {
c01013e0:	c7 45 dc 00 00 00 00 	movl	$0, -36(%ebp)
c01013e7:	eb 17 	jmp	23 <kmalloc+0x124>
; set_bmap_bit(bmap_index+i);
c01013e9:	8b 55 f4 	movl	-12(%ebp), %edx
c01013ec:	8b 45 dc 	movl	-36(%ebp), %eax
c01013ef:	01 d0 	addl	%edx, %eax
c01013f1:	83 ec 0c 	subl	$12, %esp
c01013f4:	50 	pushl	%eax
c01013f5:	e8 58 fe ff ff 	calll	-424 <set_bmap_bit>
c01013fa:	83 c4 10 	addl	$16, %esp
; for (uint32_t i=0;i<num_4b_grps;i++) {
c01013fd:	ff 45 dc 	incl	-36(%ebp)
c0101400:	8b 45 dc 	movl	-36(%ebp), %eax
c0101403:	3b 45 d8 	cmpl	-40(%ebp), %eax
c0101406:	72 e1 	jb	-31 <kmalloc+0x10d>
; uint32_t data_offset=(bmap_index*8)+8;
c0101408:	8b 45 f4 	movl	-12(%ebp), %eax
c010140b:	40 	incl	%eax
c010140c:	c1 e0 03 	shll	$3, %eax
c010140f:	89 45 d0 	movl	%eax, -48(%ebp)
; uint32_t* info=(void*)(((char*)data)+data_offset-8);
c0101412:	a1 80 60 10 c0 	movl	3222298752, %eax
c0101417:	8b 55 d0 	movl	-48(%ebp), %edx
c010141a:	83 ea 08 	subl	$8, %edx
c010141d:	01 d0 	addl	%edx, %eax
c010141f:	89 45 cc 	movl	%eax, -52(%ebp)
; info[0]=num_4b_grps;
c0101422:	8b 45 cc 	movl	-52(%ebp), %eax
c0101425:	8b 55 d8 	movl	-40(%ebp), %edx
c0101428:	89 10 	movl	%edx, (%eax)
; info[1]=bmap_index;
c010142a:	8b 45 cc 	movl	-52(%ebp), %eax
c010142d:	8d 50 04 	leal	4(%eax), %edx
c0101430:	8b 45 f4 	movl	-12(%ebp), %eax
c0101433:	89 02 	movl	%eax, (%edx)
; return (void*)(((char*)data)+data_offset);
c0101435:	8b 15 80 60 10 c0 	movl	-1072668544, %edx
c010143b:	8b 45 d0 	movl	-48(%ebp), %eax
c010143e:	01 d0 	addl	%edx, %eax
; }
c0101440:	c9 	leave
c0101441:	c3 	retl

kfree:
; void kfree(void* mem) {
c0101442:	55 	pushl	%ebp
c0101443:	89 e5 	movl	%esp, %ebp
c0101445:	83 ec 10 	subl	$16, %esp
; uint32_t* info=(uint32_t*)((uint32_t)mem-12);
c0101448:	8b 45 08 	movl	8(%ebp), %eax
c010144b:	83 e8 0c 	subl	$12, %eax
c010144e:	89 45 f8 	movl	%eax, -8(%ebp)
; uint32_t num_4b_grps=info[0];
c0101451:	8b 45 f8 	movl	-8(%ebp), %eax
c0101454:	8b 00 	movl	(%eax), %eax
c0101456:	89 45 f4 	movl	%eax, -12(%ebp)
; uint32_t bmap_index=info[1];
c0101459:	8b 45 f8 	movl	-8(%ebp), %eax
c010145c:	8b 40 04 	movl	4(%eax), %eax
c010145f:	89 45 f0 	movl	%eax, -16(%ebp)
; for (uint32_t i=0;i<num_4b_grps;i++) {
c0101462:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
c0101469:	eb 14 	jmp	20 <kfree+0x3d>
; clear_bmap_bit(bmap_index+i);
c010146b:	8b 55 f0 	movl	-16(%ebp), %edx
c010146e:	8b 45 fc 	movl	-4(%ebp), %eax
c0101471:	01 d0 	addl	%edx, %eax
c0101473:	50 	pushl	%eax
c0101474:	e8 1d fe ff ff 	calll	-483 <clear_bmap_bit>
c0101479:	83 c4 04 	addl	$4, %esp
; for (uint32_t i=0;i<num_4b_grps;i++) {
c010147c:	ff 45 fc 	incl	-4(%ebp)
c010147f:	8b 45 fc 	movl	-4(%ebp), %eax
c0101482:	3b 45 f4 	cmpl	-12(%ebp), %eax
c0101485:	72 e4 	jb	-28 <kfree+0x29>
; }
c0101487:	90 	nop
c0101488:	c9 	leave
c0101489:	c3 	retl

kernel_mailbox_new:
; uint32_t kernel_mailbox_new(uint16_t size) {
c010148a:	55 	pushl	%ebp
c010148b:	89 e5 	movl	%esp, %ebp
c010148d:	53 	pushl	%ebx
c010148e:	83 ec 14 	subl	$20, %esp
c0101491:	8b 45 08 	movl	8(%ebp), %eax
c0101494:	66 89 45 f4 	movw	%ax, -12(%ebp)
; if (next_box==262144) {
c0101498:	a1 88 60 10 c0 	movl	3222298760, %eax
c010149d:	3d 00 00 04 00 	cmpl	$262144, %eax
c01014a2:	75 07 	jne	7 <kernel_mailbox_new+0x21>
; return 0xFFFFFFFF;
c01014a4:	b8 ff ff ff ff 	movl	$4294967295, %eax
c01014a9:	eb 7d 	jmp	125 <kernel_mailbox_new+0x9e>
; mailboxes[next_box].rd=0;
c01014ab:	a1 84 60 10 c0 	movl	3222298756, %eax
c01014b0:	8b 15 88 60 10 c0 	movl	-1072668536, %edx
c01014b6:	c1 e2 04 	shll	$4, %edx
c01014b9:	01 d0 	addl	%edx, %eax
c01014bb:	c7 00 00 00 00 00 	movl	$0, (%eax)
; mailboxes[next_box].wr=0;
c01014c1:	a1 84 60 10 c0 	movl	3222298756, %eax
c01014c6:	8b 15 88 60 10 c0 	movl	-1072668536, %edx
c01014cc:	c1 e2 04 	shll	$4, %edx
c01014cf:	01 d0 	addl	%edx, %eax
c01014d1:	c7 40 04 00 00 00 00 	movl	$0, 4(%eax)
; mailboxes[next_box].size=size;
c01014d8:	a1 84 60 10 c0 	movl	3222298756, %eax
c01014dd:	8b 15 88 60 10 c0 	movl	-1072668536, %edx
c01014e3:	c1 e2 04 	shll	$4, %edx
c01014e6:	01 c2 	addl	%eax, %edx
c01014e8:	8b 45 f4 	movl	-12(%ebp), %eax
c01014eb:	66 89 42 08 	movw	%ax, 8(%edx)
; mailboxes[next_box].msg_store=kmalloc(sizeof(Message)*size);
c01014ef:	0f b7 45 f4 	movzwl	-12(%ebp), %eax
c01014f3:	c1 e0 04 	shll	$4, %eax
c01014f6:	8b 15 84 60 10 c0 	movl	-1072668540, %edx
c01014fc:	8b 0d 88 60 10 c0 	movl	-1072668536, %ecx
c0101502:	c1 e1 04 	shll	$4, %ecx
c0101505:	8d 1c 0a 	leal	(%edx,%ecx), %ebx
c0101508:	83 ec 0c 	subl	$12, %esp
c010150b:	50 	pushl	%eax
c010150c:	e8 cb fd ff ff 	calll	-565 <kmalloc>
c0101511:	83 c4 10 	addl	$16, %esp
c0101514:	89 43 0c 	movl	%eax, 12(%ebx)
; next_box++;
c0101517:	a1 88 60 10 c0 	movl	3222298760, %eax
c010151c:	40 	incl	%eax
c010151d:	a3 88 60 10 c0 	movl	%eax, 3222298760
; return next_box-1;
c0101522:	a1 88 60 10 c0 	movl	3222298760, %eax
c0101527:	48 	decl	%eax
; }
c0101528:	8b 5d fc 	movl	-4(%ebp), %ebx
c010152b:	c9 	leave
c010152c:	c3 	retl

kernel_mailbox_free:
; void kernel_mailbox_free(uint32_t box) {
c010152d:	55 	pushl	%ebp
c010152e:	89 e5 	movl	%esp, %ebp
c0101530:	83 ec 08 	subl	$8, %esp
; kfree(mailboxes[box].msg_store);
c0101533:	a1 84 60 10 c0 	movl	3222298756, %eax
c0101538:	8b 55 08 	movl	8(%ebp), %edx
c010153b:	c1 e2 04 	shll	$4, %edx
c010153e:	01 d0 	addl	%edx, %eax
c0101540:	8b 40 0c 	movl	12(%eax), %eax
c0101543:	83 ec 0c 	subl	$12, %esp
c0101546:	50 	pushl	%eax
c0101547:	e8 f6 fe ff ff 	calll	-266 <kfree>
c010154c:	83 c4 10 	addl	$16, %esp
; }
c010154f:	90 	nop
c0101550:	c9 	leave
c0101551:	c3 	retl

kernel_mailbox_send_msg:
; void kernel_mailbox_send_msg(Message* user_msg) {
c0101552:	55 	pushl	%ebp
c0101553:	89 e5 	movl	%esp, %ebp
c0101555:	57 	pushl	%edi
c0101556:	56 	pushl	%esi
c0101557:	53 	pushl	%ebx
c0101558:	83 ec 2c 	subl	$44, %esp
; Mailbox mailbox=mailboxes[user_msg->to];
c010155b:	8b 15 84 60 10 c0 	movl	-1072668540, %edx
c0101561:	8b 45 08 	movl	8(%ebp), %eax
c0101564:	8b 40 08 	movl	8(%eax), %eax
c0101567:	c1 e0 04 	shll	$4, %eax
c010156a:	01 c2 	addl	%eax, %edx
c010156c:	8d 45 d4 	leal	-44(%ebp), %eax
c010156f:	89 d3 	movl	%edx, %ebx
c0101571:	ba 04 00 00 00 	movl	$4, %edx
c0101576:	89 c7 	movl	%eax, %edi
c0101578:	89 de 	movl	%ebx, %esi
c010157a:	89 d1 	movl	%edx, %ecx
c010157c:	f3 a5 	rep		movsl	(%esi), %es:(%edi)
; char* msg_data=kmalloc(user_msg->size);
c010157e:	8b 45 08 	movl	8(%ebp), %eax
c0101581:	8b 40 0c 	movl	12(%eax), %eax
c0101584:	83 ec 0c 	subl	$12, %esp
c0101587:	50 	pushl	%eax
c0101588:	e8 4f fd ff ff 	calll	-689 <kmalloc>
c010158d:	83 c4 10 	addl	$16, %esp
c0101590:	89 45 e4 	movl	%eax, -28(%ebp)
; memcpy(msg_data,user_msg->msg,user_msg->size);
c0101593:	8b 45 08 	movl	8(%ebp), %eax
c0101596:	8b 50 0c 	movl	12(%eax), %edx
c0101599:	8b 45 08 	movl	8(%ebp), %eax
c010159c:	8b 00 	movl	(%eax), %eax
c010159e:	83 ec 04 	subl	$4, %esp
c01015a1:	52 	pushl	%edx
c01015a2:	50 	pushl	%eax
c01015a3:	ff 75 e4 	pushl	-28(%ebp)
c01015a6:	e8 ec 1a 00 00 	calll	6892 <memcpy>
c01015ab:	83 c4 10 	addl	$16, %esp
; mailbox.msg_store[mailbox.wr].msg=msg_data;
c01015ae:	8b 45 e0 	movl	-32(%ebp), %eax
c01015b1:	8b 55 d8 	movl	-40(%ebp), %edx
c01015b4:	c1 e2 04 	shll	$4, %edx
c01015b7:	01 c2 	addl	%eax, %edx
c01015b9:	8b 45 e4 	movl	-28(%ebp), %eax
c01015bc:	89 02 	movl	%eax, (%edx)
; mailbox.msg_store[mailbox.wr].from=user_msg->from;
c01015be:	8b 45 e0 	movl	-32(%ebp), %eax
c01015c1:	8b 55 d8 	movl	-40(%ebp), %edx
c01015c4:	c1 e2 04 	shll	$4, %edx
c01015c7:	01 c2 	addl	%eax, %edx
c01015c9:	8b 45 08 	movl	8(%ebp), %eax
c01015cc:	8b 40 04 	movl	4(%eax), %eax
c01015cf:	89 42 04 	movl	%eax, 4(%edx)
; mailbox.msg_store[mailbox.wr].to=user_msg->to;
c01015d2:	8b 45 e0 	movl	-32(%ebp), %eax
c01015d5:	8b 55 d8 	movl	-40(%ebp), %edx
c01015d8:	c1 e2 04 	shll	$4, %edx
c01015db:	01 c2 	addl	%eax, %edx
c01015dd:	8b 45 08 	movl	8(%ebp), %eax
c01015e0:	8b 40 08 	movl	8(%eax), %eax
c01015e3:	89 42 08 	movl	%eax, 8(%edx)
; mailbox.msg_store[mailbox.wr].size=user_msg->size;
c01015e6:	8b 45 e0 	movl	-32(%ebp), %eax
c01015e9:	8b 55 d8 	movl	-40(%ebp), %edx
c01015ec:	c1 e2 04 	shll	$4, %edx
c01015ef:	01 c2 	addl	%eax, %edx
c01015f1:	8b 45 08 	movl	8(%ebp), %eax
c01015f4:	8b 40 0c 	movl	12(%eax), %eax
c01015f7:	89 42 0c 	movl	%eax, 12(%edx)
; mailbox.wr++;
c01015fa:	8b 45 d8 	movl	-40(%ebp), %eax
c01015fd:	40 	incl	%eax
c01015fe:	89 45 d8 	movl	%eax, -40(%ebp)
; if (mailbox.wr==mailbox.size) {
c0101601:	8b 55 d8 	movl	-40(%ebp), %edx
c0101604:	8b 45 dc 	movl	-36(%ebp), %eax
c0101607:	0f b7 c0 	movzwl	%ax, %eax
c010160a:	39 c2 	cmpl	%eax, %edx
c010160c:	75 07 	jne	7 <kernel_mailbox_send_msg+0xc3>
; mailbox.wr=0;
c010160e:	c7 45 d8 00 00 00 00 	movl	$0, -40(%ebp)
; if (mailbox.wr==mailbox.rd) {
c0101615:	8b 55 d8 	movl	-40(%ebp), %edx
c0101618:	8b 45 d4 	movl	-44(%ebp), %eax
c010161b:	39 c2 	cmpl	%eax, %edx
c010161d:	75 19 	jne	25 <kernel_mailbox_send_msg+0xe6>
; mailbox.wr--;
c010161f:	8b 45 d8 	movl	-40(%ebp), %eax
c0101622:	48 	decl	%eax
c0101623:	89 45 d8 	movl	%eax, -40(%ebp)
; if (mailbox.wr==(2^32)-1) {
c0101626:	8b 45 d8 	movl	-40(%ebp), %eax
c0101629:	83 f8 21 	cmpl	$33, %eax
c010162c:	75 0a 	jne	10 <kernel_mailbox_send_msg+0xe6>
; mailbox.wr=mailbox.size-1;
c010162e:	8b 45 dc 	movl	-36(%ebp), %eax
c0101631:	0f b7 c0 	movzwl	%ax, %eax
c0101634:	48 	decl	%eax
c0101635:	89 45 d8 	movl	%eax, -40(%ebp)
; }
c0101638:	90 	nop
c0101639:	8d 65 f4 	leal	-12(%ebp), %esp
c010163c:	5b 	popl	%ebx
c010163d:	5e 	popl	%esi
c010163e:	5f 	popl	%edi
c010163f:	5d 	popl	%ebp
c0101640:	c3 	retl

kernel_mailbox_get_msg:
; void kernel_mailbox_get_msg(uint32_t box, Message* recv_msg, uint32_t buffer_sz) {
c0101641:	55 	pushl	%ebp
c0101642:	89 e5 	movl	%esp, %ebp
c0101644:	57 	pushl	%edi
c0101645:	56 	pushl	%esi
c0101646:	53 	pushl	%ebx
c0101647:	83 ec 1c 	subl	$28, %esp
; Mailbox mailbox=mailboxes[box];
c010164a:	a1 84 60 10 c0 	movl	3222298756, %eax
c010164f:	8b 55 08 	movl	8(%ebp), %edx
c0101652:	c1 e2 04 	shll	$4, %edx
c0101655:	01 c2 	addl	%eax, %edx
c0101657:	8d 45 d8 	leal	-40(%ebp), %eax
c010165a:	89 d3 	movl	%edx, %ebx
c010165c:	ba 04 00 00 00 	movl	$4, %edx
c0101661:	89 c7 	movl	%eax, %edi
c0101663:	89 de 	movl	%ebx, %esi
c0101665:	89 d1 	movl	%edx, %ecx
c0101667:	f3 a5 	rep		movsl	(%esi), %es:(%edi)
; if (mailbox.msg_store[mailbox.rd].size==0) {
c0101669:	8b 45 e4 	movl	-28(%ebp), %eax
c010166c:	8b 55 d8 	movl	-40(%ebp), %edx
c010166f:	c1 e2 04 	shll	$4, %edx
c0101672:	01 d0 	addl	%edx, %eax
c0101674:	8b 40 0c 	movl	12(%eax), %eax
c0101677:	85 c0 	testl	%eax, %eax
c0101679:	75 5f 	jne	95 <kernel_mailbox_get_msg+0x99>
; mailbox.rd++;
c010167b:	8b 45 d8 	movl	-40(%ebp), %eax
c010167e:	40 	incl	%eax
c010167f:	89 45 d8 	movl	%eax, -40(%ebp)
; if (mailbox.rd==mailbox.size) {
c0101682:	8b 55 d8 	movl	-40(%ebp), %edx
c0101685:	8b 45 e0 	movl	-32(%ebp), %eax
c0101688:	0f b7 c0 	movzwl	%ax, %eax
c010168b:	39 c2 	cmpl	%eax, %edx
c010168d:	75 07 	jne	7 <kernel_mailbox_get_msg+0x55>
; mailbox.rd=0;
c010168f:	c7 45 d8 00 00 00 00 	movl	$0, -40(%ebp)
; if (mailbox.msg_store[mailbox.rd].size==0) {
c0101696:	8b 45 e4 	movl	-28(%ebp), %eax
c0101699:	8b 55 d8 	movl	-40(%ebp), %edx
c010169c:	c1 e2 04 	shll	$4, %edx
c010169f:	01 d0 	addl	%edx, %eax
c01016a1:	8b 40 0c 	movl	12(%eax), %eax
c01016a4:	85 c0 	testl	%eax, %eax
c01016a6:	75 32 	jne	50 <kernel_mailbox_get_msg+0x99>
; mailbox.rd--;
c01016a8:	8b 45 d8 	movl	-40(%ebp), %eax
c01016ab:	48 	decl	%eax
c01016ac:	89 45 d8 	movl	%eax, -40(%ebp)
; if (mailbox.rd==(2^32)-1) {
c01016af:	8b 45 d8 	movl	-40(%ebp), %eax
c01016b2:	83 f8 21 	cmpl	$33, %eax
c01016b5:	75 0a 	jne	10 <kernel_mailbox_get_msg+0x80>
; mailbox.rd=mailbox.size-1;
c01016b7:	8b 45 e0 	movl	-32(%ebp), %eax
c01016ba:	0f b7 c0 	movzwl	%ax, %eax
c01016bd:	48 	decl	%eax
c01016be:	89 45 d8 	movl	%eax, -40(%ebp)
; recv_msg->size=0;
c01016c1:	8b 45 0c 	movl	12(%ebp), %eax
c01016c4:	c7 40 0c 00 00 00 00 	movl	$0, 12(%eax)
; recv_msg->from=0;
c01016cb:	8b 45 0c 	movl	12(%ebp), %eax
c01016ce:	c7 40 04 00 00 00 00 	movl	$0, 4(%eax)
; return;
c01016d5:	e9 09 01 00 00 	jmp	265 <kernel_mailbox_get_msg+0x1a2>
; recv_msg->from=mailbox.msg_store[mailbox.rd].from;
c01016da:	8b 45 e4 	movl	-28(%ebp), %eax
c01016dd:	8b 55 d8 	movl	-40(%ebp), %edx
c01016e0:	c1 e2 04 	shll	$4, %edx
c01016e3:	01 d0 	addl	%edx, %eax
c01016e5:	8b 50 04 	movl	4(%eax), %edx
c01016e8:	8b 45 0c 	movl	12(%ebp), %eax
c01016eb:	89 50 04 	movl	%edx, 4(%eax)
; recv_msg->to=mailbox.msg_store[mailbox.rd].to;
c01016ee:	8b 45 e4 	movl	-28(%ebp), %eax
c01016f1:	8b 55 d8 	movl	-40(%ebp), %edx
c01016f4:	c1 e2 04 	shll	$4, %edx
c01016f7:	01 d0 	addl	%edx, %eax
c01016f9:	8b 50 08 	movl	8(%eax), %edx
c01016fc:	8b 45 0c 	movl	12(%ebp), %eax
c01016ff:	89 50 08 	movl	%edx, 8(%eax)
; recv_msg->size=mailbox.msg_store[mailbox.rd].size;
c0101702:	8b 45 e4 	movl	-28(%ebp), %eax
c0101705:	8b 55 d8 	movl	-40(%ebp), %edx
c0101708:	c1 e2 04 	shll	$4, %edx
c010170b:	01 d0 	addl	%edx, %eax
c010170d:	8b 50 0c 	movl	12(%eax), %edx
c0101710:	8b 45 0c 	movl	12(%ebp), %eax
c0101713:	89 50 0c 	movl	%edx, 12(%eax)
; if (buffer_sz>mailbox.msg_store[mailbox.rd].size) {
c0101716:	8b 45 e4 	movl	-28(%ebp), %eax
c0101719:	8b 55 d8 	movl	-40(%ebp), %edx
c010171c:	c1 e2 04 	shll	$4, %edx
c010171f:	01 d0 	addl	%edx, %eax
c0101721:	8b 40 0c 	movl	12(%eax), %eax
c0101724:	39 45 10 	cmpl	%eax, 16(%ebp)
c0101727:	76 23 	jbe	35 <kernel_mailbox_get_msg+0x10b>
; recv_msg->size=mailbox.msg_store[mailbox.rd].size;
c0101729:	8b 45 e4 	movl	-28(%ebp), %eax
c010172c:	8b 55 d8 	movl	-40(%ebp), %edx
c010172f:	c1 e2 04 	shll	$4, %edx
c0101732:	01 d0 	addl	%edx, %eax
c0101734:	8b 50 0c 	movl	12(%eax), %edx
c0101737:	8b 45 0c 	movl	12(%ebp), %eax
c010173a:	89 50 0c 	movl	%edx, 12(%eax)
; recv_msg->from=0;
c010173d:	8b 45 0c 	movl	12(%ebp), %eax
c0101740:	c7 40 04 00 00 00 00 	movl	$0, 4(%eax)
; return;
c0101747:	e9 97 00 00 00 	jmp	151 <kernel_mailbox_get_msg+0x1a2>
; memcpy(recv_msg->msg,mailbox.msg_store[mailbox.rd].msg,mailbox.msg_store[mailbox.rd].size);
c010174c:	8b 45 e4 	movl	-28(%ebp), %eax
c010174f:	8b 55 d8 	movl	-40(%ebp), %edx
c0101752:	c1 e2 04 	shll	$4, %edx
c0101755:	01 d0 	addl	%edx, %eax
c0101757:	8b 48 0c 	movl	12(%eax), %ecx
c010175a:	8b 45 e4 	movl	-28(%ebp), %eax
c010175d:	8b 55 d8 	movl	-40(%ebp), %edx
c0101760:	c1 e2 04 	shll	$4, %edx
c0101763:	01 d0 	addl	%edx, %eax
c0101765:	8b 10 	movl	(%eax), %edx
c0101767:	8b 45 0c 	movl	12(%ebp), %eax
c010176a:	8b 00 	movl	(%eax), %eax
c010176c:	83 ec 04 	subl	$4, %esp
c010176f:	51 	pushl	%ecx
c0101770:	52 	pushl	%edx
c0101771:	50 	pushl	%eax
c0101772:	e8 20 19 00 00 	calll	6432 <memcpy>
c0101777:	83 c4 10 	addl	$16, %esp
; kfree(mailbox.msg_store[mailbox.rd].msg);
c010177a:	8b 45 e4 	movl	-28(%ebp), %eax
c010177d:	8b 55 d8 	movl	-40(%ebp), %edx
c0101780:	c1 e2 04 	shll	$4, %edx
c0101783:	01 d0 	addl	%edx, %eax
c0101785:	8b 00 	movl	(%eax), %eax
c0101787:	83 ec 0c 	subl	$12, %esp
c010178a:	50 	pushl	%eax
c010178b:	e8 b2 fc ff ff 	calll	-846 <kfree>
c0101790:	83 c4 10 	addl	$16, %esp
; mailbox.msg_store[mailbox.rd].size=0;
c0101793:	8b 45 e4 	movl	-28(%ebp), %eax
c0101796:	8b 55 d8 	movl	-40(%ebp), %edx
c0101799:	c1 e2 04 	shll	$4, %edx
c010179c:	01 d0 	addl	%edx, %eax
c010179e:	c7 40 0c 00 00 00 00 	movl	$0, 12(%eax)
; mailbox.rd++;
c01017a5:	8b 45 d8 	movl	-40(%ebp), %eax
c01017a8:	40 	incl	%eax
c01017a9:	89 45 d8 	movl	%eax, -40(%ebp)
; if (mailbox.rd==mailbox.size) {
c01017ac:	8b 55 d8 	movl	-40(%ebp), %edx
c01017af:	8b 45 e0 	movl	-32(%ebp), %eax
c01017b2:	0f b7 c0 	movzwl	%ax, %eax
c01017b5:	39 c2 	cmpl	%eax, %edx
c01017b7:	75 07 	jne	7 <kernel_mailbox_get_msg+0x17f>
; mailbox.rd=0;
c01017b9:	c7 45 d8 00 00 00 00 	movl	$0, -40(%ebp)
; if (mailbox.rd>mailbox.wr) {
c01017c0:	8b 55 d8 	movl	-40(%ebp), %edx
c01017c3:	8b 45 dc 	movl	-36(%ebp), %eax
c01017c6:	39 c2 	cmpl	%eax, %edx
c01017c8:	76 19 	jbe	25 <kernel_mailbox_get_msg+0x1a2>
; mailbox.rd=mailbox.wr-1;
c01017ca:	8b 45 dc 	movl	-36(%ebp), %eax
c01017cd:	48 	decl	%eax
c01017ce:	89 45 d8 	movl	%eax, -40(%ebp)
; if (mailbox.rd==(2^32)-1) {
c01017d1:	8b 45 d8 	movl	-40(%ebp), %eax
c01017d4:	83 f8 21 	cmpl	$33, %eax
c01017d7:	75 0a 	jne	10 <kernel_mailbox_get_msg+0x1a2>
; mailbox.rd=mailbox.size-1;
c01017d9:	8b 45 e0 	movl	-32(%ebp), %eax
c01017dc:	0f b7 c0 	movzwl	%ax, %eax
c01017df:	48 	decl	%eax
c01017e0:	89 45 d8 	movl	%eax, -40(%ebp)
; }
c01017e3:	8d 65 f4 	leal	-12(%ebp), %esp
c01017e6:	5b 	popl	%ebx
c01017e7:	5e 	popl	%esi
c01017e8:	5f 	popl	%edi
c01017e9:	5d 	popl	%ebp
c01017ea:	c3 	retl

is_page_present:
; static char is_page_present(int page) {
c01017eb:	55 	pushl	%ebp
c01017ec:	89 e5 	movl	%esp, %ebp
c01017ee:	83 ec 10 	subl	$16, %esp
; int table=page>>10;
c01017f1:	8b 45 08 	movl	8(%ebp), %eax
c01017f4:	c1 f8 0a 	sarl	$10, %eax
c01017f7:	89 45 fc 	movl	%eax, -4(%ebp)
; page=page&0x3FF;
c01017fa:	81 65 08 ff 03 00 00 	andl	$1023, 8(%ebp)
; if ((smap[table]&0x1)==0) {
c0101801:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101806:	8b 55 fc 	movl	-4(%ebp), %edx
c0101809:	c1 e2 02 	shll	$2, %edx
c010180c:	01 d0 	addl	%edx, %eax
c010180e:	8b 00 	movl	(%eax), %eax
c0101810:	83 e0 01 	andl	$1, %eax
c0101813:	85 c0 	testl	%eax, %eax
c0101815:	75 04 	jne	4 <is_page_present+0x30>
; return 0;
c0101817:	b0 00 	movb	$0, %al
c0101819:	eb 41 	jmp	65 <is_page_present+0x71>
; smap_page_tables[table+1]=(smap[table]&0xFFFFFC00)|0x3;
c010181b:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101820:	8b 55 fc 	movl	-4(%ebp), %edx
c0101823:	c1 e2 02 	shll	$2, %edx
c0101826:	01 d0 	addl	%edx, %eax
c0101828:	8b 00 	movl	(%eax), %eax
c010182a:	25 00 fc ff ff 	andl	$4294966272, %eax
c010182f:	89 c2 	movl	%eax, %edx
c0101831:	8b 45 fc 	movl	-4(%ebp), %eax
c0101834:	40 	incl	%eax
c0101835:	83 ca 03 	orl	$3, %edx
c0101838:	89 14 85 00 40 33 c0 	movl	%edx, -1070383104(,%eax,4)
; return smap[(1024+(1024*table))+page]&0x1;
c010183f:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101844:	8b 55 fc 	movl	-4(%ebp), %edx
c0101847:	42 	incl	%edx
c0101848:	89 d1 	movl	%edx, %ecx
c010184a:	c1 e1 0a 	shll	$10, %ecx
c010184d:	8b 55 08 	movl	8(%ebp), %edx
c0101850:	01 ca 	addl	%ecx, %edx
c0101852:	c1 e2 02 	shll	$2, %edx
c0101855:	01 d0 	addl	%edx, %eax
c0101857:	8b 00 	movl	(%eax), %eax
c0101859:	83 e0 01 	andl	$1, %eax
; }
c010185c:	c9 	leave
c010185d:	c3 	retl

map_pages:
; void map_pages(void* virt_addr_ptr,void* phys_addr_ptr,int num_pages,char usr,char wr) {
c010185e:	55 	pushl	%ebp
c010185f:	89 e5 	movl	%esp, %ebp
c0101861:	53 	pushl	%ebx
c0101862:	83 ec 34 	subl	$52, %esp
c0101865:	8b 55 14 	movl	20(%ebp), %edx
c0101868:	8b 45 18 	movl	24(%ebp), %eax
c010186b:	88 55 d4 	movb	%dl, -44(%ebp)
c010186e:	88 45 d0 	movb	%al, -48(%ebp)
; uint32_t virt_addr=(uint32_t)virt_addr_ptr;
c0101871:	8b 45 08 	movl	8(%ebp), %eax
c0101874:	89 45 e4 	movl	%eax, -28(%ebp)
; uint32_t phys_addr=(uint32_t)phys_addr_ptr;
c0101877:	8b 45 0c 	movl	12(%ebp), %eax
c010187a:	89 45 f4 	movl	%eax, -12(%ebp)
; int dir_entry=(virt_addr&0xFFC00000)>>22;
c010187d:	8b 45 e4 	movl	-28(%ebp), %eax
c0101880:	c1 e8 16 	shrl	$22, %eax
c0101883:	89 45 f0 	movl	%eax, -16(%ebp)
; int table_entry=(virt_addr&0x3FF000)>>12;
c0101886:	8b 45 e4 	movl	-28(%ebp), %eax
c0101889:	c1 e8 0c 	shrl	$12, %eax
c010188c:	25 ff 03 00 00 	andl	$1023, %eax
c0101891:	89 45 ec 	movl	%eax, -20(%ebp)
; for (int i=0;i<=num_pages;i++) {
c0101894:	c7 45 e8 00 00 00 00 	movl	$0, -24(%ebp)
c010189b:	e9 de 00 00 00 	jmp	222 <map_pages+0x120>
; if (!(smap[dir_entry]&0x1)) {
c01018a0:	a1 8c 60 10 c0 	movl	3222298764, %eax
c01018a5:	8b 55 f0 	movl	-16(%ebp), %edx
c01018a8:	c1 e2 02 	shll	$2, %edx
c01018ab:	01 d0 	addl	%edx, %eax
c01018ad:	8b 00 	movl	(%eax), %eax
c01018af:	83 e0 01 	andl	$1, %eax
c01018b2:	85 c0 	testl	%eax, %eax
c01018b4:	75 43 	jne	67 <map_pages+0x9b>
; int flags=1;
c01018b6:	c7 45 e0 01 00 00 00 	movl	$1, -32(%ebp)
; flags=flags|((wr&1)<<1);
c01018bd:	0f be 45 d0 	movsbl	-48(%ebp), %eax
c01018c1:	01 c0 	addl	%eax, %eax
c01018c3:	83 e0 02 	andl	$2, %eax
c01018c6:	09 45 e0 	orl	%eax, -32(%ebp)
; flags=flags|((usr&1)<<2);
c01018c9:	0f be 45 d4 	movsbl	-44(%ebp), %eax
c01018cd:	c1 e0 02 	shll	$2, %eax
c01018d0:	83 e0 04 	andl	$4, %eax
c01018d3:	09 45 e0 	orl	%eax, -32(%ebp)
; smap[dir_entry]=(uint32_t)pmem_alloc(1)|flags;
c01018d6:	83 ec 0c 	subl	$12, %esp
c01018d9:	6a 01 	pushl	$1
c01018db:	e8 d4 08 00 00 	calll	2260 <pmem_alloc>
c01018e0:	83 c4 10 	addl	$16, %esp
c01018e3:	89 c3 	movl	%eax, %ebx
c01018e5:	8b 55 e0 	movl	-32(%ebp), %edx
c01018e8:	a1 8c 60 10 c0 	movl	3222298764, %eax
c01018ed:	8b 4d f0 	movl	-16(%ebp), %ecx
c01018f0:	c1 e1 02 	shll	$2, %ecx
c01018f3:	01 c8 	addl	%ecx, %eax
c01018f5:	09 da 	orl	%ebx, %edx
c01018f7:	89 10 	movl	%edx, (%eax)
; smap_page_tables[dir_entry+1]=(smap[dir_entry]&0xFFFFFC00)|0x3;
c01018f9:	a1 8c 60 10 c0 	movl	3222298764, %eax
c01018fe:	8b 55 f0 	movl	-16(%ebp), %edx
c0101901:	c1 e2 02 	shll	$2, %edx
c0101904:	01 d0 	addl	%edx, %eax
c0101906:	8b 00 	movl	(%eax), %eax
c0101908:	25 00 fc ff ff 	andl	$4294966272, %eax
c010190d:	89 c2 	movl	%eax, %edx
c010190f:	8b 45 f0 	movl	-16(%ebp), %eax
c0101912:	40 	incl	%eax
c0101913:	83 ca 03 	orl	$3, %edx
c0101916:	89 14 85 00 40 33 c0 	movl	%edx, -1070383104(,%eax,4)
; int flags=1;
c010191d:	c7 45 dc 01 00 00 00 	movl	$1, -36(%ebp)
; flags=flags|((wr&1)<<1);
c0101924:	0f be 45 d0 	movsbl	-48(%ebp), %eax
c0101928:	01 c0 	addl	%eax, %eax
c010192a:	83 e0 02 	andl	$2, %eax
c010192d:	09 45 dc 	orl	%eax, -36(%ebp)
; flags=flags|((usr&1)<<2);
c0101930:	0f be 45 d4 	movsbl	-44(%ebp), %eax
c0101934:	c1 e0 02 	shll	$2, %eax
c0101937:	83 e0 04 	andl	$4, %eax
c010193a:	09 45 dc 	orl	%eax, -36(%ebp)
; smap[(1024+(1024*dir_entry))+table_entry]=phys_addr|flags;
c010193d:	8b 45 dc 	movl	-36(%ebp), %eax
c0101940:	8b 15 8c 60 10 c0 	movl	-1072668532, %edx
c0101946:	8b 4d f0 	movl	-16(%ebp), %ecx
c0101949:	41 	incl	%ecx
c010194a:	89 cb 	movl	%ecx, %ebx
c010194c:	c1 e3 0a 	shll	$10, %ebx
c010194f:	8b 4d ec 	movl	-20(%ebp), %ecx
c0101952:	01 d9 	addl	%ebx, %ecx
c0101954:	c1 e1 02 	shll	$2, %ecx
c0101957:	01 ca 	addl	%ecx, %edx
c0101959:	0b 45 f4 	orl	-12(%ebp), %eax
c010195c:	89 02 	movl	%eax, (%edx)
; table_entry++;
c010195e:	ff 45 ec 	incl	-20(%ebp)
; if (table_entry==1024) {
c0101961:	81 7d ec 00 04 00 00 	cmpl	$1024, -20(%ebp)
c0101968:	75 0a 	jne	10 <map_pages+0x116>
; table_entry=0;
c010196a:	c7 45 ec 00 00 00 00 	movl	$0, -20(%ebp)
; dir_entry++;
c0101971:	ff 45 f0 	incl	-16(%ebp)
; phys_addr+=0x1000;
c0101974:	81 45 f4 00 10 00 00 	addl	$4096, -12(%ebp)
; for (int i=0;i<=num_pages;i++) {
c010197b:	ff 45 e8 	incl	-24(%ebp)
c010197e:	8b 45 e8 	movl	-24(%ebp), %eax
c0101981:	3b 45 10 	cmpl	16(%ebp), %eax
c0101984:	0f 8e 16 ff ff ff 	jle	-234 <map_pages+0x42>
; }
c010198a:	90 	nop
c010198b:	8b 5d fc 	movl	-4(%ebp), %ebx
c010198e:	c9 	leave
c010198f:	c3 	retl

map_kstack:
; void map_kstack(uint32_t pid) {
c0101990:	55 	pushl	%ebp
c0101991:	89 e5 	movl	%esp, %ebp
c0101993:	83 ec 08 	subl	$8, %esp
; if (!(kstack_page_tables[pid]&0x1)) {
c0101996:	8b 45 08 	movl	8(%ebp), %eax
c0101999:	8b 04 85 00 00 31 c0 	movl	-1070530560(,%eax,4), %eax
c01019a0:	83 e0 01 	andl	$1, %eax
c01019a3:	85 c0 	testl	%eax, %eax
c01019a5:	75 1c 	jne	28 <map_kstack+0x33>
; kstack_page_tables[pid]=(uint32_t)pmem_alloc(1)|0x3;
c01019a7:	83 ec 0c 	subl	$12, %esp
c01019aa:	6a 01 	pushl	$1
c01019ac:	e8 03 08 00 00 	calll	2051 <pmem_alloc>
c01019b1:	83 c4 10 	addl	$16, %esp
c01019b4:	83 c8 03 	orl	$3, %eax
c01019b7:	89 c2 	movl	%eax, %edx
c01019b9:	8b 45 08 	movl	8(%ebp), %eax
c01019bc:	89 14 85 00 00 31 c0 	movl	%edx, -1070530560(,%eax,4)
; }
c01019c3:	90 	nop
c01019c4:	c9 	leave
c01019c5:	c3 	retl

find_free_pages:
; uint32_t find_free_pages(int num_pages) {
c01019c6:	55 	pushl	%ebp
c01019c7:	89 e5 	movl	%esp, %ebp
c01019c9:	83 ec 28 	subl	$40, %esp
; for(uint32_t i=1;i<131072;i++) {
c01019cc:	c7 45 ec 01 00 00 00 	movl	$1, -20(%ebp)
c01019d3:	eb 7e 	jmp	126 <find_free_pages+0x8d>
; char got_0=0;
c01019d5:	c6 45 eb 00 	movb	$0, -21(%ebp)
; remaining_blks=num_pages;
c01019d9:	8b 45 08 	movl	8(%ebp), %eax
c01019dc:	89 45 f0 	movl	%eax, -16(%ebp)
; for (uint32_t j=i*8;;j++) {
c01019df:	8b 45 ec 	movl	-20(%ebp), %eax
c01019e2:	c1 e0 03 	shll	$3, %eax
c01019e5:	89 45 e0 	movl	%eax, -32(%ebp)
; char bit=is_page_present(j);
c01019e8:	8b 45 e0 	movl	-32(%ebp), %eax
c01019eb:	50 	pushl	%eax
c01019ec:	e8 fa fd ff ff 	calll	-518 <is_page_present>
c01019f1:	83 c4 04 	addl	$4, %esp
c01019f4:	88 45 df 	movb	%al, -33(%ebp)
; if (got_0) {
c01019f7:	80 7d eb 00 	cmpb	$0, -21(%ebp)
c01019fb:	74 27 	je	39 <find_free_pages+0x5e>
; if (bit) {
c01019fd:	80 7d df 00 	cmpb	$0, -33(%ebp)
c0101a01:	74 1c 	je	28 <find_free_pages+0x59>
; if (remaining_blks==0) {
c0101a03:	83 7d f0 00 	cmpl	$0, -16(%ebp)
c0101a07:	75 08 	jne	8 <find_free_pages+0x4b>
; bmap_index=old_j;
c0101a09:	8b 45 e4 	movl	-28(%ebp), %eax
c0101a0c:	89 45 f4 	movl	%eax, -12(%ebp)
; break;
c0101a0f:	eb 39 	jmp	57 <find_free_pages+0x84>
; i+=j/8;
c0101a11:	8b 45 e0 	movl	-32(%ebp), %eax
c0101a14:	c1 e8 03 	shrl	$3, %eax
c0101a17:	01 45 ec 	addl	%eax, -20(%ebp)
; i--;
c0101a1a:	ff 4d ec 	decl	-20(%ebp)
; break;
c0101a1d:	eb 2b 	jmp	43 <find_free_pages+0x84>
; remaining_blks--;
c0101a1f:	ff 4d f0 	decl	-16(%ebp)
c0101a22:	eb 13 	jmp	19 <find_free_pages+0x71>
; if (!bit) {
c0101a24:	80 7d df 00 	cmpb	$0, -33(%ebp)
c0101a28:	75 0d 	jne	13 <find_free_pages+0x71>
; got_0=1;
c0101a2a:	c6 45 eb 01 	movb	$1, -21(%ebp)
; old_j=j;
c0101a2e:	8b 45 e0 	movl	-32(%ebp), %eax
c0101a31:	89 45 e4 	movl	%eax, -28(%ebp)
; remaining_blks--;
c0101a34:	ff 4d f0 	decl	-16(%ebp)
; if (remaining_blks==0) {
c0101a37:	83 7d f0 00 	cmpl	$0, -16(%ebp)
c0101a3b:	75 08 	jne	8 <find_free_pages+0x7f>
; bmap_index=old_j;
c0101a3d:	8b 45 e4 	movl	-28(%ebp), %eax
c0101a40:	89 45 f4 	movl	%eax, -12(%ebp)
; break;
c0101a43:	eb 05 	jmp	5 <find_free_pages+0x84>
; for (uint32_t j=i*8;;j++) {
c0101a45:	ff 45 e0 	incl	-32(%ebp)
c0101a48:	eb 9e 	jmp	-98 <find_free_pages+0x22>
; if (remaining_blks==0) {
c0101a4a:	83 7d f0 00 	cmpl	$0, -16(%ebp)
c0101a4e:	74 12 	je	18 <find_free_pages+0x9c>
; for(uint32_t i=1;i<131072;i++) {
c0101a50:	ff 45 ec 	incl	-20(%ebp)
c0101a53:	81 7d ec ff ff 01 00 	cmpl	$131071, -20(%ebp)
c0101a5a:	0f 86 75 ff ff ff 	jbe	-139 <find_free_pages+0xf>
c0101a60:	eb 01 	jmp	1 <find_free_pages+0x9d>
; break;
c0101a62:	90 	nop
; if (remaining_blks!=0) {
c0101a63:	83 7d f0 00 	cmpl	$0, -16(%ebp)
c0101a67:	74 10 	je	16 <find_free_pages+0xb3>
; vga_write_string("[PANIC] Out of memory");
c0101a69:	83 ec 0c 	subl	$12, %esp
c0101a6c:	68 fc 43 10 c0 	pushl	$3222291452
c0101a71:	e8 44 ea ff ff 	calll	-5564 <vga_write_string>
c0101a76:	83 c4 10 	addl	$16, %esp
; return bmap_index;
c0101a79:	8b 45 f4 	movl	-12(%ebp), %eax
; }
c0101a7c:	c9 	leave
c0101a7d:	c3 	retl

alloc_pages:
; void* alloc_pages(int num_pages) {
c0101a7e:	55 	pushl	%ebp
c0101a7f:	89 e5 	movl	%esp, %ebp
c0101a81:	83 ec 18 	subl	$24, %esp
; void* phys_addr=pmem_alloc(num_pages);
c0101a84:	83 ec 0c 	subl	$12, %esp
c0101a87:	ff 75 08 	pushl	8(%ebp)
c0101a8a:	e8 25 07 00 00 	calll	1829 <pmem_alloc>
c0101a8f:	83 c4 10 	addl	$16, %esp
c0101a92:	89 45 f4 	movl	%eax, -12(%ebp)
; void* addr=(void*)(find_free_pages(num_pages)<<12);
c0101a95:	83 ec 0c 	subl	$12, %esp
c0101a98:	ff 75 08 	pushl	8(%ebp)
c0101a9b:	e8 26 ff ff ff 	calll	-218 <find_free_pages>
c0101aa0:	83 c4 10 	addl	$16, %esp
c0101aa3:	c1 e0 0c 	shll	$12, %eax
c0101aa6:	89 45 f0 	movl	%eax, -16(%ebp)
; map_pages(addr,phys_addr,num_pages,1,1);
c0101aa9:	83 ec 0c 	subl	$12, %esp
c0101aac:	6a 01 	pushl	$1
c0101aae:	6a 01 	pushl	$1
c0101ab0:	ff 75 08 	pushl	8(%ebp)
c0101ab3:	ff 75 f4 	pushl	-12(%ebp)
c0101ab6:	ff 75 f0 	pushl	-16(%ebp)
c0101ab9:	e8 a0 fd ff ff 	calll	-608 <map_pages>
c0101abe:	83 c4 20 	addl	$32, %esp
; return addr;
c0101ac1:	8b 45 f0 	movl	-16(%ebp), %eax
; }
c0101ac4:	c9 	leave
c0101ac5:	c3 	retl

virt_to_phys:
; void* virt_to_phys(void* virt_addr_arg) {
c0101ac6:	55 	pushl	%ebp
c0101ac7:	89 e5 	movl	%esp, %ebp
c0101ac9:	83 ec 10 	subl	$16, %esp
; uint32_t virt_addr=(uint32_t)virt_addr_arg;
c0101acc:	8b 45 08 	movl	8(%ebp), %eax
c0101acf:	89 45 fc 	movl	%eax, -4(%ebp)
; int offset=virt_addr&0x3FF;
c0101ad2:	8b 45 fc 	movl	-4(%ebp), %eax
c0101ad5:	25 ff 03 00 00 	andl	$1023, %eax
c0101ada:	89 45 f8 	movl	%eax, -8(%ebp)
; virt_addr=virt_addr&0xFFFFFC00;
c0101add:	81 65 fc 00 fc ff ff 	andl	$4294966272, -4(%ebp)
; if (!is_page_present(virt_addr>>12)) return NULL;
c0101ae4:	8b 45 fc 	movl	-4(%ebp), %eax
c0101ae7:	c1 e8 0c 	shrl	$12, %eax
c0101aea:	50 	pushl	%eax
c0101aeb:	e8 fb fc ff ff 	calll	-773 <is_page_present>
c0101af0:	83 c4 04 	addl	$4, %esp
c0101af3:	84 c0 	testb	%al, %al
c0101af5:	75 07 	jne	7 <virt_to_phys+0x38>
c0101af7:	b8 00 00 00 00 	movl	$0, %eax
c0101afc:	eb 7e 	jmp	126 <virt_to_phys+0xb6>
; int dir_idx=(virt_addr&0xFFC00000)>>22;
c0101afe:	8b 45 fc 	movl	-4(%ebp), %eax
c0101b01:	c1 e8 16 	shrl	$22, %eax
c0101b04:	89 45 f4 	movl	%eax, -12(%ebp)
; int tbl_idx=(virt_addr&0x3FFC00)>>12;
c0101b07:	8b 45 fc 	movl	-4(%ebp), %eax
c0101b0a:	c1 e8 0c 	shrl	$12, %eax
c0101b0d:	25 ff 03 00 00 	andl	$1023, %eax
c0101b12:	89 45 f0 	movl	%eax, -16(%ebp)
; if ((smap[dir_idx]&0x1)==0) {
c0101b15:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101b1a:	8b 55 f4 	movl	-12(%ebp), %edx
c0101b1d:	c1 e2 02 	shll	$2, %edx
c0101b20:	01 d0 	addl	%edx, %eax
c0101b22:	8b 00 	movl	(%eax), %eax
c0101b24:	83 e0 01 	andl	$1, %eax
c0101b27:	85 c0 	testl	%eax, %eax
c0101b29:	75 07 	jne	7 <virt_to_phys+0x6c>
; return 0;
c0101b2b:	b8 00 00 00 00 	movl	$0, %eax
c0101b30:	eb 4a 	jmp	74 <virt_to_phys+0xb6>
; smap_page_tables[dir_idx+1]=(smap[dir_idx]&0xFFFFFC00)|0x3;
c0101b32:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101b37:	8b 55 f4 	movl	-12(%ebp), %edx
c0101b3a:	c1 e2 02 	shll	$2, %edx
c0101b3d:	01 d0 	addl	%edx, %eax
c0101b3f:	8b 00 	movl	(%eax), %eax
c0101b41:	25 00 fc ff ff 	andl	$4294966272, %eax
c0101b46:	89 c2 	movl	%eax, %edx
c0101b48:	8b 45 f4 	movl	-12(%ebp), %eax
c0101b4b:	40 	incl	%eax
c0101b4c:	83 ca 03 	orl	$3, %edx
c0101b4f:	89 14 85 00 40 33 c0 	movl	%edx, -1070383104(,%eax,4)
; return (void*)((smap[(1024+(1024*dir_idx))+tbl_idx]&0xFFFFFC00)+offset);
c0101b56:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101b5b:	8b 55 f4 	movl	-12(%ebp), %edx
c0101b5e:	42 	incl	%edx
c0101b5f:	89 d1 	movl	%edx, %ecx
c0101b61:	c1 e1 0a 	shll	$10, %ecx
c0101b64:	8b 55 f0 	movl	-16(%ebp), %edx
c0101b67:	01 ca 	addl	%ecx, %edx
c0101b69:	c1 e2 02 	shll	$2, %edx
c0101b6c:	01 d0 	addl	%edx, %eax
c0101b6e:	8b 00 	movl	(%eax), %eax
c0101b70:	25 00 fc ff ff 	andl	$4294966272, %eax
c0101b75:	89 c2 	movl	%eax, %edx
c0101b77:	8b 45 f8 	movl	-8(%ebp), %eax
c0101b7a:	01 d0 	addl	%edx, %eax
; }
c0101b7c:	c9 	leave
c0101b7d:	c3 	retl

alloc_pages_virt:
; void alloc_pages_virt(int num_pages,void* addr) {
c0101b7e:	55 	pushl	%ebp
c0101b7f:	89 e5 	movl	%esp, %ebp
c0101b81:	83 ec 18 	subl	$24, %esp
; void* phys_addr=pmem_alloc(num_pages);
c0101b84:	83 ec 0c 	subl	$12, %esp
c0101b87:	ff 75 08 	pushl	8(%ebp)
c0101b8a:	e8 25 06 00 00 	calll	1573 <pmem_alloc>
c0101b8f:	83 c4 10 	addl	$16, %esp
c0101b92:	89 45 f4 	movl	%eax, -12(%ebp)
; map_pages(addr,phys_addr,num_pages,1,1);
c0101b95:	83 ec 0c 	subl	$12, %esp
c0101b98:	6a 01 	pushl	$1
c0101b9a:	6a 01 	pushl	$1
c0101b9c:	ff 75 08 	pushl	8(%ebp)
c0101b9f:	ff 75 f4 	pushl	-12(%ebp)
c0101ba2:	ff 75 0c 	pushl	12(%ebp)
c0101ba5:	e8 b4 fc ff ff 	calll	-844 <map_pages>
c0101baa:	83 c4 20 	addl	$32, %esp
; }
c0101bad:	90 	nop
c0101bae:	c9 	leave
c0101baf:	c3 	retl

invl_page:
; void invl_page(void* addr) {
c0101bb0:	55 	pushl	%ebp
c0101bb1:	89 e5 	movl	%esp, %ebp
; asm volatile("invlpg (%0)"::"r"(addr):"memory");
c0101bb3:	8b 45 08 	movl	8(%ebp), %eax
c0101bb6:	0f 01 38 	invlpg	(%eax)
; }
c0101bb9:	90 	nop
c0101bba:	5d 	popl	%ebp
c0101bbb:	c3 	retl

paging_new_address_space:
; void* paging_new_address_space() {
c0101bbc:	55 	pushl	%ebp
c0101bbd:	89 e5 	movl	%esp, %ebp
c0101bbf:	83 ec 18 	subl	$24, %esp
; asm volatile("movl %%cr3, %%eax; movl %%eax, %0;":"=m"(cr3)::"%eax");
c0101bc2:	0f 20 d8 	movl	%cr3, %eax
c0101bc5:	89 45 ec 	movl	%eax, -20(%ebp)
; void* dir=pmem_alloc(1);
c0101bc8:	83 ec 0c 	subl	$12, %esp
c0101bcb:	6a 01 	pushl	$1
c0101bcd:	e8 e2 05 00 00 	calll	1506 <pmem_alloc>
c0101bd2:	83 c4 10 	addl	$16, %esp
c0101bd5:	89 45 f0 	movl	%eax, -16(%ebp)
; smap_page_tables[0]=((uint32_t)dir)|0x3;
c0101bd8:	8b 45 f0 	movl	-16(%ebp), %eax
c0101bdb:	83 c8 03 	orl	$3, %eax
c0101bde:	a3 00 40 33 c0 	movl	%eax, 3224584192
; invl_page(smap);
c0101be3:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101be8:	83 ec 0c 	subl	$12, %esp
c0101beb:	50 	pushl	%eax
c0101bec:	e8 bf ff ff ff 	calll	-65 <invl_page>
c0101bf1:	83 c4 10 	addl	$16, %esp
; for (uint32_t i=0;i<1024;i++) {
c0101bf4:	c7 45 f4 00 00 00 00 	movl	$0, -12(%ebp)
c0101bfb:	eb 1c 	jmp	28 <paging_new_address_space+0x5d>
; smap[i]=page_directory[i];
c0101bfd:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101c02:	8b 55 f4 	movl	-12(%ebp), %edx
c0101c05:	c1 e2 02 	shll	$2, %edx
c0101c08:	01 c2 	addl	%eax, %edx
c0101c0a:	8b 45 f4 	movl	-12(%ebp), %eax
c0101c0d:	8b 04 85 00 e0 30 c0 	movl	-1070538752(,%eax,4), %eax
c0101c14:	89 02 	movl	%eax, (%edx)
; for (uint32_t i=0;i<1024;i++) {
c0101c16:	ff 45 f4 	incl	-12(%ebp)
c0101c19:	81 7d f4 ff 03 00 00 	cmpl	$1023, -12(%ebp)
c0101c20:	76 db 	jbe	-37 <paging_new_address_space+0x41>
; smap_page_tables[0]=cr3|0x3;
c0101c22:	8b 45 ec 	movl	-20(%ebp), %eax
c0101c25:	83 c8 03 	orl	$3, %eax
c0101c28:	a3 00 40 33 c0 	movl	%eax, 3224584192
; invl_page(smap);
c0101c2d:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101c32:	83 ec 0c 	subl	$12, %esp
c0101c35:	50 	pushl	%eax
c0101c36:	e8 75 ff ff ff 	calll	-139 <invl_page>
c0101c3b:	83 c4 10 	addl	$16, %esp
; return dir;
c0101c3e:	8b 45 f0 	movl	-16(%ebp), %eax
; }
c0101c41:	c9 	leave
c0101c42:	c3 	retl

load_address_space:
; void load_address_space(uint32_t cr3) {
c0101c43:	55 	pushl	%ebp
c0101c44:	89 e5 	movl	%esp, %ebp
c0101c46:	83 ec 08 	subl	$8, %esp
; load_smap(cr3);
c0101c49:	83 ec 0c 	subl	$12, %esp
c0101c4c:	ff 75 08 	pushl	8(%ebp)
c0101c4f:	e8 15 00 00 00 	calll	21 <load_smap>
c0101c54:	83 c4 10 	addl	$16, %esp
; load_page_directory((uint32_t*)cr3);
c0101c57:	8b 45 08 	movl	8(%ebp), %eax
c0101c5a:	83 ec 0c 	subl	$12, %esp
c0101c5d:	50 	pushl	%eax
c0101c5e:	e8 1d 0d 00 00 	calll	3357 <load_page_directory>
c0101c63:	83 c4 10 	addl	$16, %esp
; }
c0101c66:	90 	nop
c0101c67:	c9 	leave
c0101c68:	c3 	retl

load_smap:
; void load_smap(uint32_t cr3) {
c0101c69:	55 	pushl	%ebp
c0101c6a:	89 e5 	movl	%esp, %ebp
c0101c6c:	83 ec 10 	subl	$16, %esp
; smap_page_tables[0]=cr3|0x3;
c0101c6f:	8b 45 08 	movl	8(%ebp), %eax
c0101c72:	83 c8 03 	orl	$3, %eax
c0101c75:	a3 00 40 33 c0 	movl	%eax, 3224584192
; invl_page(&smap[0]);
c0101c7a:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101c7f:	50 	pushl	%eax
c0101c80:	e8 2b ff ff ff 	calll	-213 <invl_page>
c0101c85:	83 c4 04 	addl	$4, %esp
; for (uint32_t i=1;i<2048;i++) {
c0101c88:	c7 45 fc 01 00 00 00 	movl	$1, -4(%ebp)
c0101c8f:	eb 27 	jmp	39 <load_smap+0x4f>
; invl_page(&smap[i*1024]);
c0101c91:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101c96:	8b 55 fc 	movl	-4(%ebp), %edx
c0101c99:	c1 e2 0c 	shll	$12, %edx
c0101c9c:	01 d0 	addl	%edx, %eax
c0101c9e:	50 	pushl	%eax
c0101c9f:	e8 0c ff ff ff 	calll	-244 <invl_page>
c0101ca4:	83 c4 04 	addl	$4, %esp
; smap_page_tables[i]=0;
c0101ca7:	8b 45 fc 	movl	-4(%ebp), %eax
c0101caa:	c7 04 85 00 40 33 c0 00 00 00 00 	movl	$0, -1070383104(,%eax,4)
; for (uint32_t i=1;i<2048;i++) {
c0101cb5:	ff 45 fc 	incl	-4(%ebp)
c0101cb8:	81 7d fc ff 07 00 00 	cmpl	$2047, -4(%ebp)
c0101cbf:	76 d0 	jbe	-48 <load_smap+0x28>
; }
c0101cc1:	90 	nop
c0101cc2:	c9 	leave
c0101cc3:	c3 	retl

unmap_pages:
; void unmap_pages(void* start_virt,uint32_t num_pages) {
c0101cc4:	55 	pushl	%ebp
c0101cc5:	89 e5 	movl	%esp, %ebp
c0101cc7:	83 ec 10 	subl	$16, %esp
; uint32_t virt_addr=(uint32_t)start_virt;
c0101cca:	8b 45 08 	movl	8(%ebp), %eax
c0101ccd:	89 45 f0 	movl	%eax, -16(%ebp)
; int dir_entry=(virt_addr&0xFFC00000)>>22;
c0101cd0:	8b 45 f0 	movl	-16(%ebp), %eax
c0101cd3:	c1 e8 16 	shrl	$22, %eax
c0101cd6:	89 45 fc 	movl	%eax, -4(%ebp)
; int table_entry=(virt_addr&0x3FF000)>>12;
c0101cd9:	8b 45 f0 	movl	-16(%ebp), %eax
c0101cdc:	c1 e8 0c 	shrl	$12, %eax
c0101cdf:	25 ff 03 00 00 	andl	$1023, %eax
c0101ce4:	89 45 f8 	movl	%eax, -8(%ebp)
; for (uint32_t i=0;i<=num_pages;i++) {
c0101ce7:	c7 45 f4 00 00 00 00 	movl	$0, -12(%ebp)
c0101cee:	e9 87 00 00 00 	jmp	135 <unmap_pages+0xb6>
; if (smap[dir_entry]&0x1) {
c0101cf3:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101cf8:	8b 55 fc 	movl	-4(%ebp), %edx
c0101cfb:	c1 e2 02 	shll	$2, %edx
c0101cfe:	01 d0 	addl	%edx, %eax
c0101d00:	8b 00 	movl	(%eax), %eax
c0101d02:	83 e0 01 	andl	$1, %eax
c0101d05:	85 c0 	testl	%eax, %eax
c0101d07:	74 6e 	je	110 <unmap_pages+0xb3>
; smap_page_tables[dir_entry+1]=(smap[dir_entry]&0xFFFFFC00)|0x3;
c0101d09:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101d0e:	8b 55 fc 	movl	-4(%ebp), %edx
c0101d11:	c1 e2 02 	shll	$2, %edx
c0101d14:	01 d0 	addl	%edx, %eax
c0101d16:	8b 00 	movl	(%eax), %eax
c0101d18:	25 00 fc ff ff 	andl	$4294966272, %eax
c0101d1d:	89 c2 	movl	%eax, %edx
c0101d1f:	8b 45 fc 	movl	-4(%ebp), %eax
c0101d22:	40 	incl	%eax
c0101d23:	83 ca 03 	orl	$3, %edx
c0101d26:	89 14 85 00 40 33 c0 	movl	%edx, -1070383104(,%eax,4)
; smap[(1024+(1024*dir_entry))+table_entry]=0;
c0101d2d:	a1 8c 60 10 c0 	movl	3222298764, %eax
c0101d32:	8b 55 fc 	movl	-4(%ebp), %edx
c0101d35:	42 	incl	%edx
c0101d36:	89 d1 	movl	%edx, %ecx
c0101d38:	c1 e1 0a 	shll	$10, %ecx
c0101d3b:	8b 55 f8 	movl	-8(%ebp), %edx
c0101d3e:	01 ca 	addl	%ecx, %edx
c0101d40:	c1 e2 02 	shll	$2, %edx
c0101d43:	01 d0 	addl	%edx, %eax
c0101d45:	c7 00 00 00 00 00 	movl	$0, (%eax)
; invl_page(start_virt+(i*1024));
c0101d4b:	8b 45 f4 	movl	-12(%ebp), %eax
c0101d4e:	c1 e0 0a 	shll	$10, %eax
c0101d51:	89 c2 	movl	%eax, %edx
c0101d53:	8b 45 08 	movl	8(%ebp), %eax
c0101d56:	01 d0 	addl	%edx, %eax
c0101d58:	50 	pushl	%eax
c0101d59:	e8 52 fe ff ff 	calll	-430 <invl_page>
c0101d5e:	83 c4 04 	addl	$4, %esp
; table_entry++;
c0101d61:	ff 45 f8 	incl	-8(%ebp)
; if (table_entry==1024) {
c0101d64:	81 7d f8 00 04 00 00 	cmpl	$1024, -8(%ebp)
c0101d6b:	75 0a 	jne	10 <unmap_pages+0xb3>
; dir_entry++;
c0101d6d:	ff 45 fc 	incl	-4(%ebp)
; table_entry=0;
c0101d70:	c7 45 f8 00 00 00 00 	movl	$0, -8(%ebp)
; for (uint32_t i=0;i<=num_pages;i++) {
c0101d77:	ff 45 f4 	incl	-12(%ebp)
c0101d7a:	8b 45 f4 	movl	-12(%ebp), %eax
c0101d7d:	3b 45 0c 	cmpl	12(%ebp), %eax
c0101d80:	0f 86 6d ff ff ff 	jbe	-147 <unmap_pages+0x2f>
; }
c0101d86:	90 	nop
c0101d87:	c9 	leave
c0101d88:	c3 	retl

paging_init:
; void paging_init() {
c0101d89:	55 	pushl	%ebp
c0101d8a:	89 e5 	movl	%esp, %ebp
c0101d8c:	83 ec 38 	subl	$56, %esp
; for (uint32_t i=0;i<NUM_KERN_DIRS*1024;i++) {
c0101d8f:	c7 45 f4 00 00 00 00 	movl	$0, -12(%ebp)
c0101d96:	eb 18 	jmp	24 <paging_init+0x27>
; kern_page_tables[i]=(i<<12)|0x3;
c0101d98:	8b 45 f4 	movl	-12(%ebp), %eax
c0101d9b:	c1 e0 0c 	shll	$12, %eax
c0101d9e:	83 c8 03 	orl	$3, %eax
c0101da1:	89 c2 	movl	%eax, %edx
c0101da3:	8b 45 f4 	movl	-12(%ebp), %eax
c0101da6:	89 14 85 00 f0 30 c0 	movl	%edx, -1070534656(,%eax,4)
; for (uint32_t i=0;i<NUM_KERN_DIRS*1024;i++) {
c0101dad:	ff 45 f4 	incl	-12(%ebp)
c0101db0:	81 7d f4 ff 03 00 00 	cmpl	$1023, -12(%ebp)
c0101db7:	76 df 	jbe	-33 <paging_init+0xf>
; for (uint32_t i=0;i<32*1024;i++) {
c0101db9:	c7 45 f0 00 00 00 00 	movl	$0, -16(%ebp)
c0101dc0:	eb 11 	jmp	17 <paging_init+0x4a>
; kstack_page_tables[i]=0;
c0101dc2:	8b 45 f0 	movl	-16(%ebp), %eax
c0101dc5:	c7 04 85 00 00 31 c0 00 00 00 00 	movl	$0, -1070530560(,%eax,4)
; for (uint32_t i=0;i<32*1024;i++) {
c0101dd0:	ff 45 f0 	incl	-16(%ebp)
c0101dd3:	81 7d f0 ff 7f 00 00 	cmpl	$32767, -16(%ebp)
c0101dda:	76 e6 	jbe	-26 <paging_init+0x39>
; for (uint32_t i=0;i<4*1024;i++) {
c0101ddc:	c7 45 ec 00 00 00 00 	movl	$0, -20(%ebp)
c0101de3:	eb 1f 	jmp	31 <paging_init+0x7b>
; kmalloc_page_tables[i]=(uint32_t)pmem_alloc(1)|0x3;
c0101de5:	83 ec 0c 	subl	$12, %esp
c0101de8:	6a 01 	pushl	$1
c0101dea:	e8 c5 03 00 00 	calll	965 <pmem_alloc>
c0101def:	83 c4 10 	addl	$16, %esp
c0101df2:	83 c8 03 	orl	$3, %eax
c0101df5:	89 c2 	movl	%eax, %edx
c0101df7:	8b 45 ec 	movl	-20(%ebp), %eax
c0101dfa:	89 14 85 00 00 33 c0 	movl	%edx, -1070399488(,%eax,4)
; for (uint32_t i=0;i<4*1024;i++) {
c0101e01:	ff 45 ec 	incl	-20(%ebp)
c0101e04:	81 7d ec ff 0f 00 00 	cmpl	$4095, -20(%ebp)
c0101e0b:	76 d8 	jbe	-40 <paging_init+0x5c>
; smap_page_tables[0]=(((uint32_t)&(page_directory))-0xC0000000)|0x3;
c0101e0d:	b8 00 e0 30 c0 	movl	$3224428544, %eax
c0101e12:	05 00 00 00 40 	addl	$1073741824, %eax
c0101e17:	83 c8 03 	orl	$3, %eax
c0101e1a:	a3 00 40 33 c0 	movl	%eax, 3224584192
; for (uint32_t i=1;i<2048;i++) {
c0101e1f:	c7 45 e8 01 00 00 00 	movl	$1, -24(%ebp)
c0101e26:	eb 11 	jmp	17 <paging_init+0xb0>
; smap_page_tables[i]=0;
c0101e28:	8b 45 e8 	movl	-24(%ebp), %eax
c0101e2b:	c7 04 85 00 40 33 c0 00 00 00 00 	movl	$0, -1070383104(,%eax,4)
; for (uint32_t i=1;i<2048;i++) {
c0101e36:	ff 45 e8 	incl	-24(%ebp)
c0101e39:	81 7d e8 ff 07 00 00 	cmpl	$2047, -24(%ebp)
c0101e40:	76 e6 	jbe	-26 <paging_init+0x9f>
; for (uint32_t i=0;i<NUM_KERN_DIRS;i++) {
c0101e42:	c7 45 e4 00 00 00 00 	movl	$0, -28(%ebp)
c0101e49:	eb 2f 	jmp	47 <paging_init+0xf1>
; uint32_t entry_virt=(uint32_t)&(kern_page_tables[i*1024]);
c0101e4b:	8b 45 e4 	movl	-28(%ebp), %eax
c0101e4e:	c1 e0 0a 	shll	$10, %eax
c0101e51:	c1 e0 02 	shll	$2, %eax
c0101e54:	05 00 f0 30 c0 	addl	$3224432640, %eax
c0101e59:	89 45 d4 	movl	%eax, -44(%ebp)
; page_directory[i+768]=(entry_virt-0xC0000000)|0x3;
c0101e5c:	8b 45 d4 	movl	-44(%ebp), %eax
c0101e5f:	8d 90 00 00 00 40 	leal	1073741824(%eax), %edx
c0101e65:	8b 45 e4 	movl	-28(%ebp), %eax
c0101e68:	05 00 03 00 00 	addl	$768, %eax
c0101e6d:	83 ca 03 	orl	$3, %edx
c0101e70:	89 14 85 00 e0 30 c0 	movl	%edx, -1070538752(,%eax,4)
; for (uint32_t i=0;i<NUM_KERN_DIRS;i++) {
c0101e77:	ff 45 e4 	incl	-28(%ebp)
c0101e7a:	83 7d e4 00 	cmpl	$0, -28(%ebp)
c0101e7e:	74 cb 	je	-53 <paging_init+0xc2>
; page_directory[985]=(uint32_t)(pmem_alloc(1024))|0x83;
c0101e80:	83 ec 0c 	subl	$12, %esp
c0101e83:	68 00 04 00 00 	pushl	$1024
c0101e88:	e8 27 03 00 00 	calll	807 <pmem_alloc>
c0101e8d:	83 c4 10 	addl	$16, %esp
c0101e90:	0c 83 	orb	$-125, %al
c0101e92:	a3 64 ef 30 c0 	movl	%eax, 3224432484
; for (uint32_t i=0;i<32;i++) {
c0101e97:	c7 45 e0 00 00 00 00 	movl	$0, -32(%ebp)
c0101e9e:	eb 2f 	jmp	47 <paging_init+0x146>
; uint32_t entry_virt=(uint32_t)&(kstack_page_tables[i*1024]);
c0101ea0:	8b 45 e0 	movl	-32(%ebp), %eax
c0101ea3:	c1 e0 0a 	shll	$10, %eax
c0101ea6:	c1 e0 02 	shll	$2, %eax
c0101ea9:	05 00 00 31 c0 	addl	$3224436736, %eax
c0101eae:	89 45 d0 	movl	%eax, -48(%ebp)
; page_directory[i+986]=(entry_virt-0xC0000000)|0x3;
c0101eb1:	8b 45 d0 	movl	-48(%ebp), %eax
c0101eb4:	8d 90 00 00 00 40 	leal	1073741824(%eax), %edx
c0101eba:	8b 45 e0 	movl	-32(%ebp), %eax
c0101ebd:	05 da 03 00 00 	addl	$986, %eax
c0101ec2:	83 ca 03 	orl	$3, %edx
c0101ec5:	89 14 85 00 e0 30 c0 	movl	%edx, -1070538752(,%eax,4)
; for (uint32_t i=0;i<32;i++) {
c0101ecc:	ff 45 e0 	incl	-32(%ebp)
c0101ecf:	83 7d e0 1f 	cmpl	$31, -32(%ebp)
c0101ed3:	76 cb 	jbe	-53 <paging_init+0x117>
; for (uint32_t i=0;i<4;i++) {
c0101ed5:	c7 45 dc 00 00 00 00 	movl	$0, -36(%ebp)
c0101edc:	eb 2f 	jmp	47 <paging_init+0x184>
; uint32_t entry_virt=(uint32_t)&(kmalloc_page_tables[i*1024]);
c0101ede:	8b 45 dc 	movl	-36(%ebp), %eax
c0101ee1:	c1 e0 0a 	shll	$10, %eax
c0101ee4:	c1 e0 02 	shll	$2, %eax
c0101ee7:	05 00 00 33 c0 	addl	$3224567808, %eax
c0101eec:	89 45 cc 	movl	%eax, -52(%ebp)
; page_directory[i+1018]=(entry_virt-0xC0000000)|0x3;
c0101eef:	8b 45 cc 	movl	-52(%ebp), %eax
c0101ef2:	8d 90 00 00 00 40 	leal	1073741824(%eax), %edx
c0101ef8:	8b 45 dc 	movl	-36(%ebp), %eax
c0101efb:	05 fa 03 00 00 	addl	$1018, %eax
c0101f00:	83 ca 03 	orl	$3, %edx
c0101f03:	89 14 85 00 e0 30 c0 	movl	%edx, -1070538752(,%eax,4)
; for (uint32_t i=0;i<4;i++) {
c0101f0a:	ff 45 dc 	incl	-36(%ebp)
c0101f0d:	83 7d dc 03 	cmpl	$3, -36(%ebp)
c0101f11:	76 cb 	jbe	-53 <paging_init+0x155>
; for (uint32_t i=0;i<2;i++) {
c0101f13:	c7 45 d8 00 00 00 00 	movl	$0, -40(%ebp)
c0101f1a:	eb 2f 	jmp	47 <paging_init+0x1c2>
; uint32_t entry_virt=(uint32_t)&(smap_page_tables[i*1024]);
c0101f1c:	8b 45 d8 	movl	-40(%ebp), %eax
c0101f1f:	c1 e0 0a 	shll	$10, %eax
c0101f22:	c1 e0 02 	shll	$2, %eax
c0101f25:	05 00 40 33 c0 	addl	$3224584192, %eax
c0101f2a:	89 45 c8 	movl	%eax, -56(%ebp)
; page_directory[i+1022]=(entry_virt-0xC0000000)|0x3;
c0101f2d:	8b 45 c8 	movl	-56(%ebp), %eax
c0101f30:	8d 90 00 00 00 40 	leal	1073741824(%eax), %edx
c0101f36:	8b 45 d8 	movl	-40(%ebp), %eax
c0101f39:	05 fe 03 00 00 	addl	$1022, %eax
c0101f3e:	83 ca 03 	orl	$3, %edx
c0101f41:	89 14 85 00 e0 30 c0 	movl	%edx, -1070538752(,%eax,4)
; for (uint32_t i=0;i<2;i++) {
c0101f48:	ff 45 d8 	incl	-40(%ebp)
c0101f4b:	83 7d d8 01 	cmpl	$1, -40(%ebp)
c0101f4f:	76 cb 	jbe	-53 <paging_init+0x193>
; load_page_directory((uint32_t*)((uint32_t)page_directory-0xC0000000));
c0101f51:	b8 00 e0 30 c0 	movl	$3224428544, %eax
c0101f56:	05 00 00 00 40 	addl	$1073741824, %eax
c0101f5b:	83 ec 0c 	subl	$12, %esp
c0101f5e:	50 	pushl	%eax
c0101f5f:	e8 1c 0a 00 00 	calll	2588 <load_page_directory>
c0101f64:	83 c4 10 	addl	$16, %esp
; }
c0101f67:	90 	nop
c0101f68:	c9 	leave
c0101f69:	c3 	retl

get_bmap_bit:
; static char get_bmap_bit(int index) {
c0101f6a:	55 	pushl	%ebp
c0101f6b:	89 e5 	movl	%esp, %ebp
c0101f6d:	53 	pushl	%ebx
c0101f6e:	83 ec 10 	subl	$16, %esp
; int byte=index/8;
c0101f71:	8b 45 08 	movl	8(%ebp), %eax
c0101f74:	85 c0 	testl	%eax, %eax
c0101f76:	79 03 	jns	3 <get_bmap_bit+0x11>
c0101f78:	83 c0 07 	addl	$7, %eax
c0101f7b:	c1 f8 03 	sarl	$3, %eax
c0101f7e:	89 45 f8 	movl	%eax, -8(%ebp)
; int bit=index%8;
c0101f81:	8b 45 08 	movl	8(%ebp), %eax
c0101f84:	25 07 00 00 80 	andl	$2147483655, %eax
c0101f89:	85 c0 	testl	%eax, %eax
c0101f8b:	79 05 	jns	5 <get_bmap_bit+0x28>
c0101f8d:	48 	decl	%eax
c0101f8e:	83 c8 f8 	orl	$-8, %eax
c0101f91:	40 	incl	%eax
c0101f92:	89 45 f4 	movl	%eax, -12(%ebp)
; char entry=bmap[byte];
c0101f95:	8b 45 f8 	movl	-8(%ebp), %eax
c0101f98:	05 00 60 33 c0 	addl	$3224592384, %eax
c0101f9d:	8a 00 	movb	(%eax), %al
c0101f9f:	88 45 f3 	movb	%al, -13(%ebp)
; return (entry&(1<<bit))>0;
c0101fa2:	0f be 55 f3 	movsbl	-13(%ebp), %edx
c0101fa6:	8b 45 f4 	movl	-12(%ebp), %eax
c0101fa9:	bb 01 00 00 00 	movl	$1, %ebx
c0101fae:	88 c1 	movb	%al, %cl
c0101fb0:	d3 e3 	shll	%cl, %ebx
c0101fb2:	89 d8 	movl	%ebx, %eax
c0101fb4:	21 d0 	andl	%edx, %eax
c0101fb6:	85 c0 	testl	%eax, %eax
c0101fb8:	0f 9f c0 	setg	%al
; }
c0101fbb:	83 c4 10 	addl	$16, %esp
c0101fbe:	5b 	popl	%ebx
c0101fbf:	5d 	popl	%ebp
c0101fc0:	c3 	retl

set_bmap_bit:
; static void set_bmap_bit(int index) {
c0101fc1:	55 	pushl	%ebp
c0101fc2:	89 e5 	movl	%esp, %ebp
c0101fc4:	53 	pushl	%ebx
c0101fc5:	83 ec 10 	subl	$16, %esp
; int byte=index/8;
c0101fc8:	8b 45 08 	movl	8(%ebp), %eax
c0101fcb:	85 c0 	testl	%eax, %eax
c0101fcd:	79 03 	jns	3 <set_bmap_bit+0x11>
c0101fcf:	83 c0 07 	addl	$7, %eax
c0101fd2:	c1 f8 03 	sarl	$3, %eax
c0101fd5:	89 45 f8 	movl	%eax, -8(%ebp)
; int bit=index%8;
c0101fd8:	8b 45 08 	movl	8(%ebp), %eax
c0101fdb:	25 07 00 00 80 	andl	$2147483655, %eax
c0101fe0:	85 c0 	testl	%eax, %eax
c0101fe2:	79 05 	jns	5 <set_bmap_bit+0x28>
c0101fe4:	48 	decl	%eax
c0101fe5:	83 c8 f8 	orl	$-8, %eax
c0101fe8:	40 	incl	%eax
c0101fe9:	89 45 f4 	movl	%eax, -12(%ebp)
; bmap[byte]=bmap[byte]|(1<<bit);
c0101fec:	8b 45 f8 	movl	-8(%ebp), %eax
c0101fef:	05 00 60 33 c0 	addl	$3224592384, %eax
c0101ff4:	8a 10 	movb	(%eax), %dl
c0101ff6:	8b 45 f4 	movl	-12(%ebp), %eax
c0101ff9:	bb 01 00 00 00 	movl	$1, %ebx
c0101ffe:	88 c1 	movb	%al, %cl
c0102000:	d3 e3 	shll	%cl, %ebx
c0102002:	89 d8 	movl	%ebx, %eax
c0102004:	09 c2 	orl	%eax, %edx
c0102006:	8b 45 f8 	movl	-8(%ebp), %eax
c0102009:	05 00 60 33 c0 	addl	$3224592384, %eax
c010200e:	88 10 	movb	%dl, (%eax)
; }
c0102010:	90 	nop
c0102011:	83 c4 10 	addl	$16, %esp
c0102014:	5b 	popl	%ebx
c0102015:	5d 	popl	%ebp
c0102016:	c3 	retl

clear_bmap_bit:
; static void clear_bmap_bit(int index) {
c0102017:	55 	pushl	%ebp
c0102018:	89 e5 	movl	%esp, %ebp
c010201a:	53 	pushl	%ebx
c010201b:	83 ec 10 	subl	$16, %esp
; int byte=index/8;
c010201e:	8b 45 08 	movl	8(%ebp), %eax
c0102021:	85 c0 	testl	%eax, %eax
c0102023:	79 03 	jns	3 <clear_bmap_bit+0x11>
c0102025:	83 c0 07 	addl	$7, %eax
c0102028:	c1 f8 03 	sarl	$3, %eax
c010202b:	89 45 f8 	movl	%eax, -8(%ebp)
; int bit=index%8;
c010202e:	8b 45 08 	movl	8(%ebp), %eax
c0102031:	25 07 00 00 80 	andl	$2147483655, %eax
c0102036:	85 c0 	testl	%eax, %eax
c0102038:	79 05 	jns	5 <clear_bmap_bit+0x28>
c010203a:	48 	decl	%eax
c010203b:	83 c8 f8 	orl	$-8, %eax
c010203e:	40 	incl	%eax
c010203f:	89 45 f4 	movl	%eax, -12(%ebp)
; bmap[byte]=bmap[byte]&(~(1<<bit));
c0102042:	8b 45 f8 	movl	-8(%ebp), %eax
c0102045:	05 00 60 33 c0 	addl	$3224592384, %eax
c010204a:	8a 10 	movb	(%eax), %dl
c010204c:	8b 45 f4 	movl	-12(%ebp), %eax
c010204f:	bb 01 00 00 00 	movl	$1, %ebx
c0102054:	88 c1 	movb	%al, %cl
c0102056:	d3 e3 	shll	%cl, %ebx
c0102058:	89 d8 	movl	%ebx, %eax
c010205a:	f7 d0 	notl	%eax
c010205c:	21 c2 	andl	%eax, %edx
c010205e:	8b 45 f8 	movl	-8(%ebp), %eax
c0102061:	05 00 60 33 c0 	addl	$3224592384, %eax
c0102066:	88 10 	movb	%dl, (%eax)
; }
c0102068:	90 	nop
c0102069:	83 c4 10 	addl	$16, %esp
c010206c:	5b 	popl	%ebx
c010206d:	5d 	popl	%ebp
c010206e:	c3 	retl

pmem_init:
; void pmem_init(struct multiboot_boot_header_tag* tags) {
c010206f:	55 	pushl	%ebp
c0102070:	89 e5 	movl	%esp, %ebp
c0102072:	83 ec 38 	subl	$56, %esp
; for (int i=0;i<131072;i++) {
c0102075:	c7 45 f4 00 00 00 00 	movl	$0, -12(%ebp)
c010207c:	eb 0e 	jmp	14 <pmem_init+0x1d>
; bmap[i]=0xFF;
c010207e:	8b 45 f4 	movl	-12(%ebp), %eax
c0102081:	05 00 60 33 c0 	addl	$3224592384, %eax
c0102086:	c6 00 ff 	movb	$-1, (%eax)
; for (int i=0;i<131072;i++) {
c0102089:	ff 45 f4 	incl	-12(%ebp)
c010208c:	81 7d f4 ff ff 01 00 	cmpl	$131071, -12(%ebp)
c0102093:	7e e9 	jle	-23 <pmem_init+0xf>
; char found_mmap=0;
c0102095:	c6 45 f3 00 	movb	$0, -13(%ebp)
; struct multiboot_tag* tag=(struct multiboot_tag*)(tags+1);
c0102099:	8b 45 08 	movl	8(%ebp), %eax
c010209c:	83 c0 08 	addl	$8, %eax
c010209f:	89 45 ec 	movl	%eax, -20(%ebp)
; while (tag->type!=0) {
c01020a2:	e9 be 00 00 00 	jmp	190 <pmem_init+0xf6>
; switch (tag->type) {
c01020a7:	8b 45 ec 	movl	-20(%ebp), %eax
c01020aa:	8b 00 	movl	(%eax), %eax
c01020ac:	83 f8 06 	cmpl	$6, %eax
c01020af:	0f 85 a1 00 00 00 	jne	161 <pmem_init+0xe7>
; found_mmap=1;
c01020b5:	c6 45 f3 01 	movb	$1, -13(%ebp)
; struct multiboot_mmap_entry* orig_ptr=(struct multiboot_mmap_entry*)(((char*)tag)+16);
c01020b9:	8b 45 ec 	movl	-20(%ebp), %eax
c01020bc:	83 c0 10 	addl	$16, %eax
c01020bf:	89 45 d8 	movl	%eax, -40(%ebp)
; for (struct multiboot_mmap_entry* ptr=orig_ptr;(char*)ptr<((char*)orig_ptr)+tag->size;ptr++) {
c01020c2:	8b 45 d8 	movl	-40(%ebp), %eax
c01020c5:	89 45 e8 	movl	%eax, -24(%ebp)
c01020c8:	eb 77 	jmp	119 <pmem_init+0xd2>
; if (ptr->type!=MULTIBOOT_MEMORY_AVAILABLE) continue;
c01020ca:	8b 45 e8 	movl	-24(%ebp), %eax
c01020cd:	8b 40 10 	movl	16(%eax), %eax
c01020d0:	83 f8 01 	cmpl	$1, %eax
c01020d3:	75 64 	jne	100 <pmem_init+0xca>
; uint32_t start=ptr->addr;
c01020d5:	8b 45 e8 	movl	-24(%ebp), %eax
c01020d8:	8b 50 04 	movl	4(%eax), %edx
c01020db:	8b 00 	movl	(%eax), %eax
c01020dd:	89 45 e4 	movl	%eax, -28(%ebp)
; if (start<0x100000) continue;
c01020e0:	81 7d e4 ff ff 0f 00 	cmpl	$1048575, -28(%ebp)
c01020e7:	76 53 	jbe	83 <pmem_init+0xcd>
; uint32_t end=start+ptr->len-1;
c01020e9:	8b 45 e8 	movl	-24(%ebp), %eax
c01020ec:	8b 50 0c 	movl	12(%eax), %edx
c01020ef:	8b 40 08 	movl	8(%eax), %eax
c01020f2:	89 c2 	movl	%eax, %edx
c01020f4:	8b 45 e4 	movl	-28(%ebp), %eax
c01020f7:	01 d0 	addl	%edx, %eax
c01020f9:	48 	decl	%eax
c01020fa:	89 45 d4 	movl	%eax, -44(%ebp)
; if (start&0xFFF) {
c01020fd:	8b 45 e4 	movl	-28(%ebp), %eax
c0102100:	25 ff 0f 00 00 	andl	$4095, %eax
c0102105:	85 c0 	testl	%eax, %eax
c0102107:	74 07 	je	7 <pmem_init+0xa1>
; start+=0x1000;
c0102109:	81 45 e4 00 10 00 00 	addl	$4096, -28(%ebp)
; start=start>>12;
c0102110:	c1 6d e4 0c 	shrl	$12, -28(%ebp)
; end=end>>12;
c0102114:	c1 6d d4 0c 	shrl	$12, -44(%ebp)
; for (uint32_t i=start;i<end;i++) {
c0102118:	8b 45 e4 	movl	-28(%ebp), %eax
c010211b:	89 45 e0 	movl	%eax, -32(%ebp)
c010211e:	eb 0f 	jmp	15 <pmem_init+0xc0>
; clear_bmap_bit(i);
c0102120:	8b 45 e0 	movl	-32(%ebp), %eax
c0102123:	50 	pushl	%eax
c0102124:	e8 ee fe ff ff 	calll	-274 <clear_bmap_bit>
c0102129:	83 c4 04 	addl	$4, %esp
; for (uint32_t i=start;i<end;i++) {
c010212c:	ff 45 e0 	incl	-32(%ebp)
c010212f:	8b 45 e0 	movl	-32(%ebp), %eax
c0102132:	3b 45 d4 	cmpl	-44(%ebp), %eax
c0102135:	72 e9 	jb	-23 <pmem_init+0xb1>
c0102137:	eb 04 	jmp	4 <pmem_init+0xce>
; if (ptr->type!=MULTIBOOT_MEMORY_AVAILABLE) continue;
c0102139:	90 	nop
c010213a:	eb 01 	jmp	1 <pmem_init+0xce>
; if (start<0x100000) continue;
c010213c:	90 	nop
; for (struct multiboot_mmap_entry* ptr=orig_ptr;(char*)ptr<((char*)orig_ptr)+tag->size;ptr++) {
c010213d:	83 45 e8 18 	addl	$24, -24(%ebp)
c0102141:	8b 45 ec 	movl	-20(%ebp), %eax
c0102144:	8b 50 04 	movl	4(%eax), %edx
c0102147:	8b 45 d8 	movl	-40(%ebp), %eax
c010214a:	01 d0 	addl	%edx, %eax
c010214c:	39 45 e8 	cmpl	%eax, -24(%ebp)
c010214f:	0f 82 75 ff ff ff 	jb	-139 <pmem_init+0x5b>
; break;
c0102155:	90 	nop
; tag=(struct multiboot_tag*)((char*)tag+((tag->size+7)&0xFFFFFFF8));
c0102156:	8b 45 ec 	movl	-20(%ebp), %eax
c0102159:	8b 40 04 	movl	4(%eax), %eax
c010215c:	83 c0 07 	addl	$7, %eax
c010215f:	83 e0 f8 	andl	$-8, %eax
c0102162:	01 45 ec 	addl	%eax, -20(%ebp)
; while (tag->type!=0) {
c0102165:	8b 45 ec 	movl	-20(%ebp), %eax
c0102168:	8b 00 	movl	(%eax), %eax
c010216a:	85 c0 	testl	%eax, %eax
c010216c:	0f 85 35 ff ff ff 	jne	-203 <pmem_init+0x38>
; if (!found_mmap) {
c0102172:	80 7d f3 00 	cmpb	$0, -13(%ebp)
c0102176:	75 15 	jne	21 <pmem_init+0x11e>
; vga_write_string("[PANIC] No memory map supplied by bootloader!");
c0102178:	83 ec 0c 	subl	$12, %esp
c010217b:	68 14 44 10 c0 	pushl	$3222291476
c0102180:	e8 35 e3 ff ff 	calll	-7371 <vga_write_string>
c0102185:	83 c4 10 	addl	$16, %esp
; halt();
c0102188:	e8 13 e7 ff ff 	calll	-6381 <halt>
; for (uint32_t i=0;i<2048;i++) {
c010218d:	c7 45 dc 00 00 00 00 	movl	$0, -36(%ebp)
c0102194:	eb 12 	jmp	18 <pmem_init+0x139>
; set_bmap_bit(i);
c0102196:	8b 45 dc 	movl	-36(%ebp), %eax
c0102199:	83 ec 0c 	subl	$12, %esp
c010219c:	50 	pushl	%eax
c010219d:	e8 1f fe ff ff 	calll	-481 <set_bmap_bit>
c01021a2:	83 c4 10 	addl	$16, %esp
; for (uint32_t i=0;i<2048;i++) {
c01021a5:	ff 45 dc 	incl	-36(%ebp)
c01021a8:	81 7d dc ff 07 00 00 	cmpl	$2047, -36(%ebp)
c01021af:	76 e5 	jbe	-27 <pmem_init+0x127>
; }
c01021b1:	90 	nop
c01021b2:	c9 	leave
c01021b3:	c3 	retl

pmem_alloc:
; void* pmem_alloc(int num_pages) {
c01021b4:	55 	pushl	%ebp
c01021b5:	89 e5 	movl	%esp, %ebp
c01021b7:	83 ec 30 	subl	$48, %esp
; for(uint32_t i=0;i<131072;i++) {
c01021ba:	c7 45 f4 00 00 00 00 	movl	$0, -12(%ebp)
c01021c1:	eb 7e 	jmp	126 <pmem_alloc+0x8d>
; char got_0=0;
c01021c3:	c6 45 f3 00 	movb	$0, -13(%ebp)
; remaining_blks=num_pages;
c01021c7:	8b 45 08 	movl	8(%ebp), %eax
c01021ca:	89 45 f8 	movl	%eax, -8(%ebp)
; for (uint32_t j=i*8;;j++) {
c01021cd:	8b 45 f4 	movl	-12(%ebp), %eax
c01021d0:	c1 e0 03 	shll	$3, %eax
c01021d3:	89 45 e8 	movl	%eax, -24(%ebp)
; char bit=get_bmap_bit(j);
c01021d6:	8b 45 e8 	movl	-24(%ebp), %eax
c01021d9:	50 	pushl	%eax
c01021da:	e8 8b fd ff ff 	calll	-629 <get_bmap_bit>
c01021df:	83 c4 04 	addl	$4, %esp
c01021e2:	88 45 e3 	movb	%al, -29(%ebp)
; if (got_0) {
c01021e5:	80 7d f3 00 	cmpb	$0, -13(%ebp)
c01021e9:	74 27 	je	39 <pmem_alloc+0x5e>
; if (bit) {
c01021eb:	80 7d e3 00 	cmpb	$0, -29(%ebp)
c01021ef:	74 1c 	je	28 <pmem_alloc+0x59>
; if (remaining_blks==0) {
c01021f1:	83 7d f8 00 	cmpl	$0, -8(%ebp)
c01021f5:	75 08 	jne	8 <pmem_alloc+0x4b>
; bmap_index=old_j;
c01021f7:	8b 45 ec 	movl	-20(%ebp), %eax
c01021fa:	89 45 fc 	movl	%eax, -4(%ebp)
; break;
c01021fd:	eb 39 	jmp	57 <pmem_alloc+0x84>
; i+=j/8;
c01021ff:	8b 45 e8 	movl	-24(%ebp), %eax
c0102202:	c1 e8 03 	shrl	$3, %eax
c0102205:	01 45 f4 	addl	%eax, -12(%ebp)
; i--;
c0102208:	ff 4d f4 	decl	-12(%ebp)
; break;
c010220b:	eb 2b 	jmp	43 <pmem_alloc+0x84>
; remaining_blks--;
c010220d:	ff 4d f8 	decl	-8(%ebp)
c0102210:	eb 13 	jmp	19 <pmem_alloc+0x71>
; if (!bit) {
c0102212:	80 7d e3 00 	cmpb	$0, -29(%ebp)
c0102216:	75 0d 	jne	13 <pmem_alloc+0x71>
; got_0=1;
c0102218:	c6 45 f3 01 	movb	$1, -13(%ebp)
; old_j=j;
c010221c:	8b 45 e8 	movl	-24(%ebp), %eax
c010221f:	89 45 ec 	movl	%eax, -20(%ebp)
; remaining_blks--;
c0102222:	ff 4d f8 	decl	-8(%ebp)
; if (remaining_blks==0) {
c0102225:	83 7d f8 00 	cmpl	$0, -8(%ebp)
c0102229:	75 08 	jne	8 <pmem_alloc+0x7f>
; bmap_index=old_j;
c010222b:	8b 45 ec 	movl	-20(%ebp), %eax
c010222e:	89 45 fc 	movl	%eax, -4(%ebp)
; break;
c0102231:	eb 05 	jmp	5 <pmem_alloc+0x84>
; for (uint32_t j=i*8;;j++) {
c0102233:	ff 45 e8 	incl	-24(%ebp)
c0102236:	eb 9e 	jmp	-98 <pmem_alloc+0x22>
; if (remaining_blks==0) {
c0102238:	83 7d f8 00 	cmpl	$0, -8(%ebp)
c010223c:	74 12 	je	18 <pmem_alloc+0x9c>
; for(uint32_t i=0;i<131072;i++) {
c010223e:	ff 45 f4 	incl	-12(%ebp)
c0102241:	81 7d f4 ff ff 01 00 	cmpl	$131071, -12(%ebp)
c0102248:	0f 86 75 ff ff ff 	jbe	-139 <pmem_alloc+0xf>
c010224e:	eb 01 	jmp	1 <pmem_alloc+0x9d>
; break;
c0102250:	90 	nop
; if (remaining_blks!=0) {
c0102251:	83 7d f8 00 	cmpl	$0, -8(%ebp)
c0102255:	74 07 	je	7 <pmem_alloc+0xaa>
; return NULL;
c0102257:	b8 00 00 00 00 	movl	$0, %eax
c010225c:	eb 31 	jmp	49 <pmem_alloc+0xdb>
; for (int i=0;i<num_pages;i++) {
c010225e:	c7 45 e4 00 00 00 00 	movl	$0, -28(%ebp)
c0102265:	eb 14 	jmp	20 <pmem_alloc+0xc7>
; set_bmap_bit(bmap_index+i);
c0102267:	8b 55 e4 	movl	-28(%ebp), %edx
c010226a:	8b 45 fc 	movl	-4(%ebp), %eax
c010226d:	01 d0 	addl	%edx, %eax
c010226f:	50 	pushl	%eax
c0102270:	e8 4c fd ff ff 	calll	-692 <set_bmap_bit>
c0102275:	83 c4 04 	addl	$4, %esp
; for (int i=0;i<num_pages;i++) {
c0102278:	ff 45 e4 	incl	-28(%ebp)
c010227b:	8b 45 e4 	movl	-28(%ebp), %eax
c010227e:	3b 45 08 	cmpl	8(%ebp), %eax
c0102281:	7c e4 	jl	-28 <pmem_alloc+0xb3>
; void* addr=(void*)(bmap_index<<12);
c0102283:	8b 45 fc 	movl	-4(%ebp), %eax
c0102286:	c1 e0 0c 	shll	$12, %eax
c0102289:	89 45 dc 	movl	%eax, -36(%ebp)
; return addr;
c010228c:	8b 45 dc 	movl	-36(%ebp), %eax
; }
c010228f:	c9 	leave
c0102290:	c3 	retl

pmem_free:
; void pmem_free(int start_page,int num_pages) {
c0102291:	55 	pushl	%ebp
c0102292:	89 e5 	movl	%esp, %ebp
c0102294:	83 ec 10 	subl	$16, %esp
; for (int i=start_page;i<num_pages;i++) {
c0102297:	8b 45 08 	movl	8(%ebp), %eax
c010229a:	89 45 fc 	movl	%eax, -4(%ebp)
c010229d:	eb 0e 	jmp	14 <pmem_free+0x1c>
; set_bmap_bit(i);
c010229f:	ff 75 fc 	pushl	-4(%ebp)
c01022a2:	e8 1a fd ff ff 	calll	-742 <set_bmap_bit>
c01022a7:	83 c4 04 	addl	$4, %esp
; for (int i=start_page;i<num_pages;i++) {
c01022aa:	ff 45 fc 	incl	-4(%ebp)
c01022ad:	8b 45 fc 	movl	-4(%ebp), %eax
c01022b0:	3b 45 0c 	cmpl	12(%ebp), %eax
c01022b3:	7c ea 	jl	-22 <pmem_free+0xe>
; }
c01022b5:	90 	nop
c01022b6:	c9 	leave
c01022b7:	c3 	retl

port_byte_in:
; uint8_t port_byte_in(uint16_t port) {
c01022b8:	55 	pushl	%ebp
c01022b9:	89 e5 	movl	%esp, %ebp
c01022bb:	83 ec 14 	subl	$20, %esp
c01022be:	8b 45 08 	movl	8(%ebp), %eax
c01022c1:	66 89 45 ec 	movw	%ax, -20(%ebp)
; asm("in %%dx, %%al":"=a"(result):"d"(port));
c01022c5:	8b 45 ec 	movl	-20(%ebp), %eax
c01022c8:	89 c2 	movl	%eax, %edx
c01022ca:	ec 	inb	%dx, %al
c01022cb:	88 45 ff 	movb	%al, -1(%ebp)
; return result;
c01022ce:	8a 45 ff 	movb	-1(%ebp), %al
; }
c01022d1:	c9 	leave
c01022d2:	c3 	retl

port_byte_out:
; void port_byte_out(uint16_t port,uint8_t data) {
c01022d3:	55 	pushl	%ebp
c01022d4:	89 e5 	movl	%esp, %ebp
c01022d6:	83 ec 08 	subl	$8, %esp
c01022d9:	8b 45 08 	movl	8(%ebp), %eax
c01022dc:	8b 55 0c 	movl	12(%ebp), %edx
c01022df:	66 89 45 fc 	movw	%ax, -4(%ebp)
c01022e3:	88 d0 	movb	%dl, %al
c01022e5:	88 45 f8 	movb	%al, -8(%ebp)
; asm("out %%al, %%dx":: "a"(data),"d"(port));
c01022e8:	8a 45 f8 	movb	-8(%ebp), %al
c01022eb:	8b 55 fc 	movl	-4(%ebp), %edx
c01022ee:	ee 	outb	%al, %dx
; }
c01022ef:	90 	nop
c01022f0:	c9 	leave
c01022f1:	c3 	retl

port_word_in:
; uint16_t port_word_in(uint16_t port) {
c01022f2:	55 	pushl	%ebp
c01022f3:	89 e5 	movl	%esp, %ebp
c01022f5:	83 ec 14 	subl	$20, %esp
c01022f8:	8b 45 08 	movl	8(%ebp), %eax
c01022fb:	66 89 45 ec 	movw	%ax, -20(%ebp)
; asm("in %%dx, %%ax":"=a"(result):"d"(port));
c01022ff:	8b 45 ec 	movl	-20(%ebp), %eax
c0102302:	89 c2 	movl	%eax, %edx
c0102304:	66 ed 	inw	%dx, %ax
c0102306:	66 89 45 fe 	movw	%ax, -2(%ebp)
; return result;
c010230a:	66 8b 45 fe 	movw	-2(%ebp), %ax
; }
c010230e:	c9 	leave
c010230f:	c3 	retl

port_word_out:
; void port_word_out(uint16_t port,uint16_t data) {
c0102310:	55 	pushl	%ebp
c0102311:	89 e5 	movl	%esp, %ebp
c0102313:	83 ec 08 	subl	$8, %esp
c0102316:	8b 55 08 	movl	8(%ebp), %edx
c0102319:	8b 45 0c 	movl	12(%ebp), %eax
c010231c:	66 89 55 fc 	movw	%dx, -4(%ebp)
c0102320:	66 89 45 f8 	movw	%ax, -8(%ebp)
; asm("out %%ax, %%dx":: "a" (data), "d" (port));
c0102324:	8b 45 f8 	movl	-8(%ebp), %eax
c0102327:	8b 55 fc 	movl	-4(%ebp), %edx
c010232a:	66 ef 	outw	%ax, %dx
; }
c010232c:	90 	nop
c010232d:	c9 	leave
c010232e:	c3 	retl

port_long_in:
; uint32_t port_long_in(uint16_t port) {
c010232f:	55 	pushl	%ebp
c0102330:	89 e5 	movl	%esp, %ebp
c0102332:	83 ec 14 	subl	$20, %esp
c0102335:	8b 45 08 	movl	8(%ebp), %eax
c0102338:	66 89 45 ec 	movw	%ax, -20(%ebp)
; asm("inl %%dx, %%eax":"=a"(result):"d"(port));
c010233c:	8b 45 ec 	movl	-20(%ebp), %eax
c010233f:	89 c2 	movl	%eax, %edx
c0102341:	ed 	inl	%dx, %eax
c0102342:	89 45 fc 	movl	%eax, -4(%ebp)
; return result;
c0102345:	8b 45 fc 	movl	-4(%ebp), %eax
; }
c0102348:	c9 	leave
c0102349:	c3 	retl

port_long_out:
; void port_long_out(uint16_t port,uint32_t data) {
c010234a:	55 	pushl	%ebp
c010234b:	89 e5 	movl	%esp, %ebp
c010234d:	83 ec 04 	subl	$4, %esp
c0102350:	8b 45 08 	movl	8(%ebp), %eax
c0102353:	66 89 45 fc 	movw	%ax, -4(%ebp)
; asm("outl %%eax, %%dx":: "a" (data), "d" (port));
c0102357:	8b 45 0c 	movl	12(%ebp), %eax
c010235a:	8b 55 fc 	movl	-4(%ebp), %edx
c010235d:	ef 	outl	%eax, %dx
; }
c010235e:	90 	nop
c010235f:	c9 	leave
c0102360:	c3 	retl

tasking_init:
; void tasking_init(void* esp) {
c0102361:	55 	pushl	%ebp
c0102362:	89 e5 	movl	%esp, %ebp
c0102364:	83 ec 08 	subl	$8, %esp
; currentTask=NULL;
c0102367:	c7 05 6c 90 10 c0 00 00 00 00 	movl	$0, -1072656276
; next_pid=0;
c0102371:	c7 05 70 90 10 c0 00 00 00 00 	movl	$0, -1072656272
; headTask=tasking_createTaskCr3KmodeParam(NULL,paging_new_address_space(),1,0,0,0,0);
c010237b:	e8 3c f8 ff ff 	calll	-1988 <paging_new_address_space>
c0102380:	83 ec 04 	subl	$4, %esp
c0102383:	6a 00 	pushl	$0
c0102385:	6a 00 	pushl	$0
c0102387:	6a 00 	pushl	$0
c0102389:	6a 00 	pushl	$0
c010238b:	6a 01 	pushl	$1
c010238d:	50 	pushl	%eax
c010238e:	6a 00 	pushl	$0
c0102390:	e8 1f 00 00 00 	calll	31 <tasking_createTaskCr3KmodeParam>
c0102395:	83 c4 20 	addl	$32, %esp
c0102398:	a3 00 60 35 c0 	movl	%eax, 3224723456
; currentTask=headTask;
c010239d:	a1 00 60 35 c0 	movl	3224723456, %eax
c01023a2:	a3 6c 90 10 c0 	movl	%eax, 3222311020
; tailTask=headTask;
c01023a7:	a1 00 60 35 c0 	movl	3224723456, %eax
c01023ac:	a3 04 60 35 c0 	movl	%eax, 3224723460
; }
c01023b1:	90 	nop
c01023b2:	c9 	leave
c01023b3:	c3 	retl

tasking_createTaskCr3KmodeParam:
; Task* tasking_createTaskCr3KmodeParam(void* eip,void* cr3,char kmode,char param1_exists,uint32_t param1_arg,char param2_exists,uint32_t param2_arg) {
c01023b4:	55 	pushl	%ebp
c01023b5:	89 e5 	movl	%esp, %ebp
c01023b7:	83 ec 38 	subl	$56, %esp
c01023ba:	8b 4d 10 	movl	16(%ebp), %ecx
c01023bd:	8b 55 14 	movl	20(%ebp), %edx
c01023c0:	8b 45 1c 	movl	28(%ebp), %eax
c01023c3:	88 4d d4 	movb	%cl, -44(%ebp)
c01023c6:	88 55 d0 	movb	%dl, -48(%ebp)
c01023c9:	88 45 cc 	movb	%al, -52(%ebp)
; Task* task=kmalloc(sizeof(Task));
c01023cc:	83 ec 0c 	subl	$12, %esp
c01023cf:	6a 1d 	pushl	$29
c01023d1:	e8 06 ef ff ff 	calll	-4346 <kmalloc>
c01023d6:	83 c4 10 	addl	$16, %esp
c01023d9:	89 45 ec 	movl	%eax, -20(%ebp)
; map_kstack(next_pid);
c01023dc:	a1 70 90 10 c0 	movl	3222311024, %eax
c01023e1:	83 ec 0c 	subl	$12, %esp
c01023e4:	50 	pushl	%eax
c01023e5:	e8 a6 f5 ff ff 	calll	-2650 <map_kstack>
c01023ea:	83 c4 10 	addl	$16, %esp
; if (param1_exists) {
c01023ed:	80 7d d0 00 	cmpb	$0, -48(%ebp)
c01023f1:	74 08 	je	8 <tasking_createTaskCr3KmodeParam+0x47>
; param1=param1_arg;
c01023f3:	8b 45 18 	movl	24(%ebp), %eax
c01023f6:	89 45 f4 	movl	%eax, -12(%ebp)
c01023f9:	eb 07 	jmp	7 <tasking_createTaskCr3KmodeParam+0x4e>
; param1=1;
c01023fb:	c7 45 f4 01 00 00 00 	movl	$1, -12(%ebp)
; if (param2_exists) {
c0102402:	80 7d cc 00 	cmpb	$0, -52(%ebp)
c0102406:	74 08 	je	8 <tasking_createTaskCr3KmodeParam+0x5c>
; param2=param2_arg;
c0102408:	8b 45 20 	movl	32(%ebp), %eax
c010240b:	89 45 f0 	movl	%eax, -16(%ebp)
c010240e:	eb 07 	jmp	7 <tasking_createTaskCr3KmodeParam+0x63>
; param2=2;
c0102410:	c7 45 f0 02 00 00 00 	movl	$2, -16(%ebp)
; task->cr3=(uint32_t)cr3;
c0102417:	8b 55 0c 	movl	12(%ebp), %edx
c010241a:	8b 45 ec 	movl	-20(%ebp), %eax
c010241d:	89 50 08 	movl	%edx, 8(%eax)
; asm volatile("movl %%cr3, %%eax; movl %%eax, %0;":"=m"(old_cr3)::"%eax");
c0102420:	0f 20 d8 	movl	%cr3, %eax
c0102423:	89 45 dc 	movl	%eax, -36(%ebp)
; load_address_space(task->cr3);
c0102426:	8b 45 ec 	movl	-20(%ebp), %eax
c0102429:	8b 40 08 	movl	8(%eax), %eax
c010242c:	83 ec 0c 	subl	$12, %esp
c010242f:	50 	pushl	%eax
c0102430:	e8 0e f8 ff ff 	calll	-2034 <load_address_space>
c0102435:	83 c4 10 	addl	$16, %esp
; if (kmode) {
c0102438:	80 7d d4 00 	cmpb	$0, -44(%ebp)
c010243c:	0f 84 b2 00 00 00 	je	178 <tasking_createTaskCr3KmodeParam+0x140>
; uint32_t top_idx=(1024*(next_pid+1));
c0102442:	a1 70 90 10 c0 	movl	3222311024, %eax
c0102447:	40 	incl	%eax
c0102448:	c1 e0 0a 	shll	$10, %eax
c010244b:	89 45 e8 	movl	%eax, -24(%ebp)
; task->kernel_esp=((uint32_t)(&kstacks[top_idx-5]));
c010244e:	a1 90 60 10 c0 	movl	3222298768, %eax
c0102453:	8b 55 e8 	movl	-24(%ebp), %edx
c0102456:	81 c2 fb ff ff 3f 	addl	$1073741819, %edx
c010245c:	c1 e2 02 	shll	$2, %edx
c010245f:	01 d0 	addl	%edx, %eax
c0102461:	89 c2 	movl	%eax, %edx
c0102463:	8b 45 ec 	movl	-20(%ebp), %eax
c0102466:	89 10 	movl	%edx, (%eax)
; task->kernel_esp_top=task->kernel_esp;
c0102468:	8b 45 ec 	movl	-20(%ebp), %eax
c010246b:	8b 10 	movl	(%eax), %edx
c010246d:	8b 45 ec 	movl	-20(%ebp), %eax
c0102470:	89 50 04 	movl	%edx, 4(%eax)
; kstacks[top_idx-5]=0;
c0102473:	a1 90 60 10 c0 	movl	3222298768, %eax
c0102478:	8b 55 e8 	movl	-24(%ebp), %edx
c010247b:	81 c2 fb ff ff 3f 	addl	$1073741819, %edx
c0102481:	c1 e2 02 	shll	$2, %edx
c0102484:	01 d0 	addl	%edx, %eax
c0102486:	c7 00 00 00 00 00 	movl	$0, (%eax)
; kstacks[top_idx-4]=0;
c010248c:	a1 90 60 10 c0 	movl	3222298768, %eax
c0102491:	8b 55 e8 	movl	-24(%ebp), %edx
c0102494:	81 c2 fc ff ff 3f 	addl	$1073741820, %edx
c010249a:	c1 e2 02 	shll	$2, %edx
c010249d:	01 d0 	addl	%edx, %eax
c010249f:	c7 00 00 00 00 00 	movl	$0, (%eax)
; kstacks[top_idx-3]=0;
c01024a5:	a1 90 60 10 c0 	movl	3222298768, %eax
c01024aa:	8b 55 e8 	movl	-24(%ebp), %edx
c01024ad:	81 c2 fd ff ff 3f 	addl	$1073741821, %edx
c01024b3:	c1 e2 02 	shll	$2, %edx
c01024b6:	01 d0 	addl	%edx, %eax
c01024b8:	c7 00 00 00 00 00 	movl	$0, (%eax)
; kstacks[top_idx-2]=0;
c01024be:	a1 90 60 10 c0 	movl	3222298768, %eax
c01024c3:	8b 55 e8 	movl	-24(%ebp), %edx
c01024c6:	81 c2 fe ff ff 3f 	addl	$1073741822, %edx
c01024cc:	c1 e2 02 	shll	$2, %edx
c01024cf:	01 d0 	addl	%edx, %eax
c01024d1:	c7 00 00 00 00 00 	movl	$0, (%eax)
; kstacks[top_idx-1]=(uint32_t)eip;
c01024d7:	a1 90 60 10 c0 	movl	3222298768, %eax
c01024dc:	8b 55 e8 	movl	-24(%ebp), %edx
c01024df:	81 c2 ff ff ff 3f 	addl	$1073741823, %edx
c01024e5:	c1 e2 02 	shll	$2, %edx
c01024e8:	01 c2 	addl	%eax, %edx
c01024ea:	8b 45 08 	movl	8(%ebp), %eax
c01024ed:	89 02 	movl	%eax, (%edx)
c01024ef:	e9 0b 01 00 00 	jmp	267 <tasking_createTaskCr3KmodeParam+0x24b>
; uint32_t top_idx=(1024*(next_pid+1));
c01024f4:	a1 70 90 10 c0 	movl	3222311024, %eax
c01024f9:	40 	incl	%eax
c01024fa:	c1 e0 0a 	shll	$10, %eax
c01024fd:	89 45 e4 	movl	%eax, -28(%ebp)
; task->kernel_esp=((uint32_t)(&kstacks[top_idx-7]));
c0102500:	a1 90 60 10 c0 	movl	3222298768, %eax
c0102505:	8b 55 e4 	movl	-28(%ebp), %edx
c0102508:	81 c2 f9 ff ff 3f 	addl	$1073741817, %edx
c010250e:	c1 e2 02 	shll	$2, %edx
c0102511:	01 d0 	addl	%edx, %eax
c0102513:	89 c2 	movl	%eax, %edx
c0102515:	8b 45 ec 	movl	-20(%ebp), %eax
c0102518:	89 10 	movl	%edx, (%eax)
; task->kernel_esp_top=task->kernel_esp;
c010251a:	8b 45 ec 	movl	-20(%ebp), %eax
c010251d:	8b 10 	movl	(%eax), %edx
c010251f:	8b 45 ec 	movl	-20(%ebp), %eax
c0102522:	89 50 04 	movl	%edx, 4(%eax)
; kstacks[top_idx-7]=0;
c0102525:	a1 90 60 10 c0 	movl	3222298768, %eax
c010252a:	8b 55 e4 	movl	-28(%ebp), %edx
c010252d:	81 c2 f9 ff ff 3f 	addl	$1073741817, %edx
c0102533:	c1 e2 02 	shll	$2, %edx
c0102536:	01 d0 	addl	%edx, %eax
c0102538:	c7 00 00 00 00 00 	movl	$0, (%eax)
; kstacks[top_idx-6]=0;
c010253e:	a1 90 60 10 c0 	movl	3222298768, %eax
c0102543:	8b 55 e4 	movl	-28(%ebp), %edx
c0102546:	81 c2 fa ff ff 3f 	addl	$1073741818, %edx
c010254c:	c1 e2 02 	shll	$2, %edx
c010254f:	01 d0 	addl	%edx, %eax
c0102551:	c7 00 00 00 00 00 	movl	$0, (%eax)
; kstacks[top_idx-5]=0;
c0102557:	a1 90 60 10 c0 	movl	3222298768, %eax
c010255c:	8b 55 e4 	movl	-28(%ebp), %edx
c010255f:	81 c2 fb ff ff 3f 	addl	$1073741819, %edx
c0102565:	c1 e2 02 	shll	$2, %edx
c0102568:	01 d0 	addl	%edx, %eax
c010256a:	c7 00 00 00 00 00 	movl	$0, (%eax)
; kstacks[top_idx-4]=0;
c0102570:	a1 90 60 10 c0 	movl	3222298768, %eax
c0102575:	8b 55 e4 	movl	-28(%ebp), %edx
c0102578:	81 c2 fc ff ff 3f 	addl	$1073741820, %edx
c010257e:	c1 e2 02 	shll	$2, %edx
c0102581:	01 d0 	addl	%edx, %eax
c0102583:	c7 00 00 00 00 00 	movl	$0, (%eax)
; kstacks[top_idx-3]=(uint32_t)task_init;
c0102589:	a1 90 60 10 c0 	movl	3222298768, %eax
c010258e:	8b 55 e4 	movl	-28(%ebp), %edx
c0102591:	81 c2 fd ff ff 3f 	addl	$1073741821, %edx
c0102597:	c1 e2 02 	shll	$2, %edx
c010259a:	01 d0 	addl	%edx, %eax
c010259c:	ba e3 29 10 c0 	movl	$3222284771, %edx
c01025a1:	89 10 	movl	%edx, (%eax)
; uint32_t* user_stack=(uint32_t*)(((uint32_t)alloc_pages(1))+0x1000);
c01025a3:	83 ec 0c 	subl	$12, %esp
c01025a6:	6a 01 	pushl	$1
c01025a8:	e8 d1 f4 ff ff 	calll	-2863 <alloc_pages>
c01025ad:	83 c4 10 	addl	$16, %esp
c01025b0:	05 00 10 00 00 	addl	$4096, %eax
c01025b5:	89 45 e0 	movl	%eax, -32(%ebp)
; user_stack-=2;
c01025b8:	83 6d e0 08 	subl	$8, -32(%ebp)
; user_stack[0]=param1;
c01025bc:	8b 45 e0 	movl	-32(%ebp), %eax
c01025bf:	8b 55 f4 	movl	-12(%ebp), %edx
c01025c2:	89 10 	movl	%edx, (%eax)
; user_stack[1]=param2;
c01025c4:	8b 45 e0 	movl	-32(%ebp), %eax
c01025c7:	8d 50 04 	leal	4(%eax), %edx
c01025ca:	8b 45 f0 	movl	-16(%ebp), %eax
c01025cd:	89 02 	movl	%eax, (%edx)
; kstacks[top_idx-2]=(uint32_t)user_stack;
c01025cf:	a1 90 60 10 c0 	movl	3222298768, %eax
c01025d4:	8b 55 e4 	movl	-28(%ebp), %edx
c01025d7:	81 c2 fe ff ff 3f 	addl	$1073741822, %edx
c01025dd:	c1 e2 02 	shll	$2, %edx
c01025e0:	01 c2 	addl	%eax, %edx
c01025e2:	8b 45 e0 	movl	-32(%ebp), %eax
c01025e5:	89 02 	movl	%eax, (%edx)
; kstacks[top_idx-1]=(uint32_t)eip;
c01025e7:	a1 90 60 10 c0 	movl	3222298768, %eax
c01025ec:	8b 55 e4 	movl	-28(%ebp), %edx
c01025ef:	81 c2 ff ff ff 3f 	addl	$1073741823, %edx
c01025f5:	c1 e2 02 	shll	$2, %edx
c01025f8:	01 c2 	addl	%eax, %edx
c01025fa:	8b 45 08 	movl	8(%ebp), %eax
c01025fd:	89 02 	movl	%eax, (%edx)
; load_address_space(old_cr3);
c01025ff:	8b 45 dc 	movl	-36(%ebp), %eax
c0102602:	83 ec 0c 	subl	$12, %esp
c0102605:	50 	pushl	%eax
c0102606:	e8 38 f6 ff ff 	calll	-2504 <load_address_space>
c010260b:	83 c4 10 	addl	$16, %esp
; task->next=NULL;
c010260e:	8b 45 ec 	movl	-20(%ebp), %eax
c0102611:	c7 40 19 00 00 00 00 	movl	$0, 25(%eax)
; task->pid=next_pid;
c0102618:	8b 15 70 90 10 c0 	movl	-1072656272, %edx
c010261e:	8b 45 ec 	movl	-20(%ebp), %eax
c0102621:	89 50 15 	movl	%edx, 21(%eax)
; task->priv=0;
c0102624:	8b 45 ec 	movl	-20(%ebp), %eax
c0102627:	c6 40 10 00 	movb	$0, 16(%eax)
; task->errno=0;
c010262b:	8b 45 ec 	movl	-20(%ebp), %eax
c010262e:	c7 40 11 00 00 00 00 	movl	$0, 17(%eax)
; if (currentTask) {
c0102635:	a1 6c 90 10 c0 	movl	3222311020, %eax
c010263a:	85 c0 	testl	%eax, %eax
c010263c:	74 0e 	je	14 <tasking_createTaskCr3KmodeParam+0x298>
; task->priv=currentTask->priv;
c010263e:	a1 6c 90 10 c0 	movl	3222311020, %eax
c0102643:	8a 50 10 	movb	16(%eax), %dl
c0102646:	8b 45 ec 	movl	-20(%ebp), %eax
c0102649:	88 50 10 	movb	%dl, 16(%eax)
; if (task->pid==1) {
c010264c:	8b 45 ec 	movl	-20(%ebp), %eax
c010264f:	8b 40 15 	movl	21(%eax), %eax
c0102652:	83 f8 01 	cmpl	$1, %eax
c0102655:	75 07 	jne	7 <tasking_createTaskCr3KmodeParam+0x2aa>
; task->priv=1;
c0102657:	8b 45 ec 	movl	-20(%ebp), %eax
c010265a:	c6 40 10 01 	movb	$1, 16(%eax)
; next_pid++;
c010265e:	a1 70 90 10 c0 	movl	3222311024, %eax
c0102663:	40 	incl	%eax
c0102664:	a3 70 90 10 c0 	movl	%eax, 3222311024
; if (next_pid>1024*32) {
c0102669:	a1 70 90 10 c0 	movl	3222311024, %eax
c010266e:	3d 00 80 00 00 	cmpl	$32768, %eax
c0102673:	76 05 	jbe	5 <tasking_createTaskCr3KmodeParam+0x2c6>
; halt(); //Cannot ever create more than 32k tasks, as I don't currently reuse PIDs.
c0102675:	e8 26 e2 ff ff 	calll	-7642 <halt>
; if (tailTask) {
c010267a:	a1 04 60 35 c0 	movl	3224723460, %eax
c010267f:	85 c0 	testl	%eax, %eax
c0102681:	74 13 	je	19 <tasking_createTaskCr3KmodeParam+0x2e2>
; tailTask->next=task;
c0102683:	a1 04 60 35 c0 	movl	3224723460, %eax
c0102688:	8b 55 ec 	movl	-20(%ebp), %edx
c010268b:	89 50 19 	movl	%edx, 25(%eax)
; tailTask=task;
c010268e:	8b 45 ec 	movl	-20(%ebp), %eax
c0102691:	a3 04 60 35 c0 	movl	%eax, 3224723460
; return task;
c0102696:	8b 45 ec 	movl	-20(%ebp), %eax
; }
c0102699:	c9 	leave
c010269a:	c3 	retl

tasking_get_errno_address:
; int* tasking_get_errno_address() {
c010269b:	55 	pushl	%ebp
c010269c:	89 e5 	movl	%esp, %ebp
; return &(currentTask->errno);
c010269e:	a1 6c 90 10 c0 	movl	3222311020, %eax
c01026a3:	83 c0 11 	addl	$17, %eax
; }
c01026a6:	5d 	popl	%ebp
c01026a7:	c3 	retl

isPrivleged:
; char isPrivleged(uint32_t pid) {
c01026a8:	55 	pushl	%ebp
c01026a9:	89 e5 	movl	%esp, %ebp
c01026ab:	83 ec 10 	subl	$16, %esp
; for (Task* task=headTask;task!=NULL;task=task->next) {
c01026ae:	a1 00 60 35 c0 	movl	3224723456, %eax
c01026b3:	89 45 fc 	movl	%eax, -4(%ebp)
c01026b6:	eb 1c 	jmp	28 <isPrivleged+0x2c>
; if (task->pid==pid) {
c01026b8:	8b 45 fc 	movl	-4(%ebp), %eax
c01026bb:	8b 40 15 	movl	21(%eax), %eax
c01026be:	39 45 08 	cmpl	%eax, 8(%ebp)
c01026c1:	75 08 	jne	8 <isPrivleged+0x23>
; return task->priv;
c01026c3:	8b 45 fc 	movl	-4(%ebp), %eax
c01026c6:	8a 40 10 	movb	16(%eax), %al
c01026c9:	eb 11 	jmp	17 <isPrivleged+0x34>
; for (Task* task=headTask;task!=NULL;task=task->next) {
c01026cb:	8b 45 fc 	movl	-4(%ebp), %eax
c01026ce:	8b 40 19 	movl	25(%eax), %eax
c01026d1:	89 45 fc 	movl	%eax, -4(%ebp)
c01026d4:	83 7d fc 00 	cmpl	$0, -4(%ebp)
c01026d8:	75 de 	jne	-34 <isPrivleged+0x10>
; return 0;
c01026da:	b0 00 	movb	$0, %al
; }
c01026dc:	c9 	leave
c01026dd:	c3 	retl

tasking_createTask:
; Task* tasking_createTask(void* eip) {
c01026de:	55 	pushl	%ebp
c01026df:	89 e5 	movl	%esp, %ebp
c01026e1:	83 ec 08 	subl	$8, %esp
; return tasking_createTaskCr3KmodeParam(eip,paging_new_address_space(),0,0,0,0,0);
c01026e4:	e8 d3 f4 ff ff 	calll	-2861 <paging_new_address_space>
c01026e9:	83 ec 04 	subl	$4, %esp
c01026ec:	6a 00 	pushl	$0
c01026ee:	6a 00 	pushl	$0
c01026f0:	6a 00 	pushl	$0
c01026f2:	6a 00 	pushl	$0
c01026f4:	6a 00 	pushl	$0
c01026f6:	50 	pushl	%eax
c01026f7:	ff 75 08 	pushl	8(%ebp)
c01026fa:	e8 b5 fc ff ff 	calll	-843 <tasking_createTaskCr3KmodeParam>
c01026ff:	83 c4 20 	addl	$32, %esp
; }
c0102702:	c9 	leave
c0102703:	c3 	retl

tasking_yield:
; void tasking_yield(registers_t registers) {
c0102704:	55 	pushl	%ebp
c0102705:	89 e5 	movl	%esp, %ebp
c0102707:	83 ec 18 	subl	$24, %esp
; Task* task=currentTask->next;
c010270a:	a1 6c 90 10 c0 	movl	3222311020, %eax
c010270f:	8b 40 19 	movl	25(%eax), %eax
c0102712:	89 45 f4 	movl	%eax, -12(%ebp)
; if (!task) {
c0102715:	83 7d f4 00 	cmpl	$0, -12(%ebp)
c0102719:	75 08 	jne	8 <tasking_yield+0x1f>
; task=headTask;
c010271b:	a1 00 60 35 c0 	movl	3224723456, %eax
c0102720:	89 45 f4 	movl	%eax, -12(%ebp)
; load_smap(task->cr3);
c0102723:	8b 45 f4 	movl	-12(%ebp), %eax
c0102726:	8b 40 08 	movl	8(%eax), %eax
c0102729:	83 ec 0c 	subl	$12, %esp
c010272c:	50 	pushl	%eax
c010272d:	e8 37 f5 ff ff 	calll	-2761 <load_smap>
c0102732:	83 c4 10 	addl	$16, %esp
; switch_to_task(task);
c0102735:	83 ec 0c 	subl	$12, %esp
c0102738:	ff 75 f4 	pushl	-12(%ebp)
c010273b:	e8 70 02 00 00 	calll	624 <switch_to_task>
c0102740:	83 c4 10 	addl	$16, %esp
; }
c0102743:	90 	nop
c0102744:	c9 	leave
c0102745:	c3 	retl

getPID:
; uint32_t getPID() {
c0102746:	55 	pushl	%ebp
c0102747:	89 e5 	movl	%esp, %ebp
; return currentTask->pid;
c0102749:	a1 6c 90 10 c0 	movl	3222311020, %eax
c010274e:	8b 40 15 	movl	21(%eax), %eax
; }
c0102751:	5d 	popl	%ebp
c0102752:	c3 	retl
c0102753:	66 90 	nop
c0102755:	66 90 	nop
c0102757:	66 90 	nop
c0102759:	66 90 	nop
c010275b:	66 90 	nop
c010275d:	66 90 	nop
c010275f:	90 	nop

isr_common_stub:
c0102760:	60 	pushal
c0102761:	66 8c d8 	movw	%ds, %ax
c0102764:	50 	pushl	%eax
c0102765:	66 b8 10 00 	movw	$16, %ax
c0102769:	8e d8 	movl	%eax, %ds
c010276b:	8e c0 	movl	%eax, %es
c010276d:	8e e0 	movl	%eax, %fs
c010276f:	8e e8 	movl	%eax, %gs
c0102771:	e8 f3 e5 ff ff 	calll	-6669 <isr_handler>
c0102776:	58 	popl	%eax
c0102777:	8e d8 	movl	%eax, %ds
c0102779:	8e c0 	movl	%eax, %es
c010277b:	8e e0 	movl	%eax, %fs
c010277d:	8e e8 	movl	%eax, %gs
c010277f:	61 	popal
c0102780:	83 c4 08 	addl	$8, %esp
c0102783:	cf 	iretl

irq_common_stub:
c0102784:	60 	pushal
c0102785:	66 8c d8 	movw	%ds, %ax
c0102788:	50 	pushl	%eax
c0102789:	66 b8 10 00 	movw	$16, %ax
c010278d:	8e d8 	movl	%eax, %ds
c010278f:	8e c0 	movl	%eax, %es
c0102791:	8e e0 	movl	%eax, %fs
c0102793:	8e e8 	movl	%eax, %gs
c0102795:	e8 fe e9 ff ff 	calll	-5634 <irq_handler>
c010279a:	5b 	popl	%ebx
c010279b:	8e db 	movl	%ebx, %ds
c010279d:	8e c3 	movl	%ebx, %es
c010279f:	8e e3 	movl	%ebx, %fs
c01027a1:	8e eb 	movl	%ebx, %gs
c01027a3:	61 	popal
c01027a4:	83 c4 08 	addl	$8, %esp
c01027a7:	fb 	sti
c01027a8:	cf 	iretl

isr0:
c01027a9:	fa 	cli
c01027aa:	6a 00 	pushl	$0
c01027ac:	6a 00 	pushl	$0
c01027ae:	eb b0 	jmp	-80 <isr_common_stub>

isr1:
c01027b0:	fa 	cli
c01027b1:	6a 00 	pushl	$0
c01027b3:	6a 01 	pushl	$1
c01027b5:	eb a9 	jmp	-87 <isr_common_stub>

isr2:
c01027b7:	fa 	cli
c01027b8:	6a 00 	pushl	$0
c01027ba:	6a 02 	pushl	$2
c01027bc:	eb a2 	jmp	-94 <isr_common_stub>

isr3:
c01027be:	fa 	cli
c01027bf:	6a 00 	pushl	$0
c01027c1:	6a 03 	pushl	$3
c01027c3:	eb 9b 	jmp	-101 <isr_common_stub>

isr4:
c01027c5:	fa 	cli
c01027c6:	6a 00 	pushl	$0
c01027c8:	6a 04 	pushl	$4
c01027ca:	eb 94 	jmp	-108 <isr_common_stub>

isr5:
c01027cc:	fa 	cli
c01027cd:	6a 00 	pushl	$0
c01027cf:	6a 05 	pushl	$5
c01027d1:	eb 8d 	jmp	-115 <isr_common_stub>

isr6:
c01027d3:	fa 	cli
c01027d4:	6a 00 	pushl	$0
c01027d6:	6a 06 	pushl	$6
c01027d8:	eb 86 	jmp	-122 <isr_common_stub>

isr7:
c01027da:	fa 	cli
c01027db:	6a 00 	pushl	$0
c01027dd:	6a 07 	pushl	$7
c01027df:	e9 7c ff ff ff 	jmp	-132 <isr_common_stub>

isr8:
c01027e4:	fa 	cli
c01027e5:	6a 08 	pushl	$8
c01027e7:	e9 74 ff ff ff 	jmp	-140 <isr_common_stub>

isr9:
c01027ec:	fa 	cli
c01027ed:	6a 00 	pushl	$0
c01027ef:	6a 09 	pushl	$9
c01027f1:	e9 6a ff ff ff 	jmp	-150 <isr_common_stub>

isr10:
c01027f6:	fa 	cli
c01027f7:	6a 0a 	pushl	$10
c01027f9:	e9 62 ff ff ff 	jmp	-158 <isr_common_stub>

isr11:
c01027fe:	fa 	cli
c01027ff:	6a 0b 	pushl	$11
c0102801:	e9 5a ff ff ff 	jmp	-166 <isr_common_stub>

isr12:
c0102806:	fa 	cli
c0102807:	6a 0c 	pushl	$12
c0102809:	e9 52 ff ff ff 	jmp	-174 <isr_common_stub>

isr13:
c010280e:	fa 	cli
c010280f:	6a 0d 	pushl	$13
c0102811:	e9 4a ff ff ff 	jmp	-182 <isr_common_stub>

isr14:
c0102816:	fa 	cli
c0102817:	6a 0e 	pushl	$14
c0102819:	e9 42 ff ff ff 	jmp	-190 <isr_common_stub>

isr15:
c010281e:	fa 	cli
c010281f:	6a 00 	pushl	$0
c0102821:	6a 0f 	pushl	$15
c0102823:	e9 38 ff ff ff 	jmp	-200 <isr_common_stub>

isr16:
c0102828:	fa 	cli
c0102829:	6a 00 	pushl	$0
c010282b:	6a 10 	pushl	$16
c010282d:	e9 2e ff ff ff 	jmp	-210 <isr_common_stub>

isr17:
c0102832:	fa 	cli
c0102833:	6a 00 	pushl	$0
c0102835:	6a 11 	pushl	$17
c0102837:	e9 24 ff ff ff 	jmp	-220 <isr_common_stub>

isr18:
c010283c:	fa 	cli
c010283d:	6a 00 	pushl	$0
c010283f:	6a 12 	pushl	$18
c0102841:	e9 1a ff ff ff 	jmp	-230 <isr_common_stub>

isr19:
c0102846:	fa 	cli
c0102847:	6a 00 	pushl	$0
c0102849:	6a 13 	pushl	$19
c010284b:	e9 10 ff ff ff 	jmp	-240 <isr_common_stub>

isr20:
c0102850:	fa 	cli
c0102851:	6a 00 	pushl	$0
c0102853:	6a 14 	pushl	$20
c0102855:	e9 06 ff ff ff 	jmp	-250 <isr_common_stub>

isr21:
c010285a:	fa 	cli
c010285b:	6a 00 	pushl	$0
c010285d:	6a 15 	pushl	$21
c010285f:	e9 fc fe ff ff 	jmp	-260 <isr_common_stub>

isr22:
c0102864:	fa 	cli
c0102865:	6a 00 	pushl	$0
c0102867:	6a 16 	pushl	$22
c0102869:	e9 f2 fe ff ff 	jmp	-270 <isr_common_stub>

isr23:
c010286e:	fa 	cli
c010286f:	6a 00 	pushl	$0
c0102871:	6a 17 	pushl	$23
c0102873:	e9 e8 fe ff ff 	jmp	-280 <isr_common_stub>

isr24:
c0102878:	fa 	cli
c0102879:	6a 00 	pushl	$0
c010287b:	6a 18 	pushl	$24
c010287d:	e9 de fe ff ff 	jmp	-290 <isr_common_stub>

isr25:
c0102882:	fa 	cli
c0102883:	6a 00 	pushl	$0
c0102885:	6a 19 	pushl	$25
c0102887:	e9 d4 fe ff ff 	jmp	-300 <isr_common_stub>

isr26:
c010288c:	fa 	cli
c010288d:	6a 00 	pushl	$0
c010288f:	6a 1a 	pushl	$26
c0102891:	e9 ca fe ff ff 	jmp	-310 <isr_common_stub>

isr27:
c0102896:	fa 	cli
c0102897:	6a 00 	pushl	$0
c0102899:	6a 1b 	pushl	$27
c010289b:	e9 c0 fe ff ff 	jmp	-320 <isr_common_stub>

isr28:
c01028a0:	fa 	cli
c01028a1:	6a 00 	pushl	$0
c01028a3:	6a 1c 	pushl	$28
c01028a5:	e9 b6 fe ff ff 	jmp	-330 <isr_common_stub>

isr29:
c01028aa:	fa 	cli
c01028ab:	6a 00 	pushl	$0
c01028ad:	6a 1d 	pushl	$29
c01028af:	e9 ac fe ff ff 	jmp	-340 <isr_common_stub>

isr30:
c01028b4:	fa 	cli
c01028b5:	6a 00 	pushl	$0
c01028b7:	6a 1e 	pushl	$30
c01028b9:	e9 a2 fe ff ff 	jmp	-350 <isr_common_stub>

isr31:
c01028be:	fa 	cli
c01028bf:	6a 00 	pushl	$0
c01028c1:	6a 1f 	pushl	$31
c01028c3:	e9 98 fe ff ff 	jmp	-360 <isr_common_stub>

isr80:
c01028c8:	fa 	cli
c01028c9:	6a 00 	pushl	$0
c01028cb:	6a 50 	pushl	$80
c01028cd:	e9 8e fe ff ff 	jmp	-370 <isr_common_stub>

irq0:
c01028d2:	fa 	cli
c01028d3:	6a 00 	pushl	$0
c01028d5:	6a 20 	pushl	$32
c01028d7:	e9 a8 fe ff ff 	jmp	-344 <irq_common_stub>

irq1:
c01028dc:	fa 	cli
c01028dd:	6a 01 	pushl	$1
c01028df:	6a 21 	pushl	$33
c01028e1:	e9 9e fe ff ff 	jmp	-354 <irq_common_stub>

irq2:
c01028e6:	fa 	cli
c01028e7:	6a 02 	pushl	$2
c01028e9:	6a 22 	pushl	$34
c01028eb:	e9 94 fe ff ff 	jmp	-364 <irq_common_stub>

irq3:
c01028f0:	fa 	cli
c01028f1:	6a 03 	pushl	$3
c01028f3:	6a 23 	pushl	$35
c01028f5:	e9 8a fe ff ff 	jmp	-374 <irq_common_stub>

irq4:
c01028fa:	fa 	cli
c01028fb:	6a 04 	pushl	$4
c01028fd:	6a 24 	pushl	$36
c01028ff:	e9 80 fe ff ff 	jmp	-384 <irq_common_stub>

irq5:
c0102904:	fa 	cli
c0102905:	6a 05 	pushl	$5
c0102907:	6a 25 	pushl	$37
c0102909:	e9 76 fe ff ff 	jmp	-394 <irq_common_stub>

irq6:
c010290e:	fa 	cli
c010290f:	6a 06 	pushl	$6
c0102911:	6a 26 	pushl	$38
c0102913:	e9 6c fe ff ff 	jmp	-404 <irq_common_stub>

irq7:
c0102918:	fa 	cli
c0102919:	6a 07 	pushl	$7
c010291b:	6a 27 	pushl	$39
c010291d:	e9 62 fe ff ff 	jmp	-414 <irq_common_stub>

irq8:
c0102922:	fa 	cli
c0102923:	6a 08 	pushl	$8
c0102925:	6a 28 	pushl	$40
c0102927:	e9 58 fe ff ff 	jmp	-424 <irq_common_stub>

irq9:
c010292c:	fa 	cli
c010292d:	6a 09 	pushl	$9
c010292f:	6a 29 	pushl	$41
c0102931:	e9 4e fe ff ff 	jmp	-434 <irq_common_stub>

irq10:
c0102936:	fa 	cli
c0102937:	6a 0a 	pushl	$10
c0102939:	6a 2a 	pushl	$42
c010293b:	e9 44 fe ff ff 	jmp	-444 <irq_common_stub>

irq11:
c0102940:	fa 	cli
c0102941:	6a 0b 	pushl	$11
c0102943:	6a 2b 	pushl	$43
c0102945:	e9 3a fe ff ff 	jmp	-454 <irq_common_stub>

irq12:
c010294a:	fa 	cli
c010294b:	6a 0c 	pushl	$12
c010294d:	6a 2c 	pushl	$44
c010294f:	e9 30 fe ff ff 	jmp	-464 <irq_common_stub>

irq13:
c0102954:	fa 	cli
c0102955:	6a 0d 	pushl	$13
c0102957:	6a 2d 	pushl	$45
c0102959:	e9 26 fe ff ff 	jmp	-474 <irq_common_stub>

irq14:
c010295e:	fa 	cli
c010295f:	6a 0e 	pushl	$14
c0102961:	6a 2e 	pushl	$46
c0102963:	e9 1c fe ff ff 	jmp	-484 <irq_common_stub>

irq15:
c0102968:	fa 	cli
c0102969:	6a 0f 	pushl	$15
c010296b:	6a 2f 	pushl	$47
c010296d:	e9 12 fe ff ff 	jmp	-494 <irq_common_stub>
c0102972:	66 90 	nop
c0102974:	66 90 	nop
c0102976:	66 90 	nop
c0102978:	66 90 	nop
c010297a:	66 90 	nop
c010297c:	66 90 	nop
c010297e:	66 90 	nop

load_page_directory:
c0102980:	55 	pushl	%ebp
c0102981:	89 e5 	movl	%esp, %ebp
c0102983:	8b 44 24 08 	movl	8(%esp), %eax
c0102987:	0f 22 d8 	movl	%eax, %cr3
c010298a:	89 ec 	movl	%ebp, %esp
c010298c:	5d 	popl	%ebp
c010298d:	c3 	retl
c010298e:	66 90 	nop

seg_upd:
c0102990:	ea 97 29 10 c0 08 00 	ljmpl	$8, $3222284695

code_upd:
c0102997:	66 b8 10 00 	movw	$16, %ax
c010299b:	8e d8 	movl	%eax, %ds
c010299d:	8e d0 	movl	%eax, %ss
c010299f:	8e c0 	movl	%eax, %es
c01029a1:	8e e0 	movl	%eax, %fs
c01029a3:	8e e8 	movl	%eax, %gs
c01029a5:	c3 	retl
c01029a6:	66 90 	nop
c01029a8:	66 90 	nop
c01029aa:	66 90 	nop
c01029ac:	66 90 	nop
c01029ae:	66 90 	nop

switch_to_task:
c01029b0:	53 	pushl	%ebx
c01029b1:	56 	pushl	%esi
c01029b2:	57 	pushl	%edi
c01029b3:	55 	pushl	%ebp
c01029b4:	8b 3d 6c 90 10 c0 	movl	-1072656276, %edi
c01029ba:	89 27 	movl	%esp, (%edi)
c01029bc:	8b 74 24 14 	movl	20(%esp), %esi
c01029c0:	89 35 6c 90 10 c0 	movl	%esi, -1072656276
c01029c6:	8b 26 	movl	(%esi), %esp
c01029c8:	8b 46 08 	movl	8(%esi), %eax
c01029cb:	8b 5e 04 	movl	4(%esi), %ebx
c01029ce:	89 1d 04 70 10 c0 	movl	%ebx, -1072664572
c01029d4:	0f 20 d9 	movl	%cr3, %ecx
c01029d7:	39 c8 	cmpl	%ecx, %eax
c01029d9:	74 03 	je	3 <switch_to_task.doneVAS>
c01029db:	0f 22 d8 	movl	%eax, %cr3

switch_to_task.doneVAS:
c01029de:	5d 	popl	%ebp
c01029df:	5f 	popl	%edi
c01029e0:	5e 	popl	%esi
c01029e1:	5b 	popl	%ebx
c01029e2:	c3 	retl

task_init:
c01029e3:	59 	popl	%ecx
c01029e4:	5b 	popl	%ebx
c01029e5:	fa 	cli
c01029e6:	66 b8 23 00 	movw	$35, %ax
c01029ea:	8e d8 	movl	%eax, %ds
c01029ec:	8e c0 	movl	%eax, %es
c01029ee:	8e e0 	movl	%eax, %fs
c01029f0:	8e e8 	movl	%eax, %gs
c01029f2:	89 c8 	movl	%ecx, %eax
c01029f4:	6a 23 	pushl	$35
c01029f6:	50 	pushl	%eax
c01029f7:	9c 	pushfl
c01029f8:	58 	popl	%eax
c01029f9:	0d 00 02 00 00 	orl	$512, %eax
c01029fe:	50 	pushl	%eax
c01029ff:	6a 1b 	pushl	$27
c0102a01:	53 	pushl	%ebx
c0102a02:	cf 	iretl

ceilf:
; float ceilf(float num) {
c0102a03:	55 	pushl	%ebp
c0102a04:	89 e5 	movl	%esp, %ebp
c0102a06:	83 ec 18 	subl	$24, %esp
; int inum=(int)num;
c0102a09:	d9 45 08 	flds	8(%ebp)
c0102a0c:	d9 7d ee 	fnstcw	-18(%ebp)
c0102a0f:	66 8b 45 ee 	movw	-18(%ebp), %ax
c0102a13:	80 cc 0c 	orb	$12, %ah
c0102a16:	66 89 45 ec 	movw	%ax, -20(%ebp)
c0102a1a:	d9 6d ec 	fldcw	-20(%ebp)
c0102a1d:	db 5d fc 	fistpl	-4(%ebp)
c0102a20:	d9 6d ee 	fldcw	-18(%ebp)
; if (num==(float)inum) {
c0102a23:	db 45 fc 	fildl	-4(%ebp)
c0102a26:	d9 45 08 	flds	8(%ebp)
c0102a29:	da e9 	fucompp
c0102a2b:	df e0 	fnstsw	%ax
c0102a2d:	80 e4 45 	andb	$69, %ah
c0102a30:	80 f4 40 	xorb	$64, %ah
c0102a33:	75 05 	jne	5 <ceilf+0x37>
; return (float)inum;
c0102a35:	db 45 fc 	fildl	-4(%ebp)
c0102a38:	eb 0a 	jmp	10 <ceilf+0x41>
; return (float)(inum+1);
c0102a3a:	8b 45 fc 	movl	-4(%ebp), %eax
c0102a3d:	40 	incl	%eax
c0102a3e:	89 45 e8 	movl	%eax, -24(%ebp)
c0102a41:	db 45 e8 	fildl	-24(%ebp)
; }
c0102a44:	c9 	leave
c0102a45:	c3 	retl

ceil:
; double ceil(double num) {
c0102a46:	55 	pushl	%ebp
c0102a47:	89 e5 	movl	%esp, %ebp
c0102a49:	83 ec 20 	subl	$32, %esp
c0102a4c:	8b 45 08 	movl	8(%ebp), %eax
c0102a4f:	89 45 e8 	movl	%eax, -24(%ebp)
c0102a52:	8b 45 0c 	movl	12(%ebp), %eax
c0102a55:	89 45 ec 	movl	%eax, -20(%ebp)
; int inum=(int)num;
c0102a58:	dd 45 e8 	fldl	-24(%ebp)
c0102a5b:	d9 7d e6 	fnstcw	-26(%ebp)
c0102a5e:	66 8b 45 e6 	movw	-26(%ebp), %ax
c0102a62:	80 cc 0c 	orb	$12, %ah
c0102a65:	66 89 45 e4 	movw	%ax, -28(%ebp)
c0102a69:	d9 6d e4 	fldcw	-28(%ebp)
c0102a6c:	db 5d fc 	fistpl	-4(%ebp)
c0102a6f:	d9 6d e6 	fldcw	-26(%ebp)
; if (num==(double)inum) {
c0102a72:	db 45 fc 	fildl	-4(%ebp)
c0102a75:	dd 45 e8 	fldl	-24(%ebp)
c0102a78:	da e9 	fucompp
c0102a7a:	df e0 	fnstsw	%ax
c0102a7c:	80 e4 45 	andb	$69, %ah
c0102a7f:	80 f4 40 	xorb	$64, %ah
c0102a82:	75 05 	jne	5 <ceil+0x43>
; return (double)inum;
c0102a84:	db 45 fc 	fildl	-4(%ebp)
c0102a87:	eb 0a 	jmp	10 <ceil+0x4d>
; return (double)(inum+1);
c0102a89:	8b 45 fc 	movl	-4(%ebp), %eax
c0102a8c:	40 	incl	%eax
c0102a8d:	89 45 e0 	movl	%eax, -32(%ebp)
c0102a90:	db 45 e0 	fildl	-32(%ebp)
; }
c0102a93:	c9 	leave
c0102a94:	c3 	retl

alloc_memory:
; void* alloc_memory(uint32_t num_pages) {
c0102a95:	55 	pushl	%ebp
c0102a96:	89 e5 	movl	%esp, %ebp
c0102a98:	53 	pushl	%ebx
c0102a99:	83 ec 10 	subl	$16, %esp
; asm volatile("  \
c0102a9c:	8b 45 08 	movl	8(%ebp), %eax
c0102a9f:	89 c3 	movl	%eax, %ebx
c0102aa1:	b8 03 00 00 00 	movl	$3, %eax
c0102aa6:	cd 50 	int	$80
c0102aa8:	89 d8 	movl	%ebx, %eax
c0102aaa:	89 45 f8 	movl	%eax, -8(%ebp)
; return address;
c0102aad:	8b 45 f8 	movl	-8(%ebp), %eax
; }
c0102ab0:	83 c4 10 	addl	$16, %esp
c0102ab3:	5b 	popl	%ebx
c0102ab4:	5d 	popl	%ebp
c0102ab5:	c3 	retl

alloc_memory_virt:
; void alloc_memory_virt(uint32_t num_pages,void* addr) {
c0102ab6:	55 	pushl	%ebp
c0102ab7:	89 e5 	movl	%esp, %ebp
c0102ab9:	53 	pushl	%ebx
; asm volatile("  \
c0102aba:	8b 45 08 	movl	8(%ebp), %eax
c0102abd:	8b 55 0c 	movl	12(%ebp), %edx
c0102ac0:	89 c3 	movl	%eax, %ebx
c0102ac2:	89 d1 	movl	%edx, %ecx
c0102ac4:	b8 04 00 00 00 	movl	$4, %eax
c0102ac9:	cd 50 	int	$80
; }
c0102acb:	90 	nop
c0102acc:	5b 	popl	%ebx
c0102acd:	5d 	popl	%ebp
c0102ace:	c3 	retl

new_address_space:
; void* new_address_space() {
c0102acf:	55 	pushl	%ebp
c0102ad0:	89 e5 	movl	%esp, %ebp
c0102ad2:	53 	pushl	%ebx
c0102ad3:	83 ec 10 	subl	$16, %esp
; asm volatile("  \
c0102ad6:	b8 08 00 00 00 	movl	$8, %eax
c0102adb:	cd 50 	int	$80
c0102add:	89 d8 	movl	%ebx, %eax
c0102adf:	89 45 f8 	movl	%eax, -8(%ebp)
; return cr3;
c0102ae2:	8b 45 f8 	movl	-8(%ebp), %eax
; }
c0102ae5:	83 c4 10 	addl	$16, %esp
c0102ae8:	5b 	popl	%ebx
c0102ae9:	5d 	popl	%ebp
c0102aea:	c3 	retl

copy_data:
; void copy_data(void* cr3, void* data,uint32_t size,void* virt_addr) {
c0102aeb:	55 	pushl	%ebp
c0102aec:	89 e5 	movl	%esp, %ebp
c0102aee:	56 	pushl	%esi
c0102aef:	53 	pushl	%ebx
; asm volatile("  \
c0102af0:	8b 45 08 	movl	8(%ebp), %eax
c0102af3:	8b 4d 0c 	movl	12(%ebp), %ecx
c0102af6:	8b 55 10 	movl	16(%ebp), %edx
c0102af9:	8b 75 14 	movl	20(%ebp), %esi
c0102afc:	89 c3 	movl	%eax, %ebx
c0102afe:	b8 0a 00 00 00 	movl	$10, %eax
c0102b03:	cd 50 	int	$80
; }
c0102b05:	90 	nop
c0102b06:	5b 	popl	%ebx
c0102b07:	5e 	popl	%esi
c0102b08:	5d 	popl	%ebp
c0102b09:	c3 	retl

put_data:
; void* put_data(void* cr3, void* data,uint32_t size) {
c0102b0a:	55 	pushl	%ebp
c0102b0b:	89 e5 	movl	%esp, %ebp
c0102b0d:	53 	pushl	%ebx
c0102b0e:	83 ec 10 	subl	$16, %esp
; asm volatile("  \
c0102b11:	8b 45 08 	movl	8(%ebp), %eax
c0102b14:	8b 4d 0c 	movl	12(%ebp), %ecx
c0102b17:	8b 55 10 	movl	16(%ebp), %edx
c0102b1a:	89 c3 	movl	%eax, %ebx
c0102b1c:	b8 0d 00 00 00 	movl	$13, %eax
c0102b21:	cd 50 	int	$80
c0102b23:	89 d8 	movl	%ebx, %eax
c0102b25:	89 45 f8 	movl	%eax, -8(%ebp)
; return virt_addr;
c0102b28:	8b 45 f8 	movl	-8(%ebp), %eax
; }
c0102b2b:	83 c4 10 	addl	$16, %esp
c0102b2e:	5b 	popl	%ebx
c0102b2f:	5d 	popl	%ebp
c0102b30:	c3 	retl

map_phys:
; void* map_phys(void* phys_addr,uint32_t num_pages) {
c0102b31:	55 	pushl	%ebp
c0102b32:	89 e5 	movl	%esp, %ebp
c0102b34:	53 	pushl	%ebx
c0102b35:	83 ec 10 	subl	$16, %esp
; asm volatile("  \
c0102b38:	8b 45 08 	movl	8(%ebp), %eax
c0102b3b:	8b 55 0c 	movl	12(%ebp), %edx
c0102b3e:	89 c3 	movl	%eax, %ebx
c0102b40:	89 d1 	movl	%edx, %ecx
c0102b42:	b8 0b 00 00 00 	movl	$11, %eax
c0102b47:	cd 50 	int	$80
c0102b49:	89 d8 	movl	%ebx, %eax
c0102b4b:	89 45 f8 	movl	%eax, -8(%ebp)
; return virt_addr;
c0102b4e:	8b 45 f8 	movl	-8(%ebp), %eax
; }
c0102b51:	83 c4 10 	addl	$16, %esp
c0102b54:	5b 	popl	%ebx
c0102b55:	5d 	popl	%ebp
c0102b56:	c3 	retl

get_bmap_bit:
; static char get_bmap_bit(char* bmap,uint32_t index) {
c0102b57:	55 	pushl	%ebp
c0102b58:	89 e5 	movl	%esp, %ebp
c0102b5a:	53 	pushl	%ebx
c0102b5b:	83 ec 10 	subl	$16, %esp
; uint32_t byte=index/8;
c0102b5e:	8b 45 0c 	movl	12(%ebp), %eax
c0102b61:	c1 e8 03 	shrl	$3, %eax
c0102b64:	89 45 f8 	movl	%eax, -8(%ebp)
; uint32_t bit=index%8;
c0102b67:	8b 45 0c 	movl	12(%ebp), %eax
c0102b6a:	83 e0 07 	andl	$7, %eax
c0102b6d:	89 45 f4 	movl	%eax, -12(%ebp)
; char entry=bmap[byte];
c0102b70:	8b 55 08 	movl	8(%ebp), %edx
c0102b73:	8b 45 f8 	movl	-8(%ebp), %eax
c0102b76:	01 d0 	addl	%edx, %eax
c0102b78:	8a 00 	movb	(%eax), %al
c0102b7a:	88 45 f3 	movb	%al, -13(%ebp)
; return (entry&(1<<bit))>0;
c0102b7d:	0f be 55 f3 	movsbl	-13(%ebp), %edx
c0102b81:	8b 45 f4 	movl	-12(%ebp), %eax
c0102b84:	bb 01 00 00 00 	movl	$1, %ebx
c0102b89:	88 c1 	movb	%al, %cl
c0102b8b:	d3 e3 	shll	%cl, %ebx
c0102b8d:	89 d8 	movl	%ebx, %eax
c0102b8f:	21 d0 	andl	%edx, %eax
c0102b91:	85 c0 	testl	%eax, %eax
c0102b93:	0f 9f c0 	setg	%al
; }
c0102b96:	83 c4 10 	addl	$16, %esp
c0102b99:	5b 	popl	%ebx
c0102b9a:	5d 	popl	%ebp
c0102b9b:	c3 	retl

set_bmap_bit:
; static void set_bmap_bit(char* bmap,uint32_t index) {
c0102b9c:	55 	pushl	%ebp
c0102b9d:	89 e5 	movl	%esp, %ebp
c0102b9f:	53 	pushl	%ebx
c0102ba0:	83 ec 10 	subl	$16, %esp
; uint32_t byte=index/8;
c0102ba3:	8b 45 0c 	movl	12(%ebp), %eax
c0102ba6:	c1 e8 03 	shrl	$3, %eax
c0102ba9:	89 45 f8 	movl	%eax, -8(%ebp)
; uint32_t bit=index%8;
c0102bac:	8b 45 0c 	movl	12(%ebp), %eax
c0102baf:	83 e0 07 	andl	$7, %eax
c0102bb2:	89 45 f4 	movl	%eax, -12(%ebp)
; bmap[byte]=bmap[byte]|(1<<bit);
c0102bb5:	8b 55 08 	movl	8(%ebp), %edx
c0102bb8:	8b 45 f8 	movl	-8(%ebp), %eax
c0102bbb:	01 d0 	addl	%edx, %eax
c0102bbd:	8a 10 	movb	(%eax), %dl
c0102bbf:	8b 45 f4 	movl	-12(%ebp), %eax
c0102bc2:	bb 01 00 00 00 	movl	$1, %ebx
c0102bc7:	88 c1 	movb	%al, %cl
c0102bc9:	d3 e3 	shll	%cl, %ebx
c0102bcb:	89 d8 	movl	%ebx, %eax
c0102bcd:	88 c3 	movb	%al, %bl
c0102bcf:	8b 4d 08 	movl	8(%ebp), %ecx
c0102bd2:	8b 45 f8 	movl	-8(%ebp), %eax
c0102bd5:	01 c8 	addl	%ecx, %eax
c0102bd7:	09 da 	orl	%ebx, %edx
c0102bd9:	88 10 	movb	%dl, (%eax)
; }
c0102bdb:	90 	nop
c0102bdc:	83 c4 10 	addl	$16, %esp
c0102bdf:	5b 	popl	%ebx
c0102be0:	5d 	popl	%ebp
c0102be1:	c3 	retl

clear_bmap_bit:
; static void clear_bmap_bit(char* bmap,uint32_t index) {
c0102be2:	55 	pushl	%ebp
c0102be3:	89 e5 	movl	%esp, %ebp
c0102be5:	53 	pushl	%ebx
c0102be6:	83 ec 10 	subl	$16, %esp
; uint32_t byte=index/8;
c0102be9:	8b 45 0c 	movl	12(%ebp), %eax
c0102bec:	c1 e8 03 	shrl	$3, %eax
c0102bef:	89 45 f8 	movl	%eax, -8(%ebp)
; uint32_t bit=index%8;
c0102bf2:	8b 45 0c 	movl	12(%ebp), %eax
c0102bf5:	83 e0 07 	andl	$7, %eax
c0102bf8:	89 45 f4 	movl	%eax, -12(%ebp)
; bmap[byte]=bmap[byte]&(~(1<<bit));
c0102bfb:	8b 55 08 	movl	8(%ebp), %edx
c0102bfe:	8b 45 f8 	movl	-8(%ebp), %eax
c0102c01:	01 d0 	addl	%edx, %eax
c0102c03:	8a 10 	movb	(%eax), %dl
c0102c05:	8b 45 f4 	movl	-12(%ebp), %eax
c0102c08:	bb 01 00 00 00 	movl	$1, %ebx
c0102c0d:	88 c1 	movb	%al, %cl
c0102c0f:	d3 e3 	shll	%cl, %ebx
c0102c11:	89 d8 	movl	%ebx, %eax
c0102c13:	f7 d0 	notl	%eax
c0102c15:	88 c3 	movb	%al, %bl
c0102c17:	8b 4d 08 	movl	8(%ebp), %ecx
c0102c1a:	8b 45 f8 	movl	-8(%ebp), %eax
c0102c1d:	01 c8 	addl	%ecx, %eax
c0102c1f:	21 da 	andl	%ebx, %edx
c0102c21:	88 10 	movb	%dl, (%eax)
; }
c0102c23:	90 	nop
c0102c24:	83 c4 10 	addl	$16, %esp
c0102c27:	5b 	popl	%ebx
c0102c28:	5d 	popl	%ebp
c0102c29:	c3 	retl

reserve_block:
; static void reserve_block(uint32_t mem_blks) {
c0102c2a:	55 	pushl	%ebp
c0102c2b:	89 e5 	movl	%esp, %ebp
c0102c2d:	53 	pushl	%ebx
c0102c2e:	83 ec 34 	subl	$52, %esp
; uint32_t bmap_byts=((mem_blks*BLK_SZ)/4)/8;
c0102c31:	8b 45 08 	movl	8(%ebp), %eax
c0102c34:	c1 e0 0c 	shll	$12, %eax
c0102c37:	c1 e8 05 	shrl	$5, %eax
c0102c3a:	89 45 f0 	movl	%eax, -16(%ebp)
; entries[num_used_entries].bitmap=alloc_memory((uint32_t)ceilf((double)bmap_byts/BLK_SZ));
c0102c3d:	8b 45 f0 	movl	-16(%ebp), %eax
c0102c40:	ba 00 00 00 00 	movl	$0, %edx
c0102c45:	89 45 c8 	movl	%eax, -56(%ebp)
c0102c48:	89 55 cc 	movl	%edx, -52(%ebp)
c0102c4b:	df 6d c8 	fildll	-56(%ebp)
c0102c4e:	dd 5d e0 	fstpl	-32(%ebp)
c0102c51:	dd 45 e0 	fldl	-32(%ebp)
c0102c54:	dd 05 48 44 10 c0 	fldl	-1072675768
c0102c5a:	de f9 	fdivrp	%st(1)
c0102c5c:	d9 5d dc 	fstps	-36(%ebp)
c0102c5f:	8b 45 dc 	movl	-36(%ebp), %eax
c0102c62:	83 ec 0c 	subl	$12, %esp
c0102c65:	50 	pushl	%eax
c0102c66:	e8 98 fd ff ff 	calll	-616 <ceilf>
c0102c6b:	83 c4 10 	addl	$16, %esp
c0102c6e:	d9 7d da 	fnstcw	-38(%ebp)
c0102c71:	66 8b 45 da 	movw	-38(%ebp), %ax
c0102c75:	80 cc 0c 	orb	$12, %ah
c0102c78:	66 89 45 d8 	movw	%ax, -40(%ebp)
c0102c7c:	d9 6d d8 	fldcw	-40(%ebp)
c0102c7f:	df 7d d0 	fistpll	-48(%ebp)
c0102c82:	d9 6d da 	fldcw	-38(%ebp)
c0102c85:	8b 45 d0 	movl	-48(%ebp), %eax
c0102c88:	8b 55 d4 	movl	-44(%ebp), %edx
c0102c8b:	8b 1d 20 88 35 c0 	movl	-1070233568, %ebx
c0102c91:	83 ec 0c 	subl	$12, %esp
c0102c94:	50 	pushl	%eax
c0102c95:	e8 fb fd ff ff 	calll	-517 <alloc_memory>
c0102c9a:	83 c4 10 	addl	$16, %esp
c0102c9d:	89 c2 	movl	%eax, %edx
c0102c9f:	89 d8 	movl	%ebx, %eax
c0102ca1:	c1 e0 02 	shll	$2, %eax
c0102ca4:	01 d8 	addl	%ebx, %eax
c0102ca6:	c1 e0 02 	shll	$2, %eax
c0102ca9:	05 20 60 35 c0 	addl	$3224723488, %eax
c0102cae:	89 10 	movl	%edx, (%eax)
; entries[num_used_entries].bitmap_byt_size=bmap_byts;
c0102cb0:	8b 15 20 88 35 c0 	movl	-1070233568, %edx
c0102cb6:	89 d0 	movl	%edx, %eax
c0102cb8:	c1 e0 02 	shll	$2, %eax
c0102cbb:	01 d0 	addl	%edx, %eax
c0102cbd:	c1 e0 02 	shll	$2, %eax
c0102cc0:	8d 90 24 60 35 c0 	leal	-1070243804(%eax), %edx
c0102cc6:	8b 45 f0 	movl	-16(%ebp), %eax
c0102cc9:	89 02 	movl	%eax, (%edx)
; entries[num_used_entries].bitmap_bit_size=bmap_byts*8;
c0102ccb:	8b 15 20 88 35 c0 	movl	-1070233568, %edx
c0102cd1:	8b 45 f0 	movl	-16(%ebp), %eax
c0102cd4:	8d 0c c5 00 00 00 00 	leal	(,%eax,8), %ecx
c0102cdb:	89 d0 	movl	%edx, %eax
c0102cdd:	c1 e0 02 	shll	$2, %eax
c0102ce0:	01 d0 	addl	%edx, %eax
c0102ce2:	c1 e0 02 	shll	$2, %eax
c0102ce5:	05 28 60 35 c0 	addl	$3224723496, %eax
c0102cea:	89 08 	movl	%ecx, (%eax)
; char* bmap=entries[num_used_entries].bitmap;
c0102cec:	8b 15 20 88 35 c0 	movl	-1070233568, %edx
c0102cf2:	89 d0 	movl	%edx, %eax
c0102cf4:	c1 e0 02 	shll	$2, %eax
c0102cf7:	01 d0 	addl	%edx, %eax
c0102cf9:	c1 e0 02 	shll	$2, %eax
c0102cfc:	05 20 60 35 c0 	addl	$3224723488, %eax
c0102d01:	8b 00 	movl	(%eax), %eax
c0102d03:	89 45 ec 	movl	%eax, -20(%ebp)
; uint32_t bmap_byt_sz=entries[num_used_entries].bitmap_byt_size;
c0102d06:	8b 15 20 88 35 c0 	movl	-1070233568, %edx
c0102d0c:	89 d0 	movl	%edx, %eax
c0102d0e:	c1 e0 02 	shll	$2, %eax
c0102d11:	01 d0 	addl	%edx, %eax
c0102d13:	c1 e0 02 	shll	$2, %eax
c0102d16:	05 24 60 35 c0 	addl	$3224723492, %eax
c0102d1b:	8b 00 	movl	(%eax), %eax
c0102d1d:	89 45 e8 	movl	%eax, -24(%ebp)
; for(uint32_t i=0;i<bmap_byt_sz;i++) {
c0102d20:	c7 45 f4 00 00 00 00 	movl	$0, -12(%ebp)
c0102d27:	eb 0e 	jmp	14 <reserve_block+0x10d>
; bmap[i]=0;
c0102d29:	8b 55 ec 	movl	-20(%ebp), %edx
c0102d2c:	8b 45 f4 	movl	-12(%ebp), %eax
c0102d2f:	01 d0 	addl	%edx, %eax
c0102d31:	c6 00 00 	movb	$0, (%eax)
; for(uint32_t i=0;i<bmap_byt_sz;i++) {
c0102d34:	ff 45 f4 	incl	-12(%ebp)
c0102d37:	8b 45 f4 	movl	-12(%ebp), %eax
c0102d3a:	3b 45 e8 	cmpl	-24(%ebp), %eax
c0102d3d:	72 ea 	jb	-22 <reserve_block+0xff>
; entries[num_used_entries].avail_data_size=mem_blks*BLK_SZ;
c0102d3f:	8b 15 20 88 35 c0 	movl	-1070233568, %edx
c0102d45:	8b 45 08 	movl	8(%ebp), %eax
c0102d48:	c1 e0 0c 	shll	$12, %eax
c0102d4b:	89 c1 	movl	%eax, %ecx
c0102d4d:	89 d0 	movl	%edx, %eax
c0102d4f:	c1 e0 02 	shll	$2, %eax
c0102d52:	01 d0 	addl	%edx, %eax
c0102d54:	c1 e0 02 	shll	$2, %eax
c0102d57:	05 2c 60 35 c0 	addl	$3224723500, %eax
c0102d5c:	89 08 	movl	%ecx, (%eax)
; entries[num_used_entries].data_block=alloc_memory(mem_blks);
c0102d5e:	8b 1d 20 88 35 c0 	movl	-1070233568, %ebx
c0102d64:	83 ec 0c 	subl	$12, %esp
c0102d67:	ff 75 08 	pushl	8(%ebp)
c0102d6a:	e8 26 fd ff ff 	calll	-730 <alloc_memory>
c0102d6f:	83 c4 10 	addl	$16, %esp
c0102d72:	89 c2 	movl	%eax, %edx
c0102d74:	89 d8 	movl	%ebx, %eax
c0102d76:	c1 e0 02 	shll	$2, %eax
c0102d79:	01 d8 	addl	%ebx, %eax
c0102d7b:	c1 e0 02 	shll	$2, %eax
c0102d7e:	05 30 60 35 c0 	addl	$3224723504, %eax
c0102d83:	89 10 	movl	%edx, (%eax)
; num_used_entries++;
c0102d85:	a1 20 88 35 c0 	movl	3224733728, %eax
c0102d8a:	40 	incl	%eax
c0102d8b:	a3 20 88 35 c0 	movl	%eax, 3224733728
; }
c0102d90:	90 	nop
c0102d91:	8b 5d fc 	movl	-4(%ebp), %ebx
c0102d94:	c9 	leave
c0102d95:	c3 	retl

malloc:
; void* malloc(size_t size) {
c0102d96:	55 	pushl	%ebp
c0102d97:	89 e5 	movl	%esp, %ebp
c0102d99:	57 	pushl	%edi
c0102d9a:	56 	pushl	%esi
c0102d9b:	53 	pushl	%ebx
c0102d9c:	83 ec 7c 	subl	$124, %esp
; uint32_t num_4b_grps=(uint32_t)ceilf((float)size/4);
c0102d9f:	8b 45 08 	movl	8(%ebp), %eax
c0102da2:	ba 00 00 00 00 	movl	$0, %edx
c0102da7:	89 45 80 	movl	%eax, -128(%ebp)
c0102daa:	89 55 84 	movl	%edx, -124(%ebp)
c0102dad:	df 6d 80 	fildll	-128(%ebp)
c0102db0:	d9 5d 94 	fstps	-108(%ebp)
c0102db3:	d9 45 94 	flds	-108(%ebp)
c0102db6:	d9 05 50 44 10 c0 	flds	-1072675760
c0102dbc:	de f9 	fdivrp	%st(1)
c0102dbe:	83 ec 0c 	subl	$12, %esp
c0102dc1:	8d 64 24 fc 	leal	-4(%esp), %esp
c0102dc5:	d9 1c 24 	fstps	(%esp)
c0102dc8:	e8 36 fc ff ff 	calll	-970 <ceilf>
c0102dcd:	83 c4 10 	addl	$16, %esp
c0102dd0:	d9 7d 92 	fnstcw	-110(%ebp)
c0102dd3:	66 8b 45 92 	movw	-110(%ebp), %ax
c0102dd7:	80 cc 0c 	orb	$12, %ah
c0102dda:	66 89 45 90 	movw	%ax, -112(%ebp)
c0102dde:	d9 6d 90 	fldcw	-112(%ebp)
c0102de1:	df 7d 88 	fistpll	-120(%ebp)
c0102de4:	d9 6d 92 	fldcw	-110(%ebp)
c0102de7:	8b 45 88 	movl	-120(%ebp), %eax
c0102dea:	8b 55 8c 	movl	-116(%ebp), %edx
c0102ded:	89 45 c0 	movl	%eax, -64(%ebp)
; num_4b_grps+=3;
c0102df0:	83 45 c0 03 	addl	$3, -64(%ebp)
; int blk_indx=-1;
c0102df4:	c7 45 e4 ff ff ff ff 	movl	$4294967295, -28(%ebp)
; for (uint32_t i=0;i<num_used_entries;i++) {
c0102dfb:	c7 45 dc 00 00 00 00 	movl	$0, -36(%ebp)
c0102e02:	e9 ec 00 00 00 	jmp	236 <malloc+0x15d>
; entry=entries[i];
c0102e07:	8b 55 dc 	movl	-36(%ebp), %edx
c0102e0a:	89 d0 	movl	%edx, %eax
c0102e0c:	c1 e0 02 	shll	$2, %eax
c0102e0f:	01 d0 	addl	%edx, %eax
c0102e11:	c1 e0 02 	shll	$2, %eax
c0102e14:	8d 90 20 60 35 c0 	leal	-1070243808(%eax), %edx
c0102e1a:	8d 45 98 	leal	-104(%ebp), %eax
c0102e1d:	89 d3 	movl	%edx, %ebx
c0102e1f:	ba 05 00 00 00 	movl	$5, %edx
c0102e24:	89 c7 	movl	%eax, %edi
c0102e26:	89 de 	movl	%ebx, %esi
c0102e28:	89 d1 	movl	%edx, %ecx
c0102e2a:	f3 a5 	rep		movsl	(%esi), %es:(%edi)
; if (entry.avail_data_size>=size) {
c0102e2c:	8b 45 a4 	movl	-92(%ebp), %eax
c0102e2f:	39 45 08 	cmpl	%eax, 8(%ebp)
c0102e32:	0f 87 aa 00 00 00 	ja	170 <malloc+0x14c>
; char* bmap=entry.bitmap;
c0102e38:	8b 45 98 	movl	-104(%ebp), %eax
c0102e3b:	89 45 bc 	movl	%eax, -68(%ebp)
; uint32_t bmap_byt_sz=entry.bitmap_byt_size;
c0102e3e:	8b 45 9c 	movl	-100(%ebp), %eax
c0102e41:	89 45 b8 	movl	%eax, -72(%ebp)
; for(uint32_t i=0;i<bmap_byt_sz;i++) {
c0102e44:	c7 45 d4 00 00 00 00 	movl	$0, -44(%ebp)
c0102e4b:	e9 83 00 00 00 	jmp	131 <malloc+0x13d>
; char got_0=0;
c0102e50:	c6 45 d3 00 	movb	$0, -45(%ebp)
; remaining_blks=num_4b_grps;
c0102e54:	8b 45 c0 	movl	-64(%ebp), %eax
c0102e57:	89 45 d8 	movl	%eax, -40(%ebp)
; for (uint32_t j=i*8;;j++) {
c0102e5a:	8b 45 d4 	movl	-44(%ebp), %eax
c0102e5d:	c1 e0 03 	shll	$3, %eax
c0102e60:	89 45 c8 	movl	%eax, -56(%ebp)
; char bit=get_bmap_bit(bmap,j);
c0102e63:	83 ec 08 	subl	$8, %esp
c0102e66:	ff 75 c8 	pushl	-56(%ebp)
c0102e69:	ff 75 bc 	pushl	-68(%ebp)
c0102e6c:	e8 e6 fc ff ff 	calll	-794 <get_bmap_bit>
c0102e71:	83 c4 10 	addl	$16, %esp
c0102e74:	88 45 b7 	movb	%al, -73(%ebp)
; if (got_0) {
c0102e77:	80 7d d3 00 	cmpb	$0, -45(%ebp)
c0102e7b:	74 27 	je	39 <malloc+0x10e>
; if (bit) {
c0102e7d:	80 7d b7 00 	cmpb	$0, -73(%ebp)
c0102e81:	74 1c 	je	28 <malloc+0x109>
; if (remaining_blks==0) {
c0102e83:	83 7d d8 00 	cmpl	$0, -40(%ebp)
c0102e87:	75 08 	jne	8 <malloc+0xfb>
; bmap_index=old_j;
c0102e89:	8b 45 cc 	movl	-52(%ebp), %eax
c0102e8c:	89 45 e0 	movl	%eax, -32(%ebp)
; break;
c0102e8f:	eb 39 	jmp	57 <malloc+0x134>
; i+=j/8;
c0102e91:	8b 45 c8 	movl	-56(%ebp), %eax
c0102e94:	c1 e8 03 	shrl	$3, %eax
c0102e97:	01 45 d4 	addl	%eax, -44(%ebp)
; i--;
c0102e9a:	ff 4d d4 	decl	-44(%ebp)
; break;
c0102e9d:	eb 2b 	jmp	43 <malloc+0x134>
; remaining_blks--;
c0102e9f:	ff 4d d8 	decl	-40(%ebp)
c0102ea2:	eb 13 	jmp	19 <malloc+0x121>
; if (!bit) {
c0102ea4:	80 7d b7 00 	cmpb	$0, -73(%ebp)
c0102ea8:	75 0d 	jne	13 <malloc+0x121>
; got_0=1;
c0102eaa:	c6 45 d3 01 	movb	$1, -45(%ebp)
; old_j=j;
c0102eae:	8b 45 c8 	movl	-56(%ebp), %eax
c0102eb1:	89 45 cc 	movl	%eax, -52(%ebp)
; remaining_blks--;
c0102eb4:	ff 4d d8 	decl	-40(%ebp)
; if (remaining_blks==0) {
c0102eb7:	83 7d d8 00 	cmpl	$0, -40(%ebp)
c0102ebb:	75 08 	jne	8 <malloc+0x12f>
; bmap_index=old_j;
c0102ebd:	8b 45 cc 	movl	-52(%ebp), %eax
c0102ec0:	89 45 e0 	movl	%eax, -32(%ebp)
; break;
c0102ec3:	eb 05 	jmp	5 <malloc+0x134>
; for (uint32_t j=i*8;;j++) {
c0102ec5:	ff 45 c8 	incl	-56(%ebp)
c0102ec8:	eb 99 	jmp	-103 <malloc+0xcd>
; if (remaining_blks==0) {
c0102eca:	83 7d d8 00 	cmpl	$0, -40(%ebp)
c0102ece:	74 11 	je	17 <malloc+0x14b>
; for(uint32_t i=0;i<bmap_byt_sz;i++) {
c0102ed0:	ff 45 d4 	incl	-44(%ebp)
c0102ed3:	8b 45 d4 	movl	-44(%ebp), %eax
c0102ed6:	3b 45 b8 	cmpl	-72(%ebp), %eax
c0102ed9:	0f 82 71 ff ff ff 	jb	-143 <malloc+0xba>
c0102edf:	eb 01 	jmp	1 <malloc+0x14c>
; break;
c0102ee1:	90 	nop
; if (remaining_blks==0) {
c0102ee2:	83 7d d8 00 	cmpl	$0, -40(%ebp)
c0102ee6:	75 08 	jne	8 <malloc+0x15a>
; blk_indx=i;
c0102ee8:	8b 45 dc 	movl	-36(%ebp), %eax
c0102eeb:	89 45 e4 	movl	%eax, -28(%ebp)
; break;
c0102eee:	eb 11 	jmp	17 <malloc+0x16b>
; for (uint32_t i=0;i<num_used_entries;i++) {
c0102ef0:	ff 45 dc 	incl	-36(%ebp)
c0102ef3:	a1 20 88 35 c0 	movl	3224733728, %eax
c0102ef8:	39 45 dc 	cmpl	%eax, -36(%ebp)
c0102efb:	0f 82 06 ff ff ff 	jb	-250 <malloc+0x71>
; if (blk_indx==-1) {
c0102f01:	83 7d e4 ff 	cmpl	$-1, -28(%ebp)
c0102f05:	75 20 	jne	32 <malloc+0x191>
; reserve_block(256);
c0102f07:	83 ec 0c 	subl	$12, %esp
c0102f0a:	68 00 01 00 00 	pushl	$256
c0102f0f:	e8 16 fd ff ff 	calll	-746 <reserve_block>
c0102f14:	83 c4 10 	addl	$16, %esp
; return malloc(size);
c0102f17:	83 ec 0c 	subl	$12, %esp
c0102f1a:	ff 75 08 	pushl	8(%ebp)
c0102f1d:	e8 74 fe ff ff 	calll	-396 <malloc>
c0102f22:	83 c4 10 	addl	$16, %esp
c0102f25:	eb 78 	jmp	120 <malloc+0x209>
; for (uint32_t i=0;i<num_4b_grps;i++) {
c0102f27:	c7 45 c4 00 00 00 00 	movl	$0, -60(%ebp)
c0102f2e:	eb 1b 	jmp	27 <malloc+0x1b5>
; set_bmap_bit(entry.bitmap,bmap_index+i);
c0102f30:	8b 55 e0 	movl	-32(%ebp), %edx
c0102f33:	8b 45 c4 	movl	-60(%ebp), %eax
c0102f36:	01 c2 	addl	%eax, %edx
c0102f38:	8b 45 98 	movl	-104(%ebp), %eax
c0102f3b:	83 ec 08 	subl	$8, %esp
c0102f3e:	52 	pushl	%edx
c0102f3f:	50 	pushl	%eax
c0102f40:	e8 57 fc ff ff 	calll	-937 <set_bmap_bit>
c0102f45:	83 c4 10 	addl	$16, %esp
; for (uint32_t i=0;i<num_4b_grps;i++) {
c0102f48:	ff 45 c4 	incl	-60(%ebp)
c0102f4b:	8b 45 c4 	movl	-60(%ebp), %eax
c0102f4e:	3b 45 c0 	cmpl	-64(%ebp), %eax
c0102f51:	72 dd 	jb	-35 <malloc+0x19a>
; uint32_t data_offset=(bmap_index*8)+12;
c0102f53:	8b 45 e0 	movl	-32(%ebp), %eax
c0102f56:	c1 e0 03 	shll	$3, %eax
c0102f59:	83 c0 0c 	addl	$12, %eax
c0102f5c:	89 45 b0 	movl	%eax, -80(%ebp)
; uint32_t* info=(void*)(((char*)entry.data_block)+data_offset-12);
c0102f5f:	8b 45 a8 	movl	-88(%ebp), %eax
c0102f62:	8b 55 b0 	movl	-80(%ebp), %edx
c0102f65:	83 ea 0c 	subl	$12, %edx
c0102f68:	01 d0 	addl	%edx, %eax
c0102f6a:	89 45 ac 	movl	%eax, -84(%ebp)
; info[0]=num_4b_grps;
c0102f6d:	8b 45 ac 	movl	-84(%ebp), %eax
c0102f70:	8b 55 c0 	movl	-64(%ebp), %edx
c0102f73:	89 10 	movl	%edx, (%eax)
; info[1]=bmap_index;
c0102f75:	8b 45 ac 	movl	-84(%ebp), %eax
c0102f78:	8d 50 04 	leal	4(%eax), %edx
c0102f7b:	8b 45 e0 	movl	-32(%ebp), %eax
c0102f7e:	89 02 	movl	%eax, (%edx)
; info[2]=blk_indx;
c0102f80:	8b 45 ac 	movl	-84(%ebp), %eax
c0102f83:	8d 50 08 	leal	8(%eax), %edx
c0102f86:	8b 45 e4 	movl	-28(%ebp), %eax
c0102f89:	89 02 	movl	%eax, (%edx)
; entry.avail_data_size-=size+12;
c0102f8b:	8b 45 a4 	movl	-92(%ebp), %eax
c0102f8e:	2b 45 08 	subl	8(%ebp), %eax
c0102f91:	83 e8 0c 	subl	$12, %eax
c0102f94:	89 45 a4 	movl	%eax, -92(%ebp)
; return (void*)(((char*)entry.data_block)+data_offset);
c0102f97:	8b 55 a8 	movl	-88(%ebp), %edx
c0102f9a:	8b 45 b0 	movl	-80(%ebp), %eax
c0102f9d:	01 d0 	addl	%edx, %eax
; }
c0102f9f:	8d 65 f4 	leal	-12(%ebp), %esp
c0102fa2:	5b 	popl	%ebx
c0102fa3:	5e 	popl	%esi
c0102fa4:	5f 	popl	%edi
c0102fa5:	5d 	popl	%ebp
c0102fa6:	c3 	retl

realloc:
; void* realloc(void *mem, size_t new_sz) {
c0102fa7:	55 	pushl	%ebp
c0102fa8:	89 e5 	movl	%esp, %ebp
c0102faa:	83 ec 18 	subl	$24, %esp
; void* ptr=malloc(new_sz);
c0102fad:	83 ec 0c 	subl	$12, %esp
c0102fb0:	ff 75 0c 	pushl	12(%ebp)
c0102fb3:	e8 de fd ff ff 	calll	-546 <malloc>
c0102fb8:	83 c4 10 	addl	$16, %esp
c0102fbb:	89 45 f4 	movl	%eax, -12(%ebp)
; if (mem==NULL) {
c0102fbe:	83 7d 08 00 	cmpl	$0, 8(%ebp)
c0102fc2:	75 05 	jne	5 <realloc+0x22>
; return ptr;
c0102fc4:	8b 45 f4 	movl	-12(%ebp), %eax
c0102fc7:	eb 38 	jmp	56 <realloc+0x5a>
; uint32_t num_4b_grps=*((uint32_t*)((char*)mem-12));
c0102fc9:	8b 45 08 	movl	8(%ebp), %eax
c0102fcc:	8b 40 f4 	movl	-12(%eax), %eax
c0102fcf:	89 45 f0 	movl	%eax, -16(%ebp)
; memcpy(ptr,mem,num_4b_grps*4);
c0102fd2:	8b 45 f0 	movl	-16(%ebp), %eax
c0102fd5:	c1 e0 02 	shll	$2, %eax
c0102fd8:	83 ec 04 	subl	$4, %esp
c0102fdb:	50 	pushl	%eax
c0102fdc:	ff 75 08 	pushl	8(%ebp)
c0102fdf:	ff 75 f4 	pushl	-12(%ebp)
c0102fe2:	e8 b0 00 00 00 	calll	176 <memcpy>
c0102fe7:	83 c4 10 	addl	$16, %esp
; free(mem);
c0102fea:	83 ec 0c 	subl	$12, %esp
c0102fed:	ff 75 08 	pushl	8(%ebp)
c0102ff0:	e8 0e 00 00 00 	calll	14 <free>
c0102ff5:	83 c4 10 	addl	$16, %esp
; mem=ptr;
c0102ff8:	8b 45 f4 	movl	-12(%ebp), %eax
c0102ffb:	89 45 08 	movl	%eax, 8(%ebp)
; return ptr;
c0102ffe:	8b 45 f4 	movl	-12(%ebp), %eax
; }
c0103001:	c9 	leave
c0103002:	c3 	retl

free:
; void free(void* mem) {
c0103003:	55 	pushl	%ebp
c0103004:	89 e5 	movl	%esp, %ebp
c0103006:	57 	pushl	%edi
c0103007:	56 	pushl	%esi
c0103008:	53 	pushl	%ebx
c0103009:	83 ec 30 	subl	$48, %esp
; uint32_t* info=(uint32_t*)((char*)mem-12);
c010300c:	8b 45 08 	movl	8(%ebp), %eax
c010300f:	83 e8 0c 	subl	$12, %eax
c0103012:	89 45 ec 	movl	%eax, -20(%ebp)
; uint32_t num_4b_grps=info[0];
c0103015:	8b 45 ec 	movl	-20(%ebp), %eax
c0103018:	8b 00 	movl	(%eax), %eax
c010301a:	89 45 e8 	movl	%eax, -24(%ebp)
; uint32_t bmap_index=info[1];
c010301d:	8b 45 ec 	movl	-20(%ebp), %eax
c0103020:	8b 40 04 	movl	4(%eax), %eax
c0103023:	89 45 e4 	movl	%eax, -28(%ebp)
; uint32_t blk_indx=info[2];
c0103026:	8b 45 ec 	movl	-20(%ebp), %eax
c0103029:	8b 40 08 	movl	8(%eax), %eax
c010302c:	89 45 e0 	movl	%eax, -32(%ebp)
; heap_block entry=entries[blk_indx];
c010302f:	8b 55 e0 	movl	-32(%ebp), %edx
c0103032:	89 d0 	movl	%edx, %eax
c0103034:	c1 e0 02 	shll	$2, %eax
c0103037:	01 d0 	addl	%edx, %eax
c0103039:	c1 e0 02 	shll	$2, %eax
c010303c:	8d 90 20 60 35 c0 	leal	-1070243808(%eax), %edx
c0103042:	8d 45 cc 	leal	-52(%ebp), %eax
c0103045:	89 d3 	movl	%edx, %ebx
c0103047:	ba 05 00 00 00 	movl	$5, %edx
c010304c:	89 c7 	movl	%eax, %edi
c010304e:	89 de 	movl	%ebx, %esi
c0103050:	89 d1 	movl	%edx, %ecx
c0103052:	f3 a5 	rep		movsl	(%esi), %es:(%edi)
; for (uint32_t i=0;i<num_4b_grps;i++) {
c0103054:	c7 45 f0 00 00 00 00 	movl	$0, -16(%ebp)
c010305b:	eb 18 	jmp	24 <free+0x72>
; clear_bmap_bit(entry.bitmap,bmap_index+i);
c010305d:	8b 55 e4 	movl	-28(%ebp), %edx
c0103060:	8b 45 f0 	movl	-16(%ebp), %eax
c0103063:	01 c2 	addl	%eax, %edx
c0103065:	8b 45 cc 	movl	-52(%ebp), %eax
c0103068:	52 	pushl	%edx
c0103069:	50 	pushl	%eax
c010306a:	e8 73 fb ff ff 	calll	-1165 <clear_bmap_bit>
c010306f:	83 c4 08 	addl	$8, %esp
; for (uint32_t i=0;i<num_4b_grps;i++) {
c0103072:	ff 45 f0 	incl	-16(%ebp)
c0103075:	8b 45 f0 	movl	-16(%ebp), %eax
c0103078:	3b 45 e8 	cmpl	-24(%ebp), %eax
c010307b:	72 e0 	jb	-32 <free+0x5a>
; entry.avail_data_size+=(num_4b_grps*4)+12;
c010307d:	8b 45 d8 	movl	-40(%ebp), %eax
c0103080:	8b 55 e8 	movl	-24(%ebp), %edx
c0103083:	83 c2 03 	addl	$3, %edx
c0103086:	c1 e2 02 	shll	$2, %edx
c0103089:	01 d0 	addl	%edx, %eax
c010308b:	89 45 d8 	movl	%eax, -40(%ebp)
; }
c010308e:	90 	nop
c010308f:	8d 65 f4 	leal	-12(%ebp), %esp
c0103092:	5b 	popl	%ebx
c0103093:	5e 	popl	%esi
c0103094:	5f 	popl	%edi
c0103095:	5d 	popl	%ebp
c0103096:	c3 	retl

memcpy:
; void* memcpy(void* dest_ptr,const void* source_ptr,size_t len) {
c0103097:	55 	pushl	%ebp
c0103098:	89 e5 	movl	%esp, %ebp
c010309a:	83 ec 10 	subl	$16, %esp
; char* source=(char*)source_ptr;
c010309d:	8b 45 0c 	movl	12(%ebp), %eax
c01030a0:	89 45 f8 	movl	%eax, -8(%ebp)
; char* dest=(char*)dest_ptr;
c01030a3:	8b 45 08 	movl	8(%ebp), %eax
c01030a6:	89 45 f4 	movl	%eax, -12(%ebp)
; for(size_t i=0;i<len;i++) {
c01030a9:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
c01030b0:	eb 17 	jmp	23 <memcpy+0x32>
; dest[i]=source[i];
c01030b2:	8b 55 f8 	movl	-8(%ebp), %edx
c01030b5:	8b 45 fc 	movl	-4(%ebp), %eax
c01030b8:	01 d0 	addl	%edx, %eax
c01030ba:	8b 4d f4 	movl	-12(%ebp), %ecx
c01030bd:	8b 55 fc 	movl	-4(%ebp), %edx
c01030c0:	01 ca 	addl	%ecx, %edx
c01030c2:	8a 00 	movb	(%eax), %al
c01030c4:	88 02 	movb	%al, (%edx)
; for(size_t i=0;i<len;i++) {
c01030c6:	ff 45 fc 	incl	-4(%ebp)
c01030c9:	8b 45 fc 	movl	-4(%ebp), %eax
c01030cc:	3b 45 10 	cmpl	16(%ebp), %eax
c01030cf:	72 e1 	jb	-31 <memcpy+0x1b>
; return dest_ptr;
c01030d1:	8b 45 08 	movl	8(%ebp), %eax
; }
c01030d4:	c9 	leave
c01030d5:	c3 	retl

memset:
; void* memset(void *dest_ptr,int val,size_t len) {
c01030d6:	55 	pushl	%ebp
c01030d7:	89 e5 	movl	%esp, %ebp
c01030d9:	83 ec 10 	subl	$16, %esp
; char* dest=(char*)dest_ptr;
c01030dc:	8b 45 08 	movl	8(%ebp), %eax
c01030df:	89 45 f8 	movl	%eax, -8(%ebp)
; for (size_t i=0;i<len;i++){
c01030e2:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
c01030e9:	eb 10 	jmp	16 <memset+0x25>
; dest[i]=(char)val;
c01030eb:	8b 55 f8 	movl	-8(%ebp), %edx
c01030ee:	8b 45 fc 	movl	-4(%ebp), %eax
c01030f1:	01 d0 	addl	%edx, %eax
c01030f3:	8b 55 0c 	movl	12(%ebp), %edx
c01030f6:	88 10 	movb	%dl, (%eax)
; for (size_t i=0;i<len;i++){
c01030f8:	ff 45 fc 	incl	-4(%ebp)
c01030fb:	8b 45 fc 	movl	-4(%ebp), %eax
c01030fe:	3b 45 10 	cmpl	16(%ebp), %eax
c0103101:	72 e8 	jb	-24 <memset+0x15>
; return dest_ptr;
c0103103:	8b 45 08 	movl	8(%ebp), %eax
; }
c0103106:	c9 	leave
c0103107:	c3 	retl

strcmp:
; int strcmp(const char* s1,const char* s2) {
c0103108:	55 	pushl	%ebp
c0103109:	89 e5 	movl	%esp, %ebp
c010310b:	83 ec 10 	subl	$16, %esp
; for (i = 0; s1[i] == s2[i]; i++) {
c010310e:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
c0103115:	eb 18 	jmp	24 <strcmp+0x27>
; if (s1[i] == '\0') return 0;
c0103117:	8b 55 fc 	movl	-4(%ebp), %edx
c010311a:	8b 45 08 	movl	8(%ebp), %eax
c010311d:	01 d0 	addl	%edx, %eax
c010311f:	8a 00 	movb	(%eax), %al
c0103121:	84 c0 	testb	%al, %al
c0103123:	75 07 	jne	7 <strcmp+0x24>
c0103125:	b8 00 00 00 00 	movl	$0, %eax
c010312a:	eb 39 	jmp	57 <strcmp+0x5d>
; for (i = 0; s1[i] == s2[i]; i++) {
c010312c:	ff 45 fc 	incl	-4(%ebp)
c010312f:	8b 55 fc 	movl	-4(%ebp), %edx
c0103132:	8b 45 08 	movl	8(%ebp), %eax
c0103135:	01 d0 	addl	%edx, %eax
c0103137:	8a 10 	movb	(%eax), %dl
c0103139:	8b 4d fc 	movl	-4(%ebp), %ecx
c010313c:	8b 45 0c 	movl	12(%ebp), %eax
c010313f:	01 c8 	addl	%ecx, %eax
c0103141:	8a 00 	movb	(%eax), %al
c0103143:	38 c2 	cmpb	%al, %dl
c0103145:	74 d0 	je	-48 <strcmp+0xf>
; return s1[i] - s2[i];
c0103147:	8b 55 fc 	movl	-4(%ebp), %edx
c010314a:	8b 45 08 	movl	8(%ebp), %eax
c010314d:	01 d0 	addl	%edx, %eax
c010314f:	8a 00 	movb	(%eax), %al
c0103151:	0f be d0 	movsbl	%al, %edx
c0103154:	8b 4d fc 	movl	-4(%ebp), %ecx
c0103157:	8b 45 0c 	movl	12(%ebp), %eax
c010315a:	01 c8 	addl	%ecx, %eax
c010315c:	8a 00 	movb	(%eax), %al
c010315e:	0f be c0 	movsbl	%al, %eax
c0103161:	29 c2 	subl	%eax, %edx
c0103163:	89 d0 	movl	%edx, %eax
; }
c0103165:	c9 	leave
c0103166:	c3 	retl

strlen:
; size_t strlen(const char* str) {
c0103167:	55 	pushl	%ebp
c0103168:	89 e5 	movl	%esp, %ebp
c010316a:	83 ec 10 	subl	$16, %esp
; for (i=0;str[i]!='\0';i++);
c010316d:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
c0103174:	eb 03 	jmp	3 <strlen+0x12>
c0103176:	ff 45 fc 	incl	-4(%ebp)
c0103179:	8b 55 08 	movl	8(%ebp), %edx
c010317c:	8b 45 fc 	movl	-4(%ebp), %eax
c010317f:	01 d0 	addl	%edx, %eax
c0103181:	8a 00 	movb	(%eax), %al
c0103183:	84 c0 	testb	%al, %al
c0103185:	75 ef 	jne	-17 <strlen+0xf>
; return i;
c0103187:	8b 45 fc 	movl	-4(%ebp), %eax
; }
c010318a:	c9 	leave
c010318b:	c3 	retl

strcpy:
; char* strcpy(char* dest,const char* src) {
c010318c:	55 	pushl	%ebp
c010318d:	89 e5 	movl	%esp, %ebp
c010318f:	83 ec 10 	subl	$16, %esp
; for (i=0;i<strlen(src);i++) {
c0103192:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
c0103199:	eb 17 	jmp	23 <strcpy+0x26>
; dest[i]=src[i];
c010319b:	8b 55 0c 	movl	12(%ebp), %edx
c010319e:	8b 45 fc 	movl	-4(%ebp), %eax
c01031a1:	01 d0 	addl	%edx, %eax
c01031a3:	8b 4d 08 	movl	8(%ebp), %ecx
c01031a6:	8b 55 fc 	movl	-4(%ebp), %edx
c01031a9:	01 ca 	addl	%ecx, %edx
c01031ab:	8a 00 	movb	(%eax), %al
c01031ad:	88 02 	movb	%al, (%edx)
; for (i=0;i<strlen(src);i++) {
c01031af:	ff 45 fc 	incl	-4(%ebp)
c01031b2:	ff 75 0c 	pushl	12(%ebp)
c01031b5:	e8 ad ff ff ff 	calll	-83 <strlen>
c01031ba:	83 c4 04 	addl	$4, %esp
c01031bd:	39 45 fc 	cmpl	%eax, -4(%ebp)
c01031c0:	72 d9 	jb	-39 <strcpy+0xf>
; dest[i]='\0';
c01031c2:	8b 55 08 	movl	8(%ebp), %edx
c01031c5:	8b 45 fc 	movl	-4(%ebp), %eax
c01031c8:	01 d0 	addl	%edx, %eax
c01031ca:	c6 00 00 	movb	$0, (%eax)
; return dest;
c01031cd:	8b 45 08 	movl	8(%ebp), %eax
; }
c01031d0:	c9 	leave
c01031d1:	c3 	retl

strrev:
; char* strrev(char* str) {
c01031d2:	55 	pushl	%ebp
c01031d3:	89 e5 	movl	%esp, %ebp
c01031d5:	83 ec 10 	subl	$16, %esp
; for (i=0,j=strlen(str)-1;i<j;i++,j--) {
c01031d8:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
c01031df:	ff 75 08 	pushl	8(%ebp)
c01031e2:	e8 80 ff ff ff 	calll	-128 <strlen>
c01031e7:	83 c4 04 	addl	$4, %esp
c01031ea:	48 	decl	%eax
c01031eb:	89 45 f8 	movl	%eax, -8(%ebp)
c01031ee:	eb 34 	jmp	52 <strrev+0x52>
; chr=str[i];
c01031f0:	8b 55 fc 	movl	-4(%ebp), %edx
c01031f3:	8b 45 08 	movl	8(%ebp), %eax
c01031f6:	01 d0 	addl	%edx, %eax
c01031f8:	8a 00 	movb	(%eax), %al
c01031fa:	88 45 f7 	movb	%al, -9(%ebp)
; str[i]=str[j];
c01031fd:	8b 55 f8 	movl	-8(%ebp), %edx
c0103200:	8b 45 08 	movl	8(%ebp), %eax
c0103203:	01 d0 	addl	%edx, %eax
c0103205:	8b 4d fc 	movl	-4(%ebp), %ecx
c0103208:	8b 55 08 	movl	8(%ebp), %edx
c010320b:	01 ca 	addl	%ecx, %edx
c010320d:	8a 00 	movb	(%eax), %al
c010320f:	88 02 	movb	%al, (%edx)
; str[j]=chr;
c0103211:	8b 55 f8 	movl	-8(%ebp), %edx
c0103214:	8b 45 08 	movl	8(%ebp), %eax
c0103217:	01 c2 	addl	%eax, %edx
c0103219:	8a 45 f7 	movb	-9(%ebp), %al
c010321c:	88 02 	movb	%al, (%edx)
; for (i=0,j=strlen(str)-1;i<j;i++,j--) {
c010321e:	ff 45 fc 	incl	-4(%ebp)
c0103221:	ff 4d f8 	decl	-8(%ebp)
c0103224:	8b 45 fc 	movl	-4(%ebp), %eax
c0103227:	3b 45 f8 	cmpl	-8(%ebp), %eax
c010322a:	7c c4 	jl	-60 <strrev+0x1e>
; return str;
c010322c:	8b 45 08 	movl	8(%ebp), %eax
; }
c010322f:	c9 	leave
c0103230:	c3 	retl

int_to_ascii:
; void int_to_ascii(int n,char* str) {
c0103231:	55 	pushl	%ebp
c0103232:	89 e5 	movl	%esp, %ebp
c0103234:	83 ec 10 	subl	$16, %esp
; if ((sign = n)<0) {
c0103237:	8b 45 08 	movl	8(%ebp), %eax
c010323a:	89 45 f8 	movl	%eax, -8(%ebp)
c010323d:	83 7d f8 00 	cmpl	$0, -8(%ebp)
c0103241:	79 03 	jns	3 <int_to_ascii+0x15>
; n=-n;
c0103243:	f7 5d 08 	negl	8(%ebp)
; i=0;
c0103246:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
; str[i++]=n%10+'0';
c010324d:	8b 45 08 	movl	8(%ebp), %eax
c0103250:	b9 0a 00 00 00 	movl	$10, %ecx
c0103255:	99 	cltd
c0103256:	f7 f9 	idivl	%ecx
c0103258:	89 d0 	movl	%edx, %eax
c010325a:	8d 48 30 	leal	48(%eax), %ecx
c010325d:	8b 45 fc 	movl	-4(%ebp), %eax
c0103260:	8d 50 01 	leal	1(%eax), %edx
c0103263:	89 55 fc 	movl	%edx, -4(%ebp)
c0103266:	89 c2 	movl	%eax, %edx
c0103268:	8b 45 0c 	movl	12(%ebp), %eax
c010326b:	01 d0 	addl	%edx, %eax
c010326d:	88 ca 	movb	%cl, %dl
c010326f:	88 10 	movb	%dl, (%eax)
; } while ((n /= 10) > 0);
c0103271:	8b 4d 08 	movl	8(%ebp), %ecx
c0103274:	b8 67 66 66 66 	movl	$1717986919, %eax
c0103279:	f7 e9 	imull	%ecx
c010327b:	c1 fa 02 	sarl	$2, %edx
c010327e:	89 c8 	movl	%ecx, %eax
c0103280:	c1 f8 1f 	sarl	$31, %eax
c0103283:	29 c2 	subl	%eax, %edx
c0103285:	89 d0 	movl	%edx, %eax
c0103287:	89 45 08 	movl	%eax, 8(%ebp)
c010328a:	83 7d 08 00 	cmpl	$0, 8(%ebp)
c010328e:	7f bd 	jg	-67 <int_to_ascii+0x1c>
; if (sign < 0) {
c0103290:	83 7d f8 00 	cmpl	$0, -8(%ebp)
c0103294:	79 13 	jns	19 <int_to_ascii+0x78>
; str[i++] = '-';
c0103296:	8b 45 fc 	movl	-4(%ebp), %eax
c0103299:	8d 50 01 	leal	1(%eax), %edx
c010329c:	89 55 fc 	movl	%edx, -4(%ebp)
c010329f:	89 c2 	movl	%eax, %edx
c01032a1:	8b 45 0c 	movl	12(%ebp), %eax
c01032a4:	01 d0 	addl	%edx, %eax
c01032a6:	c6 00 2d 	movb	$45, (%eax)
; str[i]='\0';
c01032a9:	8b 55 fc 	movl	-4(%ebp), %edx
c01032ac:	8b 45 0c 	movl	12(%ebp), %eax
c01032af:	01 d0 	addl	%edx, %eax
c01032b1:	c6 00 00 	movb	$0, (%eax)
; strrev(str);
c01032b4:	ff 75 0c 	pushl	12(%ebp)
c01032b7:	e8 16 ff ff ff 	calll	-234 <strrev>
c01032bc:	83 c4 04 	addl	$4, %esp
; }
c01032bf:	90 	nop
c01032c0:	c9 	leave
c01032c1:	c3 	retl

hex_to_ascii:
; void hex_to_ascii(int n, char* str) {
c01032c2:	55 	pushl	%ebp
c01032c3:	89 e5 	movl	%esp, %ebp
c01032c5:	83 ec 18 	subl	$24, %esp
; append(str, '0');
c01032c8:	83 ec 08 	subl	$8, %esp
c01032cb:	6a 30 	pushl	$48
c01032cd:	ff 75 0c 	pushl	12(%ebp)
c01032d0:	e8 cb 00 00 00 	calll	203 <append>
c01032d5:	83 c4 10 	addl	$16, %esp
; append(str, 'x');
c01032d8:	83 ec 08 	subl	$8, %esp
c01032db:	6a 78 	pushl	$120
c01032dd:	ff 75 0c 	pushl	12(%ebp)
c01032e0:	e8 bb 00 00 00 	calll	187 <append>
c01032e5:	83 c4 10 	addl	$16, %esp
; char zeros = 0;
c01032e8:	c6 45 f7 00 	movb	$0, -9(%ebp)
; for (i = 28; i > 0; i -= 4) {
c01032ec:	c7 45 f0 1c 00 00 00 	movl	$28, -16(%ebp)
c01032f3:	eb 61 	jmp	97 <hex_to_ascii+0x94>
; tmp = (n >> i) & 0xF;
c01032f5:	8b 45 f0 	movl	-16(%ebp), %eax
c01032f8:	8b 55 08 	movl	8(%ebp), %edx
c01032fb:	88 c1 	movb	%al, %cl
c01032fd:	d3 fa 	sarl	%cl, %edx
c01032ff:	89 d0 	movl	%edx, %eax
c0103301:	83 e0 0f 	andl	$15, %eax
c0103304:	89 45 ec 	movl	%eax, -20(%ebp)
; if (tmp == 0 && zeros == 0) continue;
c0103307:	83 7d ec 00 	cmpl	$0, -20(%ebp)
c010330b:	75 06 	jne	6 <hex_to_ascii+0x51>
c010330d:	80 7d f7 00 	cmpb	$0, -9(%ebp)
c0103311:	74 3e 	je	62 <hex_to_ascii+0x8f>
; zeros = 1;
c0103313:	c6 45 f7 01 	movb	$1, -9(%ebp)
; if (tmp > 0xA) append(str, tmp - 0xA + 'a');
c0103317:	83 7d ec 0a 	cmpl	$10, -20(%ebp)
c010331b:	76 1a 	jbe	26 <hex_to_ascii+0x75>
c010331d:	8b 45 ec 	movl	-20(%ebp), %eax
c0103320:	83 c0 57 	addl	$87, %eax
c0103323:	0f be c0 	movsbl	%al, %eax
c0103326:	83 ec 08 	subl	$8, %esp
c0103329:	50 	pushl	%eax
c010332a:	ff 75 0c 	pushl	12(%ebp)
c010332d:	e8 6e 00 00 00 	calll	110 <append>
c0103332:	83 c4 10 	addl	$16, %esp
c0103335:	eb 1b 	jmp	27 <hex_to_ascii+0x90>
; else append(str, tmp + '0');
c0103337:	8b 45 ec 	movl	-20(%ebp), %eax
c010333a:	83 c0 30 	addl	$48, %eax
c010333d:	0f be c0 	movsbl	%al, %eax
c0103340:	83 ec 08 	subl	$8, %esp
c0103343:	50 	pushl	%eax
c0103344:	ff 75 0c 	pushl	12(%ebp)
c0103347:	e8 54 00 00 00 	calll	84 <append>
c010334c:	83 c4 10 	addl	$16, %esp
c010334f:	eb 01 	jmp	1 <hex_to_ascii+0x90>
; if (tmp == 0 && zeros == 0) continue;
c0103351:	90 	nop
; for (i = 28; i > 0; i -= 4) {
c0103352:	83 6d f0 04 	subl	$4, -16(%ebp)
c0103356:	83 7d f0 00 	cmpl	$0, -16(%ebp)
c010335a:	7f 99 	jg	-103 <hex_to_ascii+0x33>
; tmp = n & 0xF;
c010335c:	8b 45 08 	movl	8(%ebp), %eax
c010335f:	83 e0 0f 	andl	$15, %eax
c0103362:	89 45 ec 	movl	%eax, -20(%ebp)
; if (tmp >= 0xA) append(str, tmp - 0xA + 'a');
c0103365:	83 7d ec 09 	cmpl	$9, -20(%ebp)
c0103369:	76 1a 	jbe	26 <hex_to_ascii+0xc3>
c010336b:	8b 45 ec 	movl	-20(%ebp), %eax
c010336e:	83 c0 57 	addl	$87, %eax
c0103371:	0f be c0 	movsbl	%al, %eax
c0103374:	83 ec 08 	subl	$8, %esp
c0103377:	50 	pushl	%eax
c0103378:	ff 75 0c 	pushl	12(%ebp)
c010337b:	e8 20 00 00 00 	calll	32 <append>
c0103380:	83 c4 10 	addl	$16, %esp
; }
c0103383:	eb 18 	jmp	24 <hex_to_ascii+0xdb>
; else append(str, tmp + '0');
c0103385:	8b 45 ec 	movl	-20(%ebp), %eax
c0103388:	83 c0 30 	addl	$48, %eax
c010338b:	0f be c0 	movsbl	%al, %eax
c010338e:	83 ec 08 	subl	$8, %esp
c0103391:	50 	pushl	%eax
c0103392:	ff 75 0c 	pushl	12(%ebp)
c0103395:	e8 06 00 00 00 	calll	6 <append>
c010339a:	83 c4 10 	addl	$16, %esp
; }
c010339d:	90 	nop
c010339e:	c9 	leave
c010339f:	c3 	retl

append:
; void append(char* s, char n) {
c01033a0:	55 	pushl	%ebp
c01033a1:	89 e5 	movl	%esp, %ebp
c01033a3:	83 ec 14 	subl	$20, %esp
c01033a6:	8b 45 0c 	movl	12(%ebp), %eax
c01033a9:	88 45 ec 	movb	%al, -20(%ebp)
; int len = strlen(s);
c01033ac:	ff 75 08 	pushl	8(%ebp)
c01033af:	e8 b3 fd ff ff 	calll	-589 <strlen>
c01033b4:	83 c4 04 	addl	$4, %esp
c01033b7:	89 45 fc 	movl	%eax, -4(%ebp)
; s[len] = n;
c01033ba:	8b 55 fc 	movl	-4(%ebp), %edx
c01033bd:	8b 45 08 	movl	8(%ebp), %eax
c01033c0:	01 c2 	addl	%eax, %edx
c01033c2:	8a 45 ec 	movb	-20(%ebp), %al
c01033c5:	88 02 	movb	%al, (%edx)
; s[len+1] = '\0';
c01033c7:	8b 45 fc 	movl	-4(%ebp), %eax
c01033ca:	8d 50 01 	leal	1(%eax), %edx
c01033cd:	8b 45 08 	movl	8(%ebp), %eax
c01033d0:	01 d0 	addl	%edx, %eax
c01033d2:	c6 00 00 	movb	$0, (%eax)
; }
c01033d5:	90 	nop
c01033d6:	c9 	leave
c01033d7:	c3 	retl

backspace:
; void backspace(char* s) {
c01033d8:	55 	pushl	%ebp
c01033d9:	89 e5 	movl	%esp, %ebp
c01033db:	83 ec 10 	subl	$16, %esp
; int len = strlen(s);
c01033de:	ff 75 08 	pushl	8(%ebp)
c01033e1:	e8 81 fd ff ff 	calll	-639 <strlen>
c01033e6:	83 c4 04 	addl	$4, %esp
c01033e9:	89 45 fc 	movl	%eax, -4(%ebp)
; s[len-1] = '\0';
c01033ec:	8b 45 fc 	movl	-4(%ebp), %eax
c01033ef:	8d 50 ff 	leal	-1(%eax), %edx
c01033f2:	8b 45 08 	movl	8(%ebp), %eax
c01033f5:	01 d0 	addl	%edx, %eax
c01033f7:	c6 00 00 	movb	$0, (%eax)
; }
c01033fa:	90 	nop
c01033fb:	c9 	leave
c01033fc:	c3 	retl

strtok_delim_check:
; static char strtok_delim_check(const char* delim) {
c01033fd:	55 	pushl	%ebp
c01033fe:	89 e5 	movl	%esp, %ebp
c0103400:	83 ec 10 	subl	$16, %esp
; for (size_t i=0;i<strlen(delim);i++) {
c0103403:	c7 45 fc 00 00 00 00 	movl	$0, -4(%ebp)
c010340a:	eb 37 	jmp	55 <strtok_delim_check+0x46>
; if (strtok_str[strtok_index]==delim[i]||strtok_str[strtok_index]=='\0') {
c010340c:	8b 15 24 88 35 c0 	movl	-1070233564, %edx
c0103412:	a1 28 88 35 c0 	movl	3224733736, %eax
c0103417:	01 d0 	addl	%edx, %eax
c0103419:	8a 10 	movb	(%eax), %dl
c010341b:	8b 4d 08 	movl	8(%ebp), %ecx
c010341e:	8b 45 fc 	movl	-4(%ebp), %eax
c0103421:	01 c8 	addl	%ecx, %eax
c0103423:	8a 00 	movb	(%eax), %al
c0103425:	38 c2 	cmpb	%al, %dl
c0103427:	74 13 	je	19 <strtok_delim_check+0x3f>
c0103429:	8b 15 24 88 35 c0 	movl	-1070233564, %edx
c010342f:	a1 28 88 35 c0 	movl	3224733736, %eax
c0103434:	01 d0 	addl	%edx, %eax
c0103436:	8a 00 	movb	(%eax), %al
c0103438:	84 c0 	testb	%al, %al
c010343a:	75 04 	jne	4 <strtok_delim_check+0x43>
; return 0;
c010343c:	b0 00 	movb	$0, %al
c010343e:	eb 15 	jmp	21 <strtok_delim_check+0x58>
; for (size_t i=0;i<strlen(delim);i++) {
c0103440:	ff 45 fc 	incl	-4(%ebp)
c0103443:	ff 75 08 	pushl	8(%ebp)
c0103446:	e8 1c fd ff ff 	calll	-740 <strlen>
c010344b:	83 c4 04 	addl	$4, %esp
c010344e:	39 45 fc 	cmpl	%eax, -4(%ebp)
c0103451:	72 b9 	jb	-71 <strtok_delim_check+0xf>
; return 1;
c0103453:	b0 01 	movb	$1, %al
; }
c0103455:	c9 	leave
c0103456:	c3 	retl

strtok:
; char* strtok(const char* str, const char* delim) {
c0103457:	55 	pushl	%ebp
c0103458:	89 e5 	movl	%esp, %ebp
c010345a:	83 ec 18 	subl	$24, %esp
; if (str!=NULL) {
c010345d:	83 7d 08 00 	cmpl	$0, 8(%ebp)
c0103461:	74 12 	je	18 <strtok+0x1e>
; strtok_str=str;
c0103463:	8b 45 08 	movl	8(%ebp), %eax
c0103466:	a3 24 88 35 c0 	movl	%eax, 3224733732
; strtok_index=0;
c010346b:	c7 05 28 88 35 c0 00 00 00 00 	movl	$0, -1070233560
; if (!strtok_str || strtok_index>strlen(strtok_str)) {
c0103475:	a1 24 88 35 c0 	movl	3224733732, %eax
c010347a:	85 c0 	testl	%eax, %eax
c010347c:	74 19 	je	25 <strtok+0x40>
c010347e:	a1 24 88 35 c0 	movl	3224733732, %eax
c0103483:	50 	pushl	%eax
c0103484:	e8 de fc ff ff 	calll	-802 <strlen>
c0103489:	83 c4 04 	addl	$4, %esp
c010348c:	89 c2 	movl	%eax, %edx
c010348e:	a1 28 88 35 c0 	movl	3224733736, %eax
c0103493:	39 c2 	cmpl	%eax, %edx
c0103495:	73 0a 	jae	10 <strtok+0x4a>
; return NULL;
c0103497:	b8 00 00 00 00 	movl	$0, %eax
c010349c:	e9 9b 00 00 00 	jmp	155 <strtok+0xe5>
; char* tok=malloc(sizeof(char)*32);
c01034a1:	83 ec 0c 	subl	$12, %esp
c01034a4:	6a 20 	pushl	$32
c01034a6:	e8 eb f8 ff ff 	calll	-1813 <malloc>
c01034ab:	83 c4 10 	addl	$16, %esp
c01034ae:	89 45 f4 	movl	%eax, -12(%ebp)
; tok[0]='\0';
c01034b1:	8b 45 f4 	movl	-12(%ebp), %eax
c01034b4:	c6 00 00 	movb	$0, (%eax)
; size_t max_len=32;
c01034b7:	c7 45 f0 20 00 00 00 	movl	$32, -16(%ebp)
; for (;strtok_delim_check(delim);strtok_index++) {
c01034be:	eb 5c 	jmp	92 <strtok+0xc5>
; if (strlen(tok)+1==max_len) {
c01034c0:	83 ec 0c 	subl	$12, %esp
c01034c3:	ff 75 f4 	pushl	-12(%ebp)
c01034c6:	e8 9c fc ff ff 	calll	-868 <strlen>
c01034cb:	83 c4 10 	addl	$16, %esp
c01034ce:	40 	incl	%eax
c01034cf:	39 45 f0 	cmpl	%eax, -16(%ebp)
c01034d2:	75 1c 	jne	28 <strtok+0x99>
; tok=realloc(tok,sizeof(char)*(max_len+32));
c01034d4:	8b 45 f0 	movl	-16(%ebp), %eax
c01034d7:	83 c0 20 	addl	$32, %eax
c01034da:	83 ec 08 	subl	$8, %esp
c01034dd:	50 	pushl	%eax
c01034de:	ff 75 f4 	pushl	-12(%ebp)
c01034e1:	e8 c1 fa ff ff 	calll	-1343 <realloc>
c01034e6:	83 c4 10 	addl	$16, %esp
c01034e9:	89 45 f4 	movl	%eax, -12(%ebp)
; max_len+=32;
c01034ec:	83 45 f0 20 	addl	$32, -16(%ebp)
; append(tok,strtok_str[strtok_index]);
c01034f0:	8b 15 24 88 35 c0 	movl	-1070233564, %edx
c01034f6:	a1 28 88 35 c0 	movl	3224733736, %eax
c01034fb:	01 d0 	addl	%edx, %eax
c01034fd:	8a 00 	movb	(%eax), %al
c01034ff:	0f be c0 	movsbl	%al, %eax
c0103502:	83 ec 08 	subl	$8, %esp
c0103505:	50 	pushl	%eax
c0103506:	ff 75 f4 	pushl	-12(%ebp)
c0103509:	e8 92 fe ff ff 	calll	-366 <append>
c010350e:	83 c4 10 	addl	$16, %esp
; for (;strtok_delim_check(delim);strtok_index++) {
c0103511:	a1 28 88 35 c0 	movl	3224733736, %eax
c0103516:	40 	incl	%eax
c0103517:	a3 28 88 35 c0 	movl	%eax, 3224733736
c010351c:	83 ec 0c 	subl	$12, %esp
c010351f:	ff 75 0c 	pushl	12(%ebp)
c0103522:	e8 d6 fe ff ff 	calll	-298 <strtok_delim_check>
c0103527:	83 c4 10 	addl	$16, %esp
c010352a:	84 c0 	testb	%al, %al
c010352c:	75 92 	jne	-110 <strtok+0x69>
; strtok_index++;
c010352e:	a1 28 88 35 c0 	movl	3224733736, %eax
c0103533:	40 	incl	%eax
c0103534:	a3 28 88 35 c0 	movl	%eax, 3224733736
; return tok;
c0103539:	8b 45 f4 	movl	-12(%ebp), %eax
; }
c010353c:	c9 	leave
c010353d:	c3 	retl

yield:
; void yield() {
c010353e:	55 	pushl	%ebp
c010353f:	89 e5 	movl	%esp, %ebp
; asm volatile("  \
c0103541:	b8 01 00 00 00 	movl	$1, %eax
c0103546:	cd 50 	int	$80
; }
c0103548:	90 	nop
c0103549:	5d 	popl	%ebp
c010354a:	c3 	retl

createTask:
; void createTask(void* task) {
c010354b:	55 	pushl	%ebp
c010354c:	89 e5 	movl	%esp, %ebp
c010354e:	53 	pushl	%ebx
; asm volatile("  \
c010354f:	8b 45 08 	movl	8(%ebp), %eax
c0103552:	89 c3 	movl	%eax, %ebx
c0103554:	b8 02 00 00 00 	movl	$2, %eax
c0103559:	cd 50 	int	$80
; }
c010355b:	90 	nop
c010355c:	5b 	popl	%ebx
c010355d:	5d 	popl	%ebp
c010355e:	c3 	retl

createTaskCr3:
; void createTaskCr3(void* task,void* cr3) {
c010355f:	55 	pushl	%ebp
c0103560:	89 e5 	movl	%esp, %ebp
c0103562:	53 	pushl	%ebx
; asm volatile("  \
c0103563:	8b 45 08 	movl	8(%ebp), %eax
c0103566:	8b 55 0c 	movl	12(%ebp), %edx
c0103569:	89 c3 	movl	%eax, %ebx
c010356b:	89 d1 	movl	%edx, %ecx
c010356d:	b8 09 00 00 00 	movl	$9, %eax
c0103572:	cd 50 	int	$80
; }
c0103574:	90 	nop
c0103575:	5b 	popl	%ebx
c0103576:	5d 	popl	%ebp
c0103577:	c3 	retl

createTaskCr3Param:
; void createTaskCr3Param(void* task,void* cr3,uint32_t param1,uint32_t param2) {
c0103578:	55 	pushl	%ebp
c0103579:	89 e5 	movl	%esp, %ebp
c010357b:	56 	pushl	%esi
c010357c:	53 	pushl	%ebx
; asm volatile("  \
c010357d:	8b 45 08 	movl	8(%ebp), %eax
c0103580:	8b 4d 0c 	movl	12(%ebp), %ecx
c0103583:	8b 55 10 	movl	16(%ebp), %edx
c0103586:	8b 75 14 	movl	20(%ebp), %esi
c0103589:	89 c3 	movl	%eax, %ebx
c010358b:	b8 0c 00 00 00 	movl	$12, %eax
c0103590:	cd 50 	int	$80
; }
c0103592:	90 	nop
c0103593:	5b 	popl	%ebx
c0103594:	5e 	popl	%esi
c0103595:	5d 	popl	%ebp
c0103596:	c3 	retl
