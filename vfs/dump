
vfs:     file format elf32-i386


Disassembly of section .init:

08048074 <.init>:
 8048074:	e8 d0 00 00 00       	call   8048149 <_start+0xb9>
 8048079:	e8 fc ff ff ff       	call   804807a <_start-0x16>
 804807e:	c2 00 00             	ret    0x0

Disassembly of section .text:

08048090 <_start>:
 8048090:	e8 93 17 00 00       	call   8049828 <__stdio_init>
 8048095:	e8 52 07 00 00       	call   80487ec <main>
 804809a:	6a 00                	push   0x0
 804809c:	e8 5d 25 00 00       	call   804a5fe <exit>
 80480a1:	c3                   	ret    
 80480a2:	66 90                	xchg   ax,ax
 80480a4:	b8 00 00 00 00       	mov    eax,0x0
 80480a9:	3d 00 00 00 00       	cmp    eax,0x0
 80480ae:	74 1c                	je     80480cc <_start+0x3c>
 80480b0:	b8 00 00 00 00       	mov    eax,0x0
 80480b5:	85 c0                	test   eax,eax
 80480b7:	74 13                	je     80480cc <_start+0x3c>
 80480b9:	55                   	push   ebp
 80480ba:	89 e5                	mov    ebp,esp
 80480bc:	83 ec 14             	sub    esp,0x14
 80480bf:	68 00 00 00 00       	push   0x0
 80480c4:	ff d0                	call   eax
 80480c6:	83 c4 10             	add    esp,0x10
 80480c9:	c9                   	leave  
 80480ca:	c3                   	ret    
 80480cb:	90                   	nop
 80480cc:	c3                   	ret    
 80480cd:	8d 76 00             	lea    esi,[esi+0x0]
 80480d0:	b8 00 00 00 00       	mov    eax,0x0
 80480d5:	2d 00 00 00 00       	sub    eax,0x0
 80480da:	89 c2                	mov    edx,eax
 80480dc:	c1 fa 02             	sar    edx,0x2
 80480df:	c1 e8 1f             	shr    eax,0x1f
 80480e2:	01 d0                	add    eax,edx
 80480e4:	d1 f8                	sar    eax,1
 80480e6:	74 1c                	je     8048104 <_start+0x74>
 80480e8:	ba 00 00 00 00       	mov    edx,0x0
 80480ed:	85 d2                	test   edx,edx
 80480ef:	74 13                	je     8048104 <_start+0x74>
 80480f1:	55                   	push   ebp
 80480f2:	89 e5                	mov    ebp,esp
 80480f4:	83 ec 10             	sub    esp,0x10
 80480f7:	50                   	push   eax
 80480f8:	68 00 00 00 00       	push   0x0
 80480fd:	ff d2                	call   edx
 80480ff:	83 c4 10             	add    esp,0x10
 8048102:	c9                   	leave  
 8048103:	c3                   	ret    
 8048104:	c3                   	ret    
 8048105:	8d 76 00             	lea    esi,[esi+0x0]
 8048108:	80 3d 00 00 00 00 00 	cmp    BYTE PTR ds:0x0,0x0
 804810f:	75 63                	jne    8048174 <_start+0xe4>
 8048111:	55                   	push   ebp
 8048112:	89 e5                	mov    ebp,esp
 8048114:	56                   	push   esi
 8048115:	53                   	push   ebx
 8048116:	bb 00 00 00 00       	mov    ebx,0x0
 804811b:	81 eb 00 00 00 00    	sub    ebx,0x0
 8048121:	c1 fb 02             	sar    ebx,0x2
 8048124:	4b                   	dec    ebx
 8048125:	be 00 00 00 00       	mov    esi,0x0
 804812a:	a1 04 00 00 00       	mov    eax,ds:0x4
 804812f:	39 d8                	cmp    eax,ebx
 8048131:	73 13                	jae    8048146 <_start+0xb6>
 8048133:	90                   	nop
 8048134:	40                   	inc    eax
 8048135:	a3 04 00 00 00       	mov    ds:0x4,eax
 804813a:	ff 14 86             	call   DWORD PTR [esi+eax*4]
 804813d:	a1 04 00 00 00       	mov    eax,ds:0x4
 8048142:	39 d8                	cmp    eax,ebx
 8048144:	72 ee                	jb     8048134 <_start+0xa4>
 8048146:	e8 59 ff ff ff       	call   80480a4 <_start+0x14>
 804814b:	b8 00 00 00 00       	mov    eax,0x0
 8048150:	85 c0                	test   eax,eax
 8048152:	74 10                	je     8048164 <_start+0xd4>
 8048154:	83 ec 0c             	sub    esp,0xc
 8048157:	68 00 00 00 00       	push   0x0
 804815c:	e8 fc ff ff ff       	call   804815d <_start+0xcd>
 8048161:	83 c4 10             	add    esp,0x10
 8048164:	c6 05 00 00 00 00 01 	mov    BYTE PTR ds:0x0,0x1
 804816b:	8d 65 f8             	lea    esp,[ebp-0x8]
 804816e:	5b                   	pop    ebx
 804816f:	5e                   	pop    esi
 8048170:	5d                   	pop    ebp
 8048171:	c3                   	ret    
 8048172:	66 90                	xchg   ax,ax
 8048174:	c3                   	ret    
 8048175:	8d 76 00             	lea    esi,[esi+0x0]
 8048178:	b8 00 00 00 00       	mov    eax,0x0
 804817d:	85 c0                	test   eax,eax
 804817f:	74 1f                	je     80481a0 <_start+0x110>
 8048181:	55                   	push   ebp
 8048182:	89 e5                	mov    ebp,esp
 8048184:	83 ec 10             	sub    esp,0x10
 8048187:	68 08 00 00 00       	push   0x8
 804818c:	68 00 00 00 00       	push   0x0
 8048191:	e8 fc ff ff ff       	call   8048192 <_start+0x102>
 8048196:	83 c4 10             	add    esp,0x10
 8048199:	c9                   	leave  
 804819a:	e9 31 ff ff ff       	jmp    80480d0 <_start+0x40>
 804819f:	90                   	nop
 80481a0:	e9 2b ff ff ff       	jmp    80480d0 <_start+0x40>

080481a5 <vfsstrcmp>:
  char* name;
  pid_t fs_pid;
  struct fs_type* next; 
} fs_type;

static int vfsstrcmp(const char* s1,const char* s2) {
 80481a5:	55                   	push   ebp
 80481a6:	89 e5                	mov    ebp,esp
 80481a8:	83 ec 10             	sub    esp,0x10
    int i;
    for (i = 0; s1[i] == s2[i]; i++) {
 80481ab:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [ebp-0x4],0x0
 80481b2:	eb 18                	jmp    80481cc <vfsstrcmp+0x27>
        if (s1[i] == '\0') return 0;
 80481b4:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 80481b7:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80481ba:	01 d0                	add    eax,edx
 80481bc:	8a 00                	mov    al,BYTE PTR [eax]
 80481be:	84 c0                	test   al,al
 80481c0:	75 07                	jne    80481c9 <vfsstrcmp+0x24>
 80481c2:	b8 00 00 00 00       	mov    eax,0x0
 80481c7:	eb 4e                	jmp    8048217 <vfsstrcmp+0x72>
    for (i = 0; s1[i] == s2[i]; i++) {
 80481c9:	ff 45 fc             	inc    DWORD PTR [ebp-0x4]
 80481cc:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 80481cf:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80481d2:	01 d0                	add    eax,edx
 80481d4:	8a 10                	mov    dl,BYTE PTR [eax]
 80481d6:	8b 4d fc             	mov    ecx,DWORD PTR [ebp-0x4]
 80481d9:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 80481dc:	01 c8                	add    eax,ecx
 80481de:	8a 00                	mov    al,BYTE PTR [eax]
 80481e0:	38 c2                	cmp    dl,al
 80481e2:	74 d0                	je     80481b4 <vfsstrcmp+0xf>
    }
    if (s1[i] == '\0') return 0;
 80481e4:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 80481e7:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80481ea:	01 d0                	add    eax,edx
 80481ec:	8a 00                	mov    al,BYTE PTR [eax]
 80481ee:	84 c0                	test   al,al
 80481f0:	75 07                	jne    80481f9 <vfsstrcmp+0x54>
 80481f2:	b8 00 00 00 00       	mov    eax,0x0
 80481f7:	eb 1e                	jmp    8048217 <vfsstrcmp+0x72>
    return s1[i] - s2[i];
 80481f9:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 80481fc:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80481ff:	01 d0                	add    eax,edx
 8048201:	8a 00                	mov    al,BYTE PTR [eax]
 8048203:	0f be d0             	movsx  edx,al
 8048206:	8b 4d fc             	mov    ecx,DWORD PTR [ebp-0x4]
 8048209:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804820c:	01 c8                	add    eax,ecx
 804820e:	8a 00                	mov    al,BYTE PTR [eax]
 8048210:	0f be c0             	movsx  eax,al
 8048213:	29 c2                	sub    edx,eax
 8048215:	89 d0                	mov    eax,edx
}
 8048217:	c9                   	leave  
 8048218:	c3                   	ret    

08048219 <vfs_mount>:

mount_point* mount_point_list=NULL;
fs_type* fs_type_list=NULL;

void vfs_mount(void* args) {
 8048219:	55                   	push   ebp
 804821a:	89 e5                	mov    ebp,esp
 804821c:	83 ec 48             	sub    esp,0x48
  serdes_state state;
  start_deserialize(args,&state);
 804821f:	83 ec 08             	sub    esp,0x8
 8048222:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048225:	50                   	push   eax
 8048226:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8048229:	e8 5e 15 00 00       	call   804978c <start_deserialize>
 804822e:	83 c4 10             	add    esp,0x10
  char* type=deserialize_str(&state);
 8048231:	83 ec 0c             	sub    esp,0xc
 8048234:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048237:	50                   	push   eax
 8048238:	e8 67 15 00 00       	call   80497a4 <deserialize_int>
 804823d:	83 c4 10             	add    esp,0x10
 8048240:	89 c2                	mov    edx,eax
 8048242:	83 ec 08             	sub    esp,0x8
 8048245:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048248:	50                   	push   eax
 8048249:	52                   	push   edx
 804824a:	e8 ad 15 00 00       	call   80497fc <deserialize_ary>
 804824f:	83 c4 10             	add    esp,0x10
 8048252:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
  char* dev=deserialize_str(&state);
 8048255:	83 ec 0c             	sub    esp,0xc
 8048258:	8d 45 c8             	lea    eax,[ebp-0x38]
 804825b:	50                   	push   eax
 804825c:	e8 43 15 00 00       	call   80497a4 <deserialize_int>
 8048261:	83 c4 10             	add    esp,0x10
 8048264:	89 c2                	mov    edx,eax
 8048266:	83 ec 08             	sub    esp,0x8
 8048269:	8d 45 c8             	lea    eax,[ebp-0x38]
 804826c:	50                   	push   eax
 804826d:	52                   	push   edx
 804826e:	e8 89 15 00 00       	call   80497fc <deserialize_ary>
 8048273:	83 c4 10             	add    esp,0x10
 8048276:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax
  char* mount_path=deserialize_str(&state);
 8048279:	83 ec 0c             	sub    esp,0xc
 804827c:	8d 45 c8             	lea    eax,[ebp-0x38]
 804827f:	50                   	push   eax
 8048280:	e8 1f 15 00 00       	call   80497a4 <deserialize_int>
 8048285:	83 c4 10             	add    esp,0x10
 8048288:	89 c2                	mov    edx,eax
 804828a:	83 ec 08             	sub    esp,0x8
 804828d:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048290:	50                   	push   eax
 8048291:	52                   	push   edx
 8048292:	e8 65 15 00 00       	call   80497fc <deserialize_ary>
 8048297:	83 c4 10             	add    esp,0x10
 804829a:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
  rpc_deallocate_buf(args,state.sizeorpos);
 804829d:	8b 45 cc             	mov    eax,DWORD PTR [ebp-0x34]
 80482a0:	83 ec 08             	sub    esp,0x8
 80482a3:	50                   	push   eax
 80482a4:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 80482a7:	e8 91 13 00 00       	call   804963d <rpc_deallocate_buf>
 80482ac:	83 c4 10             	add    esp,0x10
  fs_type* fstype=fs_type_list;
 80482af:	a1 44 c1 04 08       	mov    eax,ds:0x804c144
 80482b4:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  pid_t fs_pid=0;
 80482b7:	c7 45 f0 00 00 00 00 	mov    DWORD PTR [ebp-0x10],0x0
  for (;fstype!=NULL;fstype=fstype->next) {
 80482be:	eb 2c                	jmp    80482ec <vfs_mount+0xd3>
    if (vfsstrcmp(type,fstype->name)==0) {
 80482c0:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 80482c3:	8b 00                	mov    eax,DWORD PTR [eax]
 80482c5:	83 ec 08             	sub    esp,0x8
 80482c8:	50                   	push   eax
 80482c9:	ff 75 ec             	push   DWORD PTR [ebp-0x14]
 80482cc:	e8 d4 fe ff ff       	call   80481a5 <vfsstrcmp>
 80482d1:	83 c4 10             	add    esp,0x10
 80482d4:	85 c0                	test   eax,eax
 80482d6:	75 0b                	jne    80482e3 <vfs_mount+0xca>
      fs_pid=fstype->fs_pid;
 80482d8:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 80482db:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80482de:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
      break;
 80482e1:	eb 0f                	jmp    80482f2 <vfs_mount+0xd9>
  for (;fstype!=NULL;fstype=fstype->next) {
 80482e3:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 80482e6:	8b 40 08             	mov    eax,DWORD PTR [eax+0x8]
 80482e9:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
 80482ec:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 80482f0:	75 ce                	jne    80482c0 <vfs_mount+0xa7>
    }
  }
  if (!fs_pid) {
 80482f2:	83 7d f0 00          	cmp    DWORD PTR [ebp-0x10],0x0
 80482f6:	75 25                	jne    804831d <vfs_mount+0x104>
    int err=1;
 80482f8:	c7 45 c4 01 00 00 00 	mov    DWORD PTR [ebp-0x3c],0x1
    rpc_return(&err,sizeof(int));
 80482ff:	83 ec 08             	sub    esp,0x8
 8048302:	6a 04                	push   0x4
 8048304:	8d 45 c4             	lea    eax,[ebp-0x3c]
 8048307:	50                   	push   eax
 8048308:	e8 49 13 00 00       	call   8049656 <rpc_return>
 804830d:	83 c4 10             	add    esp,0x10
    pthread_exit(NULL);
 8048310:	83 ec 0c             	sub    esp,0xc
 8048313:	6a 00                	push   0x0
 8048315:	e8 84 12 00 00       	call   804959e <pthread_exit>
 804831a:	83 c4 10             	add    esp,0x10
  }
  char* retbuf=rpc_call(fs_pid,"mount",dev,strlen(dev)+1);
 804831d:	83 ec 0c             	sub    esp,0xc
 8048320:	ff 75 e8             	push   DWORD PTR [ebp-0x18]
 8048323:	e8 c5 1e 00 00       	call   804a1ed <strlen>
 8048328:	83 c4 10             	add    esp,0x10
 804832b:	40                   	inc    eax
 804832c:	50                   	push   eax
 804832d:	ff 75 e8             	push   DWORD PTR [ebp-0x18]
 8048330:	68 ad a6 04 08       	push   0x804a6ad
 8048335:	ff 75 f0             	push   DWORD PTR [ebp-0x10]
 8048338:	e8 b9 12 00 00       	call   80495f6 <rpc_call>
 804833d:	83 c4 10             	add    esp,0x10
 8048340:	89 45 e0             	mov    DWORD PTR [ebp-0x20],eax
  start_deserialize(retbuf,&state);
 8048343:	83 ec 08             	sub    esp,0x8
 8048346:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048349:	50                   	push   eax
 804834a:	ff 75 e0             	push   DWORD PTR [ebp-0x20]
 804834d:	e8 3a 14 00 00       	call   804978c <start_deserialize>
 8048352:	83 c4 10             	add    esp,0x10
  int err=deserialize_int(&state);
 8048355:	83 ec 0c             	sub    esp,0xc
 8048358:	8d 45 c8             	lea    eax,[ebp-0x38]
 804835b:	50                   	push   eax
 804835c:	e8 43 14 00 00       	call   80497a4 <deserialize_int>
 8048361:	83 c4 10             	add    esp,0x10
 8048364:	89 45 dc             	mov    DWORD PTR [ebp-0x24],eax
  void* data=deserialize_ptr(&state);
 8048367:	83 ec 0c             	sub    esp,0xc
 804836a:	8d 45 c8             	lea    eax,[ebp-0x38]
 804836d:	50                   	push   eax
 804836e:	e8 5d 14 00 00       	call   80497d0 <deserialize_ptr>
 8048373:	83 c4 10             	add    esp,0x10
 8048376:	89 45 d8             	mov    DWORD PTR [ebp-0x28],eax
  rpc_deallocate_buf(retbuf, state.sizeorpos);
 8048379:	8b 45 cc             	mov    eax,DWORD PTR [ebp-0x34]
 804837c:	83 ec 08             	sub    esp,0x8
 804837f:	50                   	push   eax
 8048380:	ff 75 e0             	push   DWORD PTR [ebp-0x20]
 8048383:	e8 b5 12 00 00       	call   804963d <rpc_deallocate_buf>
 8048388:	83 c4 10             	add    esp,0x10
  int* errbuf=malloc(sizeof(int));
 804838b:	83 ec 0c             	sub    esp,0xc
 804838e:	6a 04                	push   0x4
 8048390:	e8 48 06 00 00       	call   80489dd <malloc>
 8048395:	83 c4 10             	add    esp,0x10
 8048398:	89 45 d4             	mov    DWORD PTR [ebp-0x2c],eax
  *errbuf=err;
 804839b:	8b 45 d4             	mov    eax,DWORD PTR [ebp-0x2c]
 804839e:	8b 55 dc             	mov    edx,DWORD PTR [ebp-0x24]
 80483a1:	89 10                	mov    DWORD PTR [eax],edx
  if (err) {
 80483a3:	83 7d dc 00          	cmp    DWORD PTR [ebp-0x24],0x0
 80483a7:	74 2b                	je     80483d4 <vfs_mount+0x1bb>
    rpc_return(errbuf,sizeof(int));
 80483a9:	83 ec 08             	sub    esp,0x8
 80483ac:	6a 04                	push   0x4
 80483ae:	ff 75 d4             	push   DWORD PTR [ebp-0x2c]
 80483b1:	e8 a0 12 00 00       	call   8049656 <rpc_return>
 80483b6:	83 c4 10             	add    esp,0x10
    free(errbuf);
 80483b9:	83 ec 0c             	sub    esp,0xc
 80483bc:	ff 75 d4             	push   DWORD PTR [ebp-0x2c]
 80483bf:	e8 a5 0c 00 00       	call   8049069 <free>
 80483c4:	83 c4 10             	add    esp,0x10
    pthread_exit(NULL);
 80483c7:	83 ec 0c             	sub    esp,0xc
 80483ca:	6a 00                	push   0x0
 80483cc:	e8 cd 11 00 00       	call   804959e <pthread_exit>
 80483d1:	83 c4 10             	add    esp,0x10
  } 
  mount_point* mnt_pnt=malloc(sizeof(mnt_pnt));
 80483d4:	83 ec 0c             	sub    esp,0xc
 80483d7:	6a 04                	push   0x4
 80483d9:	e8 ff 05 00 00       	call   80489dd <malloc>
 80483de:	83 c4 10             	add    esp,0x10
 80483e1:	89 45 d0             	mov    DWORD PTR [ebp-0x30],eax
  mnt_pnt->fs_data=data;
 80483e4:	8b 45 d0             	mov    eax,DWORD PTR [ebp-0x30]
 80483e7:	8b 55 d8             	mov    edx,DWORD PTR [ebp-0x28]
 80483ea:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
  mnt_pnt->fs_pid=fs_pid;
 80483ed:	8b 45 d0             	mov    eax,DWORD PTR [ebp-0x30]
 80483f0:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
 80483f3:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
  mnt_pnt->path=mount_path;
 80483f6:	8b 45 d0             	mov    eax,DWORD PTR [ebp-0x30]
 80483f9:	8b 55 e4             	mov    edx,DWORD PTR [ebp-0x1c]
 80483fc:	89 10                	mov    DWORD PTR [eax],edx
  mnt_pnt->next=mount_point_list;
 80483fe:	8b 15 40 c1 04 08    	mov    edx,DWORD PTR ds:0x804c140
 8048404:	8b 45 d0             	mov    eax,DWORD PTR [ebp-0x30]
 8048407:	89 50 0c             	mov    DWORD PTR [eax+0xc],edx
  mount_point_list=mnt_pnt;
 804840a:	8b 45 d0             	mov    eax,DWORD PTR [ebp-0x30]
 804840d:	a3 40 c1 04 08       	mov    ds:0x804c140,eax
  rpc_return(errbuf,sizeof(int));
 8048412:	83 ec 08             	sub    esp,0x8
 8048415:	6a 04                	push   0x4
 8048417:	ff 75 d4             	push   DWORD PTR [ebp-0x2c]
 804841a:	e8 37 12 00 00       	call   8049656 <rpc_return>
 804841f:	83 c4 10             	add    esp,0x10
  free(errbuf);
 8048422:	83 ec 0c             	sub    esp,0xc
 8048425:	ff 75 d4             	push   DWORD PTR [ebp-0x2c]
 8048428:	e8 3c 0c 00 00       	call   8049069 <free>
 804842d:	83 c4 10             	add    esp,0x10
  pthread_exit(NULL);
 8048430:	83 ec 0c             	sub    esp,0xc
 8048433:	6a 00                	push   0x0
 8048435:	e8 64 11 00 00       	call   804959e <pthread_exit>
 804843a:	83 c4 10             	add    esp,0x10
}
 804843d:	90                   	nop
 804843e:	c9                   	leave  
 804843f:	c3                   	ret    

08048440 <vfs_register_fs>:

void vfs_register_fs(void* args) {
 8048440:	55                   	push   ebp
 8048441:	89 e5                	mov    ebp,esp
 8048443:	83 ec 28             	sub    esp,0x28
  serdes_state state;
  start_deserialize(args,&state);
 8048446:	83 ec 08             	sub    esp,0x8
 8048449:	8d 45 e4             	lea    eax,[ebp-0x1c]
 804844c:	50                   	push   eax
 804844d:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8048450:	e8 37 13 00 00       	call   804978c <start_deserialize>
 8048455:	83 c4 10             	add    esp,0x10
  char* name=deserialize_str(&state);
 8048458:	83 ec 0c             	sub    esp,0xc
 804845b:	8d 45 e4             	lea    eax,[ebp-0x1c]
 804845e:	50                   	push   eax
 804845f:	e8 40 13 00 00       	call   80497a4 <deserialize_int>
 8048464:	83 c4 10             	add    esp,0x10
 8048467:	89 c2                	mov    edx,eax
 8048469:	83 ec 08             	sub    esp,0x8
 804846c:	8d 45 e4             	lea    eax,[ebp-0x1c]
 804846f:	50                   	push   eax
 8048470:	52                   	push   edx
 8048471:	e8 86 13 00 00       	call   80497fc <deserialize_ary>
 8048476:	83 c4 10             	add    esp,0x10
 8048479:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  pid_t pid=deserialize_int(&state);
 804847c:	83 ec 0c             	sub    esp,0xc
 804847f:	8d 45 e4             	lea    eax,[ebp-0x1c]
 8048482:	50                   	push   eax
 8048483:	e8 1c 13 00 00       	call   80497a4 <deserialize_int>
 8048488:	83 c4 10             	add    esp,0x10
 804848b:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
  fs_type* type=malloc(sizeof(fs_type));
 804848e:	83 ec 0c             	sub    esp,0xc
 8048491:	6a 0c                	push   0xc
 8048493:	e8 45 05 00 00       	call   80489dd <malloc>
 8048498:	83 c4 10             	add    esp,0x10
 804849b:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
  rpc_deallocate_buf(args,state.sizeorpos);
 804849e:	8b 45 e8             	mov    eax,DWORD PTR [ebp-0x18]
 80484a1:	83 ec 08             	sub    esp,0x8
 80484a4:	50                   	push   eax
 80484a5:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 80484a8:	e8 90 11 00 00       	call   804963d <rpc_deallocate_buf>
 80484ad:	83 c4 10             	add    esp,0x10
  type->name=name;
 80484b0:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80484b3:	8b 55 f4             	mov    edx,DWORD PTR [ebp-0xc]
 80484b6:	89 10                	mov    DWORD PTR [eax],edx
  type->fs_pid=pid;
 80484b8:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80484bb:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
 80484be:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
  type->next=fs_type_list;
 80484c1:	8b 15 44 c1 04 08    	mov    edx,DWORD PTR ds:0x804c144
 80484c7:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80484ca:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
  fs_type_list=type;
 80484cd:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80484d0:	a3 44 c1 04 08       	mov    ds:0x804c144,eax
  rpc_return(NULL,0);
 80484d5:	83 ec 08             	sub    esp,0x8
 80484d8:	6a 00                	push   0x0
 80484da:	6a 00                	push   0x0
 80484dc:	e8 75 11 00 00       	call   8049656 <rpc_return>
 80484e1:	83 c4 10             	add    esp,0x10
  pthread_exit(NULL);
 80484e4:	83 ec 0c             	sub    esp,0xc
 80484e7:	6a 00                	push   0x0
 80484e9:	e8 b0 10 00 00       	call   804959e <pthread_exit>
 80484ee:	83 c4 10             	add    esp,0x10
}
 80484f1:	90                   	nop
 80484f2:	c9                   	leave  
 80484f3:	c3                   	ret    

080484f4 <open>:

void open(void* args) {
 80484f4:	55                   	push   ebp
 80484f5:	89 e5                	mov    ebp,esp
 80484f7:	53                   	push   ebx
 80484f8:	83 ec 34             	sub    esp,0x34
  serdes_state state;
  start_deserialize(args,&state);
 80484fb:	83 ec 08             	sub    esp,0x8
 80484fe:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048501:	50                   	push   eax
 8048502:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8048505:	e8 82 12 00 00       	call   804978c <start_deserialize>
 804850a:	83 c4 10             	add    esp,0x10
  char* path=deserialize_str(&state);
 804850d:	83 ec 0c             	sub    esp,0xc
 8048510:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048513:	50                   	push   eax
 8048514:	e8 8b 12 00 00       	call   80497a4 <deserialize_int>
 8048519:	83 c4 10             	add    esp,0x10
 804851c:	89 c2                	mov    edx,eax
 804851e:	83 ec 08             	sub    esp,0x8
 8048521:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048524:	50                   	push   eax
 8048525:	52                   	push   edx
 8048526:	e8 d1 12 00 00       	call   80497fc <deserialize_ary>
 804852b:	83 c4 10             	add    esp,0x10
 804852e:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax
  rpc_deallocate_buf(args,state.sizeorpos);
 8048531:	8b 45 cc             	mov    eax,DWORD PTR [ebp-0x34]
 8048534:	83 ec 08             	sub    esp,0x8
 8048537:	50                   	push   eax
 8048538:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804853b:	e8 fd 10 00 00       	call   804963d <rpc_deallocate_buf>
 8048540:	83 c4 10             	add    esp,0x10
  mount_point* mnt=mount_point_list;
 8048543:	a1 40 c1 04 08       	mov    eax,ds:0x804c140
 8048548:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  mount_point* mnt_pnt=NULL;
 804854b:	c7 45 f0 00 00 00 00 	mov    DWORD PTR [ebp-0x10],0x0
  size_t mntpnt_len=0;
 8048552:	c7 45 ec 00 00 00 00 	mov    DWORD PTR [ebp-0x14],0x0
  for (;mnt!=NULL;mnt=mnt->next) {
 8048559:	eb 50                	jmp    80485ab <open+0xb7>
    char* root=mnt->path;
 804855b:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 804855e:	8b 00                	mov    eax,DWORD PTR [eax]
 8048560:	89 45 d0             	mov    DWORD PTR [ebp-0x30],eax
    if (strlen(root)>mntpnt_len) {
 8048563:	83 ec 0c             	sub    esp,0xc
 8048566:	ff 75 d0             	push   DWORD PTR [ebp-0x30]
 8048569:	e8 7f 1c 00 00       	call   804a1ed <strlen>
 804856e:	83 c4 10             	add    esp,0x10
 8048571:	39 45 ec             	cmp    DWORD PTR [ebp-0x14],eax
 8048574:	73 2c                	jae    80485a2 <open+0xae>
      if (vfsstrcmp(root,path)==0) {
 8048576:	83 ec 08             	sub    esp,0x8
 8048579:	ff 75 e8             	push   DWORD PTR [ebp-0x18]
 804857c:	ff 75 d0             	push   DWORD PTR [ebp-0x30]
 804857f:	e8 21 fc ff ff       	call   80481a5 <vfsstrcmp>
 8048584:	83 c4 10             	add    esp,0x10
 8048587:	85 c0                	test   eax,eax
 8048589:	75 17                	jne    80485a2 <open+0xae>
        mnt_pnt=mnt;
 804858b:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 804858e:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
        mntpnt_len=strlen(root);
 8048591:	83 ec 0c             	sub    esp,0xc
 8048594:	ff 75 d0             	push   DWORD PTR [ebp-0x30]
 8048597:	e8 51 1c 00 00       	call   804a1ed <strlen>
 804859c:	83 c4 10             	add    esp,0x10
 804859f:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
  for (;mnt!=NULL;mnt=mnt->next) {
 80485a2:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 80485a5:	8b 40 0c             	mov    eax,DWORD PTR [eax+0xc]
 80485a8:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
 80485ab:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 80485af:	75 aa                	jne    804855b <open+0x67>
      }
    }
  }
  if (mnt_pnt==NULL) {
 80485b1:	83 7d f0 00          	cmp    DWORD PTR [ebp-0x10],0x0
 80485b5:	0f 85 80 00 00 00    	jne    804863b <open+0x147>
    serial_print("NO MOUNTPOINT\n");
 80485bb:	83 ec 0c             	sub    esp,0xc
 80485be:	68 b3 a6 04 08       	push   0x804a6b3
 80485c3:	e8 86 02 00 00       	call   804884e <serial_print>
 80485c8:	83 c4 10             	add    esp,0x10
    state.buf=NULL;
 80485cb:	c7 45 c8 00 00 00 00 	mov    DWORD PTR [ebp-0x38],0x0
    state.sizeorpos=0;
 80485d2:	c7 45 cc 00 00 00 00 	mov    DWORD PTR [ebp-0x34],0x0
    serialize_int(1,&state);
 80485d9:	83 ec 08             	sub    esp,0x8
 80485dc:	8d 45 c8             	lea    eax,[ebp-0x38]
 80485df:	50                   	push   eax
 80485e0:	6a 01                	push   0x1
 80485e2:	e8 b6 10 00 00       	call   804969d <serialize_int>
 80485e7:	83 c4 10             	add    esp,0x10
    serialize_ptr(NULL,&state);
 80485ea:	83 ec 08             	sub    esp,0x8
 80485ed:	8d 45 c8             	lea    eax,[ebp-0x38]
 80485f0:	50                   	push   eax
 80485f1:	6a 00                	push   0x0
 80485f3:	e8 ef 10 00 00       	call   80496e7 <serialize_ptr>
 80485f8:	83 c4 10             	add    esp,0x10
    serialize_int(0,&state);
 80485fb:	83 ec 08             	sub    esp,0x8
 80485fe:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048601:	50                   	push   eax
 8048602:	6a 00                	push   0x0
 8048604:	e8 94 10 00 00       	call   804969d <serialize_int>
 8048609:	83 c4 10             	add    esp,0x10
    rpc_return(state.buf,state.sizeorpos);
 804860c:	8b 55 cc             	mov    edx,DWORD PTR [ebp-0x34]
 804860f:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048612:	83 ec 08             	sub    esp,0x8
 8048615:	52                   	push   edx
 8048616:	50                   	push   eax
 8048617:	e8 3a 10 00 00       	call   8049656 <rpc_return>
 804861c:	83 c4 10             	add    esp,0x10
    free(state.buf);
 804861f:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048622:	83 ec 0c             	sub    esp,0xc
 8048625:	50                   	push   eax
 8048626:	e8 3e 0a 00 00       	call   8049069 <free>
 804862b:	83 c4 10             	add    esp,0x10
    pthread_exit(NULL);
 804862e:	83 ec 0c             	sub    esp,0xc
 8048631:	6a 00                	push   0x0
 8048633:	e8 66 0f 00 00       	call   804959e <pthread_exit>
 8048638:	83 c4 10             	add    esp,0x10
  }
  state.buf=NULL;
 804863b:	c7 45 c8 00 00 00 00 	mov    DWORD PTR [ebp-0x38],0x0
  state.sizeorpos=0;
 8048642:	c7 45 cc 00 00 00 00 	mov    DWORD PTR [ebp-0x34],0x0
  serialize_str(path+(strlen(mnt_pnt->path)+1),&state);
 8048649:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 804864c:	8b 00                	mov    eax,DWORD PTR [eax]
 804864e:	83 ec 0c             	sub    esp,0xc
 8048651:	50                   	push   eax
 8048652:	e8 96 1b 00 00       	call   804a1ed <strlen>
 8048657:	83 c4 10             	add    esp,0x10
 804865a:	8d 50 01             	lea    edx,[eax+0x1]
 804865d:	8b 45 e8             	mov    eax,DWORD PTR [ebp-0x18]
 8048660:	01 d0                	add    eax,edx
 8048662:	83 ec 0c             	sub    esp,0xc
 8048665:	50                   	push   eax
 8048666:	e8 82 1b 00 00       	call   804a1ed <strlen>
 804866b:	83 c4 10             	add    esp,0x10
 804866e:	40                   	inc    eax
 804866f:	89 c2                	mov    edx,eax
 8048671:	83 ec 08             	sub    esp,0x8
 8048674:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048677:	50                   	push   eax
 8048678:	52                   	push   edx
 8048679:	e8 1f 10 00 00       	call   804969d <serialize_int>
 804867e:	83 c4 10             	add    esp,0x10
 8048681:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8048684:	8b 00                	mov    eax,DWORD PTR [eax]
 8048686:	83 ec 0c             	sub    esp,0xc
 8048689:	50                   	push   eax
 804868a:	e8 5e 1b 00 00       	call   804a1ed <strlen>
 804868f:	83 c4 10             	add    esp,0x10
 8048692:	8d 50 01             	lea    edx,[eax+0x1]
 8048695:	8b 45 e8             	mov    eax,DWORD PTR [ebp-0x18]
 8048698:	01 d0                	add    eax,edx
 804869a:	83 ec 0c             	sub    esp,0xc
 804869d:	50                   	push   eax
 804869e:	e8 4a 1b 00 00       	call   804a1ed <strlen>
 80486a3:	83 c4 10             	add    esp,0x10
 80486a6:	8d 58 01             	lea    ebx,[eax+0x1]
 80486a9:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80486ac:	8b 00                	mov    eax,DWORD PTR [eax]
 80486ae:	83 ec 0c             	sub    esp,0xc
 80486b1:	50                   	push   eax
 80486b2:	e8 36 1b 00 00       	call   804a1ed <strlen>
 80486b7:	83 c4 10             	add    esp,0x10
 80486ba:	8d 50 01             	lea    edx,[eax+0x1]
 80486bd:	8b 45 e8             	mov    eax,DWORD PTR [ebp-0x18]
 80486c0:	01 c2                	add    edx,eax
 80486c2:	83 ec 04             	sub    esp,0x4
 80486c5:	8d 45 c8             	lea    eax,[ebp-0x38]
 80486c8:	50                   	push   eax
 80486c9:	53                   	push   ebx
 80486ca:	52                   	push   edx
 80486cb:	e8 61 10 00 00       	call   8049731 <serialize_ary>
 80486d0:	83 c4 10             	add    esp,0x10
  serialize_ptr(mnt_pnt->fs_data,&state);
 80486d3:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80486d6:	8b 40 08             	mov    eax,DWORD PTR [eax+0x8]
 80486d9:	83 ec 08             	sub    esp,0x8
 80486dc:	8d 55 c8             	lea    edx,[ebp-0x38]
 80486df:	52                   	push   edx
 80486e0:	50                   	push   eax
 80486e1:	e8 01 10 00 00       	call   80496e7 <serialize_ptr>
 80486e6:	83 c4 10             	add    esp,0x10
  char* retbuf=rpc_call(mnt_pnt->fs_pid,"open",state.buf,state.sizeorpos);
 80486e9:	8b 4d cc             	mov    ecx,DWORD PTR [ebp-0x34]
 80486ec:	8b 55 c8             	mov    edx,DWORD PTR [ebp-0x38]
 80486ef:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80486f2:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80486f5:	51                   	push   ecx
 80486f6:	52                   	push   edx
 80486f7:	68 c2 a6 04 08       	push   0x804a6c2
 80486fc:	50                   	push   eax
 80486fd:	e8 f4 0e 00 00       	call   80495f6 <rpc_call>
 8048702:	83 c4 10             	add    esp,0x10
 8048705:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
  free(state.buf);
 8048708:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 804870b:	83 ec 0c             	sub    esp,0xc
 804870e:	50                   	push   eax
 804870f:	e8 55 09 00 00       	call   8049069 <free>
 8048714:	83 c4 10             	add    esp,0x10
  start_deserialize(retbuf,&state);
 8048717:	83 ec 08             	sub    esp,0x8
 804871a:	8d 45 c8             	lea    eax,[ebp-0x38]
 804871d:	50                   	push   eax
 804871e:	ff 75 e4             	push   DWORD PTR [ebp-0x1c]
 8048721:	e8 66 10 00 00       	call   804978c <start_deserialize>
 8048726:	83 c4 10             	add    esp,0x10
  int err=deserialize_int(&state);
 8048729:	83 ec 0c             	sub    esp,0xc
 804872c:	8d 45 c8             	lea    eax,[ebp-0x38]
 804872f:	50                   	push   eax
 8048730:	e8 6f 10 00 00       	call   80497a4 <deserialize_int>
 8048735:	83 c4 10             	add    esp,0x10
 8048738:	89 45 e0             	mov    DWORD PTR [ebp-0x20],eax
  void* data=deserialize_ptr(&state);
 804873b:	83 ec 0c             	sub    esp,0xc
 804873e:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048741:	50                   	push   eax
 8048742:	e8 89 10 00 00       	call   80497d0 <deserialize_ptr>
 8048747:	83 c4 10             	add    esp,0x10
 804874a:	89 45 dc             	mov    DWORD PTR [ebp-0x24],eax
  pid_t alt_pid=deserialize_int(&state);
 804874d:	83 ec 0c             	sub    esp,0xc
 8048750:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048753:	50                   	push   eax
 8048754:	e8 4b 10 00 00       	call   80497a4 <deserialize_int>
 8048759:	83 c4 10             	add    esp,0x10
 804875c:	89 45 d8             	mov    DWORD PTR [ebp-0x28],eax
  pid_t fs_pid = alt_pid ? alt_pid : mnt_pnt->fs_pid;
 804875f:	83 7d d8 00          	cmp    DWORD PTR [ebp-0x28],0x0
 8048763:	75 08                	jne    804876d <open+0x279>
 8048765:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8048768:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 804876b:	eb 03                	jmp    8048770 <open+0x27c>
 804876d:	8b 45 d8             	mov    eax,DWORD PTR [ebp-0x28]
 8048770:	89 45 d4             	mov    DWORD PTR [ebp-0x2c],eax
  state.buf=NULL;
 8048773:	c7 45 c8 00 00 00 00 	mov    DWORD PTR [ebp-0x38],0x0
  state.sizeorpos=0;
 804877a:	c7 45 cc 00 00 00 00 	mov    DWORD PTR [ebp-0x34],0x0
  serialize_int(err,&state);
 8048781:	83 ec 08             	sub    esp,0x8
 8048784:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048787:	50                   	push   eax
 8048788:	ff 75 e0             	push   DWORD PTR [ebp-0x20]
 804878b:	e8 0d 0f 00 00       	call   804969d <serialize_int>
 8048790:	83 c4 10             	add    esp,0x10
  serialize_ptr(data,&state);
 8048793:	83 ec 08             	sub    esp,0x8
 8048796:	8d 45 c8             	lea    eax,[ebp-0x38]
 8048799:	50                   	push   eax
 804879a:	ff 75 dc             	push   DWORD PTR [ebp-0x24]
 804879d:	e8 45 0f 00 00       	call   80496e7 <serialize_ptr>
 80487a2:	83 c4 10             	add    esp,0x10
  serialize_int(fs_pid,&state);
 80487a5:	83 ec 08             	sub    esp,0x8
 80487a8:	8d 45 c8             	lea    eax,[ebp-0x38]
 80487ab:	50                   	push   eax
 80487ac:	ff 75 d4             	push   DWORD PTR [ebp-0x2c]
 80487af:	e8 e9 0e 00 00       	call   804969d <serialize_int>
 80487b4:	83 c4 10             	add    esp,0x10
  rpc_return(state.buf,state.sizeorpos);
 80487b7:	8b 55 cc             	mov    edx,DWORD PTR [ebp-0x34]
 80487ba:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 80487bd:	83 ec 08             	sub    esp,0x8
 80487c0:	52                   	push   edx
 80487c1:	50                   	push   eax
 80487c2:	e8 8f 0e 00 00       	call   8049656 <rpc_return>
 80487c7:	83 c4 10             	add    esp,0x10
  free(state.buf);
 80487ca:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 80487cd:	83 ec 0c             	sub    esp,0xc
 80487d0:	50                   	push   eax
 80487d1:	e8 93 08 00 00       	call   8049069 <free>
 80487d6:	83 c4 10             	add    esp,0x10
  pthread_exit(NULL);
 80487d9:	83 ec 0c             	sub    esp,0xc
 80487dc:	6a 00                	push   0x0
 80487de:	e8 bb 0d 00 00       	call   804959e <pthread_exit>
 80487e3:	83 c4 10             	add    esp,0x10
}
 80487e6:	90                   	nop
 80487e7:	8b 5d fc             	mov    ebx,DWORD PTR [ebp-0x4]
 80487ea:	c9                   	leave  
 80487eb:	c3                   	ret    

080487ec <main>:

int main() {
 80487ec:	8d 4c 24 04          	lea    ecx,[esp+0x4]
 80487f0:	83 e4 f0             	and    esp,0xfffffff0
 80487f3:	ff 71 fc             	push   DWORD PTR [ecx-0x4]
 80487f6:	55                   	push   ebp
 80487f7:	89 e5                	mov    ebp,esp
 80487f9:	51                   	push   ecx
 80487fa:	83 ec 04             	sub    esp,0x4
  rpc_register_func("mount",&vfs_mount);
 80487fd:	83 ec 08             	sub    esp,0x8
 8048800:	68 19 82 04 08       	push   0x8048219
 8048805:	68 ad a6 04 08       	push   0x804a6ad
 804880a:	e8 15 0e 00 00       	call   8049624 <rpc_register_func>
 804880f:	83 c4 10             	add    esp,0x10
  rpc_register_func("open",&open);
 8048812:	83 ec 08             	sub    esp,0x8
 8048815:	68 f4 84 04 08       	push   0x80484f4
 804881a:	68 c2 a6 04 08       	push   0x804a6c2
 804881f:	e8 00 0e 00 00       	call   8049624 <rpc_register_func>
 8048824:	83 c4 10             	add    esp,0x10
  rpc_register_func("register_fs",&vfs_register_fs);
 8048827:	83 ec 08             	sub    esp,0x8
 804882a:	68 40 84 04 08       	push   0x8048440
 804882f:	68 c7 a6 04 08       	push   0x804a6c7
 8048834:	e8 eb 0d 00 00       	call   8049624 <rpc_register_func>
 8048839:	83 c4 10             	add    esp,0x10
  rpc_mark_as_init();
 804883c:	e8 2e 0e 00 00       	call   804966f <rpc_mark_as_init>
 8048841:	b8 00 00 00 00       	mov    eax,0x0
}
 8048846:	8b 4d fc             	mov    ecx,DWORD PTR [ebp-0x4]
 8048849:	c9                   	leave  
 804884a:	8d 61 fc             	lea    esp,[ecx-0x4]
 804884d:	c3                   	ret    

0804884e <serial_print>:
#include <sys/syscalls.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void serial_print(char* str) {
 804884e:	55                   	push   ebp
 804884f:	89 e5                	mov    ebp,esp
 8048851:	53                   	push   ebx
  asm volatile("  \
 8048852:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8048855:	89 c3                	mov    ebx,eax
 8048857:	b8 0b 00 00 00       	mov    eax,0xb
 804885c:	cd 50                	int    0x50
    mov $" QU(SYSCALL_SERIAL_PRINT) ", %%eax; \
    int $80; \
  "::"b"(str));
}
 804885e:	90                   	nop
 804885f:	5b                   	pop    ebx
 8048860:	5d                   	pop    ebp
 8048861:	c3                   	ret    

08048862 <liballoc_memset>:


// ***********   HELPER FUNCTIONS  *******************************

static void *liballoc_memset(void* s, int c, size_t n)
{
 8048862:	55                   	push   ebp
 8048863:	89 e5                	mov    ebp,esp
 8048865:	83 ec 10             	sub    esp,0x10
	unsigned int i;
	for ( i = 0; i < n ; i++)
 8048868:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [ebp-0x4],0x0
 804886f:	eb 10                	jmp    8048881 <liballoc_memset+0x1f>
		((char*)s)[i] = c;
 8048871:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 8048874:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 8048877:	01 d0                	add    eax,edx
 8048879:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 804887c:	88 10                	mov    BYTE PTR [eax],dl
	for ( i = 0; i < n ; i++)
 804887e:	ff 45 fc             	inc    DWORD PTR [ebp-0x4]
 8048881:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 8048884:	3b 45 10             	cmp    eax,DWORD PTR [ebp+0x10]
 8048887:	72 e8                	jb     8048871 <liballoc_memset+0xf>
	
	return s;
 8048889:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
}
 804888c:	c9                   	leave  
 804888d:	c3                   	ret    

0804888e <liballoc_memcpy>:
static void* liballoc_memcpy(void* s1, const void* s2, size_t n)
{
 804888e:	55                   	push   ebp
 804888f:	89 e5                	mov    ebp,esp
 8048891:	83 ec 10             	sub    esp,0x10
  char *cdest;
  char *csrc;
  unsigned int *ldest = (unsigned int*)s1;
 8048894:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8048897:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  unsigned int *lsrc  = (unsigned int*)s2;
 804889a:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804889d:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax

  while ( n >= sizeof(unsigned int) )
 80488a0:	eb 1a                	jmp    80488bc <liballoc_memcpy+0x2e>
  {
      *ldest++ = *lsrc++;
 80488a2:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
 80488a5:	8d 42 04             	lea    eax,[edx+0x4]
 80488a8:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
 80488ab:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 80488ae:	8d 48 04             	lea    ecx,[eax+0x4]
 80488b1:	89 4d f4             	mov    DWORD PTR [ebp-0xc],ecx
 80488b4:	8b 12                	mov    edx,DWORD PTR [edx]
 80488b6:	89 10                	mov    DWORD PTR [eax],edx
	  n -= sizeof(unsigned int);
 80488b8:	83 6d 10 04          	sub    DWORD PTR [ebp+0x10],0x4
  while ( n >= sizeof(unsigned int) )
 80488bc:	83 7d 10 03          	cmp    DWORD PTR [ebp+0x10],0x3
 80488c0:	77 e0                	ja     80488a2 <liballoc_memcpy+0x14>
  }

  cdest = (char*)ldest;
 80488c2:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 80488c5:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
  csrc  = (char*)lsrc;
 80488c8:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80488cb:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
  
  while ( n > 0 )
 80488ce:	eb 19                	jmp    80488e9 <liballoc_memcpy+0x5b>
  {
      *cdest++ = *csrc++;
 80488d0:	8b 55 f8             	mov    edx,DWORD PTR [ebp-0x8]
 80488d3:	8d 42 01             	lea    eax,[edx+0x1]
 80488d6:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
 80488d9:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 80488dc:	8d 48 01             	lea    ecx,[eax+0x1]
 80488df:	89 4d fc             	mov    DWORD PTR [ebp-0x4],ecx
 80488e2:	8a 12                	mov    dl,BYTE PTR [edx]
 80488e4:	88 10                	mov    BYTE PTR [eax],dl
	  n -= 1;
 80488e6:	ff 4d 10             	dec    DWORD PTR [ebp+0x10]
  while ( n > 0 )
 80488e9:	83 7d 10 00          	cmp    DWORD PTR [ebp+0x10],0x0
 80488ed:	75 e1                	jne    80488d0 <liballoc_memcpy+0x42>
  }
  
  return s1;
 80488ef:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
}
 80488f2:	c9                   	leave  
 80488f3:	c3                   	ret    

080488f4 <allocate_new_page>:


// ***************************************************************

static struct liballoc_major *allocate_new_page( unsigned int size )
{
 80488f4:	55                   	push   ebp
 80488f5:	89 e5                	mov    ebp,esp
 80488f7:	53                   	push   ebx
 80488f8:	83 ec 14             	sub    esp,0x14
	unsigned int st;
	struct liballoc_major *maj;

		// This is how much space is required.
		st  = size + sizeof(struct liballoc_major);
 80488fb:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80488fe:	83 c0 18             	add    eax,0x18
 8048901:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
		st += sizeof(struct liballoc_minor);
 8048904:	83 45 f4 18          	add    DWORD PTR [ebp-0xc],0x18

				// Perfect amount of space?
		if ( (st % l_pageSize) == 0 )
 8048908:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 804890b:	25 ff 0f 00 00       	and    eax,0xfff
 8048910:	85 c0                	test   eax,eax
 8048912:	75 0b                	jne    804891f <allocate_new_page+0x2b>
			st  = st / (l_pageSize);
 8048914:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 8048917:	c1 e8 0c             	shr    eax,0xc
 804891a:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
 804891d:	eb 0a                	jmp    8048929 <allocate_new_page+0x35>
		else
			st  = st / (l_pageSize) + 1;
 804891f:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 8048922:	c1 e8 0c             	shr    eax,0xc
 8048925:	40                   	inc    eax
 8048926:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
							// No, add the buffer. 

		
		// Make sure it's >= the minimum size.
		if ( st < l_pageCount ) st = l_pageCount;
 8048929:	83 7d f4 0f          	cmp    DWORD PTR [ebp-0xc],0xf
 804892d:	77 07                	ja     8048936 <allocate_new_page+0x42>
 804892f:	c7 45 f4 10 00 00 00 	mov    DWORD PTR [ebp-0xc],0x10
		
		maj = (struct liballoc_major*)liballoc_alloc( st );
 8048936:	83 ec 0c             	sub    esp,0xc
 8048939:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 804893c:	e8 41 0b 00 00       	call   8049482 <liballoc_alloc>
 8048941:	83 c4 10             	add    esp,0x10
 8048944:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax

		if ( maj == NULL ) 
 8048947:	83 7d f0 00          	cmp    DWORD PTR [ebp-0x10],0x0
 804894b:	75 23                	jne    8048970 <allocate_new_page+0x7c>
		{
			l_warningCount += 1;
 804894d:	a1 60 c1 04 08       	mov    eax,ds:0x804c160
 8048952:	8b 15 64 c1 04 08    	mov    edx,DWORD PTR ds:0x804c164
 8048958:	83 c0 01             	add    eax,0x1
 804895b:	83 d2 00             	adc    edx,0x0
 804895e:	a3 60 c1 04 08       	mov    ds:0x804c160,eax
 8048963:	89 15 64 c1 04 08    	mov    DWORD PTR ds:0x804c164,edx
			#if defined DEBUG || defined INFO
			serial_printf( "liballoc: WARNING: liballoc_alloc( %d ) return NULL\n", st );
			FLUSH();
			#endif
			return NULL;	// uh oh, we ran out of memory.
 8048969:	b8 00 00 00 00       	mov    eax,0x0
 804896e:	eb 68                	jmp    80489d8 <allocate_new_page+0xe4>
		}
		
		maj->prev 	= NULL;
 8048970:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8048973:	c7 00 00 00 00 00    	mov    DWORD PTR [eax],0x0
		maj->next 	= NULL;
 8048979:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 804897c:	c7 40 04 00 00 00 00 	mov    DWORD PTR [eax+0x4],0x0
		maj->pages 	= st;
 8048983:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8048986:	8b 55 f4             	mov    edx,DWORD PTR [ebp-0xc]
 8048989:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
		maj->size 	= st * l_pageSize;
 804898c:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 804898f:	c1 e0 0c             	shl    eax,0xc
 8048992:	89 c2                	mov    edx,eax
 8048994:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8048997:	89 50 0c             	mov    DWORD PTR [eax+0xc],edx
		maj->usage 	= sizeof(struct liballoc_major);
 804899a:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 804899d:	c7 40 10 18 00 00 00 	mov    DWORD PTR [eax+0x10],0x18
		maj->first 	= NULL;
 80489a4:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80489a7:	c7 40 14 00 00 00 00 	mov    DWORD PTR [eax+0x14],0x0

		l_allocated += maj->size;
 80489ae:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80489b1:	8b 40 0c             	mov    eax,DWORD PTR [eax+0xc]
 80489b4:	89 c1                	mov    ecx,eax
 80489b6:	bb 00 00 00 00       	mov    ebx,0x0
 80489bb:	a1 50 c1 04 08       	mov    eax,ds:0x804c150
 80489c0:	8b 15 54 c1 04 08    	mov    edx,DWORD PTR ds:0x804c154
 80489c6:	01 c8                	add    eax,ecx
 80489c8:	11 da                	adc    edx,ebx
 80489ca:	a3 50 c1 04 08       	mov    ds:0x804c150,eax
 80489cf:	89 15 54 c1 04 08    	mov    DWORD PTR ds:0x804c154,edx
		serial_printf( "liballoc: Total memory usage = %d KB\n",  (int)((l_allocated / (1024))) );
		FLUSH();
		#endif
	
		
      return maj;
 80489d5:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
 80489d8:	8b 5d fc             	mov    ebx,DWORD PTR [ebp-0x4]
 80489db:	c9                   	leave  
 80489dc:	c3                   	ret    

080489dd <malloc>:

	


void *PREFIX(malloc)(size_t req_size)
{
 80489dd:	55                   	push   ebp
 80489de:	89 e5                	mov    ebp,esp
 80489e0:	53                   	push   ebx
 80489e1:	83 ec 44             	sub    esp,0x44
	int startedBet = 0;
 80489e4:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0
	unsigned long long bestSize = 0;
 80489eb:	c7 45 e8 00 00 00 00 	mov    DWORD PTR [ebp-0x18],0x0
 80489f2:	c7 45 ec 00 00 00 00 	mov    DWORD PTR [ebp-0x14],0x0
	void *p = NULL;
 80489f9:	c7 45 e4 00 00 00 00 	mov    DWORD PTR [ebp-0x1c],0x0
	uintptr_t diff;
	struct liballoc_major *maj;
	struct liballoc_minor *min;
	struct liballoc_minor *new_min;
	unsigned long size = req_size;
 8048a00:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8048a03:	89 45 c8             	mov    DWORD PTR [ebp-0x38],eax

	// For alignment, we adjust size so there's enough space to align.
	if ( ALIGNMENT > 1 )
	{
		size += ALIGNMENT + ALIGN_INFO;
 8048a06:	83 45 c8 20          	add    DWORD PTR [ebp-0x38],0x20
	}
				// So, ideally, we really want an alignment of 0 or 1 in order
				// to save space.
	
	liballoc_lock();
 8048a0a:	e8 43 0a 00 00       	call   8049452 <liballoc_lock>

	if ( size == 0 )
 8048a0f:	83 7d c8 00          	cmp    DWORD PTR [ebp-0x38],0x0
 8048a13:	75 33                	jne    8048a48 <malloc+0x6b>
	{
		l_warningCount += 1;
 8048a15:	a1 60 c1 04 08       	mov    eax,ds:0x804c160
 8048a1a:	8b 15 64 c1 04 08    	mov    edx,DWORD PTR ds:0x804c164
 8048a20:	83 c0 01             	add    eax,0x1
 8048a23:	83 d2 00             	adc    edx,0x0
 8048a26:	a3 60 c1 04 08       	mov    ds:0x804c160,eax
 8048a2b:	89 15 64 c1 04 08    	mov    DWORD PTR ds:0x804c164,edx
		#if defined DEBUG || defined INFO
		serial_printf( "liballoc: WARNING: alloc( 0 ) called from %x\n",
							__builtin_return_address(0) );
		FLUSH();
		#endif
		liballoc_unlock();
 8048a31:	e8 34 0a 00 00       	call   804946a <liballoc_unlock>
		return PREFIX(malloc)(1);
 8048a36:	83 ec 0c             	sub    esp,0xc
 8048a39:	6a 01                	push   0x1
 8048a3b:	e8 9d ff ff ff       	call   80489dd <malloc>
 8048a40:	83 c4 10             	add    esp,0x10
 8048a43:	e9 1c 06 00 00       	jmp    8049064 <malloc+0x687>
	}
	

	if ( l_memRoot == NULL )
 8048a48:	a1 48 c1 04 08       	mov    eax,ds:0x804c148
 8048a4d:	85 c0                	test   eax,eax
 8048a4f:	75 2b                	jne    8048a7c <malloc+0x9f>
		//atexit( liballoc_dump );
		FLUSH();
		#endif
			
		// This is the first time we are being used.
		l_memRoot = allocate_new_page( size );
 8048a51:	83 ec 0c             	sub    esp,0xc
 8048a54:	ff 75 c8             	push   DWORD PTR [ebp-0x38]
 8048a57:	e8 98 fe ff ff       	call   80488f4 <allocate_new_page>
 8048a5c:	83 c4 10             	add    esp,0x10
 8048a5f:	a3 48 c1 04 08       	mov    ds:0x804c148,eax
		if ( l_memRoot == NULL )
 8048a64:	a1 48 c1 04 08       	mov    eax,ds:0x804c148
 8048a69:	85 c0                	test   eax,eax
 8048a6b:	75 0f                	jne    8048a7c <malloc+0x9f>
		{
		  liballoc_unlock();
 8048a6d:	e8 f8 09 00 00       	call   804946a <liballoc_unlock>
		  #ifdef DEBUG
		  serial_printf( "liballoc: initial l_memRoot initialization failed\n", p); 
		  FLUSH();
		  #endif
		  return NULL;
 8048a72:	b8 00 00 00 00       	mov    eax,0x0
 8048a77:	e9 e8 05 00 00       	jmp    8049064 <malloc+0x687>
	FLUSH();
	#endif

	// Now we need to bounce through every major and find enough space....

	maj = l_memRoot;
 8048a7c:	a1 48 c1 04 08       	mov    eax,ds:0x804c148
 8048a81:	89 45 e0             	mov    DWORD PTR [ebp-0x20],eax
	startedBet = 0;
 8048a84:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0
	
	// Start at the best bet....
	if ( l_bestBet != NULL )
 8048a8b:	a1 4c c1 04 08       	mov    eax,ds:0x804c14c
 8048a90:	85 c0                	test   eax,eax
 8048a92:	0f 84 b2 05 00 00    	je     804904a <malloc+0x66d>
	{
		bestSize = l_bestBet->size - l_bestBet->usage;
 8048a98:	a1 4c c1 04 08       	mov    eax,ds:0x804c14c
 8048a9d:	8b 50 0c             	mov    edx,DWORD PTR [eax+0xc]
 8048aa0:	a1 4c c1 04 08       	mov    eax,ds:0x804c14c
 8048aa5:	8b 40 10             	mov    eax,DWORD PTR [eax+0x10]
 8048aa8:	29 c2                	sub    edx,eax
 8048aaa:	89 d0                	mov    eax,edx
 8048aac:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax
 8048aaf:	c7 45 ec 00 00 00 00 	mov    DWORD PTR [ebp-0x14],0x0

		if ( bestSize > (size + sizeof(struct liballoc_minor)))
 8048ab6:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048ab9:	83 c0 18             	add    eax,0x18
 8048abc:	ba 00 00 00 00       	mov    edx,0x0
 8048ac1:	3b 45 e8             	cmp    eax,DWORD PTR [ebp-0x18]
 8048ac4:	89 d0                	mov    eax,edx
 8048ac6:	1b 45 ec             	sbb    eax,DWORD PTR [ebp-0x14]
 8048ac9:	0f 83 7b 05 00 00    	jae    804904a <malloc+0x66d>
		{
			maj = l_bestBet;
 8048acf:	a1 4c c1 04 08       	mov    eax,ds:0x804c14c
 8048ad4:	89 45 e0             	mov    DWORD PTR [ebp-0x20],eax
			startedBet = 1;
 8048ad7:	c7 45 f4 01 00 00 00 	mov    DWORD PTR [ebp-0xc],0x1
		}
	}
	
	while ( maj != NULL )
 8048ade:	e9 67 05 00 00       	jmp    804904a <malloc+0x66d>
	{
		diff  = maj->size - maj->usage;	
 8048ae3:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048ae6:	8b 50 0c             	mov    edx,DWORD PTR [eax+0xc]
 8048ae9:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048aec:	8b 40 10             	mov    eax,DWORD PTR [eax+0x10]
 8048aef:	29 c2                	sub    edx,eax
 8048af1:	89 d0                	mov    eax,edx
 8048af3:	89 45 c4             	mov    DWORD PTR [ebp-0x3c],eax
										// free memory in the block

		if ( bestSize < diff )
 8048af6:	8b 45 c4             	mov    eax,DWORD PTR [ebp-0x3c]
 8048af9:	ba 00 00 00 00       	mov    edx,0x0
 8048afe:	8b 4d ec             	mov    ecx,DWORD PTR [ebp-0x14]
 8048b01:	39 45 e8             	cmp    DWORD PTR [ebp-0x18],eax
 8048b04:	19 d1                	sbb    ecx,edx
 8048b06:	73 15                	jae    8048b1d <malloc+0x140>
		{
			// Hmm.. this one has more memory then our bestBet. Remember!
			l_bestBet = maj;
 8048b08:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048b0b:	a3 4c c1 04 08       	mov    ds:0x804c14c,eax
			bestSize = diff;
 8048b10:	8b 45 c4             	mov    eax,DWORD PTR [ebp-0x3c]
 8048b13:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax
 8048b16:	c7 45 ec 00 00 00 00 	mov    DWORD PTR [ebp-0x14],0x0
		
		
#ifdef USE_CASE1
			
		// CASE 1:  There is not enough space in this major block.
		if ( diff < (size + sizeof( struct liballoc_minor )) )
 8048b1d:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048b20:	83 c0 18             	add    eax,0x18
 8048b23:	39 45 c4             	cmp    DWORD PTR [ebp-0x3c],eax
 8048b26:	73 68                	jae    8048b90 <malloc+0x1b3>
			serial_printf( "CASE 1: Insufficient space in block %x\n", maj);
			FLUSH();
			#endif
				
				// Another major block next to this one?
			if ( maj->next != NULL ) 
 8048b28:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048b2b:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048b2e:	85 c0                	test   eax,eax
 8048b30:	74 0e                	je     8048b40 <malloc+0x163>
			{
				maj = maj->next;		// Hop to that one.
 8048b32:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048b35:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048b38:	89 45 e0             	mov    DWORD PTR [ebp-0x20],eax
				continue;
 8048b3b:	e9 0a 05 00 00       	jmp    804904a <malloc+0x66d>
			}

			if ( startedBet == 1 )		// If we started at the best bet,
 8048b40:	83 7d f4 01          	cmp    DWORD PTR [ebp-0xc],0x1
 8048b44:	75 14                	jne    8048b5a <malloc+0x17d>
			{							// let's start all over again.
				maj = l_memRoot;
 8048b46:	a1 48 c1 04 08       	mov    eax,ds:0x804c148
 8048b4b:	89 45 e0             	mov    DWORD PTR [ebp-0x20],eax
				startedBet = 0;
 8048b4e:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0
				continue;
 8048b55:	e9 f0 04 00 00       	jmp    804904a <malloc+0x66d>
			}

			// Create a new major block next to this one and...
			maj->next = allocate_new_page( size );	// next one will be okay.
 8048b5a:	83 ec 0c             	sub    esp,0xc
 8048b5d:	ff 75 c8             	push   DWORD PTR [ebp-0x38]
 8048b60:	e8 8f fd ff ff       	call   80488f4 <allocate_new_page>
 8048b65:	83 c4 10             	add    esp,0x10
 8048b68:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]
 8048b6b:	89 42 04             	mov    DWORD PTR [edx+0x4],eax
			if ( maj->next == NULL ) break;			// no more memory.
 8048b6e:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048b71:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048b74:	85 c0                	test   eax,eax
 8048b76:	0f 84 da 04 00 00    	je     8049056 <malloc+0x679>
			maj->next->prev = maj;
 8048b7c:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048b7f:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048b82:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]
 8048b85:	89 10                	mov    DWORD PTR [eax],edx
			maj = maj->next;
 8048b87:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048b8a:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048b8d:	89 45 e0             	mov    DWORD PTR [ebp-0x20],eax
#endif

#ifdef USE_CASE2
		
		// CASE 2: It's a brand new block.
		if ( maj->first == NULL )
 8048b90:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048b93:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048b96:	85 c0                	test   eax,eax
 8048b98:	0f 85 e3 00 00 00    	jne    8048c81 <malloc+0x2a4>
		{
			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
 8048b9e:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048ba1:	83 c0 18             	add    eax,0x18
 8048ba4:	89 c2                	mov    edx,eax
 8048ba6:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048ba9:	89 50 14             	mov    DWORD PTR [eax+0x14],edx

			
			maj->first->magic 		= LIBALLOC_MAGIC;
 8048bac:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048baf:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048bb2:	c7 40 0c de c0 01 c0 	mov    DWORD PTR [eax+0xc],0xc001c0de
			maj->first->prev 		= NULL;
 8048bb9:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048bbc:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048bbf:	c7 00 00 00 00 00    	mov    DWORD PTR [eax],0x0
			maj->first->next 		= NULL;
 8048bc5:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048bc8:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048bcb:	c7 40 04 00 00 00 00 	mov    DWORD PTR [eax+0x4],0x0
			maj->first->block 		= maj;
 8048bd2:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048bd5:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048bd8:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]
 8048bdb:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
			maj->first->size 		= size;
 8048bde:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048be1:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048be4:	8b 55 c8             	mov    edx,DWORD PTR [ebp-0x38]
 8048be7:	89 50 10             	mov    DWORD PTR [eax+0x10],edx
			maj->first->req_size 	= req_size;
 8048bea:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048bed:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048bf0:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 8048bf3:	89 50 14             	mov    DWORD PTR [eax+0x14],edx
			maj->usage 	+= size + sizeof( struct liballoc_minor );
 8048bf6:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048bf9:	8b 50 10             	mov    edx,DWORD PTR [eax+0x10]
 8048bfc:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048bff:	01 d0                	add    eax,edx
 8048c01:	8d 50 18             	lea    edx,[eax+0x18]
 8048c04:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048c07:	89 50 10             	mov    DWORD PTR [eax+0x10],edx


			l_inuse += size;
 8048c0a:	8b 4d c8             	mov    ecx,DWORD PTR [ebp-0x38]
 8048c0d:	bb 00 00 00 00       	mov    ebx,0x0
 8048c12:	a1 58 c1 04 08       	mov    eax,ds:0x804c158
 8048c17:	8b 15 5c c1 04 08    	mov    edx,DWORD PTR ds:0x804c15c
 8048c1d:	01 c8                	add    eax,ecx
 8048c1f:	11 da                	adc    edx,ebx
 8048c21:	a3 58 c1 04 08       	mov    ds:0x804c158,eax
 8048c26:	89 15 5c c1 04 08    	mov    DWORD PTR ds:0x804c15c,edx
			
			
			p = (void*)((uintptr_t)(maj->first) + sizeof( struct liballoc_minor ));
 8048c2c:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048c2f:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048c32:	83 c0 18             	add    eax,0x18
 8048c35:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax

			ALIGN( p );
 8048c38:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048c3b:	83 c0 10             	add    eax,0x10
 8048c3e:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
 8048c41:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048c44:	83 e0 0f             	and    eax,0xf
 8048c47:	89 45 d8             	mov    DWORD PTR [ebp-0x28],eax
 8048c4a:	83 7d d8 00          	cmp    DWORD PTR [ebp-0x28],0x0
 8048c4e:	74 16                	je     8048c66 <malloc+0x289>
 8048c50:	b8 10 00 00 00       	mov    eax,0x10
 8048c55:	2b 45 d8             	sub    eax,DWORD PTR [ebp-0x28]
 8048c58:	89 45 d8             	mov    DWORD PTR [ebp-0x28],eax
 8048c5b:	8b 55 e4             	mov    edx,DWORD PTR [ebp-0x1c]
 8048c5e:	8b 45 d8             	mov    eax,DWORD PTR [ebp-0x28]
 8048c61:	01 d0                	add    eax,edx
 8048c63:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
 8048c66:	8b 45 d8             	mov    eax,DWORD PTR [ebp-0x28]
 8048c69:	8d 50 10             	lea    edx,[eax+0x10]
 8048c6c:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048c6f:	83 e8 10             	sub    eax,0x10
 8048c72:	88 10                	mov    BYTE PTR [eax],dl
			
			#ifdef DEBUG
			serial_printf( "CASE 2: returning %x\n", p); 
			FLUSH();
			#endif
			liballoc_unlock();		// release the lock
 8048c74:	e8 f1 07 00 00       	call   804946a <liballoc_unlock>
			return p;
 8048c79:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048c7c:	e9 e3 03 00 00       	jmp    8049064 <malloc+0x687>
#endif
				
#ifdef USE_CASE3

		// CASE 3: Block in use and enough space at the start of the block.
		diff =  (uintptr_t)(maj->first);
 8048c81:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048c84:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048c87:	89 45 c4             	mov    DWORD PTR [ebp-0x3c],eax
		diff -= (uintptr_t)maj;
 8048c8a:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048c8d:	29 45 c4             	sub    DWORD PTR [ebp-0x3c],eax
		diff -= sizeof(struct liballoc_major);
 8048c90:	83 6d c4 18          	sub    DWORD PTR [ebp-0x3c],0x18

		if ( diff >= (size + sizeof(struct liballoc_minor)) )
 8048c94:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048c97:	83 c0 18             	add    eax,0x18
 8048c9a:	39 45 c4             	cmp    DWORD PTR [ebp-0x3c],eax
 8048c9d:	0f 82 f5 00 00 00    	jb     8048d98 <malloc+0x3bb>
		{
			// Yes, space in front. Squeeze in.
			maj->first->prev = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
 8048ca3:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048ca6:	8d 50 18             	lea    edx,[eax+0x18]
 8048ca9:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048cac:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048caf:	89 10                	mov    DWORD PTR [eax],edx
			maj->first->prev->next = maj->first;
 8048cb1:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048cb4:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048cb7:	8b 00                	mov    eax,DWORD PTR [eax]
 8048cb9:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]
 8048cbc:	8b 52 14             	mov    edx,DWORD PTR [edx+0x14]
 8048cbf:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
			maj->first = maj->first->prev;
 8048cc2:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048cc5:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048cc8:	8b 10                	mov    edx,DWORD PTR [eax]
 8048cca:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048ccd:	89 50 14             	mov    DWORD PTR [eax+0x14],edx
				
			maj->first->magic 	= LIBALLOC_MAGIC;
 8048cd0:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048cd3:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048cd6:	c7 40 0c de c0 01 c0 	mov    DWORD PTR [eax+0xc],0xc001c0de
			maj->first->prev 	= NULL;
 8048cdd:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048ce0:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048ce3:	c7 00 00 00 00 00    	mov    DWORD PTR [eax],0x0
			maj->first->block 	= maj;
 8048ce9:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048cec:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048cef:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]
 8048cf2:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
			maj->first->size 	= size;
 8048cf5:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048cf8:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048cfb:	8b 55 c8             	mov    edx,DWORD PTR [ebp-0x38]
 8048cfe:	89 50 10             	mov    DWORD PTR [eax+0x10],edx
			maj->first->req_size 	= req_size;
 8048d01:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048d04:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048d07:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 8048d0a:	89 50 14             	mov    DWORD PTR [eax+0x14],edx
			maj->usage 			+= size + sizeof( struct liballoc_minor );
 8048d0d:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048d10:	8b 50 10             	mov    edx,DWORD PTR [eax+0x10]
 8048d13:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048d16:	01 d0                	add    eax,edx
 8048d18:	8d 50 18             	lea    edx,[eax+0x18]
 8048d1b:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048d1e:	89 50 10             	mov    DWORD PTR [eax+0x10],edx

			l_inuse += size;
 8048d21:	8b 4d c8             	mov    ecx,DWORD PTR [ebp-0x38]
 8048d24:	bb 00 00 00 00       	mov    ebx,0x0
 8048d29:	a1 58 c1 04 08       	mov    eax,ds:0x804c158
 8048d2e:	8b 15 5c c1 04 08    	mov    edx,DWORD PTR ds:0x804c15c
 8048d34:	01 c8                	add    eax,ecx
 8048d36:	11 da                	adc    edx,ebx
 8048d38:	a3 58 c1 04 08       	mov    ds:0x804c158,eax
 8048d3d:	89 15 5c c1 04 08    	mov    DWORD PTR ds:0x804c15c,edx

			p = (void*)((uintptr_t)(maj->first) + sizeof( struct liballoc_minor ));
 8048d43:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048d46:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048d49:	83 c0 18             	add    eax,0x18
 8048d4c:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
			ALIGN( p );
 8048d4f:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048d52:	83 c0 10             	add    eax,0x10
 8048d55:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
 8048d58:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048d5b:	83 e0 0f             	and    eax,0xf
 8048d5e:	89 45 d4             	mov    DWORD PTR [ebp-0x2c],eax
 8048d61:	83 7d d4 00          	cmp    DWORD PTR [ebp-0x2c],0x0
 8048d65:	74 16                	je     8048d7d <malloc+0x3a0>
 8048d67:	b8 10 00 00 00       	mov    eax,0x10
 8048d6c:	2b 45 d4             	sub    eax,DWORD PTR [ebp-0x2c]
 8048d6f:	89 45 d4             	mov    DWORD PTR [ebp-0x2c],eax
 8048d72:	8b 55 e4             	mov    edx,DWORD PTR [ebp-0x1c]
 8048d75:	8b 45 d4             	mov    eax,DWORD PTR [ebp-0x2c]
 8048d78:	01 d0                	add    eax,edx
 8048d7a:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
 8048d7d:	8b 45 d4             	mov    eax,DWORD PTR [ebp-0x2c]
 8048d80:	8d 50 10             	lea    edx,[eax+0x10]
 8048d83:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048d86:	83 e8 10             	sub    eax,0x10
 8048d89:	88 10                	mov    BYTE PTR [eax],dl

			#ifdef DEBUG
			serial_printf( "CASE 3: returning %x\n", p); 
			FLUSH();
			#endif
			liballoc_unlock();		// release the lock
 8048d8b:	e8 da 06 00 00       	call   804946a <liballoc_unlock>
			return p;
 8048d90:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048d93:	e9 cc 02 00 00       	jmp    8049064 <malloc+0x687>


#ifdef USE_CASE4

		// CASE 4: There is enough space in this block. But is it contiguous?
		min = maj->first;
 8048d98:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048d9b:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 8048d9e:	89 45 dc             	mov    DWORD PTR [ebp-0x24],eax
		
			// Looping within the block now...
		while ( min != NULL )
 8048da1:	e9 47 02 00 00       	jmp    8048fed <malloc+0x610>
		{
				// CASE 4.1: End of minors in a block. Space from last and end?
				if ( min->next == NULL )
 8048da6:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048da9:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048dac:	85 c0                	test   eax,eax
 8048dae:	0f 85 11 01 00 00    	jne    8048ec5 <malloc+0x4e8>
				{
					// the rest of this block is free...  is it big enough?
					diff = (uintptr_t)(maj) + maj->size;
 8048db4:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048db7:	8b 50 0c             	mov    edx,DWORD PTR [eax+0xc]
 8048dba:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048dbd:	01 d0                	add    eax,edx
 8048dbf:	89 45 c4             	mov    DWORD PTR [ebp-0x3c],eax
					diff -= (uintptr_t)min;
 8048dc2:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048dc5:	29 45 c4             	sub    DWORD PTR [ebp-0x3c],eax
					diff -= sizeof( struct liballoc_minor );
 8048dc8:	83 6d c4 18          	sub    DWORD PTR [ebp-0x3c],0x18
					diff -= min->size; 
 8048dcc:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048dcf:	8b 40 10             	mov    eax,DWORD PTR [eax+0x10]
 8048dd2:	29 45 c4             	sub    DWORD PTR [ebp-0x3c],eax
						// minus already existing usage..

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
 8048dd5:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048dd8:	83 c0 18             	add    eax,0x18
 8048ddb:	39 45 c4             	cmp    DWORD PTR [ebp-0x3c],eax
 8048dde:	0f 82 e1 00 00 00    	jb     8048ec5 <malloc+0x4e8>
					{
						// yay....
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
 8048de4:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048de7:	8b 50 10             	mov    edx,DWORD PTR [eax+0x10]
 8048dea:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048ded:	01 d0                	add    eax,edx
 8048def:	83 c0 18             	add    eax,0x18
 8048df2:	89 c2                	mov    edx,eax
 8048df4:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048df7:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
						min->next->prev = min;
 8048dfa:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048dfd:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048e00:	8b 55 dc             	mov    edx,DWORD PTR [ebp-0x24]
 8048e03:	89 10                	mov    DWORD PTR [eax],edx
						min = min->next;
 8048e05:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048e08:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048e0b:	89 45 dc             	mov    DWORD PTR [ebp-0x24],eax
						min->next = NULL;
 8048e0e:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048e11:	c7 40 04 00 00 00 00 	mov    DWORD PTR [eax+0x4],0x0
						min->magic = LIBALLOC_MAGIC;
 8048e18:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048e1b:	c7 40 0c de c0 01 c0 	mov    DWORD PTR [eax+0xc],0xc001c0de
						min->block = maj;
 8048e22:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048e25:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]
 8048e28:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
						min->size = size;
 8048e2b:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048e2e:	8b 55 c8             	mov    edx,DWORD PTR [ebp-0x38]
 8048e31:	89 50 10             	mov    DWORD PTR [eax+0x10],edx
						min->req_size = req_size;
 8048e34:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048e37:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 8048e3a:	89 50 14             	mov    DWORD PTR [eax+0x14],edx
						maj->usage += size + sizeof( struct liballoc_minor );
 8048e3d:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048e40:	8b 50 10             	mov    edx,DWORD PTR [eax+0x10]
 8048e43:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048e46:	01 d0                	add    eax,edx
 8048e48:	8d 50 18             	lea    edx,[eax+0x18]
 8048e4b:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048e4e:	89 50 10             	mov    DWORD PTR [eax+0x10],edx

						l_inuse += size;
 8048e51:	8b 4d c8             	mov    ecx,DWORD PTR [ebp-0x38]
 8048e54:	bb 00 00 00 00       	mov    ebx,0x0
 8048e59:	a1 58 c1 04 08       	mov    eax,ds:0x804c158
 8048e5e:	8b 15 5c c1 04 08    	mov    edx,DWORD PTR ds:0x804c15c
 8048e64:	01 c8                	add    eax,ecx
 8048e66:	11 da                	adc    edx,ebx
 8048e68:	a3 58 c1 04 08       	mov    ds:0x804c158,eax
 8048e6d:	89 15 5c c1 04 08    	mov    DWORD PTR ds:0x804c15c,edx
						
						p = (void*)((uintptr_t)min + sizeof( struct liballoc_minor ));
 8048e73:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048e76:	83 c0 18             	add    eax,0x18
 8048e79:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
						ALIGN( p );
 8048e7c:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048e7f:	83 c0 10             	add    eax,0x10
 8048e82:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
 8048e85:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048e88:	83 e0 0f             	and    eax,0xf
 8048e8b:	89 45 d0             	mov    DWORD PTR [ebp-0x30],eax
 8048e8e:	83 7d d0 00          	cmp    DWORD PTR [ebp-0x30],0x0
 8048e92:	74 16                	je     8048eaa <malloc+0x4cd>
 8048e94:	b8 10 00 00 00       	mov    eax,0x10
 8048e99:	2b 45 d0             	sub    eax,DWORD PTR [ebp-0x30]
 8048e9c:	89 45 d0             	mov    DWORD PTR [ebp-0x30],eax
 8048e9f:	8b 55 e4             	mov    edx,DWORD PTR [ebp-0x1c]
 8048ea2:	8b 45 d0             	mov    eax,DWORD PTR [ebp-0x30]
 8048ea5:	01 d0                	add    eax,edx
 8048ea7:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
 8048eaa:	8b 45 d0             	mov    eax,DWORD PTR [ebp-0x30]
 8048ead:	8d 50 10             	lea    edx,[eax+0x10]
 8048eb0:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048eb3:	83 e8 10             	sub    eax,0x10
 8048eb6:	88 10                	mov    BYTE PTR [eax],dl

						#ifdef DEBUG
						serial_printf( "CASE 4.1: returning %x\n", p); 
						FLUSH();
						#endif
						liballoc_unlock();		// release the lock
 8048eb8:	e8 ad 05 00 00       	call   804946a <liballoc_unlock>
						return p;
 8048ebd:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048ec0:	e9 9f 01 00 00       	jmp    8049064 <malloc+0x687>
				}



				// CASE 4.2: Is there space between two minors?
				if ( min->next != NULL )
 8048ec5:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048ec8:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048ecb:	85 c0                	test   eax,eax
 8048ecd:	0f 84 11 01 00 00    	je     8048fe4 <malloc+0x607>
				{
					// is the difference between here and next big enough?
					diff  = (uintptr_t)(min->next);
 8048ed3:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048ed6:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048ed9:	89 45 c4             	mov    DWORD PTR [ebp-0x3c],eax
					diff -= (uintptr_t)min;
 8048edc:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048edf:	29 45 c4             	sub    DWORD PTR [ebp-0x3c],eax
					diff -= sizeof( struct liballoc_minor );
 8048ee2:	83 6d c4 18          	sub    DWORD PTR [ebp-0x3c],0x18
					diff -= min->size;
 8048ee6:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048ee9:	8b 40 10             	mov    eax,DWORD PTR [eax+0x10]
 8048eec:	29 45 c4             	sub    DWORD PTR [ebp-0x3c],eax
										// minus our existing usage.

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
 8048eef:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048ef2:	83 c0 18             	add    eax,0x18
 8048ef5:	39 45 c4             	cmp    DWORD PTR [ebp-0x3c],eax
 8048ef8:	0f 82 e6 00 00 00    	jb     8048fe4 <malloc+0x607>
					{
						// yay......
						new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
 8048efe:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048f01:	8b 50 10             	mov    edx,DWORD PTR [eax+0x10]
 8048f04:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048f07:	01 d0                	add    eax,edx
 8048f09:	83 c0 18             	add    eax,0x18
 8048f0c:	89 45 c0             	mov    DWORD PTR [ebp-0x40],eax

						new_min->magic = LIBALLOC_MAGIC;
 8048f0f:	8b 45 c0             	mov    eax,DWORD PTR [ebp-0x40]
 8048f12:	c7 40 0c de c0 01 c0 	mov    DWORD PTR [eax+0xc],0xc001c0de
						new_min->next = min->next;
 8048f19:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048f1c:	8b 50 04             	mov    edx,DWORD PTR [eax+0x4]
 8048f1f:	8b 45 c0             	mov    eax,DWORD PTR [ebp-0x40]
 8048f22:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
						new_min->prev = min;
 8048f25:	8b 45 c0             	mov    eax,DWORD PTR [ebp-0x40]
 8048f28:	8b 55 dc             	mov    edx,DWORD PTR [ebp-0x24]
 8048f2b:	89 10                	mov    DWORD PTR [eax],edx
						new_min->size = size;
 8048f2d:	8b 45 c0             	mov    eax,DWORD PTR [ebp-0x40]
 8048f30:	8b 55 c8             	mov    edx,DWORD PTR [ebp-0x38]
 8048f33:	89 50 10             	mov    DWORD PTR [eax+0x10],edx
						new_min->req_size = req_size;
 8048f36:	8b 45 c0             	mov    eax,DWORD PTR [ebp-0x40]
 8048f39:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 8048f3c:	89 50 14             	mov    DWORD PTR [eax+0x14],edx
						new_min->block = maj;
 8048f3f:	8b 45 c0             	mov    eax,DWORD PTR [ebp-0x40]
 8048f42:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]
 8048f45:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
						min->next->prev = new_min;
 8048f48:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048f4b:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048f4e:	8b 55 c0             	mov    edx,DWORD PTR [ebp-0x40]
 8048f51:	89 10                	mov    DWORD PTR [eax],edx
						min->next = new_min;
 8048f53:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048f56:	8b 55 c0             	mov    edx,DWORD PTR [ebp-0x40]
 8048f59:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
						maj->usage += size + sizeof( struct liballoc_minor );
 8048f5c:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048f5f:	8b 50 10             	mov    edx,DWORD PTR [eax+0x10]
 8048f62:	8b 45 c8             	mov    eax,DWORD PTR [ebp-0x38]
 8048f65:	01 d0                	add    eax,edx
 8048f67:	8d 50 18             	lea    edx,[eax+0x18]
 8048f6a:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048f6d:	89 50 10             	mov    DWORD PTR [eax+0x10],edx
						
						l_inuse += size;
 8048f70:	8b 4d c8             	mov    ecx,DWORD PTR [ebp-0x38]
 8048f73:	bb 00 00 00 00       	mov    ebx,0x0
 8048f78:	a1 58 c1 04 08       	mov    eax,ds:0x804c158
 8048f7d:	8b 15 5c c1 04 08    	mov    edx,DWORD PTR ds:0x804c15c
 8048f83:	01 c8                	add    eax,ecx
 8048f85:	11 da                	adc    edx,ebx
 8048f87:	a3 58 c1 04 08       	mov    ds:0x804c158,eax
 8048f8c:	89 15 5c c1 04 08    	mov    DWORD PTR ds:0x804c15c,edx
						
						p = (void*)((uintptr_t)new_min + sizeof( struct liballoc_minor ));
 8048f92:	8b 45 c0             	mov    eax,DWORD PTR [ebp-0x40]
 8048f95:	83 c0 18             	add    eax,0x18
 8048f98:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
						ALIGN( p );
 8048f9b:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048f9e:	83 c0 10             	add    eax,0x10
 8048fa1:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
 8048fa4:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048fa7:	83 e0 0f             	and    eax,0xf
 8048faa:	89 45 cc             	mov    DWORD PTR [ebp-0x34],eax
 8048fad:	83 7d cc 00          	cmp    DWORD PTR [ebp-0x34],0x0
 8048fb1:	74 16                	je     8048fc9 <malloc+0x5ec>
 8048fb3:	b8 10 00 00 00       	mov    eax,0x10
 8048fb8:	2b 45 cc             	sub    eax,DWORD PTR [ebp-0x34]
 8048fbb:	89 45 cc             	mov    DWORD PTR [ebp-0x34],eax
 8048fbe:	8b 55 e4             	mov    edx,DWORD PTR [ebp-0x1c]
 8048fc1:	8b 45 cc             	mov    eax,DWORD PTR [ebp-0x34]
 8048fc4:	01 d0                	add    eax,edx
 8048fc6:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
 8048fc9:	8b 45 cc             	mov    eax,DWORD PTR [ebp-0x34]
 8048fcc:	8d 50 10             	lea    edx,[eax+0x10]
 8048fcf:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048fd2:	83 e8 10             	sub    eax,0x10
 8048fd5:	88 10                	mov    BYTE PTR [eax],dl
						#ifdef DEBUG
						serial_printf( "CASE 4.2: returning %x\n", p); 
						FLUSH();
						#endif
						
						liballoc_unlock();		// release the lock
 8048fd7:	e8 8e 04 00 00       	call   804946a <liballoc_unlock>
						return p;
 8048fdc:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8048fdf:	e9 80 00 00 00       	jmp    8049064 <malloc+0x687>
					}
				}	// min->next != NULL

				min = min->next;
 8048fe4:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 8048fe7:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048fea:	89 45 dc             	mov    DWORD PTR [ebp-0x24],eax
		while ( min != NULL )
 8048fed:	83 7d dc 00          	cmp    DWORD PTR [ebp-0x24],0x0
 8048ff1:	0f 85 af fd ff ff    	jne    8048da6 <malloc+0x3c9>
#endif

#ifdef USE_CASE5

		// CASE 5: Block full! Ensure next block and loop.
		if ( maj->next == NULL ) 
 8048ff7:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8048ffa:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8048ffd:	85 c0                	test   eax,eax
 8048fff:	75 40                	jne    8049041 <malloc+0x664>
			#ifdef DEBUG
			serial_printf( "CASE 5: block full\n");
			FLUSH();
			#endif

			if ( startedBet == 1 )
 8049001:	83 7d f4 01          	cmp    DWORD PTR [ebp-0xc],0x1
 8049005:	75 11                	jne    8049018 <malloc+0x63b>
			{
				maj = l_memRoot;
 8049007:	a1 48 c1 04 08       	mov    eax,ds:0x804c148
 804900c:	89 45 e0             	mov    DWORD PTR [ebp-0x20],eax
				startedBet = 0;
 804900f:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0
				continue;
 8049016:	eb 32                	jmp    804904a <malloc+0x66d>
			}
				
			// we've run out. we need more...
			maj->next = allocate_new_page( size );		// next one guaranteed to be okay
 8049018:	83 ec 0c             	sub    esp,0xc
 804901b:	ff 75 c8             	push   DWORD PTR [ebp-0x38]
 804901e:	e8 d1 f8 ff ff       	call   80488f4 <allocate_new_page>
 8049023:	83 c4 10             	add    esp,0x10
 8049026:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]
 8049029:	89 42 04             	mov    DWORD PTR [edx+0x4],eax
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
 804902c:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 804902f:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8049032:	85 c0                	test   eax,eax
 8049034:	74 23                	je     8049059 <malloc+0x67c>
			maj->next->prev = maj;
 8049036:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8049039:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 804903c:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]
 804903f:	89 10                	mov    DWORD PTR [eax],edx

		}

#endif

		maj = maj->next;
 8049041:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 8049044:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8049047:	89 45 e0             	mov    DWORD PTR [ebp-0x20],eax
	while ( maj != NULL )
 804904a:	83 7d e0 00          	cmp    DWORD PTR [ebp-0x20],0x0
 804904e:	0f 85 8f fa ff ff    	jne    8048ae3 <malloc+0x106>
 8049054:	eb 04                	jmp    804905a <malloc+0x67d>
			if ( maj->next == NULL ) break;			// no more memory.
 8049056:	90                   	nop
 8049057:	eb 01                	jmp    804905a <malloc+0x67d>
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
 8049059:	90                   	nop
	} // while (maj != NULL)


	
	liballoc_unlock();		// release the lock
 804905a:	e8 0b 04 00 00       	call   804946a <liballoc_unlock>
	#if defined DEBUG || defined INFO
	serial_printf( "liballoc: WARNING: PREFIX(malloc)( %d ) returning NULL.\n", size);
	liballoc_dump();
	FLUSH();
	#endif
	return NULL;
 804905f:	b8 00 00 00 00       	mov    eax,0x0
}
 8049064:	8b 5d fc             	mov    ebx,DWORD PTR [ebp-0x4]
 8049067:	c9                   	leave  
 8049068:	c3                   	ret    

08049069 <free>:




void PREFIX(free)(void *ptr)
{
 8049069:	55                   	push   ebp
 804906a:	89 e5                	mov    ebp,esp
 804906c:	53                   	push   ebx
 804906d:	83 ec 24             	sub    esp,0x24
	struct liballoc_minor *min;
	struct liballoc_major *maj;

	if ( ptr == NULL ) 
 8049070:	83 7d 08 00          	cmp    DWORD PTR [ebp+0x8],0x0
 8049074:	75 21                	jne    8049097 <free+0x2e>
	{
		l_warningCount += 1;
 8049076:	a1 60 c1 04 08       	mov    eax,ds:0x804c160
 804907b:	8b 15 64 c1 04 08    	mov    edx,DWORD PTR ds:0x804c164
 8049081:	83 c0 01             	add    eax,0x1
 8049084:	83 d2 00             	adc    edx,0x0
 8049087:	a3 60 c1 04 08       	mov    ds:0x804c160,eax
 804908c:	89 15 64 c1 04 08    	mov    DWORD PTR ds:0x804c164,edx
		#if defined DEBUG || defined INFO
		serial_printf( "liballoc: WARNING: PREFIX(free)( NULL ) called from %x\n",
							__builtin_return_address(0) );
		FLUSH();
		#endif
		return;
 8049092:	e9 29 02 00 00       	jmp    80492c0 <free+0x257>
	}

	UNALIGN( ptr );
 8049097:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804909a:	83 e8 10             	sub    eax,0x10
 804909d:	8a 00                	mov    al,BYTE PTR [eax]
 804909f:	0f be c0             	movsx  eax,al
 80490a2:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
 80490a5:	83 7d f4 1f          	cmp    DWORD PTR [ebp-0xc],0x1f
 80490a9:	77 09                	ja     80490b4 <free+0x4b>
 80490ab:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80490ae:	2b 45 f4             	sub    eax,DWORD PTR [ebp-0xc]
 80490b1:	89 45 08             	mov    DWORD PTR [ebp+0x8],eax

	liballoc_lock();		// lockit
 80490b4:	e8 99 03 00 00       	call   8049452 <liballoc_lock>


	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
 80490b9:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80490bc:	83 e8 18             	sub    eax,0x18
 80490bf:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax

	
	if ( min->magic != LIBALLOC_MAGIC ) 
 80490c2:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80490c5:	8b 40 0c             	mov    eax,DWORD PTR [eax+0xc]
 80490c8:	3d de c0 01 c0       	cmp    eax,0xc001c0de
 80490cd:	74 74                	je     8049143 <free+0xda>
	{
		l_errorCount += 1;
 80490cf:	a1 68 c1 04 08       	mov    eax,ds:0x804c168
 80490d4:	8b 15 6c c1 04 08    	mov    edx,DWORD PTR ds:0x804c16c
 80490da:	83 c0 01             	add    eax,0x1
 80490dd:	83 d2 00             	adc    edx,0x0
 80490e0:	a3 68 c1 04 08       	mov    ds:0x804c168,eax
 80490e5:	89 15 6c c1 04 08    	mov    DWORD PTR ds:0x804c16c,edx

		// Check for overrun errors. For all bytes of LIBALLOC_MAGIC 
		if ( 
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
 80490eb:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80490ee:	8b 40 0c             	mov    eax,DWORD PTR [eax+0xc]
 80490f1:	25 ff ff ff 00       	and    eax,0xffffff
		if ( 
 80490f6:	3d de c0 01 00       	cmp    eax,0x1c0de
 80490fb:	74 20                	je     804911d <free+0xb4>
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
 80490fd:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8049100:	8b 40 0c             	mov    eax,DWORD PTR [eax+0xc]
 8049103:	0f b7 c0             	movzx  eax,ax
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
 8049106:	3d de c0 00 00       	cmp    eax,0xc0de
 804910b:	74 10                	je     804911d <free+0xb4>
			((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF)) 
 804910d:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8049110:	8b 40 0c             	mov    eax,DWORD PTR [eax+0xc]
 8049113:	0f b6 c0             	movzx  eax,al
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
 8049116:	3d de 00 00 00       	cmp    eax,0xde
 804911b:	75 1c                	jne    8049139 <free+0xd0>
		   )
		{
			l_possibleOverruns += 1;
 804911d:	a1 70 c1 04 08       	mov    eax,ds:0x804c170
 8049122:	8b 15 74 c1 04 08    	mov    edx,DWORD PTR ds:0x804c174
 8049128:	83 c0 01             	add    eax,0x1
 804912b:	83 d2 00             	adc    edx,0x0
 804912e:	a3 70 c1 04 08       	mov    ds:0x804c170,eax
 8049133:	89 15 74 c1 04 08    	mov    DWORD PTR ds:0x804c174,edx
			FLUSH();
			#endif
		}
			
		// being lied to...
		liballoc_unlock();		// release the lock
 8049139:	e8 2c 03 00 00       	call   804946a <liballoc_unlock>
		return;
 804913e:	e9 7d 01 00 00       	jmp    80492c0 <free+0x257>
				ptr );
	FLUSH();
	#endif
	

		maj = min->block;
 8049143:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8049146:	8b 40 08             	mov    eax,DWORD PTR [eax+0x8]
 8049149:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax

		l_inuse -= min->size;
 804914c:	a1 58 c1 04 08       	mov    eax,ds:0x804c158
 8049151:	8b 15 5c c1 04 08    	mov    edx,DWORD PTR ds:0x804c15c
 8049157:	8b 4d f0             	mov    ecx,DWORD PTR [ebp-0x10]
 804915a:	8b 49 10             	mov    ecx,DWORD PTR [ecx+0x10]
 804915d:	bb 00 00 00 00       	mov    ebx,0x0
 8049162:	29 c8                	sub    eax,ecx
 8049164:	19 da                	sbb    edx,ebx
 8049166:	a3 58 c1 04 08       	mov    ds:0x804c158,eax
 804916b:	89 15 5c c1 04 08    	mov    DWORD PTR ds:0x804c15c,edx

		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
 8049171:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 8049174:	8b 50 10             	mov    edx,DWORD PTR [eax+0x10]
 8049177:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 804917a:	8b 40 10             	mov    eax,DWORD PTR [eax+0x10]
 804917d:	29 c2                	sub    edx,eax
 804917f:	89 d0                	mov    eax,edx
 8049181:	8d 50 e8             	lea    edx,[eax-0x18]
 8049184:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 8049187:	89 50 10             	mov    DWORD PTR [eax+0x10],edx
		min->magic  = LIBALLOC_DEAD;		// No mojo.
 804918a:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 804918d:	c7 40 0c ad de ad de 	mov    DWORD PTR [eax+0xc],0xdeaddead

		if ( min->next != NULL ) min->next->prev = min->prev;
 8049194:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8049197:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 804919a:	85 c0                	test   eax,eax
 804919c:	74 0d                	je     80491ab <free+0x142>
 804919e:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80491a1:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80491a4:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
 80491a7:	8b 12                	mov    edx,DWORD PTR [edx]
 80491a9:	89 10                	mov    DWORD PTR [eax],edx
		if ( min->prev != NULL ) min->prev->next = min->next;
 80491ab:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80491ae:	8b 00                	mov    eax,DWORD PTR [eax]
 80491b0:	85 c0                	test   eax,eax
 80491b2:	74 0e                	je     80491c2 <free+0x159>
 80491b4:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80491b7:	8b 00                	mov    eax,DWORD PTR [eax]
 80491b9:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
 80491bc:	8b 52 04             	mov    edx,DWORD PTR [edx+0x4]
 80491bf:	89 50 04             	mov    DWORD PTR [eax+0x4],edx

		if ( min->prev == NULL ) maj->first = min->next;	
 80491c2:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80491c5:	8b 00                	mov    eax,DWORD PTR [eax]
 80491c7:	85 c0                	test   eax,eax
 80491c9:	75 0c                	jne    80491d7 <free+0x16e>
 80491cb:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 80491ce:	8b 50 04             	mov    edx,DWORD PTR [eax+0x4]
 80491d1:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80491d4:	89 50 14             	mov    DWORD PTR [eax+0x14],edx
							// minor.


	// We need to clean up after the majors now....

	if ( maj->first == NULL )	// Block completely unused.
 80491d7:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80491da:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 80491dd:	85 c0                	test   eax,eax
 80491df:	0f 85 93 00 00 00    	jne    8049278 <free+0x20f>
	{
		if ( l_memRoot == maj ) l_memRoot = maj->next;
 80491e5:	a1 48 c1 04 08       	mov    eax,ds:0x804c148
 80491ea:	39 45 ec             	cmp    DWORD PTR [ebp-0x14],eax
 80491ed:	75 0b                	jne    80491fa <free+0x191>
 80491ef:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80491f2:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80491f5:	a3 48 c1 04 08       	mov    ds:0x804c148,eax
		if ( l_bestBet == maj ) l_bestBet = NULL;
 80491fa:	a1 4c c1 04 08       	mov    eax,ds:0x804c14c
 80491ff:	39 45 ec             	cmp    DWORD PTR [ebp-0x14],eax
 8049202:	75 0a                	jne    804920e <free+0x1a5>
 8049204:	c7 05 4c c1 04 08 00 	mov    DWORD PTR ds:0x804c14c,0x0
 804920b:	00 00 00 
		if ( maj->prev != NULL ) maj->prev->next = maj->next;
 804920e:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 8049211:	8b 00                	mov    eax,DWORD PTR [eax]
 8049213:	85 c0                	test   eax,eax
 8049215:	74 0e                	je     8049225 <free+0x1bc>
 8049217:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 804921a:	8b 00                	mov    eax,DWORD PTR [eax]
 804921c:	8b 55 ec             	mov    edx,DWORD PTR [ebp-0x14]
 804921f:	8b 52 04             	mov    edx,DWORD PTR [edx+0x4]
 8049222:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
		if ( maj->next != NULL ) maj->next->prev = maj->prev;
 8049225:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 8049228:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 804922b:	85 c0                	test   eax,eax
 804922d:	74 0d                	je     804923c <free+0x1d3>
 804922f:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 8049232:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8049235:	8b 55 ec             	mov    edx,DWORD PTR [ebp-0x14]
 8049238:	8b 12                	mov    edx,DWORD PTR [edx]
 804923a:	89 10                	mov    DWORD PTR [eax],edx
		l_allocated -= maj->size;
 804923c:	a1 50 c1 04 08       	mov    eax,ds:0x804c150
 8049241:	8b 15 54 c1 04 08    	mov    edx,DWORD PTR ds:0x804c154
 8049247:	8b 4d ec             	mov    ecx,DWORD PTR [ebp-0x14]
 804924a:	8b 49 0c             	mov    ecx,DWORD PTR [ecx+0xc]
 804924d:	bb 00 00 00 00       	mov    ebx,0x0
 8049252:	29 c8                	sub    eax,ecx
 8049254:	19 da                	sbb    edx,ebx
 8049256:	a3 50 c1 04 08       	mov    ds:0x804c150,eax
 804925b:	89 15 54 c1 04 08    	mov    DWORD PTR ds:0x804c154,edx

		liballoc_free( maj, maj->pages );
 8049261:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 8049264:	8b 40 08             	mov    eax,DWORD PTR [eax+0x8]
 8049267:	83 ec 08             	sub    esp,0x8
 804926a:	50                   	push   eax
 804926b:	ff 75 ec             	push   DWORD PTR [ebp-0x14]
 804926e:	e8 26 02 00 00       	call   8049499 <liballoc_free>
 8049273:	83 c4 10             	add    esp,0x10
 8049276:	eb 43                	jmp    80492bb <free+0x252>
	}
	else
	{
		if ( l_bestBet != NULL )
 8049278:	a1 4c c1 04 08       	mov    eax,ds:0x804c14c
 804927d:	85 c0                	test   eax,eax
 804927f:	74 3a                	je     80492bb <free+0x252>
		{
			int bestSize = l_bestBet->size  - l_bestBet->usage;
 8049281:	a1 4c c1 04 08       	mov    eax,ds:0x804c14c
 8049286:	8b 50 0c             	mov    edx,DWORD PTR [eax+0xc]
 8049289:	a1 4c c1 04 08       	mov    eax,ds:0x804c14c
 804928e:	8b 40 10             	mov    eax,DWORD PTR [eax+0x10]
 8049291:	29 c2                	sub    edx,eax
 8049293:	89 d0                	mov    eax,edx
 8049295:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax
			int majSize = maj->size - maj->usage;
 8049298:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 804929b:	8b 50 0c             	mov    edx,DWORD PTR [eax+0xc]
 804929e:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80492a1:	8b 40 10             	mov    eax,DWORD PTR [eax+0x10]
 80492a4:	29 c2                	sub    edx,eax
 80492a6:	89 d0                	mov    eax,edx
 80492a8:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax

			if ( majSize > bestSize ) l_bestBet = maj;
 80492ab:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 80492ae:	3b 45 e8             	cmp    eax,DWORD PTR [ebp-0x18]
 80492b1:	7e 08                	jle    80492bb <free+0x252>
 80492b3:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80492b6:	a3 4c c1 04 08       	mov    ds:0x804c14c,eax
	#ifdef DEBUG
	serial_printf( "OK\n");
	FLUSH();
	#endif
	
	liballoc_unlock();		// release the lock
 80492bb:	e8 aa 01 00 00       	call   804946a <liballoc_unlock>
}
 80492c0:	8b 5d fc             	mov    ebx,DWORD PTR [ebp-0x4]
 80492c3:	c9                   	leave  
 80492c4:	c3                   	ret    

080492c5 <calloc>:




void* PREFIX(calloc)(size_t nobj, size_t size)
{
 80492c5:	55                   	push   ebp
 80492c6:	89 e5                	mov    ebp,esp
 80492c8:	83 ec 18             	sub    esp,0x18
       int real_size;
       void *p;

       real_size = nobj * size;
 80492cb:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80492ce:	0f af 45 0c          	imul   eax,DWORD PTR [ebp+0xc]
 80492d2:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
       
       p = PREFIX(malloc)( real_size );
 80492d5:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 80492d8:	83 ec 0c             	sub    esp,0xc
 80492db:	50                   	push   eax
 80492dc:	e8 fc f6 ff ff       	call   80489dd <malloc>
 80492e1:	83 c4 10             	add    esp,0x10
 80492e4:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax

       liballoc_memset( p, 0, real_size );
 80492e7:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 80492ea:	83 ec 04             	sub    esp,0x4
 80492ed:	50                   	push   eax
 80492ee:	6a 00                	push   0x0
 80492f0:	ff 75 f0             	push   DWORD PTR [ebp-0x10]
 80492f3:	e8 6a f5 ff ff       	call   8048862 <liballoc_memset>
 80492f8:	83 c4 10             	add    esp,0x10

       return p;
 80492fb:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
 80492fe:	c9                   	leave  
 80492ff:	c3                   	ret    

08049300 <realloc>:



void*   PREFIX(realloc)(void *p, size_t size)
{
 8049300:	55                   	push   ebp
 8049301:	89 e5                	mov    ebp,esp
 8049303:	83 ec 18             	sub    esp,0x18
	void *ptr;
	struct liballoc_minor *min;
	unsigned int real_size;
	
	// Honour the case of size == 0 => free old and return NULL
	if ( size == 0 )
 8049306:	83 7d 0c 00          	cmp    DWORD PTR [ebp+0xc],0x0
 804930a:	75 18                	jne    8049324 <realloc+0x24>
	{
		PREFIX(free)( p );
 804930c:	83 ec 0c             	sub    esp,0xc
 804930f:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049312:	e8 52 fd ff ff       	call   8049069 <free>
 8049317:	83 c4 10             	add    esp,0x10
		return NULL;
 804931a:	b8 00 00 00 00       	mov    eax,0x0
 804931f:	e9 2c 01 00 00       	jmp    8049450 <realloc+0x150>
	}

	// In the case of a NULL pointer, return a simple malloc.
	if ( p == NULL ) return PREFIX(malloc)( size );
 8049324:	83 7d 08 00          	cmp    DWORD PTR [ebp+0x8],0x0
 8049328:	75 13                	jne    804933d <realloc+0x3d>
 804932a:	83 ec 0c             	sub    esp,0xc
 804932d:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 8049330:	e8 a8 f6 ff ff       	call   80489dd <malloc>
 8049335:	83 c4 10             	add    esp,0x10
 8049338:	e9 13 01 00 00       	jmp    8049450 <realloc+0x150>

	// Unalign the pointer if required.
	ptr = p;
 804933d:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8049340:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
	UNALIGN(ptr);
 8049343:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 8049346:	83 e8 10             	sub    eax,0x10
 8049349:	8a 00                	mov    al,BYTE PTR [eax]
 804934b:	0f be c0             	movsx  eax,al
 804934e:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
 8049351:	83 7d f0 1f          	cmp    DWORD PTR [ebp-0x10],0x1f
 8049355:	77 09                	ja     8049360 <realloc+0x60>
 8049357:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 804935a:	2b 45 f0             	sub    eax,DWORD PTR [ebp-0x10]
 804935d:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax

	liballoc_lock();		// lockit
 8049360:	e8 ed 00 00 00       	call   8049452 <liballoc_lock>

		min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
 8049365:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 8049368:	83 e8 18             	sub    eax,0x18
 804936b:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax

		// Ensure it is a valid structure.
		if ( min->magic != LIBALLOC_MAGIC ) 
 804936e:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 8049371:	8b 40 0c             	mov    eax,DWORD PTR [eax+0xc]
 8049374:	3d de c0 01 c0       	cmp    eax,0xc001c0de
 8049379:	74 76                	je     80493f1 <realloc+0xf1>
		{
			l_errorCount += 1;
 804937b:	a1 68 c1 04 08       	mov    eax,ds:0x804c168
 8049380:	8b 15 6c c1 04 08    	mov    edx,DWORD PTR ds:0x804c16c
 8049386:	83 c0 01             	add    eax,0x1
 8049389:	83 d2 00             	adc    edx,0x0
 804938c:	a3 68 c1 04 08       	mov    ds:0x804c168,eax
 8049391:	89 15 6c c1 04 08    	mov    DWORD PTR ds:0x804c16c,edx
	
			// Check for overrun errors. For all bytes of LIBALLOC_MAGIC 
			if ( 
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
 8049397:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 804939a:	8b 40 0c             	mov    eax,DWORD PTR [eax+0xc]
 804939d:	25 ff ff ff 00       	and    eax,0xffffff
			if ( 
 80493a2:	3d de c0 01 00       	cmp    eax,0x1c0de
 80493a7:	74 20                	je     80493c9 <realloc+0xc9>
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
 80493a9:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80493ac:	8b 40 0c             	mov    eax,DWORD PTR [eax+0xc]
 80493af:	0f b7 c0             	movzx  eax,ax
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
 80493b2:	3d de c0 00 00       	cmp    eax,0xc0de
 80493b7:	74 10                	je     80493c9 <realloc+0xc9>
				((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF)) 
 80493b9:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80493bc:	8b 40 0c             	mov    eax,DWORD PTR [eax+0xc]
 80493bf:	0f b6 c0             	movzx  eax,al
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
 80493c2:	3d de 00 00 00       	cmp    eax,0xde
 80493c7:	75 1c                	jne    80493e5 <realloc+0xe5>
			   )
			{
				l_possibleOverruns += 1;
 80493c9:	a1 70 c1 04 08       	mov    eax,ds:0x804c170
 80493ce:	8b 15 74 c1 04 08    	mov    edx,DWORD PTR ds:0x804c174
 80493d4:	83 c0 01             	add    eax,0x1
 80493d7:	83 d2 00             	adc    edx,0x0
 80493da:	a3 70 c1 04 08       	mov    ds:0x804c170,eax
 80493df:	89 15 74 c1 04 08    	mov    DWORD PTR ds:0x804c174,edx
				FLUSH();
				#endif
			}
			
			// being lied to...
			liballoc_unlock();		// release the lock
 80493e5:	e8 80 00 00 00       	call   804946a <liballoc_unlock>
			return NULL;
 80493ea:	b8 00 00 00 00       	mov    eax,0x0
 80493ef:	eb 5f                	jmp    8049450 <realloc+0x150>
		}	
		
		// Definitely a memory block.
		
		real_size = min->req_size;
 80493f1:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 80493f4:	8b 40 14             	mov    eax,DWORD PTR [eax+0x14]
 80493f7:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax

		if ( real_size >= size ) 
 80493fa:	8b 45 e8             	mov    eax,DWORD PTR [ebp-0x18]
 80493fd:	3b 45 0c             	cmp    eax,DWORD PTR [ebp+0xc]
 8049400:	72 13                	jb     8049415 <realloc+0x115>
		{
			min->req_size = size;
 8049402:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 8049405:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 8049408:	89 50 14             	mov    DWORD PTR [eax+0x14],edx
			liballoc_unlock();
 804940b:	e8 5a 00 00 00       	call   804946a <liballoc_unlock>
			return p;
 8049410:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8049413:	eb 3b                	jmp    8049450 <realloc+0x150>
		}

	liballoc_unlock();
 8049415:	e8 50 00 00 00       	call   804946a <liballoc_unlock>

	// If we got here then we're reallocating to a block bigger than us.
	ptr = PREFIX(malloc)( size );					// We need to allocate new memory
 804941a:	83 ec 0c             	sub    esp,0xc
 804941d:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 8049420:	e8 b8 f5 ff ff       	call   80489dd <malloc>
 8049425:	83 c4 10             	add    esp,0x10
 8049428:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
	liballoc_memcpy( ptr, p, real_size );
 804942b:	83 ec 04             	sub    esp,0x4
 804942e:	ff 75 e8             	push   DWORD PTR [ebp-0x18]
 8049431:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049434:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 8049437:	e8 52 f4 ff ff       	call   804888e <liballoc_memcpy>
 804943c:	83 c4 10             	add    esp,0x10
	PREFIX(free)( p );
 804943f:	83 ec 0c             	sub    esp,0xc
 8049442:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049445:	e8 1f fc ff ff       	call   8049069 <free>
 804944a:	83 c4 10             	add    esp,0x10

	return ptr;
 804944d:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
}
 8049450:	c9                   	leave  
 8049451:	c3                   	ret    

08049452 <liballoc_lock>:
#include <memory.h>
#include <pthread.h>

pthread_spinlock_t lock;

int liballoc_lock() {
 8049452:	55                   	push   ebp
 8049453:	89 e5                	mov    ebp,esp
 8049455:	83 ec 08             	sub    esp,0x8
  return pthread_spin_lock(&lock);
 8049458:	83 ec 0c             	sub    esp,0xc
 804945b:	68 8c c1 04 08       	push   0x804c18c
 8049460:	e8 59 01 00 00       	call   80495be <pthread_spin_lock>
 8049465:	83 c4 10             	add    esp,0x10
}
 8049468:	c9                   	leave  
 8049469:	c3                   	ret    

0804946a <liballoc_unlock>:

extern int liballoc_unlock() {
 804946a:	55                   	push   ebp
 804946b:	89 e5                	mov    ebp,esp
 804946d:	83 ec 08             	sub    esp,0x8
  return pthread_spin_unlock(&lock);
 8049470:	83 ec 0c             	sub    esp,0xc
 8049473:	68 8c c1 04 08       	push   0x804c18c
 8049478:	e8 5c 01 00 00       	call   80495d9 <pthread_spin_unlock>
 804947d:	83 c4 10             	add    esp,0x10
}
 8049480:	c9                   	leave  
 8049481:	c3                   	ret    

08049482 <liballoc_alloc>:

extern void* liballoc_alloc(size_t num_pages) {
 8049482:	55                   	push   ebp
 8049483:	89 e5                	mov    ebp,esp
 8049485:	83 ec 08             	sub    esp,0x8
  return alloc_memory(num_pages);
 8049488:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804948b:	83 ec 0c             	sub    esp,0xc
 804948e:	50                   	push   eax
 804948f:	e8 0f 00 00 00       	call   80494a3 <alloc_memory>
 8049494:	83 c4 10             	add    esp,0x10
}
 8049497:	c9                   	leave  
 8049498:	c3                   	ret    

08049499 <liballoc_free>:

extern int liballoc_free(void* ptr,size_t num_pages) {
 8049499:	55                   	push   ebp
 804949a:	89 e5                	mov    ebp,esp
  return 0;
 804949c:	b8 00 00 00 00       	mov    eax,0x0
}
 80494a1:	5d                   	pop    ebp
 80494a2:	c3                   	ret    

080494a3 <alloc_memory>:
#include <sys/syscalls.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void* alloc_memory(int num_pages) {
 80494a3:	55                   	push   ebp
 80494a4:	89 e5                	mov    ebp,esp
 80494a6:	53                   	push   ebx
 80494a7:	83 ec 10             	sub    esp,0x10
  void* address;
  asm volatile("  \
 80494aa:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80494ad:	ba 00 00 00 00       	mov    edx,0x0
 80494b2:	89 c3                	mov    ebx,eax
 80494b4:	89 d1                	mov    ecx,edx
 80494b6:	b8 07 00 00 00       	mov    eax,0x7
 80494bb:	cd 50                	int    0x50
 80494bd:	89 d8                	mov    eax,ebx
 80494bf:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
    mov $" QU(SYSCALL_ALLOC_MEM) ", %%eax; \
    int $80; \
  ":"=b"(address):"b"(num_pages),"c"(NULL));
  return address;
 80494c2:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
}
 80494c5:	83 c4 10             	add    esp,0x10
 80494c8:	5b                   	pop    ebx
 80494c9:	5d                   	pop    ebp
 80494ca:	c3                   	ret    

080494cb <alloc_memory_virt>:

void alloc_memory_virt(int num_pages,void* addr) {
 80494cb:	55                   	push   ebp
 80494cc:	89 e5                	mov    ebp,esp
 80494ce:	53                   	push   ebx
  asm volatile("  \
 80494cf:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80494d2:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 80494d5:	89 c3                	mov    ebx,eax
 80494d7:	89 d1                	mov    ecx,edx
 80494d9:	b8 07 00 00 00       	mov    eax,0x7
 80494de:	cd 50                	int    0x50
    mov $" QU(SYSCALL_ALLOC_MEM) ", %%eax; \
    int $80; \
  "::"b"(num_pages),"c"(addr));
}
 80494e0:	90                   	nop
 80494e1:	5b                   	pop    ebx
 80494e2:	5d                   	pop    ebp
 80494e3:	c3                   	ret    

080494e4 <new_address_space>:

void* new_address_space() {
 80494e4:	55                   	push   ebp
 80494e5:	89 e5                	mov    ebp,esp
 80494e7:	53                   	push   ebx
 80494e8:	83 ec 10             	sub    esp,0x10
  void* address_space;
  asm volatile("  \
 80494eb:	b8 09 00 00 00       	mov    eax,0x9
 80494f0:	cd 50                	int    0x50
 80494f2:	89 d8                	mov    eax,ebx
 80494f4:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
    mov $" QU(SYSCALL_NEW_ADDR_SPACE) ", %%eax; \
    int $80; \
  ":"=b"(address_space));
  return address_space;
 80494f7:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
}
 80494fa:	83 c4 10             	add    esp,0x10
 80494fd:	5b                   	pop    ebx
 80494fe:	5d                   	pop    ebp
 80494ff:	c3                   	ret    

08049500 <copy_data>:

void copy_data(void* address_space, void* data,size_t size,void* virt_addr) {
 8049500:	55                   	push   ebp
 8049501:	89 e5                	mov    ebp,esp
 8049503:	56                   	push   esi
 8049504:	53                   	push   ebx
  asm volatile("  \
 8049505:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8049508:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
 804950b:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
 804950e:	8b 75 14             	mov    esi,DWORD PTR [ebp+0x14]
 8049511:	89 c3                	mov    ebx,eax
 8049513:	b8 0a 00 00 00       	mov    eax,0xa
 8049518:	cd 50                	int    0x50
    mov $" QU(SYSCALL_ADDR_SPACES_COPY_DATA) ", %%eax; \
    int $80; \
  "::"b"(address_space),"c"(data),"d"(size),"S"(virt_addr));
}
 804951a:	90                   	nop
 804951b:	5b                   	pop    ebx
 804951c:	5e                   	pop    esi
 804951d:	5d                   	pop    ebp
 804951e:	c3                   	ret    

0804951f <put_data>:

void* put_data(void* address_space, void* data,size_t size) {
 804951f:	55                   	push   ebp
 8049520:	89 e5                	mov    ebp,esp
 8049522:	56                   	push   esi
 8049523:	53                   	push   ebx
 8049524:	83 ec 10             	sub    esp,0x10
  void* virt_addr;
  asm volatile("  \
 8049527:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804952a:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
 804952d:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
 8049530:	be 00 00 00 00       	mov    esi,0x0
 8049535:	89 c3                	mov    ebx,eax
 8049537:	b8 0a 00 00 00       	mov    eax,0xa
 804953c:	cd 50                	int    0x50
 804953e:	89 d8                	mov    eax,ebx
 8049540:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
    mov $" QU(SYSCALL_ADDR_SPACES_COPY_DATA) ", %%eax; \
    int $80; \
  ":"=b"(virt_addr):"b"(address_space),"c"(data),"d"(size),"S"(NULL));
  return virt_addr;
 8049543:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
}
 8049546:	83 c4 10             	add    esp,0x10
 8049549:	5b                   	pop    ebx
 804954a:	5e                   	pop    esi
 804954b:	5d                   	pop    ebp
 804954c:	c3                   	ret    

0804954d <map_phys>:

void* map_phys(void* phys_addr,size_t num_pages) {
 804954d:	55                   	push   ebp
 804954e:	89 e5                	mov    ebp,esp
 8049550:	53                   	push   ebx
 8049551:	83 ec 10             	sub    esp,0x10
  void* virt_addr;
  asm volatile("  \
 8049554:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8049557:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 804955a:	89 c3                	mov    ebx,eax
 804955c:	89 d1                	mov    ecx,edx
 804955e:	b8 08 00 00 00       	mov    eax,0x8
 8049563:	cd 50                	int    0x50
 8049565:	89 d8                	mov    eax,ebx
 8049567:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
    mov $" QU(SYSCALL_PRIV_MAP_PAGES) ", %%eax; \
    int $80; \
  ":"=b"(virt_addr):"b"(phys_addr),"c"(num_pages));
  return virt_addr;
 804956a:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
}
 804956d:	83 c4 10             	add    esp,0x10
 8049570:	5b                   	pop    ebx
 8049571:	5d                   	pop    ebp
 8049572:	c3                   	ret    

08049573 <pthread_create>:
#include <__helpers.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start_routine)(void*), void *restrict arg) {
 8049573:	55                   	push   ebp
 8049574:	89 e5                	mov    ebp,esp
 8049576:	53                   	push   ebx
  if (thread==NULL) {
 8049577:	83 7d 08 00          	cmp    DWORD PTR [ebp+0x8],0x0
 804957b:	75 07                	jne    8049584 <pthread_create+0x11>
    return 1;
 804957d:	b8 01 00 00 00       	mov    eax,0x1
 8049582:	eb 17                	jmp    804959b <pthread_create+0x28>
  }
  asm volatile("  \
 8049584:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049587:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
 804958a:	8b 55 14             	mov    edx,DWORD PTR [ebp+0x14]
 804958d:	89 c3                	mov    ebx,eax
 804958f:	b8 0e 00 00 00       	mov    eax,0xe
 8049594:	cd 50                	int    0x50
    mov $" QU(SYSCALL_NEW_THREAD) ", %%eax; \
    int $80; \
  "::"b"(start_routine),"c"(thread),"d"(arg));
  return 0;
 8049596:	b8 00 00 00 00       	mov    eax,0x0
}
 804959b:	5b                   	pop    ebx
 804959c:	5d                   	pop    ebp
 804959d:	c3                   	ret    

0804959e <pthread_exit>:

void pthread_exit(void *value_ptr) {
 804959e:	55                   	push   ebp
 804959f:	89 e5                	mov    ebp,esp
  asm volatile("  \
 80495a1:	b8 13 00 00 00       	mov    eax,0x13
 80495a6:	cd 50                	int    0x50
    mov $" QU(SYSCALL_THREAD_EXIT) ", %eax; \
    int $80;");
}
 80495a8:	90                   	nop
 80495a9:	5d                   	pop    ebp
 80495aa:	c3                   	ret    

080495ab <pthread_spin_init>:

int pthread_spin_init(pthread_spinlock_t *lock, int pshared) {
 80495ab:	55                   	push   ebp
 80495ac:	89 e5                	mov    ebp,esp
  *lock=0;
 80495ae:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80495b1:	c7 00 00 00 00 00    	mov    DWORD PTR [eax],0x0
  return 0;
 80495b7:	b8 00 00 00 00       	mov    eax,0x0
}
 80495bc:	5d                   	pop    ebp
 80495bd:	c3                   	ret    

080495be <pthread_spin_lock>:

int pthread_spin_lock(pthread_spinlock_t *lock) {
 80495be:	55                   	push   ebp
 80495bf:	89 e5                	mov    ebp,esp
 80495c1:	83 ec 08             	sub    esp,0x8
  __pthread_spin_lock_helper(lock);
 80495c4:	83 ec 0c             	sub    esp,0xc
 80495c7:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 80495ca:	e8 a1 10 00 00       	call   804a670 <__pthread_spin_lock_helper>
 80495cf:	83 c4 10             	add    esp,0x10
  return 0;
 80495d2:	b8 00 00 00 00       	mov    eax,0x0
}
 80495d7:	c9                   	leave  
 80495d8:	c3                   	ret    

080495d9 <pthread_spin_unlock>:

int pthread_spin_unlock(pthread_spinlock_t *lock) {
 80495d9:	55                   	push   ebp
 80495da:	89 e5                	mov    ebp,esp
  *lock=0;
 80495dc:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80495df:	c7 00 00 00 00 00    	mov    DWORD PTR [eax],0x0
  return 0;
 80495e5:	b8 00 00 00 00       	mov    eax,0x0
}
 80495ea:	5d                   	pop    ebp
 80495eb:	c3                   	ret    

080495ec <pthread_spin_destroy>:

int pthread_spin_destroy(pthread_spinlock_t *lock) {
 80495ec:	55                   	push   ebp
 80495ed:	89 e5                	mov    ebp,esp
  return 0;
 80495ef:	b8 00 00 00 00       	mov    eax,0x0
}
 80495f4:	5d                   	pop    ebp
 80495f5:	c3                   	ret    

080495f6 <rpc_call>:

#define QUAUX(X) #X
#define QU(X) QUAUX(X)


void* rpc_call(pid_t pid,char* name,void* buf,size_t size) {
 80495f6:	55                   	push   ebp
 80495f7:	89 e5                	mov    ebp,esp
 80495f9:	57                   	push   edi
 80495fa:	56                   	push   esi
 80495fb:	53                   	push   ebx
 80495fc:	83 ec 10             	sub    esp,0x10
  void* retbuf;
  asm volatile("  \
 80495ff:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8049602:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
 8049605:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
 8049608:	8b 75 14             	mov    esi,DWORD PTR [ebp+0x14]
 804960b:	89 c3                	mov    ebx,eax
 804960d:	b8 0f 00 00 00       	mov    eax,0xf
 8049612:	cd 50                	int    0x50
 8049614:	89 f8                	mov    eax,edi
 8049616:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
    mov $" QU(SYSCALL_CALL_RPC) ", %%eax; \
    int $80; \
  ":"=D"(retbuf):"b"(pid),"c"(name),"d"(buf),"S"(size));
  return retbuf;
 8049619:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
 804961c:	83 c4 10             	add    esp,0x10
 804961f:	5b                   	pop    ebx
 8049620:	5e                   	pop    esi
 8049621:	5f                   	pop    edi
 8049622:	5d                   	pop    ebp
 8049623:	c3                   	ret    

08049624 <rpc_register_func>:

void rpc_register_func(char* name,rpc_func code) {
 8049624:	55                   	push   ebp
 8049625:	89 e5                	mov    ebp,esp
 8049627:	53                   	push   ebx
  asm volatile("  \
 8049628:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804962b:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 804962e:	89 c3                	mov    ebx,eax
 8049630:	89 d1                	mov    ecx,edx
 8049632:	b8 10 00 00 00       	mov    eax,0x10
 8049637:	cd 50                	int    0x50
    mov $" QU(SYSCALL_REGISTER_RPC) ", %%eax; \
    int $80; \
  "::"b"(name),"c"(code));
}
 8049639:	90                   	nop
 804963a:	5b                   	pop    ebx
 804963b:	5d                   	pop    ebp
 804963c:	c3                   	ret    

0804963d <rpc_deallocate_buf>:

void rpc_deallocate_buf(void* buf,size_t size) {
 804963d:	55                   	push   ebp
 804963e:	89 e5                	mov    ebp,esp
 8049640:	53                   	push   ebx
  asm volatile("  \
 8049641:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8049644:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 8049647:	89 c3                	mov    ebx,eax
 8049649:	89 d1                	mov    ecx,edx
 804964b:	b8 11 00 00 00       	mov    eax,0x11
 8049650:	cd 50                	int    0x50
    mov $" QU(SYSCALL_DEALLOCTATE_RPC_RET) ", %%eax; \
    int $80; \
  "::"b"(buf),"c"(size));
}
 8049652:	90                   	nop
 8049653:	5b                   	pop    ebx
 8049654:	5d                   	pop    ebp
 8049655:	c3                   	ret    

08049656 <rpc_return>:

void rpc_return(void* buf,size_t size) {
 8049656:	55                   	push   ebp
 8049657:	89 e5                	mov    ebp,esp
 8049659:	53                   	push   ebx
  asm volatile("  \
 804965a:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804965d:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 8049660:	89 c3                	mov    ebx,eax
 8049662:	89 d1                	mov    ecx,edx
 8049664:	b8 12 00 00 00       	mov    eax,0x12
 8049669:	cd 50                	int    0x50
    mov $" QU(SYSCALL_RPC_RET) ", %%eax; \
    int $80; \
  "::"b"(buf),"c"(size));
}
 804966b:	90                   	nop
 804966c:	5b                   	pop    ebx
 804966d:	5d                   	pop    ebp
 804966e:	c3                   	ret    

0804966f <rpc_mark_as_init>:

void rpc_mark_as_init() {
 804966f:	55                   	push   ebp
 8049670:	89 e5                	mov    ebp,esp
  asm volatile("  \
 8049672:	b8 15 00 00 00       	mov    eax,0x15
 8049677:	cd 50                	int    0x50
    mov $" QU(SYSCALL_RPC_MARK_AS_INIT) ", %%eax; \
    int $80; \
  "::);
}
 8049679:	90                   	nop
 804967a:	5d                   	pop    ebp
 804967b:	c3                   	ret    

0804967c <rpc_is_init>:
char rpc_is_init(pid_t pid) {
 804967c:	55                   	push   ebp
 804967d:	89 e5                	mov    ebp,esp
 804967f:	53                   	push   ebx
 8049680:	83 ec 10             	sub    esp,0x10
  char is_init;
  asm volatile("  \
 8049683:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8049686:	89 c3                	mov    ebx,eax
 8049688:	b8 16 00 00 00       	mov    eax,0x16
 804968d:	cd 50                	int    0x50
 804968f:	88 c8                	mov    al,cl
 8049691:	88 45 fb             	mov    BYTE PTR [ebp-0x5],al
    mov $" QU(SYSCALL_RPC_IS_INIT) ", %%eax; \
    int $80; \
  ":"=c"(is_init):"b"(pid));
  return is_init;
 8049694:	8a 45 fb             	mov    al,BYTE PTR [ebp-0x5]
}
 8049697:	83 c4 10             	add    esp,0x10
 804969a:	5b                   	pop    ebx
 804969b:	5d                   	pop    ebp
 804969c:	c3                   	ret    

0804969d <serialize_int>:
#include <serdes.h>
#include <stdlib.h>
#include <string.h>

void serialize_int(int num,serdes_state* state) {
 804969d:	55                   	push   ebp
 804969e:	89 e5                	mov    ebp,esp
 80496a0:	83 ec 08             	sub    esp,0x8
  state->buf=realloc(state->buf,state->sizeorpos+sizeof(int));
 80496a3:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 80496a6:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80496a9:	8d 50 04             	lea    edx,[eax+0x4]
 80496ac:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 80496af:	8b 00                	mov    eax,DWORD PTR [eax]
 80496b1:	83 ec 08             	sub    esp,0x8
 80496b4:	52                   	push   edx
 80496b5:	50                   	push   eax
 80496b6:	e8 45 fc ff ff       	call   8049300 <realloc>
 80496bb:	83 c4 10             	add    esp,0x10
 80496be:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 80496c1:	89 02                	mov    DWORD PTR [edx],eax
  *((int*)(state->buf+state->sizeorpos))=num;
 80496c3:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 80496c6:	8b 10                	mov    edx,DWORD PTR [eax]
 80496c8:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 80496cb:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80496ce:	01 c2                	add    edx,eax
 80496d0:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80496d3:	89 02                	mov    DWORD PTR [edx],eax
  state->sizeorpos+=sizeof(int);
 80496d5:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 80496d8:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80496db:	8d 50 04             	lea    edx,[eax+0x4]
 80496de:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 80496e1:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
}
 80496e4:	90                   	nop
 80496e5:	c9                   	leave  
 80496e6:	c3                   	ret    

080496e7 <serialize_ptr>:

void serialize_ptr(void* ptr,serdes_state* state) {
 80496e7:	55                   	push   ebp
 80496e8:	89 e5                	mov    ebp,esp
 80496ea:	83 ec 08             	sub    esp,0x8
  state->buf=realloc(state->buf,state->sizeorpos+sizeof(void*));
 80496ed:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 80496f0:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80496f3:	8d 50 04             	lea    edx,[eax+0x4]
 80496f6:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 80496f9:	8b 00                	mov    eax,DWORD PTR [eax]
 80496fb:	83 ec 08             	sub    esp,0x8
 80496fe:	52                   	push   edx
 80496ff:	50                   	push   eax
 8049700:	e8 fb fb ff ff       	call   8049300 <realloc>
 8049705:	83 c4 10             	add    esp,0x10
 8049708:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 804970b:	89 02                	mov    DWORD PTR [edx],eax
  *((void**)(state->buf+state->sizeorpos))=ptr;
 804970d:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049710:	8b 10                	mov    edx,DWORD PTR [eax]
 8049712:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049715:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8049718:	01 c2                	add    edx,eax
 804971a:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804971d:	89 02                	mov    DWORD PTR [edx],eax
  state->sizeorpos+=sizeof(void*);
 804971f:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049722:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8049725:	8d 50 04             	lea    edx,[eax+0x4]
 8049728:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804972b:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
}
 804972e:	90                   	nop
 804972f:	c9                   	leave  
 8049730:	c3                   	ret    

08049731 <serialize_ary>:

void serialize_ary(void* ary,size_t len,serdes_state* state) {
 8049731:	55                   	push   ebp
 8049732:	89 e5                	mov    ebp,esp
 8049734:	83 ec 08             	sub    esp,0x8
  state->buf=realloc(state->buf,state->sizeorpos+len);
 8049737:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 804973a:	8b 50 04             	mov    edx,DWORD PTR [eax+0x4]
 804973d:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049740:	01 c2                	add    edx,eax
 8049742:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049745:	8b 00                	mov    eax,DWORD PTR [eax]
 8049747:	83 ec 08             	sub    esp,0x8
 804974a:	52                   	push   edx
 804974b:	50                   	push   eax
 804974c:	e8 af fb ff ff       	call   8049300 <realloc>
 8049751:	83 c4 10             	add    esp,0x10
 8049754:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
 8049757:	89 02                	mov    DWORD PTR [edx],eax
  memcpy(state->buf+state->sizeorpos,ary,len);
 8049759:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 804975c:	8b 10                	mov    edx,DWORD PTR [eax]
 804975e:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049761:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8049764:	01 d0                	add    eax,edx
 8049766:	83 ec 04             	sub    esp,0x4
 8049769:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804976c:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804976f:	50                   	push   eax
 8049770:	e8 a8 09 00 00       	call   804a11d <memcpy>
 8049775:	83 c4 10             	add    esp,0x10
  state->sizeorpos+=len;
 8049778:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 804977b:	8b 50 04             	mov    edx,DWORD PTR [eax+0x4]
 804977e:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049781:	01 c2                	add    edx,eax
 8049783:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049786:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
}
 8049789:	90                   	nop
 804978a:	c9                   	leave  
 804978b:	c3                   	ret    

0804978c <start_deserialize>:


void start_deserialize(char* buf,serdes_state* state) {
 804978c:	55                   	push   ebp
 804978d:	89 e5                	mov    ebp,esp
  state->buf=buf;
 804978f:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049792:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 8049795:	89 10                	mov    DWORD PTR [eax],edx
  state->sizeorpos=0;
 8049797:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804979a:	c7 40 04 00 00 00 00 	mov    DWORD PTR [eax+0x4],0x0
}
 80497a1:	90                   	nop
 80497a2:	5d                   	pop    ebp
 80497a3:	c3                   	ret    

080497a4 <deserialize_int>:

int deserialize_int(serdes_state* state) {
 80497a4:	55                   	push   ebp
 80497a5:	89 e5                	mov    ebp,esp
 80497a7:	83 ec 10             	sub    esp,0x10
  int num=*((int*)(state->buf+state->sizeorpos));
 80497aa:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80497ad:	8b 10                	mov    edx,DWORD PTR [eax]
 80497af:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80497b2:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80497b5:	01 d0                	add    eax,edx
 80497b7:	8b 00                	mov    eax,DWORD PTR [eax]
 80497b9:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
  state->sizeorpos+=sizeof(int);
 80497bc:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80497bf:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80497c2:	8d 50 04             	lea    edx,[eax+0x4]
 80497c5:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80497c8:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
  return num;
 80497cb:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
}
 80497ce:	c9                   	leave  
 80497cf:	c3                   	ret    

080497d0 <deserialize_ptr>:

void* deserialize_ptr(serdes_state* state) {
 80497d0:	55                   	push   ebp
 80497d1:	89 e5                	mov    ebp,esp
 80497d3:	83 ec 10             	sub    esp,0x10
  void* ptr=*((void**)(state->buf+state->sizeorpos));
 80497d6:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80497d9:	8b 10                	mov    edx,DWORD PTR [eax]
 80497db:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80497de:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80497e1:	01 d0                	add    eax,edx
 80497e3:	8b 00                	mov    eax,DWORD PTR [eax]
 80497e5:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
  state->sizeorpos+=sizeof(void*);
 80497e8:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80497eb:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80497ee:	8d 50 04             	lea    edx,[eax+0x4]
 80497f1:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80497f4:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
  return ptr;
 80497f7:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
}
 80497fa:	c9                   	leave  
 80497fb:	c3                   	ret    

080497fc <deserialize_ary>:

void* deserialize_ary(size_t len,serdes_state* state) {
 80497fc:	55                   	push   ebp
 80497fd:	89 e5                	mov    ebp,esp
 80497ff:	83 ec 10             	sub    esp,0x10
  void* ary=((void*)(state->buf+state->sizeorpos));
 8049802:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049805:	8b 10                	mov    edx,DWORD PTR [eax]
 8049807:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804980a:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 804980d:	01 d0                	add    eax,edx
 804980f:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
  state->sizeorpos+=len;
 8049812:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049815:	8b 50 04             	mov    edx,DWORD PTR [eax+0x4]
 8049818:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804981b:	01 c2                	add    edx,eax
 804981d:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049820:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
  return ary;
 8049823:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
}
 8049826:	c9                   	leave  
 8049827:	c3                   	ret    

08049828 <__stdio_init>:

/** 
 * Initialize stdio.
 * Must not be called by user code.
*/
void __stdio_init() {
 8049828:	55                   	push   ebp
 8049829:	89 e5                	mov    ebp,esp
}
 804982b:	90                   	nop
 804982c:	5d                   	pop    ebp
 804982d:	c3                   	ret    

0804982e <fopen>:

FILE* fopen(char* filename,char* mode) {
 804982e:	55                   	push   ebp
 804982f:	89 e5                	mov    ebp,esp
 8049831:	83 ec 28             	sub    esp,0x28
  serdes_state state={0};
 8049834:	c7 45 dc 00 00 00 00 	mov    DWORD PTR [ebp-0x24],0x0
 804983b:	c7 45 e0 00 00 00 00 	mov    DWORD PTR [ebp-0x20],0x0
  serialize_str(filename,&state);
 8049842:	83 ec 0c             	sub    esp,0xc
 8049845:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049848:	e8 a0 09 00 00       	call   804a1ed <strlen>
 804984d:	83 c4 10             	add    esp,0x10
 8049850:	40                   	inc    eax
 8049851:	89 c2                	mov    edx,eax
 8049853:	83 ec 08             	sub    esp,0x8
 8049856:	8d 45 dc             	lea    eax,[ebp-0x24]
 8049859:	50                   	push   eax
 804985a:	52                   	push   edx
 804985b:	e8 3d fe ff ff       	call   804969d <serialize_int>
 8049860:	83 c4 10             	add    esp,0x10
 8049863:	83 ec 0c             	sub    esp,0xc
 8049866:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049869:	e8 7f 09 00 00       	call   804a1ed <strlen>
 804986e:	83 c4 10             	add    esp,0x10
 8049871:	8d 50 01             	lea    edx,[eax+0x1]
 8049874:	83 ec 04             	sub    esp,0x4
 8049877:	8d 45 dc             	lea    eax,[ebp-0x24]
 804987a:	50                   	push   eax
 804987b:	52                   	push   edx
 804987c:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804987f:	e8 ad fe ff ff       	call   8049731 <serialize_ary>
 8049884:	83 c4 10             	add    esp,0x10
  void* retval=rpc_call(2,"open",state.buf,state.sizeorpos);
 8049887:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]
 804988a:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 804988d:	52                   	push   edx
 804988e:	50                   	push   eax
 804988f:	68 d3 a6 04 08       	push   0x804a6d3
 8049894:	6a 02                	push   0x2
 8049896:	e8 5b fd ff ff       	call   80495f6 <rpc_call>
 804989b:	83 c4 10             	add    esp,0x10
 804989e:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  free(state.buf);
 80498a1:	8b 45 dc             	mov    eax,DWORD PTR [ebp-0x24]
 80498a4:	83 ec 0c             	sub    esp,0xc
 80498a7:	50                   	push   eax
 80498a8:	e8 bc f7 ff ff       	call   8049069 <free>
 80498ad:	83 c4 10             	add    esp,0x10
  start_deserialize(retval,&state);
 80498b0:	83 ec 08             	sub    esp,0x8
 80498b3:	8d 45 dc             	lea    eax,[ebp-0x24]
 80498b6:	50                   	push   eax
 80498b7:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 80498ba:	e8 cd fe ff ff       	call   804978c <start_deserialize>
 80498bf:	83 c4 10             	add    esp,0x10
  int err=deserialize_int(&state);
 80498c2:	83 ec 0c             	sub    esp,0xc
 80498c5:	8d 45 dc             	lea    eax,[ebp-0x24]
 80498c8:	50                   	push   eax
 80498c9:	e8 d6 fe ff ff       	call   80497a4 <deserialize_int>
 80498ce:	83 c4 10             	add    esp,0x10
 80498d1:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
  void* fs_data=deserialize_ptr(&state);
 80498d4:	83 ec 0c             	sub    esp,0xc
 80498d7:	8d 45 dc             	lea    eax,[ebp-0x24]
 80498da:	50                   	push   eax
 80498db:	e8 f0 fe ff ff       	call   80497d0 <deserialize_ptr>
 80498e0:	83 c4 10             	add    esp,0x10
 80498e3:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
  pid_t fs_pid=deserialize_int(&state);
 80498e6:	83 ec 0c             	sub    esp,0xc
 80498e9:	8d 45 dc             	lea    eax,[ebp-0x24]
 80498ec:	50                   	push   eax
 80498ed:	e8 b2 fe ff ff       	call   80497a4 <deserialize_int>
 80498f2:	83 c4 10             	add    esp,0x10
 80498f5:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax
  rpc_deallocate_buf(retval,state.sizeorpos);
 80498f8:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]
 80498fb:	83 ec 08             	sub    esp,0x8
 80498fe:	50                   	push   eax
 80498ff:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 8049902:	e8 36 fd ff ff       	call   804963d <rpc_deallocate_buf>
 8049907:	83 c4 10             	add    esp,0x10
  if (err) {
 804990a:	83 7d f0 00          	cmp    DWORD PTR [ebp-0x10],0x0
 804990e:	74 07                	je     8049917 <fopen+0xe9>
    return NULL;
 8049910:	b8 00 00 00 00       	mov    eax,0x0
 8049915:	eb 2e                	jmp    8049945 <fopen+0x117>
  } else {
    FILE* file=malloc(sizeof(FILE));
 8049917:	83 ec 0c             	sub    esp,0xc
 804991a:	6a 0c                	push   0xc
 804991c:	e8 bc f0 ff ff       	call   80489dd <malloc>
 8049921:	83 c4 10             	add    esp,0x10
 8049924:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
    file->fs_pid=fs_pid;
 8049927:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 804992a:	8b 55 e8             	mov    edx,DWORD PTR [ebp-0x18]
 804992d:	89 10                	mov    DWORD PTR [eax],edx
    file->fs_data=fs_data;
 804992f:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8049932:	8b 55 ec             	mov    edx,DWORD PTR [ebp-0x14]
 8049935:	89 50 04             	mov    DWORD PTR [eax+0x4],edx
    file->pos=0;
 8049938:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 804993b:	c7 40 08 00 00 00 00 	mov    DWORD PTR [eax+0x8],0x0
    return file;
 8049942:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
  }
}
 8049945:	c9                   	leave  
 8049946:	c3                   	ret    

08049947 <fputc>:
 * \param stream The stream to write to
 * \returns the written character, or EOF on failure
*/
int putc(int c, FILE* stream) __attribute__ ((alias ("fputc")));

int fputc(int c, FILE* stream) {
 8049947:	55                   	push   ebp
 8049948:	89 e5                	mov    ebp,esp
 804994a:	83 ec 18             	sub    esp,0x18
  char str[]={c,'\0'};
 804994d:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8049950:	88 45 f6             	mov    BYTE PTR [ebp-0xa],al
 8049953:	c6 45 f7 00          	mov    BYTE PTR [ebp-0x9],0x0
  if (fputs(str,stream)==0) {
 8049957:	83 ec 08             	sub    esp,0x8
 804995a:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804995d:	8d 45 f6             	lea    eax,[ebp-0xa]
 8049960:	50                   	push   eax
 8049961:	e8 9f 02 00 00       	call   8049c05 <fputs>
 8049966:	83 c4 10             	add    esp,0x10
 8049969:	85 c0                	test   eax,eax
 804996b:	75 07                	jne    8049974 <fputc+0x2d>
    return EOF;
 804996d:	b8 ff ff ff ff       	mov    eax,0xffffffff
 8049972:	eb 03                	jmp    8049977 <fputc+0x30>
  } else {
    return c;
 8049974:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
  }
  return EOF;
}
 8049977:	c9                   	leave  
 8049978:	c3                   	ret    

08049979 <fgetc>:
 * \param stream The file to read from
 * \returns the read character, or EOF if the read fails
*/
int getc(FILE* stream) __attribute__ ((alias ("fgetc"))); 

int fgetc(FILE* stream) {
 8049979:	55                   	push   ebp
 804997a:	89 e5                	mov    ebp,esp
 804997c:	83 ec 18             	sub    esp,0x18
  char c[2];
  if (fgets(&c[0],1,stream)==NULL) {
 804997f:	83 ec 04             	sub    esp,0x4
 8049982:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049985:	6a 01                	push   0x1
 8049987:	8d 45 f6             	lea    eax,[ebp-0xa]
 804998a:	50                   	push   eax
 804998b:	e8 37 00 00 00       	call   80499c7 <fgets>
 8049990:	83 c4 10             	add    esp,0x10
 8049993:	85 c0                	test   eax,eax
 8049995:	75 07                	jne    804999e <fgetc+0x25>
    return EOF;
 8049997:	b8 ff ff ff ff       	mov    eax,0xffffffff
 804999c:	eb 06                	jmp    80499a4 <fgetc+0x2b>
  } else {
    return c[0];
 804999e:	8a 45 f6             	mov    al,BYTE PTR [ebp-0xa]
 80499a1:	0f be c0             	movsx  eax,al
  }
  return EOF;
}
 80499a4:	c9                   	leave  
 80499a5:	c3                   	ret    

080499a6 <gets>:

char* gets(char* s) {
 80499a6:	55                   	push   ebp
 80499a7:	89 e5                	mov    ebp,esp
 80499a9:	83 ec 08             	sub    esp,0x8
  return fgets(s,INT_MAX,stdin);
 80499ac:	a1 78 c1 04 08       	mov    eax,ds:0x804c178
 80499b1:	83 ec 04             	sub    esp,0x4
 80499b4:	50                   	push   eax
 80499b5:	68 ff ff ff 7f       	push   0x7fffffff
 80499ba:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 80499bd:	e8 05 00 00 00       	call   80499c7 <fgets>
 80499c2:	83 c4 10             	add    esp,0x10
}
 80499c5:	c9                   	leave  
 80499c6:	c3                   	ret    

080499c7 <fgets>:

char* fgets(char* str,int count,FILE* stream) {
 80499c7:	55                   	push   ebp
 80499c8:	89 e5                	mov    ebp,esp
 80499ca:	83 ec 18             	sub    esp,0x18
  count=fread(str,1,count-1,stream)+1;
 80499cd:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 80499d0:	48                   	dec    eax
 80499d1:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 80499d4:	50                   	push   eax
 80499d5:	6a 01                	push   0x1
 80499d7:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 80499da:	e8 81 00 00 00       	call   8049a60 <fread>
 80499df:	83 c4 10             	add    esp,0x10
 80499e2:	40                   	inc    eax
 80499e3:	89 45 0c             	mov    DWORD PTR [ebp+0xc],eax
  if (count==0) {
 80499e6:	83 7d 0c 00          	cmp    DWORD PTR [ebp+0xc],0x0
 80499ea:	75 07                	jne    80499f3 <fgets+0x2c>
    return NULL;
 80499ec:	b8 00 00 00 00       	mov    eax,0x0
 80499f1:	eb 6b                	jmp    8049a5e <fgets+0x97>
  }
  str[count]='\0';
 80499f3:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 80499f6:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 80499f9:	01 d0                	add    eax,edx
 80499fb:	c6 00 00             	mov    BYTE PTR [eax],0x0
  int newlinepos=-1;
 80499fe:	c7 45 f4 ff ff ff ff 	mov    DWORD PTR [ebp-0xc],0xffffffff
  for (int i=0;i<(count-1);i++) {
 8049a05:	c7 45 f0 00 00 00 00 	mov    DWORD PTR [ebp-0x10],0x0
 8049a0c:	eb 19                	jmp    8049a27 <fgets+0x60>
    if (str[i]=='\n') {
 8049a0e:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
 8049a11:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 8049a14:	01 d0                	add    eax,edx
 8049a16:	8a 00                	mov    al,BYTE PTR [eax]
 8049a18:	3c 0a                	cmp    al,0xa
 8049a1a:	75 08                	jne    8049a24 <fgets+0x5d>
      newlinepos=i;
 8049a1c:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8049a1f:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
      break;
 8049a22:	eb 0c                	jmp    8049a30 <fgets+0x69>
  for (int i=0;i<(count-1);i++) {
 8049a24:	ff 45 f0             	inc    DWORD PTR [ebp-0x10]
 8049a27:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049a2a:	48                   	dec    eax
 8049a2b:	39 45 f0             	cmp    DWORD PTR [ebp-0x10],eax
 8049a2e:	7c de                	jl     8049a0e <fgets+0x47>
    }
  }
  if (newlinepos) {
 8049a30:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 8049a34:	74 25                	je     8049a5b <fgets+0x94>
    stream->pos-=(count-1);
 8049a36:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049a39:	8b 40 08             	mov    eax,DWORD PTR [eax+0x8]
 8049a3c:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 8049a3f:	4a                   	dec    edx
 8049a40:	29 d0                	sub    eax,edx
 8049a42:	89 c2                	mov    edx,eax
 8049a44:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049a47:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
    stream->pos+=newlinepos;
 8049a4a:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049a4d:	8b 50 08             	mov    edx,DWORD PTR [eax+0x8]
 8049a50:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 8049a53:	01 c2                	add    edx,eax
 8049a55:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049a58:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
  }
  return str;
 8049a5b:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
}
 8049a5e:	c9                   	leave  
 8049a5f:	c3                   	ret    

08049a60 <fread>:

size_t fread(void* buffer_ptr,size_t size,size_t count,FILE* stream) {
 8049a60:	55                   	push   ebp
 8049a61:	89 e5                	mov    ebp,esp
 8049a63:	83 ec 28             	sub    esp,0x28
  serdes_state state={0};
 8049a66:	c7 45 e4 00 00 00 00 	mov    DWORD PTR [ebp-0x1c],0x0
 8049a6d:	c7 45 e8 00 00 00 00 	mov    DWORD PTR [ebp-0x18],0x0
  serialize_ptr(stream->fs_data,&state);
 8049a74:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 8049a77:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8049a7a:	83 ec 08             	sub    esp,0x8
 8049a7d:	8d 55 e4             	lea    edx,[ebp-0x1c]
 8049a80:	52                   	push   edx
 8049a81:	50                   	push   eax
 8049a82:	e8 60 fc ff ff       	call   80496e7 <serialize_ptr>
 8049a87:	83 c4 10             	add    esp,0x10
  serialize_int(size*count,&state);
 8049a8a:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049a8d:	0f af 45 10          	imul   eax,DWORD PTR [ebp+0x10]
 8049a91:	89 c2                	mov    edx,eax
 8049a93:	83 ec 08             	sub    esp,0x8
 8049a96:	8d 45 e4             	lea    eax,[ebp-0x1c]
 8049a99:	50                   	push   eax
 8049a9a:	52                   	push   edx
 8049a9b:	e8 fd fb ff ff       	call   804969d <serialize_int>
 8049aa0:	83 c4 10             	add    esp,0x10
  serialize_int(stream->pos,&state);
 8049aa3:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 8049aa6:	8b 40 08             	mov    eax,DWORD PTR [eax+0x8]
 8049aa9:	83 ec 08             	sub    esp,0x8
 8049aac:	8d 55 e4             	lea    edx,[ebp-0x1c]
 8049aaf:	52                   	push   edx
 8049ab0:	50                   	push   eax
 8049ab1:	e8 e7 fb ff ff       	call   804969d <serialize_int>
 8049ab6:	83 c4 10             	add    esp,0x10
  void* retbuf=rpc_call(stream->fs_pid,"read",state.buf,state.sizeorpos);
 8049ab9:	8b 4d e8             	mov    ecx,DWORD PTR [ebp-0x18]
 8049abc:	8b 55 e4             	mov    edx,DWORD PTR [ebp-0x1c]
 8049abf:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 8049ac2:	8b 00                	mov    eax,DWORD PTR [eax]
 8049ac4:	51                   	push   ecx
 8049ac5:	52                   	push   edx
 8049ac6:	68 d8 a6 04 08       	push   0x804a6d8
 8049acb:	50                   	push   eax
 8049acc:	e8 25 fb ff ff       	call   80495f6 <rpc_call>
 8049ad1:	83 c4 10             	add    esp,0x10
 8049ad4:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  free(state.buf);
 8049ad7:	8b 45 e4             	mov    eax,DWORD PTR [ebp-0x1c]
 8049ada:	83 ec 0c             	sub    esp,0xc
 8049add:	50                   	push   eax
 8049ade:	e8 86 f5 ff ff       	call   8049069 <free>
 8049ae3:	83 c4 10             	add    esp,0x10
  state.buf=NULL;
 8049ae6:	c7 45 e4 00 00 00 00 	mov    DWORD PTR [ebp-0x1c],0x0
  state.sizeorpos=0;
 8049aed:	c7 45 e8 00 00 00 00 	mov    DWORD PTR [ebp-0x18],0x0
  start_deserialize(retbuf,&state);
 8049af4:	83 ec 08             	sub    esp,0x8
 8049af7:	8d 45 e4             	lea    eax,[ebp-0x1c]
 8049afa:	50                   	push   eax
 8049afb:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 8049afe:	e8 89 fc ff ff       	call   804978c <start_deserialize>
 8049b03:	83 c4 10             	add    esp,0x10
  int bytes_read=deserialize_int(&state);
 8049b06:	83 ec 0c             	sub    esp,0xc
 8049b09:	8d 45 e4             	lea    eax,[ebp-0x1c]
 8049b0c:	50                   	push   eax
 8049b0d:	e8 92 fc ff ff       	call   80497a4 <deserialize_int>
 8049b12:	83 c4 10             	add    esp,0x10
 8049b15:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
  if (bytes_read) {
 8049b18:	83 7d f0 00          	cmp    DWORD PTR [ebp-0x10],0x0
 8049b1c:	74 2f                	je     8049b4d <fread+0xed>
    void* ary=deserialize_ary(bytes_read,&state);
 8049b1e:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8049b21:	83 ec 08             	sub    esp,0x8
 8049b24:	8d 55 e4             	lea    edx,[ebp-0x1c]
 8049b27:	52                   	push   edx
 8049b28:	50                   	push   eax
 8049b29:	e8 ce fc ff ff       	call   80497fc <deserialize_ary>
 8049b2e:	83 c4 10             	add    esp,0x10
 8049b31:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
    memcpy(buffer_ptr,ary,size*count);
 8049b34:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049b37:	0f af 45 10          	imul   eax,DWORD PTR [ebp+0x10]
 8049b3b:	83 ec 04             	sub    esp,0x4
 8049b3e:	50                   	push   eax
 8049b3f:	ff 75 ec             	push   DWORD PTR [ebp-0x14]
 8049b42:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049b45:	e8 d3 05 00 00       	call   804a11d <memcpy>
 8049b4a:	83 c4 10             	add    esp,0x10
  }
  rpc_deallocate_buf(retbuf,state.sizeorpos);
 8049b4d:	8b 45 e8             	mov    eax,DWORD PTR [ebp-0x18]
 8049b50:	83 ec 08             	sub    esp,0x8
 8049b53:	50                   	push   eax
 8049b54:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 8049b57:	e8 e1 fa ff ff       	call   804963d <rpc_deallocate_buf>
 8049b5c:	83 c4 10             	add    esp,0x10
  stream->pos+=bytes_read;
 8049b5f:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 8049b62:	8b 50 08             	mov    edx,DWORD PTR [eax+0x8]
 8049b65:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8049b68:	01 c2                	add    edx,eax
 8049b6a:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 8049b6d:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
  return bytes_read;
 8049b70:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
 8049b73:	c9                   	leave  
 8049b74:	c3                   	ret    

08049b75 <puts>:

int puts(const char *s) {
 8049b75:	55                   	push   ebp
 8049b76:	89 e5                	mov    ebp,esp
 8049b78:	83 ec 18             	sub    esp,0x18
  char* str=malloc(sizeof(char)*(strlen(s)+2));
 8049b7b:	83 ec 0c             	sub    esp,0xc
 8049b7e:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049b81:	e8 67 06 00 00       	call   804a1ed <strlen>
 8049b86:	83 c4 10             	add    esp,0x10
 8049b89:	83 c0 02             	add    eax,0x2
 8049b8c:	83 ec 0c             	sub    esp,0xc
 8049b8f:	50                   	push   eax
 8049b90:	e8 48 ee ff ff       	call   80489dd <malloc>
 8049b95:	83 c4 10             	add    esp,0x10
 8049b98:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  strcpy(str,s);
 8049b9b:	83 ec 08             	sub    esp,0x8
 8049b9e:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049ba1:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 8049ba4:	e8 69 06 00 00       	call   804a212 <strcpy>
 8049ba9:	83 c4 10             	add    esp,0x10
  str[strlen(s)]='\n';
 8049bac:	83 ec 0c             	sub    esp,0xc
 8049baf:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049bb2:	e8 36 06 00 00       	call   804a1ed <strlen>
 8049bb7:	83 c4 10             	add    esp,0x10
 8049bba:	8b 55 f4             	mov    edx,DWORD PTR [ebp-0xc]
 8049bbd:	01 d0                	add    eax,edx
 8049bbf:	c6 00 0a             	mov    BYTE PTR [eax],0xa
  str[strlen(s)+1]='\0';
 8049bc2:	83 ec 0c             	sub    esp,0xc
 8049bc5:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049bc8:	e8 20 06 00 00       	call   804a1ed <strlen>
 8049bcd:	83 c4 10             	add    esp,0x10
 8049bd0:	8d 50 01             	lea    edx,[eax+0x1]
 8049bd3:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 8049bd6:	01 d0                	add    eax,edx
 8049bd8:	c6 00 00             	mov    BYTE PTR [eax],0x0
  int code=fputs(str,stdout);
 8049bdb:	a1 7c c1 04 08       	mov    eax,ds:0x804c17c
 8049be0:	83 ec 08             	sub    esp,0x8
 8049be3:	50                   	push   eax
 8049be4:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 8049be7:	e8 19 00 00 00       	call   8049c05 <fputs>
 8049bec:	83 c4 10             	add    esp,0x10
 8049bef:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
  free(str);
 8049bf2:	83 ec 0c             	sub    esp,0xc
 8049bf5:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 8049bf8:	e8 6c f4 ff ff       	call   8049069 <free>
 8049bfd:	83 c4 10             	add    esp,0x10
  return code;
 8049c00:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
 8049c03:	c9                   	leave  
 8049c04:	c3                   	ret    

08049c05 <fputs>:

int fputs(const char* s, FILE* stream) {
 8049c05:	55                   	push   ebp
 8049c06:	89 e5                	mov    ebp,esp
 8049c08:	83 ec 18             	sub    esp,0x18
  size_t retval=fwrite((void*)s,strlen(s),1,stream);
 8049c0b:	83 ec 0c             	sub    esp,0xc
 8049c0e:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049c11:	e8 d7 05 00 00       	call   804a1ed <strlen>
 8049c16:	83 c4 10             	add    esp,0x10
 8049c19:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 8049c1c:	6a 01                	push   0x1
 8049c1e:	50                   	push   eax
 8049c1f:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049c22:	e8 1a 00 00 00       	call   8049c41 <fwrite>
 8049c27:	83 c4 10             	add    esp,0x10
 8049c2a:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  if (retval==0) {
 8049c2d:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 8049c31:	75 07                	jne    8049c3a <fputs+0x35>
    return EOF;
 8049c33:	b8 ff ff ff ff       	mov    eax,0xffffffff
 8049c38:	eb 05                	jmp    8049c3f <fputs+0x3a>
  } else {
    return 0;
 8049c3a:	b8 00 00 00 00       	mov    eax,0x0
  }
}
 8049c3f:	c9                   	leave  
 8049c40:	c3                   	ret    

08049c41 <fwrite>:

size_t fwrite(void* buffer_ptr,size_t size,size_t count,FILE* stream) {
 8049c41:	55                   	push   ebp
 8049c42:	89 e5                	mov    ebp,esp
 8049c44:	83 ec 18             	sub    esp,0x18
  serdes_state state={0};
 8049c47:	c7 45 e8 00 00 00 00 	mov    DWORD PTR [ebp-0x18],0x0
 8049c4e:	c7 45 ec 00 00 00 00 	mov    DWORD PTR [ebp-0x14],0x0
  serialize_ptr(stream->fs_data,&state);
 8049c55:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 8049c58:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 8049c5b:	83 ec 08             	sub    esp,0x8
 8049c5e:	8d 55 e8             	lea    edx,[ebp-0x18]
 8049c61:	52                   	push   edx
 8049c62:	50                   	push   eax
 8049c63:	e8 7f fa ff ff       	call   80496e7 <serialize_ptr>
 8049c68:	83 c4 10             	add    esp,0x10
  serialize_int(size*count,&state);
 8049c6b:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049c6e:	0f af 45 10          	imul   eax,DWORD PTR [ebp+0x10]
 8049c72:	89 c2                	mov    edx,eax
 8049c74:	83 ec 08             	sub    esp,0x8
 8049c77:	8d 45 e8             	lea    eax,[ebp-0x18]
 8049c7a:	50                   	push   eax
 8049c7b:	52                   	push   edx
 8049c7c:	e8 1c fa ff ff       	call   804969d <serialize_int>
 8049c81:	83 c4 10             	add    esp,0x10
  serialize_int(stream->pos,&state);
 8049c84:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 8049c87:	8b 40 08             	mov    eax,DWORD PTR [eax+0x8]
 8049c8a:	83 ec 08             	sub    esp,0x8
 8049c8d:	8d 55 e8             	lea    edx,[ebp-0x18]
 8049c90:	52                   	push   edx
 8049c91:	50                   	push   eax
 8049c92:	e8 06 fa ff ff       	call   804969d <serialize_int>
 8049c97:	83 c4 10             	add    esp,0x10
  serialize_ary(buffer_ptr,size*count,&state);
 8049c9a:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049c9d:	0f af 45 10          	imul   eax,DWORD PTR [ebp+0x10]
 8049ca1:	83 ec 04             	sub    esp,0x4
 8049ca4:	8d 55 e8             	lea    edx,[ebp-0x18]
 8049ca7:	52                   	push   edx
 8049ca8:	50                   	push   eax
 8049ca9:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049cac:	e8 80 fa ff ff       	call   8049731 <serialize_ary>
 8049cb1:	83 c4 10             	add    esp,0x10
  void* retbuf=rpc_call(stream->fs_pid,"write",state.buf,state.sizeorpos);
 8049cb4:	8b 4d ec             	mov    ecx,DWORD PTR [ebp-0x14]
 8049cb7:	8b 55 e8             	mov    edx,DWORD PTR [ebp-0x18]
 8049cba:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 8049cbd:	8b 00                	mov    eax,DWORD PTR [eax]
 8049cbf:	51                   	push   ecx
 8049cc0:	52                   	push   edx
 8049cc1:	68 dd a6 04 08       	push   0x804a6dd
 8049cc6:	50                   	push   eax
 8049cc7:	e8 2a f9 ff ff       	call   80495f6 <rpc_call>
 8049ccc:	83 c4 10             	add    esp,0x10
 8049ccf:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  free(state.buf);
 8049cd2:	8b 45 e8             	mov    eax,DWORD PTR [ebp-0x18]
 8049cd5:	83 ec 0c             	sub    esp,0xc
 8049cd8:	50                   	push   eax
 8049cd9:	e8 8b f3 ff ff       	call   8049069 <free>
 8049cde:	83 c4 10             	add    esp,0x10
  start_deserialize(retbuf,&state);
 8049ce1:	83 ec 08             	sub    esp,0x8
 8049ce4:	8d 45 e8             	lea    eax,[ebp-0x18]
 8049ce7:	50                   	push   eax
 8049ce8:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 8049ceb:	e8 9c fa ff ff       	call   804978c <start_deserialize>
 8049cf0:	83 c4 10             	add    esp,0x10
  int bytes_wrote=deserialize_int(&state);
 8049cf3:	83 ec 0c             	sub    esp,0xc
 8049cf6:	8d 45 e8             	lea    eax,[ebp-0x18]
 8049cf9:	50                   	push   eax
 8049cfa:	e8 a5 fa ff ff       	call   80497a4 <deserialize_int>
 8049cff:	83 c4 10             	add    esp,0x10
 8049d02:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
  rpc_deallocate_buf(retbuf,state.sizeorpos);
 8049d05:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 8049d08:	83 ec 08             	sub    esp,0x8
 8049d0b:	50                   	push   eax
 8049d0c:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 8049d0f:	e8 29 f9 ff ff       	call   804963d <rpc_deallocate_buf>
 8049d14:	83 c4 10             	add    esp,0x10
  stream->pos+=bytes_wrote;
 8049d17:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 8049d1a:	8b 50 08             	mov    edx,DWORD PTR [eax+0x8]
 8049d1d:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8049d20:	01 c2                	add    edx,eax
 8049d22:	8b 45 14             	mov    eax,DWORD PTR [ebp+0x14]
 8049d25:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
  return bytes_wrote;
 8049d28:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
}
 8049d2b:	c9                   	leave  
 8049d2c:	c3                   	ret    

08049d2d <register_fs>:

void register_fs(const char* name,pid_t pid) {
 8049d2d:	55                   	push   ebp
 8049d2e:	89 e5                	mov    ebp,esp
 8049d30:	83 ec 18             	sub    esp,0x18
  serdes_state state={0};
 8049d33:	c7 45 f0 00 00 00 00 	mov    DWORD PTR [ebp-0x10],0x0
 8049d3a:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0
  serialize_str((char*)name,&state);
 8049d41:	83 ec 0c             	sub    esp,0xc
 8049d44:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049d47:	e8 a1 04 00 00       	call   804a1ed <strlen>
 8049d4c:	83 c4 10             	add    esp,0x10
 8049d4f:	40                   	inc    eax
 8049d50:	89 c2                	mov    edx,eax
 8049d52:	83 ec 08             	sub    esp,0x8
 8049d55:	8d 45 f0             	lea    eax,[ebp-0x10]
 8049d58:	50                   	push   eax
 8049d59:	52                   	push   edx
 8049d5a:	e8 3e f9 ff ff       	call   804969d <serialize_int>
 8049d5f:	83 c4 10             	add    esp,0x10
 8049d62:	83 ec 0c             	sub    esp,0xc
 8049d65:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049d68:	e8 80 04 00 00       	call   804a1ed <strlen>
 8049d6d:	83 c4 10             	add    esp,0x10
 8049d70:	8d 50 01             	lea    edx,[eax+0x1]
 8049d73:	83 ec 04             	sub    esp,0x4
 8049d76:	8d 45 f0             	lea    eax,[ebp-0x10]
 8049d79:	50                   	push   eax
 8049d7a:	52                   	push   edx
 8049d7b:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049d7e:	e8 ae f9 ff ff       	call   8049731 <serialize_ary>
 8049d83:	83 c4 10             	add    esp,0x10
  serialize_int(pid,&state);
 8049d86:	83 ec 08             	sub    esp,0x8
 8049d89:	8d 45 f0             	lea    eax,[ebp-0x10]
 8049d8c:	50                   	push   eax
 8049d8d:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 8049d90:	e8 08 f9 ff ff       	call   804969d <serialize_int>
 8049d95:	83 c4 10             	add    esp,0x10
  rpc_call(2,"register_fs",state.buf,state.sizeorpos);
 8049d98:	8b 55 f4             	mov    edx,DWORD PTR [ebp-0xc]
 8049d9b:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 8049d9e:	52                   	push   edx
 8049d9f:	50                   	push   eax
 8049da0:	68 e3 a6 04 08       	push   0x804a6e3
 8049da5:	6a 02                	push   0x2
 8049da7:	e8 4a f8 ff ff       	call   80495f6 <rpc_call>
 8049dac:	83 c4 10             	add    esp,0x10
}
 8049daf:	90                   	nop
 8049db0:	c9                   	leave  
 8049db1:	c3                   	ret    

08049db2 <mount>:

int mount(char* file,char* type,char* path) {
 8049db2:	55                   	push   ebp
 8049db3:	89 e5                	mov    ebp,esp
 8049db5:	83 ec 18             	sub    esp,0x18
  serdes_state state={0};
 8049db8:	c7 45 ec 00 00 00 00 	mov    DWORD PTR [ebp-0x14],0x0
 8049dbf:	c7 45 f0 00 00 00 00 	mov    DWORD PTR [ebp-0x10],0x0
  serialize_str(type,&state);
 8049dc6:	83 ec 0c             	sub    esp,0xc
 8049dc9:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 8049dcc:	e8 1c 04 00 00       	call   804a1ed <strlen>
 8049dd1:	83 c4 10             	add    esp,0x10
 8049dd4:	40                   	inc    eax
 8049dd5:	89 c2                	mov    edx,eax
 8049dd7:	83 ec 08             	sub    esp,0x8
 8049dda:	8d 45 ec             	lea    eax,[ebp-0x14]
 8049ddd:	50                   	push   eax
 8049dde:	52                   	push   edx
 8049ddf:	e8 b9 f8 ff ff       	call   804969d <serialize_int>
 8049de4:	83 c4 10             	add    esp,0x10
 8049de7:	83 ec 0c             	sub    esp,0xc
 8049dea:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 8049ded:	e8 fb 03 00 00       	call   804a1ed <strlen>
 8049df2:	83 c4 10             	add    esp,0x10
 8049df5:	8d 50 01             	lea    edx,[eax+0x1]
 8049df8:	83 ec 04             	sub    esp,0x4
 8049dfb:	8d 45 ec             	lea    eax,[ebp-0x14]
 8049dfe:	50                   	push   eax
 8049dff:	52                   	push   edx
 8049e00:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 8049e03:	e8 29 f9 ff ff       	call   8049731 <serialize_ary>
 8049e08:	83 c4 10             	add    esp,0x10
  serialize_str(file,&state);
 8049e0b:	83 ec 0c             	sub    esp,0xc
 8049e0e:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049e11:	e8 d7 03 00 00       	call   804a1ed <strlen>
 8049e16:	83 c4 10             	add    esp,0x10
 8049e19:	40                   	inc    eax
 8049e1a:	89 c2                	mov    edx,eax
 8049e1c:	83 ec 08             	sub    esp,0x8
 8049e1f:	8d 45 ec             	lea    eax,[ebp-0x14]
 8049e22:	50                   	push   eax
 8049e23:	52                   	push   edx
 8049e24:	e8 74 f8 ff ff       	call   804969d <serialize_int>
 8049e29:	83 c4 10             	add    esp,0x10
 8049e2c:	83 ec 0c             	sub    esp,0xc
 8049e2f:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049e32:	e8 b6 03 00 00       	call   804a1ed <strlen>
 8049e37:	83 c4 10             	add    esp,0x10
 8049e3a:	8d 50 01             	lea    edx,[eax+0x1]
 8049e3d:	83 ec 04             	sub    esp,0x4
 8049e40:	8d 45 ec             	lea    eax,[ebp-0x14]
 8049e43:	50                   	push   eax
 8049e44:	52                   	push   edx
 8049e45:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049e48:	e8 e4 f8 ff ff       	call   8049731 <serialize_ary>
 8049e4d:	83 c4 10             	add    esp,0x10
  serialize_str(path,&state);
 8049e50:	83 ec 0c             	sub    esp,0xc
 8049e53:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 8049e56:	e8 92 03 00 00       	call   804a1ed <strlen>
 8049e5b:	83 c4 10             	add    esp,0x10
 8049e5e:	40                   	inc    eax
 8049e5f:	89 c2                	mov    edx,eax
 8049e61:	83 ec 08             	sub    esp,0x8
 8049e64:	8d 45 ec             	lea    eax,[ebp-0x14]
 8049e67:	50                   	push   eax
 8049e68:	52                   	push   edx
 8049e69:	e8 2f f8 ff ff       	call   804969d <serialize_int>
 8049e6e:	83 c4 10             	add    esp,0x10
 8049e71:	83 ec 0c             	sub    esp,0xc
 8049e74:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 8049e77:	e8 71 03 00 00       	call   804a1ed <strlen>
 8049e7c:	83 c4 10             	add    esp,0x10
 8049e7f:	8d 50 01             	lea    edx,[eax+0x1]
 8049e82:	83 ec 04             	sub    esp,0x4
 8049e85:	8d 45 ec             	lea    eax,[ebp-0x14]
 8049e88:	50                   	push   eax
 8049e89:	52                   	push   edx
 8049e8a:	ff 75 10             	push   DWORD PTR [ebp+0x10]
 8049e8d:	e8 9f f8 ff ff       	call   8049731 <serialize_ary>
 8049e92:	83 c4 10             	add    esp,0x10
  int* err=rpc_call(2,"mount",state.buf,state.sizeorpos);
 8049e95:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
 8049e98:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 8049e9b:	52                   	push   edx
 8049e9c:	50                   	push   eax
 8049e9d:	68 ef a6 04 08       	push   0x804a6ef
 8049ea2:	6a 02                	push   0x2
 8049ea4:	e8 4d f7 ff ff       	call   80495f6 <rpc_call>
 8049ea9:	83 c4 10             	add    esp,0x10
 8049eac:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  return *err;
 8049eaf:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 8049eb2:	8b 00                	mov    eax,DWORD PTR [eax]
}
 8049eb4:	c9                   	leave  
 8049eb5:	c3                   	ret    

08049eb6 <vfprintf>:

int vfprintf(FILE* stream,const char* format,va_list arg) {
 8049eb6:	55                   	push   ebp
 8049eb7:	89 e5                	mov    ebp,esp
 8049eb9:	83 ec 38             	sub    esp,0x38
  int c;
	for(;*format!='\0';format++) {
 8049ebc:	e9 7d 01 00 00       	jmp    804a03e <vfprintf+0x188>
    if(*format!='%') {
 8049ec1:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049ec4:	8a 00                	mov    al,BYTE PTR [eax]
 8049ec6:	3c 25                	cmp    al,0x25
 8049ec8:	74 1f                	je     8049ee9 <vfprintf+0x33>
  		c=fputc(*format,stream);
 8049eca:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049ecd:	8a 00                	mov    al,BYTE PTR [eax]
 8049ecf:	0f be c0             	movsx  eax,al
 8049ed2:	83 ec 08             	sub    esp,0x8
 8049ed5:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049ed8:	50                   	push   eax
 8049ed9:	e8 69 fa ff ff       	call   8049947 <fputc>
 8049ede:	83 c4 10             	add    esp,0x10
 8049ee1:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
      continue;
 8049ee4:	e9 52 01 00 00       	jmp    804a03b <vfprintf+0x185>
  	}
    format++;
 8049ee9:	ff 45 0c             	inc    DWORD PTR [ebp+0xc]
		switch(*format) {
 8049eec:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 8049eef:	8a 00                	mov    al,BYTE PTR [eax]
 8049ef1:	0f be c0             	movsx  eax,al
 8049ef4:	83 f8 78             	cmp    eax,0x78
 8049ef7:	0f 84 f1 00 00 00    	je     8049fee <vfprintf+0x138>
 8049efd:	83 f8 78             	cmp    eax,0x78
 8049f00:	0f 8f 35 01 00 00    	jg     804a03b <vfprintf+0x185>
 8049f06:	83 f8 73             	cmp    eax,0x73
 8049f09:	0f 84 b0 00 00 00    	je     8049fbf <vfprintf+0x109>
 8049f0f:	83 f8 73             	cmp    eax,0x73
 8049f12:	0f 8f 23 01 00 00    	jg     804a03b <vfprintf+0x185>
 8049f18:	83 f8 63             	cmp    eax,0x63
 8049f1b:	74 0a                	je     8049f27 <vfprintf+0x71>
 8049f1d:	83 f8 64             	cmp    eax,0x64
 8049f20:	74 3b                	je     8049f5d <vfprintf+0xa7>
 8049f22:	e9 14 01 00 00       	jmp    804a03b <vfprintf+0x185>
			case 'c': {
        int i=va_arg(arg,int);
 8049f27:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049f2a:	8d 50 04             	lea    edx,[eax+0x4]
 8049f2d:	89 55 10             	mov    DWORD PTR [ebp+0x10],edx
 8049f30:	8b 00                	mov    eax,DWORD PTR [eax]
 8049f32:	89 45 e4             	mov    DWORD PTR [ebp-0x1c],eax
				c=fputc(i,stream);
 8049f35:	83 ec 08             	sub    esp,0x8
 8049f38:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049f3b:	ff 75 e4             	push   DWORD PTR [ebp-0x1c]
 8049f3e:	e8 04 fa ff ff       	call   8049947 <fputc>
 8049f43:	83 c4 10             	add    esp,0x10
 8049f46:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
        if (c==EOF) {
 8049f49:	83 7d ec ff          	cmp    DWORD PTR [ebp-0x14],0xffffffff
 8049f4d:	0f 85 e1 00 00 00    	jne    804a034 <vfprintf+0x17e>
          return EOF;
 8049f53:	b8 ff ff ff ff       	mov    eax,0xffffffff
 8049f58:	e9 f3 00 00 00       	jmp    804a050 <vfprintf+0x19a>
        }
				break;
      }
			case 'd': {
        int i=va_arg(arg,int); 		//Fetch Decimal/Integer argument
 8049f5d:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049f60:	8d 50 04             	lea    edx,[eax+0x4]
 8049f63:	89 55 10             	mov    DWORD PTR [ebp+0x10],edx
 8049f66:	8b 00                	mov    eax,DWORD PTR [eax]
 8049f68:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
				if(i<0) {
 8049f6b:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 8049f6f:	79 13                	jns    8049f84 <vfprintf+0xce>
					i=-i;
 8049f71:	f7 5d f4             	neg    DWORD PTR [ebp-0xc]
					fputc('-',stream);
 8049f74:	83 ec 08             	sub    esp,0x8
 8049f77:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049f7a:	6a 2d                	push   0x2d
 8049f7c:	e8 c6 f9 ff ff       	call   8049947 <fputc>
 8049f81:	83 c4 10             	add    esp,0x10
				}
        char str[11];
        int_to_ascii(i,str);
 8049f84:	83 ec 08             	sub    esp,0x8
 8049f87:	8d 45 d9             	lea    eax,[ebp-0x27]
 8049f8a:	50                   	push   eax
 8049f8b:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 8049f8e:	e8 24 03 00 00       	call   804a2b7 <int_to_ascii>
 8049f93:	83 c4 10             	add    esp,0x10
				c=fputs(str,stream);
 8049f96:	83 ec 08             	sub    esp,0x8
 8049f99:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049f9c:	8d 45 d9             	lea    eax,[ebp-0x27]
 8049f9f:	50                   	push   eax
 8049fa0:	e8 60 fc ff ff       	call   8049c05 <fputs>
 8049fa5:	83 c4 10             	add    esp,0x10
 8049fa8:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
        if (c==EOF) {
 8049fab:	83 7d ec ff          	cmp    DWORD PTR [ebp-0x14],0xffffffff
 8049faf:	0f 85 82 00 00 00    	jne    804a037 <vfprintf+0x181>
          return EOF;
 8049fb5:	b8 ff ff ff ff       	mov    eax,0xffffffff
 8049fba:	e9 91 00 00 00       	jmp    804a050 <vfprintf+0x19a>
      //   int i=va_arg(arg,unsigned int); //Fetch Octal representation
			// 	puts(convert(i,8));
			// 	break;
      // }
			case 's': {
        char* s=va_arg(arg,char*);
 8049fbf:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049fc2:	8d 50 04             	lea    edx,[eax+0x4]
 8049fc5:	89 55 10             	mov    DWORD PTR [ebp+0x10],edx
 8049fc8:	8b 00                	mov    eax,DWORD PTR [eax]
 8049fca:	89 45 e8             	mov    DWORD PTR [ebp-0x18],eax
				c=fputs(s,stream);
 8049fcd:	83 ec 08             	sub    esp,0x8
 8049fd0:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 8049fd3:	ff 75 e8             	push   DWORD PTR [ebp-0x18]
 8049fd6:	e8 2a fc ff ff       	call   8049c05 <fputs>
 8049fdb:	83 c4 10             	add    esp,0x10
 8049fde:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
        if (c==EOF) {
 8049fe1:	83 7d ec ff          	cmp    DWORD PTR [ebp-0x14],0xffffffff
 8049fe5:	75 53                	jne    804a03a <vfprintf+0x184>
          return EOF;
 8049fe7:	b8 ff ff ff ff       	mov    eax,0xffffffff
 8049fec:	eb 62                	jmp    804a050 <vfprintf+0x19a>
        }
				break;
      }
			case 'x': {
        unsigned int i=va_arg(arg, unsigned int);
 8049fee:	8b 45 10             	mov    eax,DWORD PTR [ebp+0x10]
 8049ff1:	8d 50 04             	lea    edx,[eax+0x4]
 8049ff4:	89 55 10             	mov    DWORD PTR [ebp+0x10],edx
 8049ff7:	8b 00                	mov    eax,DWORD PTR [eax]
 8049ff9:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
        char str[11];
        str[0]='\0';
 8049ffc:	c6 45 ce 00          	mov    BYTE PTR [ebp-0x32],0x0
        hex_to_ascii(i,str);
 804a000:	83 ec 08             	sub    esp,0x8
 804a003:	8d 45 ce             	lea    eax,[ebp-0x32]
 804a006:	50                   	push   eax
 804a007:	ff 75 f0             	push   DWORD PTR [ebp-0x10]
 804a00a:	e8 39 03 00 00       	call   804a348 <hex_to_ascii>
 804a00f:	83 c4 10             	add    esp,0x10
				c=fputs(str,stream);
 804a012:	83 ec 08             	sub    esp,0x8
 804a015:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804a018:	8d 45 ce             	lea    eax,[ebp-0x32]
 804a01b:	50                   	push   eax
 804a01c:	e8 e4 fb ff ff       	call   8049c05 <fputs>
 804a021:	83 c4 10             	add    esp,0x10
 804a024:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
        if (c==EOF) {
 804a027:	83 7d ec ff          	cmp    DWORD PTR [ebp-0x14],0xffffffff
 804a02b:	75 0e                	jne    804a03b <vfprintf+0x185>
          return EOF;
 804a02d:	b8 ff ff ff ff       	mov    eax,0xffffffff
 804a032:	eb 1c                	jmp    804a050 <vfprintf+0x19a>
				break;
 804a034:	90                   	nop
 804a035:	eb 04                	jmp    804a03b <vfprintf+0x185>
				break;
 804a037:	90                   	nop
 804a038:	eb 01                	jmp    804a03b <vfprintf+0x185>
				break;
 804a03a:	90                   	nop
	for(;*format!='\0';format++) {
 804a03b:	ff 45 0c             	inc    DWORD PTR [ebp+0xc]
 804a03e:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804a041:	8a 00                	mov    al,BYTE PTR [eax]
 804a043:	84 c0                	test   al,al
 804a045:	0f 85 76 fe ff ff    	jne    8049ec1 <vfprintf+0xb>
        }
				break;
      }
		}
	}
  return 1;
 804a04b:	b8 01 00 00 00       	mov    eax,0x1
}
 804a050:	c9                   	leave  
 804a051:	c3                   	ret    

0804a052 <fprintf>:

int fprintf(FILE* stream,const char* format,...) {
 804a052:	55                   	push   ebp
 804a053:	89 e5                	mov    ebp,esp
 804a055:	83 ec 18             	sub    esp,0x18
  va_list arg;
  int code;
  va_start(arg,format);
 804a058:	8d 45 10             	lea    eax,[ebp+0x10]
 804a05b:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
  code=vfprintf(stream,format,arg);
 804a05e:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 804a061:	83 ec 04             	sub    esp,0x4
 804a064:	50                   	push   eax
 804a065:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a068:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804a06b:	e8 46 fe ff ff       	call   8049eb6 <vfprintf>
 804a070:	83 c4 10             	add    esp,0x10
 804a073:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  va_end(arg);
  if (code) {
 804a076:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 804a07a:	74 10                	je     804a08c <fprintf+0x3a>
    return strlen(format);
 804a07c:	83 ec 0c             	sub    esp,0xc
 804a07f:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a082:	e8 66 01 00 00       	call   804a1ed <strlen>
 804a087:	83 c4 10             	add    esp,0x10
 804a08a:	eb 05                	jmp    804a091 <fprintf+0x3f>
  } else {
    return EOF;
 804a08c:	b8 ff ff ff ff       	mov    eax,0xffffffff
  }
}
 804a091:	c9                   	leave  
 804a092:	c3                   	ret    

0804a093 <printf>:

int printf(const char* format,...) {
 804a093:	55                   	push   ebp
 804a094:	89 e5                	mov    ebp,esp
 804a096:	83 ec 18             	sub    esp,0x18
  va_list arg;
  int code;
  va_start(arg,format);
 804a099:	8d 45 0c             	lea    eax,[ebp+0xc]
 804a09c:	89 45 f0             	mov    DWORD PTR [ebp-0x10],eax
  code=vfprintf(stdout,format,arg);
 804a09f:	8b 55 f0             	mov    edx,DWORD PTR [ebp-0x10]
 804a0a2:	a1 7c c1 04 08       	mov    eax,ds:0x804c17c
 804a0a7:	83 ec 04             	sub    esp,0x4
 804a0aa:	52                   	push   edx
 804a0ab:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804a0ae:	50                   	push   eax
 804a0af:	e8 02 fe ff ff       	call   8049eb6 <vfprintf>
 804a0b4:	83 c4 10             	add    esp,0x10
 804a0b7:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  va_end(arg);
  if (code) {
 804a0ba:	83 7d f4 00          	cmp    DWORD PTR [ebp-0xc],0x0
 804a0be:	74 10                	je     804a0d0 <printf+0x3d>
    return strlen(format);
 804a0c0:	83 ec 0c             	sub    esp,0xc
 804a0c3:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804a0c6:	e8 22 01 00 00       	call   804a1ed <strlen>
 804a0cb:	83 c4 10             	add    esp,0x10
 804a0ce:	eb 05                	jmp    804a0d5 <printf+0x42>
  } else {
    return EOF;
 804a0d0:	b8 ff ff ff ff       	mov    eax,0xffffffff
  }
}
 804a0d5:	c9                   	leave  
 804a0d6:	c3                   	ret    

0804a0d7 <fseek>:

int fseek(FILE* stream,long offset,int origin) {
 804a0d7:	55                   	push   ebp
 804a0d8:	89 e5                	mov    ebp,esp
  switch (origin) {
 804a0da:	83 7d 10 03          	cmp    DWORD PTR [ebp+0x10],0x3
 804a0de:	74 14                	je     804a0f4 <fseek+0x1d>
 804a0e0:	83 7d 10 03          	cmp    DWORD PTR [ebp+0x10],0x3
 804a0e4:	7f 2c                	jg     804a112 <fseek+0x3b>
 804a0e6:	83 7d 10 01          	cmp    DWORD PTR [ebp+0x10],0x1
 804a0ea:	74 13                	je     804a0ff <fseek+0x28>
 804a0ec:	83 7d 10 02          	cmp    DWORD PTR [ebp+0x10],0x2
 804a0f0:	74 23                	je     804a115 <fseek+0x3e>
    stream->pos+=offset;
    break;
  case SEEK_END:
    break;
  default:
    break;
 804a0f2:	eb 1e                	jmp    804a112 <fseek+0x3b>
    stream->pos=offset;
 804a0f4:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a0f7:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 804a0fa:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
    break;
 804a0fd:	eb 17                	jmp    804a116 <fseek+0x3f>
    stream->pos+=offset;
 804a0ff:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a102:	8b 50 08             	mov    edx,DWORD PTR [eax+0x8]
 804a105:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804a108:	01 c2                	add    edx,eax
 804a10a:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a10d:	89 50 08             	mov    DWORD PTR [eax+0x8],edx
    break;
 804a110:	eb 04                	jmp    804a116 <fseek+0x3f>
    break;
 804a112:	90                   	nop
 804a113:	eb 01                	jmp    804a116 <fseek+0x3f>
    break;
 804a115:	90                   	nop
  }
  return 0;
 804a116:	b8 00 00 00 00       	mov    eax,0x0
}
 804a11b:	5d                   	pop    ebp
 804a11c:	c3                   	ret    

0804a11d <memcpy>:
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

void* memcpy(void* dest_ptr,const void* source_ptr,size_t len) {
 804a11d:	55                   	push   ebp
 804a11e:	89 e5                	mov    ebp,esp
 804a120:	83 ec 10             	sub    esp,0x10
    char* source=(char*)source_ptr;
 804a123:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804a126:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
    char* dest=(char*)dest_ptr;
 804a129:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a12c:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
    for(size_t i=0;i<len;i++) {
 804a12f:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [ebp-0x4],0x0
 804a136:	eb 17                	jmp    804a14f <memcpy+0x32>
      dest[i]=source[i];
 804a138:	8b 55 f8             	mov    edx,DWORD PTR [ebp-0x8]
 804a13b:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a13e:	01 d0                	add    eax,edx
 804a140:	8b 4d f4             	mov    ecx,DWORD PTR [ebp-0xc]
 804a143:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 804a146:	01 ca                	add    edx,ecx
 804a148:	8a 00                	mov    al,BYTE PTR [eax]
 804a14a:	88 02                	mov    BYTE PTR [edx],al
    for(size_t i=0;i<len;i++) {
 804a14c:	ff 45 fc             	inc    DWORD PTR [ebp-0x4]
 804a14f:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a152:	3b 45 10             	cmp    eax,DWORD PTR [ebp+0x10]
 804a155:	72 e1                	jb     804a138 <memcpy+0x1b>
    }
    return dest_ptr;
 804a157:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
}
 804a15a:	c9                   	leave  
 804a15b:	c3                   	ret    

0804a15c <memset>:

void* memset(void *dest_ptr,int val,size_t len) {
 804a15c:	55                   	push   ebp
 804a15d:	89 e5                	mov    ebp,esp
 804a15f:	83 ec 10             	sub    esp,0x10
    char* dest=(char*)dest_ptr;
 804a162:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a165:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
    for (size_t i=0;i<len;i++){
 804a168:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [ebp-0x4],0x0
 804a16f:	eb 10                	jmp    804a181 <memset+0x25>
      dest[i]=(char)val;
 804a171:	8b 55 f8             	mov    edx,DWORD PTR [ebp-0x8]
 804a174:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a177:	01 d0                	add    eax,edx
 804a179:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 804a17c:	88 10                	mov    BYTE PTR [eax],dl
    for (size_t i=0;i<len;i++){
 804a17e:	ff 45 fc             	inc    DWORD PTR [ebp-0x4]
 804a181:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a184:	3b 45 10             	cmp    eax,DWORD PTR [ebp+0x10]
 804a187:	72 e8                	jb     804a171 <memset+0x15>
    }
    return dest_ptr;
 804a189:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
}
 804a18c:	c9                   	leave  
 804a18d:	c3                   	ret    

0804a18e <strcmp>:

int strcmp(const char* s1,const char* s2) {
 804a18e:	55                   	push   ebp
 804a18f:	89 e5                	mov    ebp,esp
 804a191:	83 ec 10             	sub    esp,0x10
    int i;
    for (i = 0; s1[i] == s2[i]; i++) {
 804a194:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [ebp-0x4],0x0
 804a19b:	eb 18                	jmp    804a1b5 <strcmp+0x27>
        if (s1[i] == '\0') return 0;
 804a19d:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 804a1a0:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a1a3:	01 d0                	add    eax,edx
 804a1a5:	8a 00                	mov    al,BYTE PTR [eax]
 804a1a7:	84 c0                	test   al,al
 804a1a9:	75 07                	jne    804a1b2 <strcmp+0x24>
 804a1ab:	b8 00 00 00 00       	mov    eax,0x0
 804a1b0:	eb 39                	jmp    804a1eb <strcmp+0x5d>
    for (i = 0; s1[i] == s2[i]; i++) {
 804a1b2:	ff 45 fc             	inc    DWORD PTR [ebp-0x4]
 804a1b5:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 804a1b8:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a1bb:	01 d0                	add    eax,edx
 804a1bd:	8a 10                	mov    dl,BYTE PTR [eax]
 804a1bf:	8b 4d fc             	mov    ecx,DWORD PTR [ebp-0x4]
 804a1c2:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804a1c5:	01 c8                	add    eax,ecx
 804a1c7:	8a 00                	mov    al,BYTE PTR [eax]
 804a1c9:	38 c2                	cmp    dl,al
 804a1cb:	74 d0                	je     804a19d <strcmp+0xf>
    }
    return s1[i] - s2[i];
 804a1cd:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 804a1d0:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a1d3:	01 d0                	add    eax,edx
 804a1d5:	8a 00                	mov    al,BYTE PTR [eax]
 804a1d7:	0f be d0             	movsx  edx,al
 804a1da:	8b 4d fc             	mov    ecx,DWORD PTR [ebp-0x4]
 804a1dd:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804a1e0:	01 c8                	add    eax,ecx
 804a1e2:	8a 00                	mov    al,BYTE PTR [eax]
 804a1e4:	0f be c0             	movsx  eax,al
 804a1e7:	29 c2                	sub    edx,eax
 804a1e9:	89 d0                	mov    eax,edx
}
 804a1eb:	c9                   	leave  
 804a1ec:	c3                   	ret    

0804a1ed <strlen>:

size_t strlen(const char* str) {
 804a1ed:	55                   	push   ebp
 804a1ee:	89 e5                	mov    ebp,esp
 804a1f0:	83 ec 10             	sub    esp,0x10
  size_t i;
  for (i=0;str[i]!='\0';i++);
 804a1f3:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [ebp-0x4],0x0
 804a1fa:	eb 03                	jmp    804a1ff <strlen+0x12>
 804a1fc:	ff 45 fc             	inc    DWORD PTR [ebp-0x4]
 804a1ff:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 804a202:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a205:	01 d0                	add    eax,edx
 804a207:	8a 00                	mov    al,BYTE PTR [eax]
 804a209:	84 c0                	test   al,al
 804a20b:	75 ef                	jne    804a1fc <strlen+0xf>
  return i;
 804a20d:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
}
 804a210:	c9                   	leave  
 804a211:	c3                   	ret    

0804a212 <strcpy>:

char* strcpy(char* dest,const char* src) {
 804a212:	55                   	push   ebp
 804a213:	89 e5                	mov    ebp,esp
 804a215:	83 ec 10             	sub    esp,0x10
  size_t i;
  for (i=0;i<strlen(src);i++) {
 804a218:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [ebp-0x4],0x0
 804a21f:	eb 17                	jmp    804a238 <strcpy+0x26>
    dest[i]=src[i];
 804a221:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 804a224:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a227:	01 d0                	add    eax,edx
 804a229:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
 804a22c:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 804a22f:	01 ca                	add    edx,ecx
 804a231:	8a 00                	mov    al,BYTE PTR [eax]
 804a233:	88 02                	mov    BYTE PTR [edx],al
  for (i=0;i<strlen(src);i++) {
 804a235:	ff 45 fc             	inc    DWORD PTR [ebp-0x4]
 804a238:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a23b:	e8 ad ff ff ff       	call   804a1ed <strlen>
 804a240:	83 c4 04             	add    esp,0x4
 804a243:	39 45 fc             	cmp    DWORD PTR [ebp-0x4],eax
 804a246:	72 d9                	jb     804a221 <strcpy+0xf>
  }
  dest[i]='\0';
 804a248:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 804a24b:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a24e:	01 d0                	add    eax,edx
 804a250:	c6 00 00             	mov    BYTE PTR [eax],0x0
  return dest;
 804a253:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
}
 804a256:	c9                   	leave  
 804a257:	c3                   	ret    

0804a258 <strrev>:

char* strrev(char* str) {
 804a258:	55                   	push   ebp
 804a259:	89 e5                	mov    ebp,esp
 804a25b:	83 ec 10             	sub    esp,0x10
    char chr;
    int i,j;
    for (i=0,j=strlen(str)-1;i<j;i++,j--) {
 804a25e:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [ebp-0x4],0x0
 804a265:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804a268:	e8 80 ff ff ff       	call   804a1ed <strlen>
 804a26d:	83 c4 04             	add    esp,0x4
 804a270:	48                   	dec    eax
 804a271:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
 804a274:	eb 34                	jmp    804a2aa <strrev+0x52>
      chr=str[i];
 804a276:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 804a279:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a27c:	01 d0                	add    eax,edx
 804a27e:	8a 00                	mov    al,BYTE PTR [eax]
 804a280:	88 45 f7             	mov    BYTE PTR [ebp-0x9],al
      str[i]=str[j];
 804a283:	8b 55 f8             	mov    edx,DWORD PTR [ebp-0x8]
 804a286:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a289:	01 d0                	add    eax,edx
 804a28b:	8b 4d fc             	mov    ecx,DWORD PTR [ebp-0x4]
 804a28e:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 804a291:	01 ca                	add    edx,ecx
 804a293:	8a 00                	mov    al,BYTE PTR [eax]
 804a295:	88 02                	mov    BYTE PTR [edx],al
      str[j]=chr;
 804a297:	8b 55 f8             	mov    edx,DWORD PTR [ebp-0x8]
 804a29a:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a29d:	01 c2                	add    edx,eax
 804a29f:	8a 45 f7             	mov    al,BYTE PTR [ebp-0x9]
 804a2a2:	88 02                	mov    BYTE PTR [edx],al
    for (i=0,j=strlen(str)-1;i<j;i++,j--) {
 804a2a4:	ff 45 fc             	inc    DWORD PTR [ebp-0x4]
 804a2a7:	ff 4d f8             	dec    DWORD PTR [ebp-0x8]
 804a2aa:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a2ad:	3b 45 f8             	cmp    eax,DWORD PTR [ebp-0x8]
 804a2b0:	7c c4                	jl     804a276 <strrev+0x1e>
    }
    return str;
 804a2b2:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
}
 804a2b5:	c9                   	leave  
 804a2b6:	c3                   	ret    

0804a2b7 <int_to_ascii>:

void int_to_ascii(int n,char* str) {
 804a2b7:	55                   	push   ebp
 804a2b8:	89 e5                	mov    ebp,esp
 804a2ba:	83 ec 10             	sub    esp,0x10
    int i;
    int sign;
    if ((sign = n)<0) {
 804a2bd:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a2c0:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
 804a2c3:	83 7d f8 00          	cmp    DWORD PTR [ebp-0x8],0x0
 804a2c7:	79 03                	jns    804a2cc <int_to_ascii+0x15>
      n=-n;
 804a2c9:	f7 5d 08             	neg    DWORD PTR [ebp+0x8]
    }
    i=0;
 804a2cc:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [ebp-0x4],0x0
    do {
      str[i++]=n%10+'0';
 804a2d3:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a2d6:	b9 0a 00 00 00       	mov    ecx,0xa
 804a2db:	99                   	cdq    
 804a2dc:	f7 f9                	idiv   ecx
 804a2de:	89 d0                	mov    eax,edx
 804a2e0:	8d 48 30             	lea    ecx,[eax+0x30]
 804a2e3:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a2e6:	8d 50 01             	lea    edx,[eax+0x1]
 804a2e9:	89 55 fc             	mov    DWORD PTR [ebp-0x4],edx
 804a2ec:	89 c2                	mov    edx,eax
 804a2ee:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804a2f1:	01 d0                	add    eax,edx
 804a2f3:	88 ca                	mov    dl,cl
 804a2f5:	88 10                	mov    BYTE PTR [eax],dl
    } while ((n /= 10) > 0);
 804a2f7:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
 804a2fa:	b8 67 66 66 66       	mov    eax,0x66666667
 804a2ff:	f7 e9                	imul   ecx
 804a301:	c1 fa 02             	sar    edx,0x2
 804a304:	89 c8                	mov    eax,ecx
 804a306:	c1 f8 1f             	sar    eax,0x1f
 804a309:	29 c2                	sub    edx,eax
 804a30b:	89 d0                	mov    eax,edx
 804a30d:	89 45 08             	mov    DWORD PTR [ebp+0x8],eax
 804a310:	83 7d 08 00          	cmp    DWORD PTR [ebp+0x8],0x0
 804a314:	7f bd                	jg     804a2d3 <int_to_ascii+0x1c>
    if (sign < 0) {
 804a316:	83 7d f8 00          	cmp    DWORD PTR [ebp-0x8],0x0
 804a31a:	79 13                	jns    804a32f <int_to_ascii+0x78>
      str[i++] = '-';
 804a31c:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a31f:	8d 50 01             	lea    edx,[eax+0x1]
 804a322:	89 55 fc             	mov    DWORD PTR [ebp-0x4],edx
 804a325:	89 c2                	mov    edx,eax
 804a327:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804a32a:	01 d0                	add    eax,edx
 804a32c:	c6 00 2d             	mov    BYTE PTR [eax],0x2d
    }
    str[i]='\0';
 804a32f:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 804a332:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804a335:	01 d0                	add    eax,edx
 804a337:	c6 00 00             	mov    BYTE PTR [eax],0x0
    strrev(str);
 804a33a:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a33d:	e8 16 ff ff ff       	call   804a258 <strrev>
 804a342:	83 c4 04             	add    esp,0x4
}
 804a345:	90                   	nop
 804a346:	c9                   	leave  
 804a347:	c3                   	ret    

0804a348 <hex_to_ascii>:

void hex_to_ascii(unsigned int n, char* str) {
 804a348:	55                   	push   ebp
 804a349:	89 e5                	mov    ebp,esp
 804a34b:	83 ec 18             	sub    esp,0x18
    str[0]='\0'; 
 804a34e:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804a351:	c6 00 00             	mov    BYTE PTR [eax],0x0
    append(str, '0');
 804a354:	83 ec 08             	sub    esp,0x8
 804a357:	6a 30                	push   0x30
 804a359:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a35c:	e8 cb 00 00 00       	call   804a42c <append>
 804a361:	83 c4 10             	add    esp,0x10
    append(str, 'x');
 804a364:	83 ec 08             	sub    esp,0x8
 804a367:	6a 78                	push   0x78
 804a369:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a36c:	e8 bb 00 00 00       	call   804a42c <append>
 804a371:	83 c4 10             	add    esp,0x10
    char zeros = 0;
 804a374:	c6 45 f7 00          	mov    BYTE PTR [ebp-0x9],0x0

    unsigned int tmp;
    int i;
    for (i = 28; i > 0; i -= 4) {
 804a378:	c7 45 f0 1c 00 00 00 	mov    DWORD PTR [ebp-0x10],0x1c
 804a37f:	eb 61                	jmp    804a3e2 <hex_to_ascii+0x9a>
        tmp = (n >> i) & 0xF;
 804a381:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 804a384:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]
 804a387:	88 c1                	mov    cl,al
 804a389:	d3 ea                	shr    edx,cl
 804a38b:	89 d0                	mov    eax,edx
 804a38d:	83 e0 0f             	and    eax,0xf
 804a390:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
        if (tmp == 0 && zeros == 0) continue;
 804a393:	83 7d ec 00          	cmp    DWORD PTR [ebp-0x14],0x0
 804a397:	75 06                	jne    804a39f <hex_to_ascii+0x57>
 804a399:	80 7d f7 00          	cmp    BYTE PTR [ebp-0x9],0x0
 804a39d:	74 3e                	je     804a3dd <hex_to_ascii+0x95>
        zeros = 1;
 804a39f:	c6 45 f7 01          	mov    BYTE PTR [ebp-0x9],0x1
        if (tmp >= 0xA) append(str, tmp - 0xA + 'a');
 804a3a3:	83 7d ec 09          	cmp    DWORD PTR [ebp-0x14],0x9
 804a3a7:	76 1a                	jbe    804a3c3 <hex_to_ascii+0x7b>
 804a3a9:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 804a3ac:	83 c0 57             	add    eax,0x57
 804a3af:	0f be c0             	movsx  eax,al
 804a3b2:	83 ec 08             	sub    esp,0x8
 804a3b5:	50                   	push   eax
 804a3b6:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a3b9:	e8 6e 00 00 00       	call   804a42c <append>
 804a3be:	83 c4 10             	add    esp,0x10
 804a3c1:	eb 1b                	jmp    804a3de <hex_to_ascii+0x96>
        else append(str, tmp + '0');
 804a3c3:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 804a3c6:	83 c0 30             	add    eax,0x30
 804a3c9:	0f be c0             	movsx  eax,al
 804a3cc:	83 ec 08             	sub    esp,0x8
 804a3cf:	50                   	push   eax
 804a3d0:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a3d3:	e8 54 00 00 00       	call   804a42c <append>
 804a3d8:	83 c4 10             	add    esp,0x10
 804a3db:	eb 01                	jmp    804a3de <hex_to_ascii+0x96>
        if (tmp == 0 && zeros == 0) continue;
 804a3dd:	90                   	nop
    for (i = 28; i > 0; i -= 4) {
 804a3de:	83 6d f0 04          	sub    DWORD PTR [ebp-0x10],0x4
 804a3e2:	83 7d f0 00          	cmp    DWORD PTR [ebp-0x10],0x0
 804a3e6:	7f 99                	jg     804a381 <hex_to_ascii+0x39>
    }

    tmp = n & 0xF;
 804a3e8:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a3eb:	83 e0 0f             	and    eax,0xf
 804a3ee:	89 45 ec             	mov    DWORD PTR [ebp-0x14],eax
    if (tmp >= 0xA) append(str, tmp - 0xA + 'a');
 804a3f1:	83 7d ec 09          	cmp    DWORD PTR [ebp-0x14],0x9
 804a3f5:	76 1a                	jbe    804a411 <hex_to_ascii+0xc9>
 804a3f7:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 804a3fa:	83 c0 57             	add    eax,0x57
 804a3fd:	0f be c0             	movsx  eax,al
 804a400:	83 ec 08             	sub    esp,0x8
 804a403:	50                   	push   eax
 804a404:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a407:	e8 20 00 00 00       	call   804a42c <append>
 804a40c:	83 c4 10             	add    esp,0x10
    else append(str, tmp + '0');
}
 804a40f:	eb 18                	jmp    804a429 <hex_to_ascii+0xe1>
    else append(str, tmp + '0');
 804a411:	8b 45 ec             	mov    eax,DWORD PTR [ebp-0x14]
 804a414:	83 c0 30             	add    eax,0x30
 804a417:	0f be c0             	movsx  eax,al
 804a41a:	83 ec 08             	sub    esp,0x8
 804a41d:	50                   	push   eax
 804a41e:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a421:	e8 06 00 00 00       	call   804a42c <append>
 804a426:	83 c4 10             	add    esp,0x10
}
 804a429:	90                   	nop
 804a42a:	c9                   	leave  
 804a42b:	c3                   	ret    

0804a42c <append>:

void append(char* s, char n) {
 804a42c:	55                   	push   ebp
 804a42d:	89 e5                	mov    ebp,esp
 804a42f:	83 ec 14             	sub    esp,0x14
 804a432:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]
 804a435:	88 45 ec             	mov    BYTE PTR [ebp-0x14],al
    int len = strlen(s);
 804a438:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804a43b:	e8 ad fd ff ff       	call   804a1ed <strlen>
 804a440:	83 c4 04             	add    esp,0x4
 804a443:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
    s[len] = n;
 804a446:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 804a449:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a44c:	01 c2                	add    edx,eax
 804a44e:	8a 45 ec             	mov    al,BYTE PTR [ebp-0x14]
 804a451:	88 02                	mov    BYTE PTR [edx],al
    s[len+1] = '\0';
 804a453:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a456:	8d 50 01             	lea    edx,[eax+0x1]
 804a459:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a45c:	01 d0                	add    eax,edx
 804a45e:	c6 00 00             	mov    BYTE PTR [eax],0x0
}
 804a461:	90                   	nop
 804a462:	c9                   	leave  
 804a463:	c3                   	ret    

0804a464 <backspace>:

void backspace(char* s) {
 804a464:	55                   	push   ebp
 804a465:	89 e5                	mov    ebp,esp
 804a467:	83 ec 10             	sub    esp,0x10
    int len = strlen(s);
 804a46a:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804a46d:	e8 7b fd ff ff       	call   804a1ed <strlen>
 804a472:	83 c4 04             	add    esp,0x4
 804a475:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax
    s[len-1] = '\0';
 804a478:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a47b:	8d 50 ff             	lea    edx,[eax-0x1]
 804a47e:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a481:	01 d0                	add    eax,edx
 804a483:	c6 00 00             	mov    BYTE PTR [eax],0x0
}
 804a486:	90                   	nop
 804a487:	c9                   	leave  
 804a488:	c3                   	ret    

0804a489 <strtok_delim_check>:

static const char* strtok_str=NULL;
static size_t strtok_index;

static char strtok_delim_check(const char* delim) {
 804a489:	55                   	push   ebp
 804a48a:	89 e5                	mov    ebp,esp
 804a48c:	83 ec 10             	sub    esp,0x10
  for (size_t i=0;i<strlen(delim);i++) {
 804a48f:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [ebp-0x4],0x0
 804a496:	eb 37                	jmp    804a4cf <strtok_delim_check+0x46>
    if (strtok_str[strtok_index]==delim[i]||strtok_str[strtok_index]=='\0') {
 804a498:	8b 15 84 c1 04 08    	mov    edx,DWORD PTR ds:0x804c184
 804a49e:	a1 88 c1 04 08       	mov    eax,ds:0x804c188
 804a4a3:	01 d0                	add    eax,edx
 804a4a5:	8a 10                	mov    dl,BYTE PTR [eax]
 804a4a7:	8b 4d 08             	mov    ecx,DWORD PTR [ebp+0x8]
 804a4aa:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]
 804a4ad:	01 c8                	add    eax,ecx
 804a4af:	8a 00                	mov    al,BYTE PTR [eax]
 804a4b1:	38 c2                	cmp    dl,al
 804a4b3:	74 13                	je     804a4c8 <strtok_delim_check+0x3f>
 804a4b5:	8b 15 84 c1 04 08    	mov    edx,DWORD PTR ds:0x804c184
 804a4bb:	a1 88 c1 04 08       	mov    eax,ds:0x804c188
 804a4c0:	01 d0                	add    eax,edx
 804a4c2:	8a 00                	mov    al,BYTE PTR [eax]
 804a4c4:	84 c0                	test   al,al
 804a4c6:	75 04                	jne    804a4cc <strtok_delim_check+0x43>
      return 0;
 804a4c8:	b0 00                	mov    al,0x0
 804a4ca:	eb 15                	jmp    804a4e1 <strtok_delim_check+0x58>
  for (size_t i=0;i<strlen(delim);i++) {
 804a4cc:	ff 45 fc             	inc    DWORD PTR [ebp-0x4]
 804a4cf:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 804a4d2:	e8 16 fd ff ff       	call   804a1ed <strlen>
 804a4d7:	83 c4 04             	add    esp,0x4
 804a4da:	39 45 fc             	cmp    DWORD PTR [ebp-0x4],eax
 804a4dd:	72 b9                	jb     804a498 <strtok_delim_check+0xf>
    }
  }
  return 1;
 804a4df:	b0 01                	mov    al,0x1
}
 804a4e1:	c9                   	leave  
 804a4e2:	c3                   	ret    

0804a4e3 <strtok>:

char* strtok(const char* str, const char* delim) {
 804a4e3:	55                   	push   ebp
 804a4e4:	89 e5                	mov    ebp,esp
 804a4e6:	83 ec 18             	sub    esp,0x18
  if (str!=NULL) {
 804a4e9:	83 7d 08 00          	cmp    DWORD PTR [ebp+0x8],0x0
 804a4ed:	74 12                	je     804a501 <strtok+0x1e>
    strtok_str=str;
 804a4ef:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a4f2:	a3 84 c1 04 08       	mov    ds:0x804c184,eax
    strtok_index=0;
 804a4f7:	c7 05 88 c1 04 08 00 	mov    DWORD PTR ds:0x804c188,0x0
 804a4fe:	00 00 00 
  }
  if (!strtok_str || strtok_index>strlen(strtok_str)) {
 804a501:	a1 84 c1 04 08       	mov    eax,ds:0x804c184
 804a506:	85 c0                	test   eax,eax
 804a508:	74 18                	je     804a522 <strtok+0x3f>
 804a50a:	a1 84 c1 04 08       	mov    eax,ds:0x804c184
 804a50f:	50                   	push   eax
 804a510:	e8 d8 fc ff ff       	call   804a1ed <strlen>
 804a515:	83 c4 04             	add    esp,0x4
 804a518:	8b 15 88 c1 04 08    	mov    edx,DWORD PTR ds:0x804c188
 804a51e:	39 d0                	cmp    eax,edx
 804a520:	73 0a                	jae    804a52c <strtok+0x49>
    return NULL;
 804a522:	b8 00 00 00 00       	mov    eax,0x0
 804a527:	e9 9b 00 00 00       	jmp    804a5c7 <strtok+0xe4>
  }
  char* tok=malloc(sizeof(char)*32);
 804a52c:	83 ec 0c             	sub    esp,0xc
 804a52f:	6a 20                	push   0x20
 804a531:	e8 a7 e4 ff ff       	call   80489dd <malloc>
 804a536:	83 c4 10             	add    esp,0x10
 804a539:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
  tok[0]='\0';
 804a53c:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
 804a53f:	c6 00 00             	mov    BYTE PTR [eax],0x0
  size_t max_len=32;
 804a542:	c7 45 f0 20 00 00 00 	mov    DWORD PTR [ebp-0x10],0x20
  for (;strtok_delim_check(delim);strtok_index++) {
 804a549:	eb 5c                	jmp    804a5a7 <strtok+0xc4>
    if (strlen(tok)+1==max_len) {
 804a54b:	83 ec 0c             	sub    esp,0xc
 804a54e:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 804a551:	e8 97 fc ff ff       	call   804a1ed <strlen>
 804a556:	83 c4 10             	add    esp,0x10
 804a559:	40                   	inc    eax
 804a55a:	39 45 f0             	cmp    DWORD PTR [ebp-0x10],eax
 804a55d:	75 1c                	jne    804a57b <strtok+0x98>
      tok=realloc(tok,sizeof(char)*(max_len+32));
 804a55f:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
 804a562:	83 c0 20             	add    eax,0x20
 804a565:	83 ec 08             	sub    esp,0x8
 804a568:	50                   	push   eax
 804a569:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 804a56c:	e8 8f ed ff ff       	call   8049300 <realloc>
 804a571:	83 c4 10             	add    esp,0x10
 804a574:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
      max_len+=32;
 804a577:	83 45 f0 20          	add    DWORD PTR [ebp-0x10],0x20
    }
    append(tok,strtok_str[strtok_index]);
 804a57b:	8b 15 84 c1 04 08    	mov    edx,DWORD PTR ds:0x804c184
 804a581:	a1 88 c1 04 08       	mov    eax,ds:0x804c188
 804a586:	01 d0                	add    eax,edx
 804a588:	8a 00                	mov    al,BYTE PTR [eax]
 804a58a:	0f be c0             	movsx  eax,al
 804a58d:	83 ec 08             	sub    esp,0x8
 804a590:	50                   	push   eax
 804a591:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 804a594:	e8 93 fe ff ff       	call   804a42c <append>
 804a599:	83 c4 10             	add    esp,0x10
  for (;strtok_delim_check(delim);strtok_index++) {
 804a59c:	a1 88 c1 04 08       	mov    eax,ds:0x804c188
 804a5a1:	40                   	inc    eax
 804a5a2:	a3 88 c1 04 08       	mov    ds:0x804c188,eax
 804a5a7:	83 ec 0c             	sub    esp,0xc
 804a5aa:	ff 75 0c             	push   DWORD PTR [ebp+0xc]
 804a5ad:	e8 d7 fe ff ff       	call   804a489 <strtok_delim_check>
 804a5b2:	83 c4 10             	add    esp,0x10
 804a5b5:	84 c0                	test   al,al
 804a5b7:	75 92                	jne    804a54b <strtok+0x68>
  }
  strtok_index++;
 804a5b9:	a1 88 c1 04 08       	mov    eax,ds:0x804c188
 804a5be:	40                   	inc    eax
 804a5bf:	a3 88 c1 04 08       	mov    ds:0x804c188,eax
  return tok;
 804a5c4:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
}
 804a5c7:	c9                   	leave  
 804a5c8:	c3                   	ret    

0804a5c9 <yield>:
#include <tasking.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void yield() {
 804a5c9:	55                   	push   ebp
 804a5ca:	89 e5                	mov    ebp,esp
 804a5cc:	53                   	push   ebx
  asm volatile("  \
 804a5cd:	b8 00 00 00 00       	mov    eax,0x0
 804a5d2:	89 c3                	mov    ebx,eax
 804a5d4:	b8 01 00 00 00       	mov    eax,0x1
 804a5d9:	cd 50                	int    0x50
    mov $" QU(SYSCALL_YIELD) ", %%eax; \
    int $80; \
  "::"b"(0));
}
 804a5db:	90                   	nop
 804a5dc:	5b                   	pop    ebx
 804a5dd:	5d                   	pop    ebp
 804a5de:	c3                   	ret    

0804a5df <create_proc>:

void create_proc(void* start,void* address_space,void* param1,void* param2) {
 804a5df:	55                   	push   ebp
 804a5e0:	89 e5                	mov    ebp,esp
 804a5e2:	56                   	push   esi
 804a5e3:	53                   	push   ebx
  asm volatile("  \
 804a5e4:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a5e7:	8b 4d 0c             	mov    ecx,DWORD PTR [ebp+0xc]
 804a5ea:	8b 55 10             	mov    edx,DWORD PTR [ebp+0x10]
 804a5ed:	8b 75 14             	mov    esi,DWORD PTR [ebp+0x14]
 804a5f0:	89 c3                	mov    ebx,eax
 804a5f2:	b8 00 00 00 00       	mov    eax,0x0
 804a5f7:	cd 50                	int    0x50
    mov $" QU(SYSCALL_CREATEPROC) ", %%eax; \
    int $80; \
  "::"b"(start),"c"(address_space),"d"(param1),"S"(param2));
}
 804a5f9:	90                   	nop
 804a5fa:	5b                   	pop    ebx
 804a5fb:	5e                   	pop    esi
 804a5fc:	5d                   	pop    ebp
 804a5fd:	c3                   	ret    

0804a5fe <exit>:

__attribute__((noreturn)) void exit(int code) {
 804a5fe:	55                   	push   ebp
 804a5ff:	89 e5                	mov    ebp,esp
 804a601:	53                   	push   ebx
  code=code&0xff;
 804a602:	81 65 08 ff 00 00 00 	and    DWORD PTR [ebp+0x8],0xff
  asm volatile("  \
 804a609:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a60c:	89 c3                	mov    ebx,eax
 804a60e:	b8 04 00 00 00       	mov    eax,0x4
 804a613:	cd 50                	int    0x50
    mov $" QU(SYSCALL_EXIT) ", %%eax; \
    int $80; \
  "::"b"(code));
  for(;;);
 804a615:	eb fe                	jmp    804a615 <exit+0x17>

0804a617 <block_thread>:
}


void block_thread(thread_state state) {
 804a617:	55                   	push   ebp
 804a618:	89 e5                	mov    ebp,esp
 804a61a:	53                   	push   ebx
  asm volatile("  \
 804a61b:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a61e:	89 c3                	mov    ebx,eax
 804a620:	b8 02 00 00 00       	mov    eax,0x2
 804a625:	cd 50                	int    0x50
    mov $" QU(SYSCALL_BLOCK) ", %%eax; \
    int $80; \
  "::"b"(state));
}
 804a627:	90                   	nop
 804a628:	5b                   	pop    ebx
 804a629:	5d                   	pop    ebp
 804a62a:	c3                   	ret    

0804a62b <unblock_thread>:

void unblock_thread(pid_t pid,pid_t tid) {
 804a62b:	55                   	push   ebp
 804a62c:	89 e5                	mov    ebp,esp
 804a62e:	53                   	push   ebx
  asm volatile("  \
 804a62f:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a632:	8b 55 0c             	mov    edx,DWORD PTR [ebp+0xc]
 804a635:	89 c3                	mov    ebx,eax
 804a637:	89 d1                	mov    ecx,edx
 804a639:	b8 03 00 00 00       	mov    eax,0x3
 804a63e:	cd 50                	int    0x50
    mov $" QU(SYSCALL_UNBLOCK) ", %%eax; \
    int $80; \
  "::"b"(pid),"c"(tid));
}
 804a640:	90                   	nop
 804a641:	5b                   	pop    ebx
 804a642:	5d                   	pop    ebp
 804a643:	c3                   	ret    

0804a644 <check_proc_exists>:

char check_proc_exists(pid_t pid) {
 804a644:	55                   	push   ebp
 804a645:	89 e5                	mov    ebp,esp
 804a647:	53                   	push   ebx
 804a648:	83 ec 10             	sub    esp,0x10
  char exists;
  asm volatile("  \
 804a64b:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
 804a64e:	89 c3                	mov    ebx,eax
 804a650:	b8 14 00 00 00       	mov    eax,0x14
 804a655:	cd 50                	int    0x50
 804a657:	88 c8                	mov    al,cl
 804a659:	88 45 fb             	mov    BYTE PTR [ebp-0x5],al
    mov $" QU(SYSCALL_CHECK_PROC_EXISTS) ", %%eax; \
    int $80; \
  ":"=c"(exists):"b"(pid));
  return exists;
 804a65c:	8a 45 fb             	mov    al,BYTE PTR [ebp-0x5]
}
 804a65f:	83 c4 10             	add    esp,0x10
 804a662:	5b                   	pop    ebx
 804a663:	5d                   	pop    ebp
 804a664:	c3                   	ret    
 804a665:	66 90                	xchg   ax,ax
 804a667:	66 90                	xchg   ax,ax
 804a669:	66 90                	xchg   ax,ax
 804a66b:	66 90                	xchg   ax,ax
 804a66d:	66 90                	xchg   ax,ax
 804a66f:	90                   	nop

0804a670 <__pthread_spin_lock_helper>:
 804a670:	8b 5c 24 04          	mov    ebx,DWORD PTR [esp+0x4]
 804a674:	b8 01 00 00 00       	mov    eax,0x1
 804a679:	87 03                	xchg   DWORD PTR [ebx],eax
 804a67b:	85 c0                	test   eax,eax
 804a67d:	75 f1                	jne    804a670 <__pthread_spin_lock_helper>
 804a67f:	c3                   	ret    
 804a680:	a1 fc ff ff ff       	mov    eax,ds:0xfffffffc
 804a685:	83 f8 ff             	cmp    eax,0xffffffff
 804a688:	74 1a                	je     804a6a4 <__pthread_spin_lock_helper+0x34>
 804a68a:	55                   	push   ebp
 804a68b:	89 e5                	mov    ebp,esp
 804a68d:	53                   	push   ebx
 804a68e:	52                   	push   edx
 804a68f:	bb fc ff ff ff       	mov    ebx,0xfffffffc
 804a694:	ff d0                	call   eax
 804a696:	83 eb 04             	sub    ebx,0x4
 804a699:	8b 03                	mov    eax,DWORD PTR [ebx]
 804a69b:	83 f8 ff             	cmp    eax,0xffffffff
 804a69e:	75 f4                	jne    804a694 <__pthread_spin_lock_helper+0x24>
 804a6a0:	58                   	pop    eax
 804a6a1:	5b                   	pop    ebx
 804a6a2:	5d                   	pop    ebp
 804a6a3:	c3                   	ret    
 804a6a4:	c3                   	ret    

Disassembly of section .fini:

0804a6a5 <.fini>:
 804a6a5:	e8 60 00 00 00       	call   804a70a <__pthread_spin_lock_helper+0x9a>
 804a6aa:	c2 00 00             	ret    0x0
