
kernel/kernel.elf:     file format elf32-i386


Disassembly of section .text:

c0100000 <_kernel_start>:
c0100000:	d6                   	(bad)  
c0100001:	50                   	push   %eax
c0100002:	52                   	push   %edx
c0100003:	e8 00 00 00 00       	call   c0100008 <_kernel_start+0x8>
c0100008:	40                   	inc    %eax
c0100009:	00 00                	add    %al,(%eax)
c010000b:	00 ea                	add    %ch,%dl
c010000d:	ae                   	scas   %es:(%edi),%al
c010000e:	ad                   	lods   %ds:(%esi),%eax
c010000f:	17                   	pop    %ss

c0100010 <info_tag_start>:
c0100010:	01 00                	add    %eax,(%eax)
c0100012:	00 00                	add    %al,(%eax)
c0100014:	10 00                	adc    %al,(%eax)
c0100016:	00 00                	add    %al,(%eax)
c0100018:	04 00                	add    $0x0,%al
c010001a:	00 00                	add    %al,(%eax)
c010001c:	06                   	push   %es
c010001d:	00 00                	add    %al,(%eax)
	...

c0100020 <info_tag_end>:
c0100020:	03 00                	add    (%eax),%eax
c0100022:	00 00                	add    %al,(%eax)
c0100024:	0c 00                	or     $0x0,%al
c0100026:	00 00                	add    %al,(%eax)
c0100028:	0e                   	push   %cs
c0100029:	01 10                	add    %edx,(%eax)
c010002b:	00 00                	add    %al,(%eax)
c010002d:	00 00                	add    %al,(%eax)
c010002f:	00 06                	add    %al,(%esi)
c0100031:	00 00                	add    %al,(%eax)
c0100033:	00 08                	add    %cl,(%eax)
c0100035:	00 00                	add    %al,(%eax)
c0100037:	00 00                	add    %al,(%eax)
c0100039:	00 00                	add    %al,(%eax)
c010003b:	00 08                	add    %cl,(%eax)
c010003d:	00 00                	add    %al,(%eax)
	...

c0100040 <address_spaces_copy_data>:
#include "cpu/paging.h"
#include "cpu/arch_consts.h"
#include <stddef.h>

void address_spaces_copy_data(void* address_space, void* data,size_t size,void* virt_addr) {
c0100040:	55                   	push   %ebp
c0100041:	89 e5                	mov    %esp,%ebp
c0100043:	83 ec 18             	sub    $0x18,%esp
  void* phys_addr=virt_to_phys(data);
c0100046:	83 ec 0c             	sub    $0xc,%esp
c0100049:	ff 75 0c             	pushl  0xc(%ebp)
c010004c:	e8 f3 31 00 00       	call   c0103244 <virt_to_phys>
c0100051:	83 c4 10             	add    $0x10,%esp
c0100054:	89 45 f4             	mov    %eax,-0xc(%ebp)
  RUN_IN_ADDRESS_SPACE(address_space,map_pages(virt_addr,phys_addr,(size/PAGE_SZ)+1,1,1));
c0100057:	e8 b1 36 00 00       	call   c010370d <get_address_space>
c010005c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010005f:	83 ec 0c             	sub    $0xc,%esp
c0100062:	ff 75 08             	pushl  0x8(%ebp)
c0100065:	e8 5f 33 00 00       	call   c01033c9 <load_address_space>
c010006a:	83 c4 10             	add    $0x10,%esp
c010006d:	8b 45 10             	mov    0x10(%ebp),%eax
c0100070:	c1 e8 0c             	shr    $0xc,%eax
c0100073:	40                   	inc    %eax
c0100074:	83 ec 0c             	sub    $0xc,%esp
c0100077:	6a 01                	push   $0x1
c0100079:	6a 01                	push   $0x1
c010007b:	50                   	push   %eax
c010007c:	ff 75 f4             	pushl  -0xc(%ebp)
c010007f:	ff 75 14             	pushl  0x14(%ebp)
c0100082:	e8 22 2f 00 00       	call   c0102fa9 <map_pages>
c0100087:	83 c4 20             	add    $0x20,%esp
c010008a:	83 ec 0c             	sub    $0xc,%esp
c010008d:	ff 75 f0             	pushl  -0x10(%ebp)
c0100090:	e8 34 33 00 00       	call   c01033c9 <load_address_space>
c0100095:	83 c4 10             	add    $0x10,%esp
}
c0100098:	90                   	nop
c0100099:	c9                   	leave  
c010009a:	c3                   	ret    

c010009b <address_spaces_put_data>:

void* address_spaces_put_data(void* address_space, void* data,size_t size) {
c010009b:	55                   	push   %ebp
c010009c:	89 e5                	mov    %esp,%ebp
c010009e:	83 ec 18             	sub    $0x18,%esp
  void* phys_addr=virt_to_phys(data);
c01000a1:	83 ec 0c             	sub    $0xc,%esp
c01000a4:	ff 75 0c             	pushl  0xc(%ebp)
c01000a7:	e8 98 31 00 00       	call   c0103244 <virt_to_phys>
c01000ac:	83 c4 10             	add    $0x10,%esp
c01000af:	89 45 f4             	mov    %eax,-0xc(%ebp)
  void* virt_addr;
  RUN_IN_ADDRESS_SPACE(address_space,{
c01000b2:	e8 56 36 00 00       	call   c010370d <get_address_space>
c01000b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01000ba:	83 ec 0c             	sub    $0xc,%esp
c01000bd:	ff 75 08             	pushl  0x8(%ebp)
c01000c0:	e8 04 33 00 00       	call   c01033c9 <load_address_space>
c01000c5:	83 c4 10             	add    $0x10,%esp
c01000c8:	8b 45 10             	mov    0x10(%ebp),%eax
c01000cb:	c1 e8 0c             	shr    $0xc,%eax
c01000ce:	40                   	inc    %eax
c01000cf:	83 ec 0c             	sub    $0xc,%esp
c01000d2:	50                   	push   %eax
c01000d3:	e8 7a 30 00 00       	call   c0103152 <find_free_pages>
c01000d8:	83 c4 10             	add    $0x10,%esp
c01000db:	89 45 ec             	mov    %eax,-0x14(%ebp)
c01000de:	8b 45 10             	mov    0x10(%ebp),%eax
c01000e1:	c1 e8 0c             	shr    $0xc,%eax
c01000e4:	40                   	inc    %eax
c01000e5:	83 ec 0c             	sub    $0xc,%esp
c01000e8:	6a 01                	push   $0x1
c01000ea:	6a 01                	push   $0x1
c01000ec:	50                   	push   %eax
c01000ed:	ff 75 f4             	pushl  -0xc(%ebp)
c01000f0:	ff 75 ec             	pushl  -0x14(%ebp)
c01000f3:	e8 b1 2e 00 00       	call   c0102fa9 <map_pages>
c01000f8:	83 c4 20             	add    $0x20,%esp
c01000fb:	83 ec 0c             	sub    $0xc,%esp
c01000fe:	ff 75 f0             	pushl  -0x10(%ebp)
c0100101:	e8 c3 32 00 00       	call   c01033c9 <load_address_space>
c0100106:	83 c4 10             	add    $0x10,%esp
   virt_addr=find_free_pages((size/PAGE_SZ)+1);
   map_pages(virt_addr,phys_addr,(size/PAGE_SZ)+1,1,1);
  });
  return virt_addr;
c0100109:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c010010c:	c9                   	leave  
c010010d:	c3                   	ret    

c010010e <_start>:
c010010e:	3d 89 62 d7 36       	cmp    $0x36d76289,%eax
c0100113:	0f 85 85 00 00 00    	jne    c010019e <loop>
c0100119:	bf 00 f0 1c 00       	mov    $0x1cf000,%edi
c010011e:	be 00 00 00 00       	mov    $0x0,%esi
c0100123:	b9 00 08 00 00       	mov    $0x800,%ecx
c0100128:	89 f2                	mov    %esi,%edx
c010012a:	83 ca 07             	or     $0x7,%edx
c010012d:	89 17                	mov    %edx,(%edi)
c010012f:	81 c6 00 10 00 00    	add    $0x1000,%esi
c0100135:	83 c7 04             	add    $0x4,%edi
c0100138:	e2 ee                	loop   c0100128 <_start+0x1a>
c010013a:	c7 05 00 e0 1c 00 07 	movl   $0x1cf007,0x1ce000
c0100141:	f0 1c 00 
c0100144:	c7 05 00 ec 1c 00 07 	movl   $0x1cf007,0x1cec00
c010014b:	f0 1c 00 
c010014e:	c7 05 04 ec 1c 00 07 	movl   $0x1d0007,0x1cec04
c0100155:	00 1d 00 
c0100158:	b9 00 e0 1c 00       	mov    $0x1ce000,%ecx
c010015d:	0f 22 d9             	mov    %ecx,%cr3
c0100160:	0f 20 c1             	mov    %cr0,%ecx
c0100163:	81 c9 00 00 01 80    	or     $0x80010000,%ecx
c0100169:	0f 22 c1             	mov    %ecx,%cr0
c010016c:	0f 20 e1             	mov    %cr4,%ecx
c010016f:	83 c9 10             	or     $0x10,%ecx
c0100172:	0f 22 e1             	mov    %ecx,%cr4
c0100175:	8d 0d 7d 01 10 c0    	lea    0xc010017d,%ecx
c010017b:	ff e1                	jmp    *%ecx
c010017d:	c7 05 00 e0 1c c0 00 	movl   $0x0,0xc01ce000
c0100184:	00 00 00 
c0100187:	0f 20 d9             	mov    %cr3,%ecx
c010018a:	0f 22 d9             	mov    %ecx,%cr3
c010018d:	bc 58 8d 3e c0       	mov    $0xc03e8d58,%esp
c0100192:	81 c3 00 00 00 c0    	add    $0xc0000000,%ebx
c0100198:	53                   	push   %ebx
c0100199:	e8 f5 00 00 00       	call   c0100293 <kmain>

c010019e <loop>:
c010019e:	eb fe                	jmp    c010019e <loop>

c01001a0 <read_initrd>:
long initrd_sz;
char* initrd;
typedef int (*func_ptr)();
static struct multiboot_boot_header_tag* tags;

static void read_initrd(struct multiboot_boot_header_tag* tags) {
c01001a0:	55                   	push   %ebp
c01001a1:	89 e5                	mov    %esp,%ebp
c01001a3:	83 ec 18             	sub    $0x18,%esp
  struct multiboot_tag* tag=(struct multiboot_tag*)(tags+1);
c01001a6:	8b 45 08             	mov    0x8(%ebp),%eax
c01001a9:	83 c0 08             	add    $0x8,%eax
c01001ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (tag->type!=0) {
c01001af:	e9 85 00 00 00       	jmp    c0100239 <read_initrd+0x99>
    switch (tag->type) {
c01001b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01001b7:	8b 00                	mov    (%eax),%eax
c01001b9:	83 f8 03             	cmp    $0x3,%eax
c01001bc:	75 6c                	jne    c010022a <read_initrd+0x8a>
      case MULTIBOOT_TAG_TYPE_MODULE: {
        struct multiboot_tag_module* mod=(struct multiboot_tag_module*) tag;
c01001be:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01001c1:	89 45 f0             	mov    %eax,-0x10(%ebp)
        initrd=malloc(sizeof(char)*(mod->mod_end-mod->mod_start));
c01001c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01001c7:	8b 50 0c             	mov    0xc(%eax),%edx
c01001ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01001cd:	8b 40 08             	mov    0x8(%eax),%eax
c01001d0:	29 c2                	sub    %eax,%edx
c01001d2:	89 d0                	mov    %edx,%eax
c01001d4:	83 ec 0c             	sub    $0xc,%esp
c01001d7:	50                   	push   %eax
c01001d8:	e8 97 42 00 00       	call   c0104474 <malloc>
c01001dd:	83 c4 10             	add    $0x10,%esp
c01001e0:	a3 04 90 10 c0       	mov    %eax,0xc0109004
        initrd_sz=mod->mod_end-mod->mod_start;
c01001e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01001e8:	8b 50 0c             	mov    0xc(%eax),%edx
c01001eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01001ee:	8b 40 08             	mov    0x8(%eax),%eax
c01001f1:	29 c2                	sub    %eax,%edx
c01001f3:	89 d0                	mov    %edx,%eax
c01001f5:	a3 00 90 10 c0       	mov    %eax,0xc0109000
        memcpy(initrd,(void*)(mod->mod_start+0xC0000000),mod->mod_end-mod->mod_start);
c01001fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01001fd:	8b 50 0c             	mov    0xc(%eax),%edx
c0100200:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0100203:	8b 40 08             	mov    0x8(%eax),%eax
c0100206:	89 d1                	mov    %edx,%ecx
c0100208:	29 c1                	sub    %eax,%ecx
c010020a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010020d:	8b 40 08             	mov    0x8(%eax),%eax
c0100210:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0100215:	89 c2                	mov    %eax,%edx
c0100217:	a1 04 90 10 c0       	mov    0xc0109004,%eax
c010021c:	83 ec 04             	sub    $0x4,%esp
c010021f:	51                   	push   %ecx
c0100220:	52                   	push   %edx
c0100221:	50                   	push   %eax
c0100222:	e8 a1 4f 00 00       	call   c01051c8 <memcpy>
c0100227:	83 c4 10             	add    $0x10,%esp
      }
    }
    tag=(struct multiboot_tag*)((char*)tag+((tag->size+7)&0xFFFFFFF8));
c010022a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010022d:	8b 40 04             	mov    0x4(%eax),%eax
c0100230:	83 c0 07             	add    $0x7,%eax
c0100233:	83 e0 f8             	and    $0xfffffff8,%eax
c0100236:	01 45 f4             	add    %eax,-0xc(%ebp)
  while (tag->type!=0) {
c0100239:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010023c:	8b 00                	mov    (%eax),%eax
c010023e:	85 c0                	test   %eax,%eax
c0100240:	0f 85 6e ff ff ff    	jne    c01001b4 <read_initrd+0x14>
  }
}
c0100246:	90                   	nop
c0100247:	90                   	nop
c0100248:	c9                   	leave  
c0100249:	c3                   	ret    

c010024a <getsize>:

size_t getsize(const char *in) {
c010024a:	55                   	push   %ebp
c010024b:	89 e5                	mov    %esp,%ebp
c010024d:	83 ec 10             	sub    $0x10,%esp
    size_t size=0;
c0100250:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    size_t j;
    size_t count=1;
c0100257:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    for (j=11;j>0;j--,count*=8) {
c010025e:	c7 45 f8 0b 00 00 00 	movl   $0xb,-0x8(%ebp)
c0100265:	eb 21                	jmp    c0100288 <getsize+0x3e>
        size+=((in[j-1]-'0')*count);
c0100267:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010026a:	8d 50 ff             	lea    -0x1(%eax),%edx
c010026d:	8b 45 08             	mov    0x8(%ebp),%eax
c0100270:	01 d0                	add    %edx,%eax
c0100272:	8a 00                	mov    (%eax),%al
c0100274:	0f be c0             	movsbl %al,%eax
c0100277:	83 e8 30             	sub    $0x30,%eax
c010027a:	0f af 45 f4          	imul   -0xc(%ebp),%eax
c010027e:	01 45 fc             	add    %eax,-0x4(%ebp)
    for (j=11;j>0;j--,count*=8) {
c0100281:	ff 4d f8             	decl   -0x8(%ebp)
c0100284:	c1 65 f4 03          	shll   $0x3,-0xc(%ebp)
c0100288:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c010028c:	75 d9                	jne    c0100267 <getsize+0x1d>
    }
    return size;
c010028e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0100291:	c9                   	leave  
c0100292:	c3                   	ret    

c0100293 <kmain>:

void kmain(struct multiboot_boot_header_tag* hdr) {
c0100293:	55                   	push   %ebp
c0100294:	89 e5                	mov    %esp,%ebp
c0100296:	81 ec 98 00 00 00    	sub    $0x98,%esp
  tags=hdr;
c010029c:	8b 45 08             	mov    0x8(%ebp),%eax
c010029f:	a3 00 10 1d c0       	mov    %eax,0xc01d1000
  cpu_init();
c01002a4:	e8 38 1d 00 00       	call   c0101fe1 <cpu_init>
  serial_init();
c01002a9:	e8 b9 35 00 00       	call   c0103867 <serial_init>
  pmem_init(tags);
c01002ae:	a1 00 10 1d c0       	mov    0xc01d1000,%eax
c01002b3:	83 ec 0c             	sub    $0xc,%esp
c01002b6:	50                   	push   %eax
c01002b7:	e8 1e 06 00 00       	call   c01008da <pmem_init>
c01002bc:	83 c4 10             	add    $0x10,%esp
  paging_init();
c01002bf:	e8 1e 32 00 00       	call   c01034e2 <paging_init>
  isr_install();
c01002c4:	e8 15 20 00 00       	call   c01022de <isr_install>
  asm volatile("sti");
c01002c9:	fb                   	sti    
  tasking_init();
c01002ca:	e8 59 12 00 00       	call   c0101528 <tasking_init>
  vga_init((char*)0xC00B8000);
c01002cf:	83 ec 0c             	sub    $0xc,%esp
c01002d2:	68 00 80 0b c0       	push   $0xc00b8000
c01002d7:	e8 96 1c 00 00       	call   c0101f72 <vga_init>
c01002dc:	83 c4 10             	add    $0x10,%esp
  timer_init(100);
c01002df:	83 ec 0c             	sub    $0xc,%esp
c01002e2:	6a 64                	push   $0x64
c01002e4:	e8 af 3c 00 00       	call   c0103f98 <timer_init>
c01002e9:	83 c4 10             	add    $0x10,%esp
  read_initrd(tags);
c01002ec:	a1 00 10 1d c0       	mov    0xc01d1000,%eax
c01002f1:	83 ec 0c             	sub    $0xc,%esp
c01002f4:	50                   	push   %eax
c01002f5:	e8 a6 fe ff ff       	call   c01001a0 <read_initrd>
c01002fa:	83 c4 10             	add    $0x10,%esp
  int pos=0;
c01002fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t datapos;
  tar_header* tar_hdr;
  for (int i=0;;i++) {
c0100304:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    tar_hdr=(tar_header*)&initrd[pos];
c010030b:	8b 15 04 90 10 c0    	mov    0xc0109004,%edx
c0100311:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100314:	01 d0                	add    %edx,%eax
c0100316:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (tar_hdr->filename[0]=='\0') break;
c0100319:	8b 45 d0             	mov    -0x30(%ebp),%eax
c010031c:	8a 00                	mov    (%eax),%al
c010031e:	84 c0                	test   %al,%al
c0100320:	74 7a                	je     c010039c <kmain+0x109>
    size_t size=getsize(tar_hdr->size);
c0100322:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0100325:	83 c0 7c             	add    $0x7c,%eax
c0100328:	83 ec 0c             	sub    $0xc,%esp
c010032b:	50                   	push   %eax
c010032c:	e8 19 ff ff ff       	call   c010024a <getsize>
c0100331:	83 c4 10             	add    $0x10,%esp
c0100334:	89 45 cc             	mov    %eax,-0x34(%ebp)
    pos+=512;
c0100337:	81 45 f4 00 02 00 00 	addl   $0x200,-0xc(%ebp)
    if (strcmp(&tar_hdr->filename[0],"init")==0) {
c010033e:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0100341:	83 ec 08             	sub    $0x8,%esp
c0100344:	68 00 60 10 c0       	push   $0xc0106000
c0100349:	50                   	push   %eax
c010034a:	e8 ea 4e 00 00       	call   c0105239 <strcmp>
c010034f:	83 c4 10             	add    $0x10,%esp
c0100352:	85 c0                	test   %eax,%eax
c0100354:	75 08                	jne    c010035e <kmain+0xcb>
      datapos=pos;
c0100356:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100359:	89 45 f0             	mov    %eax,-0x10(%ebp)
      break;
c010035c:	eb 3f                	jmp    c010039d <kmain+0x10a>
    }
    pos+=size;
c010035e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0100361:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0100364:	01 d0                	add    %edx,%eax
c0100366:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (pos%512!=0) {
c0100369:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010036c:	25 ff 01 00 00       	and    $0x1ff,%eax
c0100371:	85 c0                	test   %eax,%eax
c0100373:	74 1f                	je     c0100394 <kmain+0x101>
      pos+=512-(pos%512);
c0100375:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100378:	25 ff 01 00 80       	and    $0x800001ff,%eax
c010037d:	85 c0                	test   %eax,%eax
c010037f:	79 07                	jns    c0100388 <kmain+0xf5>
c0100381:	48                   	dec    %eax
c0100382:	0d 00 fe ff ff       	or     $0xfffffe00,%eax
c0100387:	40                   	inc    %eax
c0100388:	ba 00 02 00 00       	mov    $0x200,%edx
c010038d:	29 c2                	sub    %eax,%edx
c010038f:	89 d0                	mov    %edx,%eax
c0100391:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (int i=0;;i++) {
c0100394:	ff 45 ec             	incl   -0x14(%ebp)
c0100397:	e9 6f ff ff ff       	jmp    c010030b <kmain+0x78>
    if (tar_hdr->filename[0]=='\0') break;
c010039c:	90                   	nop
    }
  }
  elf_header header;
  pos=datapos;
c010039d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01003a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char* hdr_ptr=(char*)&header;
c01003a3:	8d 45 88             	lea    -0x78(%ebp),%eax
c01003a6:	89 45 c8             	mov    %eax,-0x38(%ebp)
  for (size_t i=0;i<sizeof(elf_header);i++) {
c01003a9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c01003b0:	eb 1d                	jmp    c01003cf <kmain+0x13c>
    hdr_ptr[i]=initrd[pos];
c01003b2:	8b 15 04 90 10 c0    	mov    0xc0109004,%edx
c01003b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01003bb:	01 d0                	add    %edx,%eax
c01003bd:	8b 4d c8             	mov    -0x38(%ebp),%ecx
c01003c0:	8b 55 e8             	mov    -0x18(%ebp),%edx
c01003c3:	01 ca                	add    %ecx,%edx
c01003c5:	8a 00                	mov    (%eax),%al
c01003c7:	88 02                	mov    %al,(%edx)
    pos++;
c01003c9:	ff 45 f4             	incl   -0xc(%ebp)
  for (size_t i=0;i<sizeof(elf_header);i++) {
c01003cc:	ff 45 e8             	incl   -0x18(%ebp)
c01003cf:	83 7d e8 33          	cmpl   $0x33,-0x18(%ebp)
c01003d3:	76 dd                	jbe    c01003b2 <kmain+0x11f>
  }
  if (header.magic!=ELF_MAGIC) {
c01003d5:	8b 45 88             	mov    -0x78(%ebp),%eax
c01003d8:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
c01003dd:	74 15                	je     c01003f4 <kmain+0x161>
    vga_write_string("[INFO] Invalid magic number for prog.elf\n");
c01003df:	83 ec 0c             	sub    $0xc,%esp
c01003e2:	68 08 60 10 c0       	push   $0xc0106008
c01003e7:	e8 94 1b 00 00       	call   c0101f80 <vga_write_string>
c01003ec:	83 c4 10             	add    $0x10,%esp
      yield();
    }
    for (;;);
    exit(0);
  }
}
c01003ef:	e9 5c 01 00 00       	jmp    c0100550 <kmain+0x2bd>
    void* address_space=new_address_space();
c01003f4:	e8 14 4c 00 00       	call   c010500d <new_address_space>
c01003f9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    for (int i=0;i<header.pheader_ent_nm;i++) {
c01003fc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0100403:	e9 e7 00 00 00       	jmp    c01004ef <kmain+0x25c>
      pos=(header.prog_hdr)+(header.pheader_ent_sz*i)+datapos;
c0100408:	8b 55 a4             	mov    -0x5c(%ebp),%edx
c010040b:	66 8b 45 b2          	mov    -0x4e(%ebp),%ax
c010040f:	0f b7 c0             	movzwl %ax,%eax
c0100412:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
c0100416:	01 c2                	add    %eax,%edx
c0100418:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010041b:	01 d0                	add    %edx,%eax
c010041d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char* phdr_ptr=(char*)&pheader;
c0100420:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
c0100426:	89 45 c0             	mov    %eax,-0x40(%ebp)
      for (size_t i=0;i<sizeof(elf_pheader);i++) {
c0100429:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c0100430:	eb 1d                	jmp    c010044f <kmain+0x1bc>
        phdr_ptr[i]=initrd[pos];
c0100432:	8b 15 04 90 10 c0    	mov    0xc0109004,%edx
c0100438:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010043b:	01 d0                	add    %edx,%eax
c010043d:	8b 4d c0             	mov    -0x40(%ebp),%ecx
c0100440:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0100443:	01 ca                	add    %ecx,%edx
c0100445:	8a 00                	mov    (%eax),%al
c0100447:	88 02                	mov    %al,(%edx)
        pos++;
c0100449:	ff 45 f4             	incl   -0xc(%ebp)
      for (size_t i=0;i<sizeof(elf_pheader);i++) {
c010044c:	ff 45 e0             	incl   -0x20(%ebp)
c010044f:	83 7d e0 1f          	cmpl   $0x1f,-0x20(%ebp)
c0100453:	76 dd                	jbe    c0100432 <kmain+0x19f>
      char* ptr=alloc_memory(((pheader.memsz)/4096)+1);
c0100455:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c010045b:	c1 e8 0c             	shr    $0xc,%eax
c010045e:	40                   	inc    %eax
c010045f:	83 ec 0c             	sub    $0xc,%esp
c0100462:	50                   	push   %eax
c0100463:	e8 64 4b 00 00       	call   c0104fcc <alloc_memory>
c0100468:	83 c4 10             	add    $0x10,%esp
c010046b:	89 45 bc             	mov    %eax,-0x44(%ebp)
      memset(ptr,0,pheader.memsz);
c010046e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c0100474:	83 ec 04             	sub    $0x4,%esp
c0100477:	50                   	push   %eax
c0100478:	6a 00                	push   $0x0
c010047a:	ff 75 bc             	pushl  -0x44(%ebp)
c010047d:	e8 85 4d 00 00       	call   c0105207 <memset>
c0100482:	83 c4 10             	add    $0x10,%esp
      if (pheader.filesz>0) {
c0100485:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
c010048b:	85 c0                	test   %eax,%eax
c010048d:	74 3f                	je     c01004ce <kmain+0x23b>
        pos=pheader.offset+datapos;
c010048f:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
c0100495:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0100498:	01 d0                	add    %edx,%eax
c010049a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for (size_t i=0;i<pheader.filesz;i++) {
c010049d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c01004a4:	eb 1d                	jmp    c01004c3 <kmain+0x230>
          ptr[i]=initrd[pos];
c01004a6:	8b 15 04 90 10 c0    	mov    0xc0109004,%edx
c01004ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01004af:	01 d0                	add    %edx,%eax
c01004b1:	8b 4d bc             	mov    -0x44(%ebp),%ecx
c01004b4:	8b 55 dc             	mov    -0x24(%ebp),%edx
c01004b7:	01 ca                	add    %ecx,%edx
c01004b9:	8a 00                	mov    (%eax),%al
c01004bb:	88 02                	mov    %al,(%edx)
          pos++;
c01004bd:	ff 45 f4             	incl   -0xc(%ebp)
        for (size_t i=0;i<pheader.filesz;i++) {
c01004c0:	ff 45 dc             	incl   -0x24(%ebp)
c01004c3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
c01004c9:	39 45 dc             	cmp    %eax,-0x24(%ebp)
c01004cc:	72 d8                	jb     c01004a6 <kmain+0x213>
      copy_data(address_space,ptr,pheader.memsz,(void*)pheader.vaddr);
c01004ce:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
c01004d4:	89 c2                	mov    %eax,%edx
c01004d6:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c01004dc:	52                   	push   %edx
c01004dd:	50                   	push   %eax
c01004de:	ff 75 bc             	pushl  -0x44(%ebp)
c01004e1:	ff 75 c4             	pushl  -0x3c(%ebp)
c01004e4:	e8 40 4b 00 00       	call   c0105029 <copy_data>
c01004e9:	83 c4 10             	add    $0x10,%esp
    for (int i=0;i<header.pheader_ent_nm;i++) {
c01004ec:	ff 45 e4             	incl   -0x1c(%ebp)
c01004ef:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c01004f2:	0f b7 c0             	movzwl %ax,%eax
c01004f5:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c01004f8:	0f 8c 0a ff ff ff    	jl     c0100408 <kmain+0x175>
     create_proc((void*)header.entry,address_space,NULL,NULL);
c01004fe:	8b 45 a0             	mov    -0x60(%ebp),%eax
c0100501:	6a 00                	push   $0x0
c0100503:	6a 00                	push   $0x0
c0100505:	ff 75 c4             	pushl  -0x3c(%ebp)
c0100508:	50                   	push   %eax
c0100509:	e8 7c 51 00 00       	call   c010568a <create_proc>
c010050e:	83 c4 10             	add    $0x10,%esp
    for (int i=0;i<4;i++) {
c0100511:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c0100518:	eb 08                	jmp    c0100522 <kmain+0x28f>
      yield();
c010051a:	e8 55 51 00 00       	call   c0105674 <yield>
    for (int i=0;i<4;i++) {
c010051f:	ff 45 d8             	incl   -0x28(%ebp)
c0100522:	83 7d d8 03          	cmpl   $0x3,-0x28(%ebp)
c0100526:	7e f2                	jle    c010051a <kmain+0x287>
    unblock_thread(1,0);
c0100528:	83 ec 08             	sub    $0x8,%esp
c010052b:	6a 00                	push   $0x0
c010052d:	6a 01                	push   $0x1
c010052f:	e8 a2 51 00 00       	call   c01056d6 <unblock_thread>
c0100534:	83 c4 10             	add    $0x10,%esp
    for (int i=0;i<4;i++) {
c0100537:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c010053e:	eb 08                	jmp    c0100548 <kmain+0x2b5>
      yield();
c0100540:	e8 2f 51 00 00       	call   c0105674 <yield>
    for (int i=0;i<4;i++) {
c0100545:	ff 45 d4             	incl   -0x2c(%ebp)
c0100548:	83 7d d4 03          	cmpl   $0x3,-0x2c(%ebp)
c010054c:	7e f2                	jle    c0100540 <kmain+0x2ad>
    for (;;);
c010054e:	eb fe                	jmp    c010054e <kmain+0x2bb>
}
c0100550:	c9                   	leave  
c0100551:	c3                   	ret    

c0100552 <get_bmap_bit>:
/**
 * Get a bit in the heap bitmap
 * \param index The bit to get
 * \return the bit
*/
static char get_bmap_bit(size_t index) {
c0100552:	55                   	push   %ebp
c0100553:	89 e5                	mov    %esp,%ebp
c0100555:	53                   	push   %ebx
c0100556:	83 ec 10             	sub    $0x10,%esp
  size_t byte=index/8;
c0100559:	8b 45 08             	mov    0x8(%ebp),%eax
c010055c:	c1 e8 03             	shr    $0x3,%eax
c010055f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=index%8;
c0100562:	8b 45 08             	mov    0x8(%ebp),%eax
c0100565:	83 e0 07             	and    $0x7,%eax
c0100568:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char entry=bitmap[byte];
c010056b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010056e:	05 20 10 1d c0       	add    $0xc01d1020,%eax
c0100573:	8a 00                	mov    (%eax),%al
c0100575:	88 45 f3             	mov    %al,-0xd(%ebp)
  return (entry&(1<<bit))>0;
c0100578:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
c010057c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010057f:	bb 01 00 00 00       	mov    $0x1,%ebx
c0100584:	88 c1                	mov    %al,%cl
c0100586:	d3 e3                	shl    %cl,%ebx
c0100588:	89 d8                	mov    %ebx,%eax
c010058a:	21 d0                	and    %edx,%eax
c010058c:	85 c0                	test   %eax,%eax
c010058e:	0f 9f c0             	setg   %al
}
c0100591:	83 c4 10             	add    $0x10,%esp
c0100594:	5b                   	pop    %ebx
c0100595:	5d                   	pop    %ebp
c0100596:	c3                   	ret    

c0100597 <set_bmap_bit>:

/**
 * Set a bit in the heap bitmap
 * \param index The bit to set
*/
static void set_bmap_bit(size_t index) {
c0100597:	55                   	push   %ebp
c0100598:	89 e5                	mov    %esp,%ebp
c010059a:	53                   	push   %ebx
c010059b:	83 ec 10             	sub    $0x10,%esp
  size_t byte=index/8;
c010059e:	8b 45 08             	mov    0x8(%ebp),%eax
c01005a1:	c1 e8 03             	shr    $0x3,%eax
c01005a4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=index%8;
c01005a7:	8b 45 08             	mov    0x8(%ebp),%eax
c01005aa:	83 e0 07             	and    $0x7,%eax
c01005ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
  bitmap[byte]=bitmap[byte]|(1<<bit);
c01005b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01005b3:	05 20 10 1d c0       	add    $0xc01d1020,%eax
c01005b8:	8a 10                	mov    (%eax),%dl
c01005ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01005bd:	bb 01 00 00 00       	mov    $0x1,%ebx
c01005c2:	88 c1                	mov    %al,%cl
c01005c4:	d3 e3                	shl    %cl,%ebx
c01005c6:	89 d8                	mov    %ebx,%eax
c01005c8:	09 c2                	or     %eax,%edx
c01005ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01005cd:	05 20 10 1d c0       	add    $0xc01d1020,%eax
c01005d2:	88 10                	mov    %dl,(%eax)
}
c01005d4:	90                   	nop
c01005d5:	83 c4 10             	add    $0x10,%esp
c01005d8:	5b                   	pop    %ebx
c01005d9:	5d                   	pop    %ebp
c01005da:	c3                   	ret    

c01005db <clear_bmap_bit>:

/**
 * Clear a bit in the heap bitmap
 * \param index The bit to clear
*/
static void clear_bmap_bit(size_t index) {
c01005db:	55                   	push   %ebp
c01005dc:	89 e5                	mov    %esp,%ebp
c01005de:	53                   	push   %ebx
c01005df:	83 ec 10             	sub    $0x10,%esp
  size_t byte=index/8;
c01005e2:	8b 45 08             	mov    0x8(%ebp),%eax
c01005e5:	c1 e8 03             	shr    $0x3,%eax
c01005e8:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=index%8;
c01005eb:	8b 45 08             	mov    0x8(%ebp),%eax
c01005ee:	83 e0 07             	and    $0x7,%eax
c01005f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  bitmap[byte]=bitmap[byte]&(~(1<<bit));
c01005f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01005f7:	05 20 10 1d c0       	add    $0xc01d1020,%eax
c01005fc:	8a 10                	mov    (%eax),%dl
c01005fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100601:	bb 01 00 00 00       	mov    $0x1,%ebx
c0100606:	88 c1                	mov    %al,%cl
c0100608:	d3 e3                	shl    %cl,%ebx
c010060a:	89 d8                	mov    %ebx,%eax
c010060c:	f7 d0                	not    %eax
c010060e:	21 c2                	and    %eax,%edx
c0100610:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0100613:	05 20 10 1d c0       	add    $0xc01d1020,%eax
c0100618:	88 10                	mov    %dl,(%eax)
}
c010061a:	90                   	nop
c010061b:	83 c4 10             	add    $0x10,%esp
c010061e:	5b                   	pop    %ebx
c010061f:	5d                   	pop    %ebp
c0100620:	c3                   	ret    

c0100621 <kmalloc>:

void* kmalloc(size_t size) {
c0100621:	55                   	push   %ebp
c0100622:	89 e5                	mov    %esp,%ebp
c0100624:	83 ec 48             	sub    $0x48,%esp
  size_t num_4b_grps=(size_t)ceilf((float)size/4);
c0100627:	8b 45 08             	mov    0x8(%ebp),%eax
c010062a:	ba 00 00 00 00       	mov    $0x0,%edx
c010062f:	89 45 b8             	mov    %eax,-0x48(%ebp)
c0100632:	89 55 bc             	mov    %edx,-0x44(%ebp)
c0100635:	df 6d b8             	fildll -0x48(%ebp)
c0100638:	d9 05 44 60 10 c0    	flds   0xc0106044
c010063e:	de f9                	fdivrp %st,%st(1)
c0100640:	83 ec 0c             	sub    $0xc,%esp
c0100643:	8d 64 24 fc          	lea    -0x4(%esp),%esp
c0100647:	d9 1c 24             	fstps  (%esp)
c010064a:	e8 eb 48 00 00       	call   c0104f3a <ceilf>
c010064f:	83 c4 10             	add    $0x10,%esp
c0100652:	d9 7d c6             	fnstcw -0x3a(%ebp)
c0100655:	66 8b 45 c6          	mov    -0x3a(%ebp),%ax
c0100659:	80 cc 0c             	or     $0xc,%ah
c010065c:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
c0100660:	d9 6d c4             	fldcw  -0x3c(%ebp)
c0100663:	df 7d b8             	fistpll -0x48(%ebp)
c0100666:	d9 6d c6             	fldcw  -0x3a(%ebp)
c0100669:	8b 45 b8             	mov    -0x48(%ebp),%eax
c010066c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  num_4b_grps+=2;
c010066f:	83 45 d8 02          	addl   $0x2,-0x28(%ebp)
  size_t bmap_index;
  size_t remaining_blks;
  for(size_t i=0;i<KMALLOC_BMAP_SZ;i++) {
c0100673:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c010067a:	e9 80 00 00 00       	jmp    c01006ff <kmalloc+0xde>
    char got_0=0;
c010067f:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
    remaining_blks=num_4b_grps;
c0100683:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0100686:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t old_j;
    for (size_t j=i*8;;j++) {
c0100689:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010068c:	c1 e0 03             	shl    $0x3,%eax
c010068f:	89 45 e0             	mov    %eax,-0x20(%ebp)
      char bit=get_bmap_bit(j);
c0100692:	83 ec 0c             	sub    $0xc,%esp
c0100695:	ff 75 e0             	pushl  -0x20(%ebp)
c0100698:	e8 b5 fe ff ff       	call   c0100552 <get_bmap_bit>
c010069d:	83 c4 10             	add    $0x10,%esp
c01006a0:	88 45 d7             	mov    %al,-0x29(%ebp)
      if (got_0) {
c01006a3:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
c01006a7:	74 27                	je     c01006d0 <kmalloc+0xaf>
        if (bit) {
c01006a9:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c01006ad:	74 1c                	je     c01006cb <kmalloc+0xaa>
          if (remaining_blks==0) {
c01006af:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01006b3:	75 08                	jne    c01006bd <kmalloc+0x9c>
              bmap_index=old_j;
c01006b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01006b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
              break;
c01006bb:	eb 39                	jmp    c01006f6 <kmalloc+0xd5>
          } else {
            i+=j/8;
c01006bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01006c0:	c1 e8 03             	shr    $0x3,%eax
c01006c3:	01 45 ec             	add    %eax,-0x14(%ebp)
            i--;
c01006c6:	ff 4d ec             	decl   -0x14(%ebp)
            break;
c01006c9:	eb 2b                	jmp    c01006f6 <kmalloc+0xd5>
          }
        } else {
          remaining_blks--;
c01006cb:	ff 4d f0             	decl   -0x10(%ebp)
c01006ce:	eb 13                	jmp    c01006e3 <kmalloc+0xc2>
        }
      } else {
        if (!bit) {
c01006d0:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
c01006d4:	75 0d                	jne    c01006e3 <kmalloc+0xc2>
          got_0=1;
c01006d6:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
          old_j=j;
c01006da:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01006dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          remaining_blks--;
c01006e0:	ff 4d f0             	decl   -0x10(%ebp)
        }
      }
      if (remaining_blks==0) {
c01006e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01006e7:	75 08                	jne    c01006f1 <kmalloc+0xd0>
        bmap_index=old_j;
c01006e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01006ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
        break;
c01006ef:	eb 05                	jmp    c01006f6 <kmalloc+0xd5>
    for (size_t j=i*8;;j++) {
c01006f1:	ff 45 e0             	incl   -0x20(%ebp)
c01006f4:	eb 9c                	jmp    c0100692 <kmalloc+0x71>
      }
    }
    if (remaining_blks==0) {
c01006f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01006fa:	74 12                	je     c010070e <kmalloc+0xed>
  for(size_t i=0;i<KMALLOC_BMAP_SZ;i++) {
c01006fc:	ff 45 ec             	incl   -0x14(%ebp)
c01006ff:	81 7d ec ff ff 07 00 	cmpl   $0x7ffff,-0x14(%ebp)
c0100706:	0f 86 73 ff ff ff    	jbe    c010067f <kmalloc+0x5e>
c010070c:	eb 01                	jmp    c010070f <kmalloc+0xee>
      break;
c010070e:	90                   	nop
    }
  }
  if (remaining_blks!=0) {
c010070f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0100713:	74 15                	je     c010072a <kmalloc+0x109>
    serial_printf("Kmalloc fail!\n");
c0100715:	83 ec 0c             	sub    $0xc,%esp
c0100718:	68 34 60 10 c0       	push   $0xc0106034
c010071d:	e8 33 37 00 00       	call   c0103e55 <serial_printf>
c0100722:	83 c4 10             	add    $0x10,%esp
    halt();
c0100725:	e8 36 39 00 00       	call   c0104060 <halt>
    return NULL;
  }
  for (size_t i=0;i<num_4b_grps;i++) {
c010072a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c0100731:	eb 17                	jmp    c010074a <kmalloc+0x129>
    set_bmap_bit(bmap_index+i);
c0100733:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0100736:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0100739:	01 d0                	add    %edx,%eax
c010073b:	83 ec 0c             	sub    $0xc,%esp
c010073e:	50                   	push   %eax
c010073f:	e8 53 fe ff ff       	call   c0100597 <set_bmap_bit>
c0100744:	83 c4 10             	add    $0x10,%esp
  for (size_t i=0;i<num_4b_grps;i++) {
c0100747:	ff 45 dc             	incl   -0x24(%ebp)
c010074a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010074d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0100750:	72 e1                	jb     c0100733 <kmalloc+0x112>
  }
  size_t data_offset=(bmap_index*8)+8;
c0100752:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100755:	40                   	inc    %eax
c0100756:	c1 e0 03             	shl    $0x3,%eax
c0100759:	89 45 d0             	mov    %eax,-0x30(%ebp)
  size_t* info=(void*)(((char*)data)+data_offset-8);
c010075c:	a1 00 80 10 c0       	mov    0xc0108000,%eax
c0100761:	8b 55 d0             	mov    -0x30(%ebp),%edx
c0100764:	83 ea 08             	sub    $0x8,%edx
c0100767:	01 d0                	add    %edx,%eax
c0100769:	89 45 cc             	mov    %eax,-0x34(%ebp)
  info[0]=num_4b_grps;
c010076c:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010076f:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0100772:	89 10                	mov    %edx,(%eax)
  info[1]=bmap_index;
c0100774:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0100777:	8d 50 04             	lea    0x4(%eax),%edx
c010077a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010077d:	89 02                	mov    %eax,(%edx)
  return (void*)(((char*)data)+data_offset);
c010077f:	8b 15 00 80 10 c0    	mov    0xc0108000,%edx
c0100785:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0100788:	01 d0                	add    %edx,%eax

}
c010078a:	c9                   	leave  
c010078b:	c3                   	ret    

c010078c <kfree>:

void kfree(void* mem) {
c010078c:	55                   	push   %ebp
c010078d:	89 e5                	mov    %esp,%ebp
c010078f:	83 ec 10             	sub    $0x10,%esp
  size_t* info=(size_t*)((size_t)mem-8);
c0100792:	8b 45 08             	mov    0x8(%ebp),%eax
c0100795:	83 e8 08             	sub    $0x8,%eax
c0100798:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t num_4b_grps=info[0];
c010079b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010079e:	8b 00                	mov    (%eax),%eax
c01007a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t bmap_index=info[1];
c01007a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01007a6:	8b 40 04             	mov    0x4(%eax),%eax
c01007a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (size_t i=0;i<num_4b_grps;i++) {
c01007ac:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01007b3:	eb 14                	jmp    c01007c9 <kfree+0x3d>
    clear_bmap_bit(bmap_index+i);
c01007b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01007b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01007bb:	01 d0                	add    %edx,%eax
c01007bd:	50                   	push   %eax
c01007be:	e8 18 fe ff ff       	call   c01005db <clear_bmap_bit>
c01007c3:	83 c4 04             	add    $0x4,%esp
  for (size_t i=0;i<num_4b_grps;i++) {
c01007c6:	ff 45 fc             	incl   -0x4(%ebp)
c01007c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01007cc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c01007cf:	72 e4                	jb     c01007b5 <kfree+0x29>
  }
}
c01007d1:	90                   	nop
c01007d2:	90                   	nop
c01007d3:	c9                   	leave  
c01007d4:	c3                   	ret    

c01007d5 <get_bmap_bit>:
/**
 * Get a bit in the bitmap
 * \param index The bit to get
 * \return the bit
*/
static char get_bmap_bit(int index) {
c01007d5:	55                   	push   %ebp
c01007d6:	89 e5                	mov    %esp,%ebp
c01007d8:	53                   	push   %ebx
c01007d9:	83 ec 10             	sub    $0x10,%esp
  int byte=index/8;
c01007dc:	8b 45 08             	mov    0x8(%ebp),%eax
c01007df:	85 c0                	test   %eax,%eax
c01007e1:	79 03                	jns    c01007e6 <get_bmap_bit+0x11>
c01007e3:	83 c0 07             	add    $0x7,%eax
c01007e6:	c1 f8 03             	sar    $0x3,%eax
c01007e9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  int bit=index%8;
c01007ec:	8b 45 08             	mov    0x8(%ebp),%eax
c01007ef:	25 07 00 00 80       	and    $0x80000007,%eax
c01007f4:	85 c0                	test   %eax,%eax
c01007f6:	79 05                	jns    c01007fd <get_bmap_bit+0x28>
c01007f8:	48                   	dec    %eax
c01007f9:	83 c8 f8             	or     $0xfffffff8,%eax
c01007fc:	40                   	inc    %eax
c01007fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char entry=bmap[byte];
c0100800:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0100803:	05 20 10 25 c0       	add    $0xc0251020,%eax
c0100808:	8a 00                	mov    (%eax),%al
c010080a:	88 45 f3             	mov    %al,-0xd(%ebp)
  return (entry&(1<<bit))>0;
c010080d:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
c0100811:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100814:	bb 01 00 00 00       	mov    $0x1,%ebx
c0100819:	88 c1                	mov    %al,%cl
c010081b:	d3 e3                	shl    %cl,%ebx
c010081d:	89 d8                	mov    %ebx,%eax
c010081f:	21 d0                	and    %edx,%eax
c0100821:	85 c0                	test   %eax,%eax
c0100823:	0f 9f c0             	setg   %al
}
c0100826:	83 c4 10             	add    $0x10,%esp
c0100829:	5b                   	pop    %ebx
c010082a:	5d                   	pop    %ebp
c010082b:	c3                   	ret    

c010082c <set_bmap_bit>:

/**
 * Set a bit in the heap bitmap
 * \param index The bit to set
*/
static void set_bmap_bit(int index) {
c010082c:	55                   	push   %ebp
c010082d:	89 e5                	mov    %esp,%ebp
c010082f:	53                   	push   %ebx
c0100830:	83 ec 10             	sub    $0x10,%esp
  int byte=index/8;
c0100833:	8b 45 08             	mov    0x8(%ebp),%eax
c0100836:	85 c0                	test   %eax,%eax
c0100838:	79 03                	jns    c010083d <set_bmap_bit+0x11>
c010083a:	83 c0 07             	add    $0x7,%eax
c010083d:	c1 f8 03             	sar    $0x3,%eax
c0100840:	89 45 f8             	mov    %eax,-0x8(%ebp)
  int bit=index%8;
c0100843:	8b 45 08             	mov    0x8(%ebp),%eax
c0100846:	25 07 00 00 80       	and    $0x80000007,%eax
c010084b:	85 c0                	test   %eax,%eax
c010084d:	79 05                	jns    c0100854 <set_bmap_bit+0x28>
c010084f:	48                   	dec    %eax
c0100850:	83 c8 f8             	or     $0xfffffff8,%eax
c0100853:	40                   	inc    %eax
c0100854:	89 45 f4             	mov    %eax,-0xc(%ebp)
  bmap[byte]=bmap[byte]|(1<<bit);
c0100857:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010085a:	05 20 10 25 c0       	add    $0xc0251020,%eax
c010085f:	8a 10                	mov    (%eax),%dl
c0100861:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100864:	bb 01 00 00 00       	mov    $0x1,%ebx
c0100869:	88 c1                	mov    %al,%cl
c010086b:	d3 e3                	shl    %cl,%ebx
c010086d:	89 d8                	mov    %ebx,%eax
c010086f:	09 c2                	or     %eax,%edx
c0100871:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0100874:	05 20 10 25 c0       	add    $0xc0251020,%eax
c0100879:	88 10                	mov    %dl,(%eax)
}
c010087b:	90                   	nop
c010087c:	83 c4 10             	add    $0x10,%esp
c010087f:	5b                   	pop    %ebx
c0100880:	5d                   	pop    %ebp
c0100881:	c3                   	ret    

c0100882 <clear_bmap_bit>:

/**
 * Clear a bit in the heap bitmap
 * \param index The bit to clear
*/
static void clear_bmap_bit(int index) {
c0100882:	55                   	push   %ebp
c0100883:	89 e5                	mov    %esp,%ebp
c0100885:	53                   	push   %ebx
c0100886:	83 ec 10             	sub    $0x10,%esp
  int byte=index/8;
c0100889:	8b 45 08             	mov    0x8(%ebp),%eax
c010088c:	85 c0                	test   %eax,%eax
c010088e:	79 03                	jns    c0100893 <clear_bmap_bit+0x11>
c0100890:	83 c0 07             	add    $0x7,%eax
c0100893:	c1 f8 03             	sar    $0x3,%eax
c0100896:	89 45 f8             	mov    %eax,-0x8(%ebp)
  int bit=index%8;
c0100899:	8b 45 08             	mov    0x8(%ebp),%eax
c010089c:	25 07 00 00 80       	and    $0x80000007,%eax
c01008a1:	85 c0                	test   %eax,%eax
c01008a3:	79 05                	jns    c01008aa <clear_bmap_bit+0x28>
c01008a5:	48                   	dec    %eax
c01008a6:	83 c8 f8             	or     $0xfffffff8,%eax
c01008a9:	40                   	inc    %eax
c01008aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  bmap[byte]=bmap[byte]&(~(1<<bit));
c01008ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01008b0:	05 20 10 25 c0       	add    $0xc0251020,%eax
c01008b5:	8a 10                	mov    (%eax),%dl
c01008b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01008ba:	bb 01 00 00 00       	mov    $0x1,%ebx
c01008bf:	88 c1                	mov    %al,%cl
c01008c1:	d3 e3                	shl    %cl,%ebx
c01008c3:	89 d8                	mov    %ebx,%eax
c01008c5:	f7 d0                	not    %eax
c01008c7:	21 c2                	and    %eax,%edx
c01008c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01008cc:	05 20 10 25 c0       	add    $0xc0251020,%eax
c01008d1:	88 10                	mov    %dl,(%eax)
}
c01008d3:	90                   	nop
c01008d4:	83 c4 10             	add    $0x10,%esp
c01008d7:	5b                   	pop    %ebx
c01008d8:	5d                   	pop    %ebp
c01008d9:	c3                   	ret    

c01008da <pmem_init>:

void pmem_init(struct multiboot_boot_header_tag* tags) {
c01008da:	55                   	push   %ebp
c01008db:	89 e5                	mov    %esp,%ebp
c01008dd:	83 ec 38             	sub    $0x38,%esp
  for (int i=0;i<BMAP_LEN;i++) {
c01008e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01008e7:	eb 0e                	jmp    c01008f7 <pmem_init+0x1d>
    bmap[i]=0xFF;
c01008e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01008ec:	05 20 10 25 c0       	add    $0xc0251020,%eax
c01008f1:	c6 00 ff             	movb   $0xff,(%eax)
  for (int i=0;i<BMAP_LEN;i++) {
c01008f4:	ff 45 f4             	incl   -0xc(%ebp)
c01008f7:	81 7d f4 ff ff 01 00 	cmpl   $0x1ffff,-0xc(%ebp)
c01008fe:	7e e9                	jle    c01008e9 <pmem_init+0xf>
  }
  char found_mmap=0;
c0100900:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  struct multiboot_tag* tag=(struct multiboot_tag*)(tags+1);
c0100904:	8b 45 08             	mov    0x8(%ebp),%eax
c0100907:	83 c0 08             	add    $0x8,%eax
c010090a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  while (tag->type!=0) {
c010090d:	e9 be 00 00 00       	jmp    c01009d0 <pmem_init+0xf6>
    switch (tag->type) {
c0100912:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0100915:	8b 00                	mov    (%eax),%eax
c0100917:	83 f8 06             	cmp    $0x6,%eax
c010091a:	0f 85 a1 00 00 00    	jne    c01009c1 <pmem_init+0xe7>
      case MULTIBOOT_TAG_TYPE_MMAP: {
        found_mmap=1;
c0100920:	c6 45 f3 01          	movb   $0x1,-0xd(%ebp)
        struct multiboot_mmap_entry* orig_ptr=(struct multiboot_mmap_entry*)(((char*)tag)+16);
c0100924:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0100927:	83 c0 10             	add    $0x10,%eax
c010092a:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for (struct multiboot_mmap_entry* ptr=orig_ptr;(char*)ptr<((char*)orig_ptr)+tag->size;ptr++) {
c010092d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0100930:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0100933:	eb 77                	jmp    c01009ac <pmem_init+0xd2>
          if (ptr->type!=MULTIBOOT_MEMORY_AVAILABLE) continue;
c0100935:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0100938:	8b 40 10             	mov    0x10(%eax),%eax
c010093b:	83 f8 01             	cmp    $0x1,%eax
c010093e:	75 64                	jne    c01009a4 <pmem_init+0xca>
          size_t start=ptr->addr;
c0100940:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0100943:	8b 50 04             	mov    0x4(%eax),%edx
c0100946:	8b 00                	mov    (%eax),%eax
c0100948:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          if (start<0x100000) continue;
c010094b:	81 7d e4 ff ff 0f 00 	cmpl   $0xfffff,-0x1c(%ebp)
c0100952:	76 53                	jbe    c01009a7 <pmem_init+0xcd>
          size_t end=start+ptr->len-1;
c0100954:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0100957:	8b 50 0c             	mov    0xc(%eax),%edx
c010095a:	8b 40 08             	mov    0x8(%eax),%eax
c010095d:	89 c2                	mov    %eax,%edx
c010095f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0100962:	01 d0                	add    %edx,%eax
c0100964:	48                   	dec    %eax
c0100965:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          if (start&(FRAME_SZ-1)) {
c0100968:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010096b:	25 ff 0f 00 00       	and    $0xfff,%eax
c0100970:	85 c0                	test   %eax,%eax
c0100972:	74 07                	je     c010097b <pmem_init+0xa1>
            start+=FRAME_SZ;
c0100974:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
          }
          start=start>>FRAME_NO_OFFSET;
c010097b:	c1 6d e4 0c          	shrl   $0xc,-0x1c(%ebp)
          end=end>>FRAME_NO_OFFSET;
c010097f:	c1 6d d4 0c          	shrl   $0xc,-0x2c(%ebp)
          for (size_t i=start;i<end;i++) {
c0100983:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0100986:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0100989:	eb 0f                	jmp    c010099a <pmem_init+0xc0>
            clear_bmap_bit(i);
c010098b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010098e:	50                   	push   %eax
c010098f:	e8 ee fe ff ff       	call   c0100882 <clear_bmap_bit>
c0100994:	83 c4 04             	add    $0x4,%esp
          for (size_t i=start;i<end;i++) {
c0100997:	ff 45 e0             	incl   -0x20(%ebp)
c010099a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010099d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
c01009a0:	72 e9                	jb     c010098b <pmem_init+0xb1>
c01009a2:	eb 04                	jmp    c01009a8 <pmem_init+0xce>
          if (ptr->type!=MULTIBOOT_MEMORY_AVAILABLE) continue;
c01009a4:	90                   	nop
c01009a5:	eb 01                	jmp    c01009a8 <pmem_init+0xce>
          if (start<0x100000) continue;
c01009a7:	90                   	nop
        for (struct multiboot_mmap_entry* ptr=orig_ptr;(char*)ptr<((char*)orig_ptr)+tag->size;ptr++) {
c01009a8:	83 45 e8 18          	addl   $0x18,-0x18(%ebp)
c01009ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01009af:	8b 50 04             	mov    0x4(%eax),%edx
c01009b2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01009b5:	01 d0                	add    %edx,%eax
c01009b7:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c01009ba:	0f 82 75 ff ff ff    	jb     c0100935 <pmem_init+0x5b>
          }
        }
        break;
c01009c0:	90                   	nop
      }
    }
    tag=(struct multiboot_tag*)((char*)tag+((tag->size+7)&0xFFFFFFF8));
c01009c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01009c4:	8b 40 04             	mov    0x4(%eax),%eax
c01009c7:	83 c0 07             	add    $0x7,%eax
c01009ca:	83 e0 f8             	and    $0xfffffff8,%eax
c01009cd:	01 45 ec             	add    %eax,-0x14(%ebp)
  while (tag->type!=0) {
c01009d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01009d3:	8b 00                	mov    (%eax),%eax
c01009d5:	85 c0                	test   %eax,%eax
c01009d7:	0f 85 35 ff ff ff    	jne    c0100912 <pmem_init+0x38>
  }
  if (!found_mmap) {
c01009dd:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01009e1:	75 15                	jne    c01009f8 <pmem_init+0x11e>
    vga_write_string("[PANIC] No memory map supplied by bootloader!");
c01009e3:	83 ec 0c             	sub    $0xc,%esp
c01009e6:	68 48 60 10 c0       	push   $0xc0106048
c01009eb:	e8 90 15 00 00       	call   c0101f80 <vga_write_string>
c01009f0:	83 c4 10             	add    $0x10,%esp
    halt();
c01009f3:	e8 68 36 00 00       	call   c0104060 <halt>
  }
  for (size_t i=0;i<NUM_KERN_FRAMES;i++) {
c01009f8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c01009ff:	eb 12                	jmp    c0100a13 <pmem_init+0x139>
    set_bmap_bit(i);
c0100a01:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0100a04:	83 ec 0c             	sub    $0xc,%esp
c0100a07:	50                   	push   %eax
c0100a08:	e8 1f fe ff ff       	call   c010082c <set_bmap_bit>
c0100a0d:	83 c4 10             	add    $0x10,%esp
  for (size_t i=0;i<NUM_KERN_FRAMES;i++) {
c0100a10:	ff 45 dc             	incl   -0x24(%ebp)
c0100a13:	81 7d dc ff 0f 00 00 	cmpl   $0xfff,-0x24(%ebp)
c0100a1a:	76 e5                	jbe    c0100a01 <pmem_init+0x127>
  }
}
c0100a1c:	90                   	nop
c0100a1d:	90                   	nop
c0100a1e:	c9                   	leave  
c0100a1f:	c3                   	ret    

c0100a20 <pmem_alloc>:

void* pmem_alloc(int num_pages) {
c0100a20:	55                   	push   %ebp
c0100a21:	89 e5                	mov    %esp,%ebp
c0100a23:	83 ec 38             	sub    $0x38,%esp
  size_t bmap_index;
  size_t remaining_blks;
  for(size_t i=0;i<131072;i++) {
c0100a26:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0100a2d:	eb 7e                	jmp    c0100aad <pmem_alloc+0x8d>
    char got_0=0;
c0100a2f:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
    remaining_blks=num_pages;
c0100a33:	8b 45 08             	mov    0x8(%ebp),%eax
c0100a36:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t old_j;
    for (size_t j=i*8;;j++) {
c0100a39:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0100a3c:	c1 e0 03             	shl    $0x3,%eax
c0100a3f:	89 45 e0             	mov    %eax,-0x20(%ebp)
      char bit=get_bmap_bit(j);
c0100a42:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0100a45:	50                   	push   %eax
c0100a46:	e8 8a fd ff ff       	call   c01007d5 <get_bmap_bit>
c0100a4b:	83 c4 04             	add    $0x4,%esp
c0100a4e:	88 45 db             	mov    %al,-0x25(%ebp)
      if (got_0) {
c0100a51:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
c0100a55:	74 27                	je     c0100a7e <pmem_alloc+0x5e>
        if (bit) {
c0100a57:	80 7d db 00          	cmpb   $0x0,-0x25(%ebp)
c0100a5b:	74 1c                	je     c0100a79 <pmem_alloc+0x59>
          if (remaining_blks==0) {
c0100a5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0100a61:	75 08                	jne    c0100a6b <pmem_alloc+0x4b>
              bmap_index=old_j;
c0100a63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0100a66:	89 45 f4             	mov    %eax,-0xc(%ebp)
              break;
c0100a69:	eb 39                	jmp    c0100aa4 <pmem_alloc+0x84>
          } else {
            i+=j/8;
c0100a6b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0100a6e:	c1 e8 03             	shr    $0x3,%eax
c0100a71:	01 45 ec             	add    %eax,-0x14(%ebp)
            i--;
c0100a74:	ff 4d ec             	decl   -0x14(%ebp)
            break;
c0100a77:	eb 2b                	jmp    c0100aa4 <pmem_alloc+0x84>
          }
        } else {
          remaining_blks--;
c0100a79:	ff 4d f0             	decl   -0x10(%ebp)
c0100a7c:	eb 13                	jmp    c0100a91 <pmem_alloc+0x71>
        }
      } else {
        if (!bit) {
c0100a7e:	80 7d db 00          	cmpb   $0x0,-0x25(%ebp)
c0100a82:	75 0d                	jne    c0100a91 <pmem_alloc+0x71>
          got_0=1;
c0100a84:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
          old_j=j;
c0100a88:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0100a8b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          remaining_blks--;
c0100a8e:	ff 4d f0             	decl   -0x10(%ebp)
        }
      }
      if (remaining_blks==0) {
c0100a91:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0100a95:	75 08                	jne    c0100a9f <pmem_alloc+0x7f>
        bmap_index=old_j;
c0100a97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0100a9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        break;
c0100a9d:	eb 05                	jmp    c0100aa4 <pmem_alloc+0x84>
    for (size_t j=i*8;;j++) {
c0100a9f:	ff 45 e0             	incl   -0x20(%ebp)
c0100aa2:	eb 9e                	jmp    c0100a42 <pmem_alloc+0x22>
      }
    }
    if (remaining_blks==0) {
c0100aa4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0100aa8:	74 12                	je     c0100abc <pmem_alloc+0x9c>
  for(size_t i=0;i<131072;i++) {
c0100aaa:	ff 45 ec             	incl   -0x14(%ebp)
c0100aad:	81 7d ec ff ff 01 00 	cmpl   $0x1ffff,-0x14(%ebp)
c0100ab4:	0f 86 75 ff ff ff    	jbe    c0100a2f <pmem_alloc+0xf>
c0100aba:	eb 01                	jmp    c0100abd <pmem_alloc+0x9d>
      break;
c0100abc:	90                   	nop
    }
  }
  if (remaining_blks!=0) {
c0100abd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0100ac1:	74 15                	je     c0100ad8 <pmem_alloc+0xb8>
    serial_printf("Out of memory! Halting!\n");
c0100ac3:	83 ec 0c             	sub    $0xc,%esp
c0100ac6:	68 76 60 10 c0       	push   $0xc0106076
c0100acb:	e8 85 33 00 00       	call   c0103e55 <serial_printf>
c0100ad0:	83 c4 10             	add    $0x10,%esp
    halt();
c0100ad3:	e8 88 35 00 00       	call   c0104060 <halt>
    return NULL;
  }
  for (int i=0;i<num_pages;i++) {
c0100ad8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c0100adf:	eb 17                	jmp    c0100af8 <pmem_alloc+0xd8>
    set_bmap_bit(bmap_index+i);
c0100ae1:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0100ae4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100ae7:	01 d0                	add    %edx,%eax
c0100ae9:	83 ec 0c             	sub    $0xc,%esp
c0100aec:	50                   	push   %eax
c0100aed:	e8 3a fd ff ff       	call   c010082c <set_bmap_bit>
c0100af2:	83 c4 10             	add    $0x10,%esp
  for (int i=0;i<num_pages;i++) {
c0100af5:	ff 45 dc             	incl   -0x24(%ebp)
c0100af8:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0100afb:	3b 45 08             	cmp    0x8(%ebp),%eax
c0100afe:	7c e1                	jl     c0100ae1 <pmem_alloc+0xc1>
  }
  void* addr=(void*)(bmap_index<<12);
c0100b00:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100b03:	c1 e0 0c             	shl    $0xc,%eax
c0100b06:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  return addr;
c0100b09:	8b 45 d4             	mov    -0x2c(%ebp),%eax
}
c0100b0c:	c9                   	leave  
c0100b0d:	c3                   	ret    

c0100b0e <pmem_free>:

void pmem_free(void* start,int num_pages) {
c0100b0e:	55                   	push   %ebp
c0100b0f:	89 e5                	mov    %esp,%ebp
c0100b11:	83 ec 10             	sub    $0x10,%esp
  int start_page=(size_t)start>>FRAME_NO_OFFSET;
c0100b14:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b17:	c1 e8 0c             	shr    $0xc,%eax
c0100b1a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for (int i=start_page;i<num_pages;i++) {
c0100b1d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0100b20:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0100b23:	eb 0e                	jmp    c0100b33 <pmem_free+0x25>
    set_bmap_bit(i);
c0100b25:	ff 75 fc             	pushl  -0x4(%ebp)
c0100b28:	e8 ff fc ff ff       	call   c010082c <set_bmap_bit>
c0100b2d:	83 c4 04             	add    $0x4,%esp
  for (int i=start_page;i<num_pages;i++) {
c0100b30:	ff 45 fc             	incl   -0x4(%ebp)
c0100b33:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0100b36:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0100b39:	7c ea                	jl     c0100b25 <pmem_free+0x17>
  }
}
c0100b3b:	90                   	nop
c0100b3c:	90                   	nop
c0100b3d:	c9                   	leave  
c0100b3e:	c3                   	ret    

c0100b3f <mark_init>:

/**
 * Mark a process as ready to accept RPC calls
 * \param pid The pid to mark
*/
static void mark_init(pid_t pid) {
c0100b3f:	55                   	push   %ebp
c0100b40:	89 e5                	mov    %esp,%ebp
c0100b42:	53                   	push   %ebx
c0100b43:	83 ec 10             	sub    $0x10,%esp
  size_t byte=pid/8;
c0100b46:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b49:	85 c0                	test   %eax,%eax
c0100b4b:	79 03                	jns    c0100b50 <mark_init+0x11>
c0100b4d:	83 c0 07             	add    $0x7,%eax
c0100b50:	c1 f8 03             	sar    $0x3,%eax
c0100b53:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=pid%8;
c0100b56:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b59:	25 07 00 00 80       	and    $0x80000007,%eax
c0100b5e:	85 c0                	test   %eax,%eax
c0100b60:	79 05                	jns    c0100b67 <mark_init+0x28>
c0100b62:	48                   	dec    %eax
c0100b63:	83 c8 f8             	or     $0xfffffff8,%eax
c0100b66:	40                   	inc    %eax
c0100b67:	89 45 f4             	mov    %eax,-0xc(%ebp)
  process_ready_bmap[byte]=process_ready_bmap[byte]|(1<<bit);
c0100b6a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0100b6d:	05 20 10 2b c0       	add    $0xc02b1020,%eax
c0100b72:	8a 10                	mov    (%eax),%dl
c0100b74:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100b77:	bb 01 00 00 00       	mov    $0x1,%ebx
c0100b7c:	88 c1                	mov    %al,%cl
c0100b7e:	d3 e3                	shl    %cl,%ebx
c0100b80:	89 d8                	mov    %ebx,%eax
c0100b82:	09 c2                	or     %eax,%edx
c0100b84:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0100b87:	05 20 10 2b c0       	add    $0xc02b1020,%eax
c0100b8c:	88 10                	mov    %dl,(%eax)
}
c0100b8e:	90                   	nop
c0100b8f:	83 c4 10             	add    $0x10,%esp
c0100b92:	5b                   	pop    %ebx
c0100b93:	5d                   	pop    %ebp
c0100b94:	c3                   	ret    

c0100b95 <kernel_rpc_is_init>:
//   size_t byte=pid/8;
//   size_t bit=pid%8;
//   process_ready_bmap[byte]=process_ready_bmap[byte]&(~(1<<bit));
// }

char kernel_rpc_is_init(pid_t pid) {
c0100b95:	55                   	push   %ebp
c0100b96:	89 e5                	mov    %esp,%ebp
c0100b98:	53                   	push   %ebx
c0100b99:	83 ec 10             	sub    $0x10,%esp
  size_t byte=pid/8;
c0100b9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b9f:	85 c0                	test   %eax,%eax
c0100ba1:	79 03                	jns    c0100ba6 <kernel_rpc_is_init+0x11>
c0100ba3:	83 c0 07             	add    $0x7,%eax
c0100ba6:	c1 f8 03             	sar    $0x3,%eax
c0100ba9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=pid%8;
c0100bac:	8b 45 08             	mov    0x8(%ebp),%eax
c0100baf:	25 07 00 00 80       	and    $0x80000007,%eax
c0100bb4:	85 c0                	test   %eax,%eax
c0100bb6:	79 05                	jns    c0100bbd <kernel_rpc_is_init+0x28>
c0100bb8:	48                   	dec    %eax
c0100bb9:	83 c8 f8             	or     $0xfffffff8,%eax
c0100bbc:	40                   	inc    %eax
c0100bbd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char entry=process_ready_bmap[byte];
c0100bc0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0100bc3:	05 20 10 2b c0       	add    $0xc02b1020,%eax
c0100bc8:	8a 00                	mov    (%eax),%al
c0100bca:	88 45 f3             	mov    %al,-0xd(%ebp)
  return (entry&(1<<bit))>0;
c0100bcd:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
c0100bd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100bd4:	bb 01 00 00 00       	mov    $0x1,%ebx
c0100bd9:	88 c1                	mov    %al,%cl
c0100bdb:	d3 e3                	shl    %cl,%ebx
c0100bdd:	89 d8                	mov    %ebx,%eax
c0100bdf:	21 d0                	and    %edx,%eax
c0100be1:	85 c0                	test   %eax,%eax
c0100be3:	0f 9f c0             	setg   %al
}
c0100be6:	83 c4 10             	add    $0x10,%esp
c0100be9:	5b                   	pop    %ebx
c0100bea:	5d                   	pop    %ebp
c0100beb:	c3                   	ret    

c0100bec <kernel_rpc_call>:

void* kernel_rpc_call(pid_t pid,char* name,void* buf,size_t size) {
c0100bec:	55                   	push   %ebp
c0100bed:	89 e5                	mov    %esp,%ebp
c0100bef:	83 ec 28             	sub    $0x28,%esp
  //serial_printf("PID %d calling %s on PID %d\n",tasking_get_PID(),name,pid);
  if (kernel_rpc_is_init(pid)==0) {
c0100bf2:	ff 75 08             	pushl  0x8(%ebp)
c0100bf5:	e8 9b ff ff ff       	call   c0100b95 <kernel_rpc_is_init>
c0100bfa:	83 c4 04             	add    $0x4,%esp
c0100bfd:	84 c0                	test   %al,%al
c0100bff:	75 6a                	jne    c0100c6b <kernel_rpc_call+0x7f>
    rpc_waiting_thread* waiting_thread=kmalloc(sizeof(rpc_waiting_thread));
c0100c01:	83 ec 0c             	sub    $0xc,%esp
c0100c04:	6a 10                	push   $0x10
c0100c06:	e8 16 fa ff ff       	call   c0100621 <kmalloc>
c0100c0b:	83 c4 10             	add    $0x10,%esp
c0100c0e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (waiting_thread==NULL) {
c0100c11:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0100c15:	75 15                	jne    c0100c2c <kernel_rpc_call+0x40>
      serial_printf("Kmalloc unable to allocate waiting_thread\n");
c0100c17:	83 ec 0c             	sub    $0xc,%esp
c0100c1a:	68 90 60 10 c0       	push   $0xc0106090
c0100c1f:	e8 31 32 00 00       	call   c0103e55 <serial_printf>
c0100c24:	83 c4 10             	add    $0x10,%esp
      halt();
c0100c27:	e8 34 34 00 00       	call   c0104060 <halt>
    }
    waiting_thread->process_waiting_on=pid;
c0100c2c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0100c2f:	8b 55 08             	mov    0x8(%ebp),%edx
c0100c32:	89 50 08             	mov    %edx,0x8(%eax)
    waiting_thread->waiting_pid=tasking_get_PID();
c0100c35:	e8 59 09 00 00       	call   c0101593 <tasking_get_PID>
c0100c3a:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0100c3d:	89 02                	mov    %eax,(%edx)
    waiting_thread->waiting_tid=tasking_get_TID();
c0100c3f:	e8 5f 09 00 00       	call   c01015a3 <tasking_get_TID>
c0100c44:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0100c47:	89 42 04             	mov    %eax,0x4(%edx)
    waiting_thread->next=waiting_thread_list;
c0100c4a:	8b 15 20 20 2b c0    	mov    0xc02b2020,%edx
c0100c50:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0100c53:	89 50 0c             	mov    %edx,0xc(%eax)
    waiting_thread_list=waiting_thread;
c0100c56:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0100c59:	a3 20 20 2b c0       	mov    %eax,0xc02b2020
    tasking_block(THREAD_WAITING_FOR_RPC_INIT);
c0100c5e:	83 ec 0c             	sub    $0xc,%esp
c0100c61:	6a 05                	push   $0x5
c0100c63:	e8 9e 0c 00 00       	call   c0101906 <tasking_block>
c0100c68:	83 c4 10             	add    $0x10,%esp
  }
  rpc_func_info* func=NULL;
c0100c6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  rpc_func_info* funcs=process_funcs[pid];
c0100c72:	8b 45 08             	mov    0x8(%ebp),%eax
c0100c75:	8b 04 85 20 10 27 c0 	mov    -0x3fd8efe0(,%eax,4),%eax
c0100c7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  for (size_t i = 0; i < process_num_funcs[pid]; i++){
c0100c7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0100c86:	eb 43                	jmp    c0100ccb <kernel_rpc_call+0xdf>
    if (strcmp(funcs[i].name,name)==0) {
c0100c88:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0100c8b:	89 d0                	mov    %edx,%eax
c0100c8d:	c1 e0 03             	shl    $0x3,%eax
c0100c90:	01 d0                	add    %edx,%eax
c0100c92:	c1 e0 02             	shl    $0x2,%eax
c0100c95:	89 c2                	mov    %eax,%edx
c0100c97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0100c9a:	01 d0                	add    %edx,%eax
c0100c9c:	83 ec 08             	sub    $0x8,%esp
c0100c9f:	ff 75 0c             	pushl  0xc(%ebp)
c0100ca2:	50                   	push   %eax
c0100ca3:	e8 91 45 00 00       	call   c0105239 <strcmp>
c0100ca8:	83 c4 10             	add    $0x10,%esp
c0100cab:	85 c0                	test   %eax,%eax
c0100cad:	75 19                	jne    c0100cc8 <kernel_rpc_call+0xdc>
      func=&funcs[i];
c0100caf:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0100cb2:	89 d0                	mov    %edx,%eax
c0100cb4:	c1 e0 03             	shl    $0x3,%eax
c0100cb7:	01 d0                	add    %edx,%eax
c0100cb9:	c1 e0 02             	shl    $0x2,%eax
c0100cbc:	89 c2                	mov    %eax,%edx
c0100cbe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0100cc1:	01 d0                	add    %edx,%eax
c0100cc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
      break;
c0100cc6:	eb 12                	jmp    c0100cda <kernel_rpc_call+0xee>
  for (size_t i = 0; i < process_num_funcs[pid]; i++){
c0100cc8:	ff 45 f0             	incl   -0x10(%ebp)
c0100ccb:	8b 45 08             	mov    0x8(%ebp),%eax
c0100cce:	8b 04 85 20 10 29 c0 	mov    -0x3fd6efe0(,%eax,4),%eax
c0100cd5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0100cd8:	72 ae                	jb     c0100c88 <kernel_rpc_call+0x9c>
    }
  }
  if (func==NULL) {
c0100cda:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0100cde:	75 20                	jne    c0100d00 <kernel_rpc_call+0x114>
    serial_printf("No function %s for PID %d\n",name,pid);
c0100ce0:	83 ec 04             	sub    $0x4,%esp
c0100ce3:	ff 75 08             	pushl  0x8(%ebp)
c0100ce6:	ff 75 0c             	pushl  0xc(%ebp)
c0100ce9:	68 bb 60 10 c0       	push   $0xc01060bb
c0100cee:	e8 62 31 00 00       	call   c0103e55 <serial_printf>
c0100cf3:	83 c4 10             	add    $0x10,%esp
    return NULL;
c0100cf6:	b8 00 00 00 00       	mov    $0x0,%eax
c0100cfb:	e9 04 01 00 00       	jmp    c0100e04 <kernel_rpc_call+0x218>
  }
  void* virtaddr=NULL;
c0100d00:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if (buf) {
c0100d07:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0100d0b:	0f 84 b6 00 00 00    	je     c0100dc7 <kernel_rpc_call+0x1db>
    virtaddr=alloc_pages((size/PAGE_SZ)+1);
c0100d11:	8b 45 14             	mov    0x14(%ebp),%eax
c0100d14:	c1 e8 0c             	shr    $0xc,%eax
c0100d17:	40                   	inc    %eax
c0100d18:	83 ec 0c             	sub    $0xc,%esp
c0100d1b:	50                   	push   %eax
c0100d1c:	e8 f0 24 00 00       	call   c0103211 <alloc_pages>
c0100d21:	83 c4 10             	add    $0x10,%esp
c0100d24:	89 45 ec             	mov    %eax,-0x14(%ebp)
    void* physaddr=virt_to_phys(virtaddr);
c0100d27:	83 ec 0c             	sub    $0xc,%esp
c0100d2a:	ff 75 ec             	pushl  -0x14(%ebp)
c0100d2d:	e8 12 25 00 00       	call   c0103244 <virt_to_phys>
c0100d32:	83 c4 10             	add    $0x10,%esp
c0100d35:	89 45 e0             	mov    %eax,-0x20(%ebp)
    memcpy(virtaddr,buf,size);
c0100d38:	83 ec 04             	sub    $0x4,%esp
c0100d3b:	ff 75 14             	pushl  0x14(%ebp)
c0100d3e:	ff 75 10             	pushl  0x10(%ebp)
c0100d41:	ff 75 ec             	pushl  -0x14(%ebp)
c0100d44:	e8 7f 44 00 00       	call   c01051c8 <memcpy>
c0100d49:	83 c4 10             	add    $0x10,%esp
    unmap_pages(virtaddr,(size/PAGE_SZ)+1,0);
c0100d4c:	8b 45 14             	mov    0x14(%ebp),%eax
c0100d4f:	c1 e8 0c             	shr    $0xc,%eax
c0100d52:	40                   	inc    %eax
c0100d53:	83 ec 04             	sub    $0x4,%esp
c0100d56:	6a 00                	push   $0x0
c0100d58:	50                   	push   %eax
c0100d59:	ff 75 ec             	pushl  -0x14(%ebp)
c0100d5c:	e8 74 26 00 00       	call   c01033d5 <unmap_pages>
c0100d61:	83 c4 10             	add    $0x10,%esp
    RUN_IN_ADDRESS_SPACE(tasking_get_address_space(pid),{
c0100d64:	e8 a4 29 00 00       	call   c010370d <get_address_space>
c0100d69:	89 45 dc             	mov    %eax,-0x24(%ebp)
c0100d6c:	83 ec 0c             	sub    $0xc,%esp
c0100d6f:	ff 75 08             	pushl  0x8(%ebp)
c0100d72:	e8 2e 10 00 00       	call   c0101da5 <tasking_get_address_space>
c0100d77:	83 c4 10             	add    $0x10,%esp
c0100d7a:	83 ec 0c             	sub    $0xc,%esp
c0100d7d:	50                   	push   %eax
c0100d7e:	e8 46 26 00 00       	call   c01033c9 <load_address_space>
c0100d83:	83 c4 10             	add    $0x10,%esp
c0100d86:	8b 45 14             	mov    0x14(%ebp),%eax
c0100d89:	c1 e8 0c             	shr    $0xc,%eax
c0100d8c:	40                   	inc    %eax
c0100d8d:	83 ec 0c             	sub    $0xc,%esp
c0100d90:	50                   	push   %eax
c0100d91:	e8 bc 23 00 00       	call   c0103152 <find_free_pages>
c0100d96:	83 c4 10             	add    $0x10,%esp
c0100d99:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0100d9c:	8b 45 14             	mov    0x14(%ebp),%eax
c0100d9f:	c1 e8 0c             	shr    $0xc,%eax
c0100da2:	40                   	inc    %eax
c0100da3:	83 ec 0c             	sub    $0xc,%esp
c0100da6:	6a 01                	push   $0x1
c0100da8:	6a 01                	push   $0x1
c0100daa:	50                   	push   %eax
c0100dab:	ff 75 e0             	pushl  -0x20(%ebp)
c0100dae:	ff 75 ec             	pushl  -0x14(%ebp)
c0100db1:	e8 f3 21 00 00       	call   c0102fa9 <map_pages>
c0100db6:	83 c4 20             	add    $0x20,%esp
c0100db9:	83 ec 0c             	sub    $0xc,%esp
c0100dbc:	ff 75 dc             	pushl  -0x24(%ebp)
c0100dbf:	e8 05 26 00 00       	call   c01033c9 <load_address_space>
c0100dc4:	83 c4 10             	add    $0x10,%esp
      virtaddr=find_free_pages((size/PAGE_SZ)+1);
      map_pages(virtaddr,physaddr,(size/PAGE_SZ)+1,1,1);
    });
  }
  pid_t tid=tasking_new_thread(func->code,pid,virtaddr,0);
c0100dc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100dca:	8b 40 20             	mov    0x20(%eax),%eax
c0100dcd:	6a 00                	push   $0x0
c0100dcf:	ff 75 ec             	pushl  -0x14(%ebp)
c0100dd2:	ff 75 08             	pushl  0x8(%ebp)
c0100dd5:	50                   	push   %eax
c0100dd6:	e8 e2 07 00 00       	call   c01015bd <tasking_new_thread>
c0100ddb:	83 c4 10             	add    $0x10,%esp
c0100dde:	89 45 d8             	mov    %eax,-0x28(%ebp)
  tasking_set_rpc_calling_thread(pid,tid);
c0100de1:	83 ec 08             	sub    $0x8,%esp
c0100de4:	ff 75 d8             	pushl  -0x28(%ebp)
c0100de7:	ff 75 08             	pushl  0x8(%ebp)
c0100dea:	e8 d1 0f 00 00       	call   c0101dc0 <tasking_set_rpc_calling_thread>
c0100def:	83 c4 10             	add    $0x10,%esp
  // Block the thread and wait for an unblock from rpc_return
  tasking_block(THREAD_WAITING_FOR_RPC);
c0100df2:	83 ec 0c             	sub    $0xc,%esp
c0100df5:	6a 04                	push   $0x4
c0100df7:	e8 0a 0b 00 00       	call   c0101906 <tasking_block>
c0100dfc:	83 c4 10             	add    $0x10,%esp
  // Now that RPC call has returned, pass the return buffer back to the caller
  return tasking_get_rpc_ret_buf();
c0100dff:	e8 48 10 00 00       	call   c0101e4c <tasking_get_rpc_ret_buf>
}
c0100e04:	c9                   	leave  
c0100e05:	c3                   	ret    

c0100e06 <kernel_rpc_register_func>:

void kernel_rpc_register_func(char* name,rpc_func code) {
c0100e06:	55                   	push   %ebp
c0100e07:	89 e5                	mov    %esp,%ebp
c0100e09:	83 ec 18             	sub    $0x18,%esp
  pid_t pid=tasking_get_PID();
c0100e0c:	e8 82 07 00 00       	call   c0101593 <tasking_get_PID>
c0100e11:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (process_funcs[pid]==NULL) {
c0100e14:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100e17:	8b 04 85 20 10 27 c0 	mov    -0x3fd8efe0(,%eax,4),%eax
c0100e1e:	85 c0                	test   %eax,%eax
c0100e20:	75 1a                	jne    c0100e3c <kernel_rpc_register_func+0x36>
    process_funcs[pid]=kmalloc(sizeof(rpc_func_info)*32);
c0100e22:	83 ec 0c             	sub    $0xc,%esp
c0100e25:	68 80 04 00 00       	push   $0x480
c0100e2a:	e8 f2 f7 ff ff       	call   c0100621 <kmalloc>
c0100e2f:	83 c4 10             	add    $0x10,%esp
c0100e32:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0100e35:	89 04 95 20 10 27 c0 	mov    %eax,-0x3fd8efe0(,%edx,4)
  }
  if (process_num_funcs[pid]==32) {
c0100e3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100e3f:	8b 04 85 20 10 29 c0 	mov    -0x3fd6efe0(,%eax,4),%eax
c0100e46:	83 f8 20             	cmp    $0x20,%eax
c0100e49:	75 12                	jne    c0100e5d <kernel_rpc_register_func+0x57>
    serial_printf("Already registered 32 functions!");
c0100e4b:	83 ec 0c             	sub    $0xc,%esp
c0100e4e:	68 d8 60 10 c0       	push   $0xc01060d8
c0100e53:	e8 fd 2f 00 00       	call   c0103e55 <serial_printf>
c0100e58:	83 c4 10             	add    $0x10,%esp
    return;
c0100e5b:	eb 55                	jmp    c0100eb2 <kernel_rpc_register_func+0xac>
  }
  rpc_func_info* info=&process_funcs[pid][process_num_funcs[pid]];
c0100e5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100e60:	8b 0c 85 20 10 27 c0 	mov    -0x3fd8efe0(,%eax,4),%ecx
c0100e67:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100e6a:	8b 14 85 20 10 29 c0 	mov    -0x3fd6efe0(,%eax,4),%edx
c0100e71:	89 d0                	mov    %edx,%eax
c0100e73:	c1 e0 03             	shl    $0x3,%eax
c0100e76:	01 d0                	add    %edx,%eax
c0100e78:	c1 e0 02             	shl    $0x2,%eax
c0100e7b:	01 c8                	add    %ecx,%eax
c0100e7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  strcpy(&info->name[0],name);
c0100e80:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0100e83:	83 ec 08             	sub    $0x8,%esp
c0100e86:	ff 75 08             	pushl  0x8(%ebp)
c0100e89:	50                   	push   %eax
c0100e8a:	e8 2e 44 00 00       	call   c01052bd <strcpy>
c0100e8f:	83 c4 10             	add    $0x10,%esp
  info->code=code;
c0100e92:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0100e95:	8b 55 0c             	mov    0xc(%ebp),%edx
c0100e98:	89 50 20             	mov    %edx,0x20(%eax)
  process_num_funcs[pid]++;
c0100e9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100e9e:	8b 04 85 20 10 29 c0 	mov    -0x3fd6efe0(,%eax,4),%eax
c0100ea5:	8d 50 01             	lea    0x1(%eax),%edx
c0100ea8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100eab:	89 14 85 20 10 29 c0 	mov    %edx,-0x3fd6efe0(,%eax,4)
}
c0100eb2:	c9                   	leave  
c0100eb3:	c3                   	ret    

c0100eb4 <kernel_rpc_deallocate_buf>:

void kernel_rpc_deallocate_buf(void* buf,size_t size) {
c0100eb4:	55                   	push   %ebp
c0100eb5:	89 e5                	mov    %esp,%ebp
c0100eb7:	83 ec 08             	sub    $0x8,%esp
  if (buf==NULL) return;
c0100eba:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0100ebe:	74 18                	je     c0100ed8 <kernel_rpc_deallocate_buf+0x24>
  dealloc_pages((size/PAGE_SZ)+1,buf);
c0100ec0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100ec3:	c1 e8 0c             	shr    $0xc,%eax
c0100ec6:	40                   	inc    %eax
c0100ec7:	83 ec 08             	sub    $0x8,%esp
c0100eca:	ff 75 08             	pushl  0x8(%ebp)
c0100ecd:	50                   	push   %eax
c0100ece:	e8 4b 28 00 00       	call   c010371e <dealloc_pages>
c0100ed3:	83 c4 10             	add    $0x10,%esp
c0100ed6:	eb 01                	jmp    c0100ed9 <kernel_rpc_deallocate_buf+0x25>
  if (buf==NULL) return;
c0100ed8:	90                   	nop
}
c0100ed9:	c9                   	leave  
c0100eda:	c3                   	ret    

c0100edb <kernel_rpc_return>:

void kernel_rpc_return(void* buf,size_t size) {
c0100edb:	55                   	push   %ebp
c0100edc:	89 e5                	mov    %esp,%ebp
c0100ede:	83 ec 28             	sub    $0x28,%esp
  pid_t tid;
  pid_t pid=tasking_get_rpc_calling_thread(&tid);
c0100ee1:	83 ec 0c             	sub    $0xc,%esp
c0100ee4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0100ee7:	50                   	push   %eax
c0100ee8:	e8 0f 0f 00 00       	call   c0101dfc <tasking_get_rpc_calling_thread>
c0100eed:	83 c4 10             	add    $0x10,%esp
c0100ef0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void* virtaddr=NULL;
c0100ef3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  if (buf) {
c0100efa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0100efe:	0f 84 b6 00 00 00    	je     c0100fba <kernel_rpc_return+0xdf>
    virtaddr=alloc_pages((size/PAGE_SZ)+1);
c0100f04:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100f07:	c1 e8 0c             	shr    $0xc,%eax
c0100f0a:	40                   	inc    %eax
c0100f0b:	83 ec 0c             	sub    $0xc,%esp
c0100f0e:	50                   	push   %eax
c0100f0f:	e8 fd 22 00 00       	call   c0103211 <alloc_pages>
c0100f14:	83 c4 10             	add    $0x10,%esp
c0100f17:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* physaddr=virt_to_phys(virtaddr);
c0100f1a:	83 ec 0c             	sub    $0xc,%esp
c0100f1d:	ff 75 f4             	pushl  -0xc(%ebp)
c0100f20:	e8 1f 23 00 00       	call   c0103244 <virt_to_phys>
c0100f25:	83 c4 10             	add    $0x10,%esp
c0100f28:	89 45 ec             	mov    %eax,-0x14(%ebp)
    memcpy(virtaddr,buf,size);
c0100f2b:	83 ec 04             	sub    $0x4,%esp
c0100f2e:	ff 75 0c             	pushl  0xc(%ebp)
c0100f31:	ff 75 08             	pushl  0x8(%ebp)
c0100f34:	ff 75 f4             	pushl  -0xc(%ebp)
c0100f37:	e8 8c 42 00 00       	call   c01051c8 <memcpy>
c0100f3c:	83 c4 10             	add    $0x10,%esp
    unmap_pages(virtaddr,(size/PAGE_SZ)+1,0);
c0100f3f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100f42:	c1 e8 0c             	shr    $0xc,%eax
c0100f45:	40                   	inc    %eax
c0100f46:	83 ec 04             	sub    $0x4,%esp
c0100f49:	6a 00                	push   $0x0
c0100f4b:	50                   	push   %eax
c0100f4c:	ff 75 f4             	pushl  -0xc(%ebp)
c0100f4f:	e8 81 24 00 00       	call   c01033d5 <unmap_pages>
c0100f54:	83 c4 10             	add    $0x10,%esp
    RUN_IN_ADDRESS_SPACE(tasking_get_address_space(pid),{
c0100f57:	e8 b1 27 00 00       	call   c010370d <get_address_space>
c0100f5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0100f5f:	83 ec 0c             	sub    $0xc,%esp
c0100f62:	ff 75 f0             	pushl  -0x10(%ebp)
c0100f65:	e8 3b 0e 00 00       	call   c0101da5 <tasking_get_address_space>
c0100f6a:	83 c4 10             	add    $0x10,%esp
c0100f6d:	83 ec 0c             	sub    $0xc,%esp
c0100f70:	50                   	push   %eax
c0100f71:	e8 53 24 00 00       	call   c01033c9 <load_address_space>
c0100f76:	83 c4 10             	add    $0x10,%esp
c0100f79:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100f7c:	c1 e8 0c             	shr    $0xc,%eax
c0100f7f:	40                   	inc    %eax
c0100f80:	83 ec 0c             	sub    $0xc,%esp
c0100f83:	50                   	push   %eax
c0100f84:	e8 c9 21 00 00       	call   c0103152 <find_free_pages>
c0100f89:	83 c4 10             	add    $0x10,%esp
c0100f8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0100f8f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100f92:	c1 e8 0c             	shr    $0xc,%eax
c0100f95:	40                   	inc    %eax
c0100f96:	83 ec 0c             	sub    $0xc,%esp
c0100f99:	6a 01                	push   $0x1
c0100f9b:	6a 01                	push   $0x1
c0100f9d:	50                   	push   %eax
c0100f9e:	ff 75 ec             	pushl  -0x14(%ebp)
c0100fa1:	ff 75 f4             	pushl  -0xc(%ebp)
c0100fa4:	e8 00 20 00 00       	call   c0102fa9 <map_pages>
c0100fa9:	83 c4 20             	add    $0x20,%esp
c0100fac:	83 ec 0c             	sub    $0xc,%esp
c0100faf:	ff 75 e8             	pushl  -0x18(%ebp)
c0100fb2:	e8 12 24 00 00       	call   c01033c9 <load_address_space>
c0100fb7:	83 c4 10             	add    $0x10,%esp
      virtaddr=find_free_pages((size/PAGE_SZ)+1);
      map_pages(virtaddr,physaddr,(size/PAGE_SZ)+1,1,1);
    });
  }
  tasking_set_rpc_ret_buf(virtaddr);
c0100fba:	83 ec 0c             	sub    $0xc,%esp
c0100fbd:	ff 75 f4             	pushl  -0xc(%ebp)
c0100fc0:	e8 51 0e 00 00       	call   c0101e16 <tasking_set_rpc_ret_buf>
c0100fc5:	83 c4 10             	add    $0x10,%esp
  tasking_unblock(pid,tid);
c0100fc8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0100fcb:	83 ec 08             	sub    $0x8,%esp
c0100fce:	50                   	push   %eax
c0100fcf:	ff 75 f0             	pushl  -0x10(%ebp)
c0100fd2:	e8 3d 0b 00 00       	call   c0101b14 <tasking_unblock>
c0100fd7:	83 c4 10             	add    $0x10,%esp
}
c0100fda:	90                   	nop
c0100fdb:	c9                   	leave  
c0100fdc:	c3                   	ret    

c0100fdd <kernel_get_num_rpc_funcs>:

size_t kernel_get_num_rpc_funcs(pid_t pid) {
c0100fdd:	55                   	push   %ebp
c0100fde:	89 e5                	mov    %esp,%ebp
  return process_num_funcs[pid];
c0100fe0:	8b 45 08             	mov    0x8(%ebp),%eax
c0100fe3:	8b 04 85 20 10 29 c0 	mov    -0x3fd6efe0(,%eax,4),%eax
}
c0100fea:	5d                   	pop    %ebp
c0100feb:	c3                   	ret    

c0100fec <kernel_rpc_mark_as_init>:

void kernel_rpc_mark_as_init() {
c0100fec:	55                   	push   %ebp
c0100fed:	89 e5                	mov    %esp,%ebp
c0100fef:	53                   	push   %ebx
c0100ff0:	83 ec 14             	sub    $0x14,%esp
  mark_init(tasking_get_PID());
c0100ff3:	e8 9b 05 00 00       	call   c0101593 <tasking_get_PID>
c0100ff8:	83 ec 0c             	sub    $0xc,%esp
c0100ffb:	50                   	push   %eax
c0100ffc:	e8 3e fb ff ff       	call   c0100b3f <mark_init>
c0101001:	83 c4 10             	add    $0x10,%esp
  if (waiting_thread_list) {
c0101004:	a1 20 20 2b c0       	mov    0xc02b2020,%eax
c0101009:	85 c0                	test   %eax,%eax
c010100b:	0f 84 88 00 00 00    	je     c0101099 <kernel_rpc_mark_as_init+0xad>
    rpc_waiting_thread* prev=NULL;
c0101011:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for (rpc_waiting_thread* waiting_thread=waiting_thread_list;waiting_thread!=NULL;waiting_thread=waiting_thread->next) {
c0101018:	a1 20 20 2b c0       	mov    0xc02b2020,%eax
c010101d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0101020:	eb 71                	jmp    c0101093 <kernel_rpc_mark_as_init+0xa7>
      if (waiting_thread->process_waiting_on==tasking_get_PID()) {
c0101022:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101025:	8b 58 08             	mov    0x8(%eax),%ebx
c0101028:	e8 66 05 00 00       	call   c0101593 <tasking_get_PID>
c010102d:	39 c3                	cmp    %eax,%ebx
c010102f:	75 53                	jne    c0101084 <kernel_rpc_mark_as_init+0x98>
        tasking_unblock(waiting_thread->waiting_pid,waiting_thread->waiting_tid);
c0101031:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101034:	8b 50 04             	mov    0x4(%eax),%edx
c0101037:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010103a:	8b 00                	mov    (%eax),%eax
c010103c:	83 ec 08             	sub    $0x8,%esp
c010103f:	52                   	push   %edx
c0101040:	50                   	push   %eax
c0101041:	e8 ce 0a 00 00       	call   c0101b14 <tasking_unblock>
c0101046:	83 c4 10             	add    $0x10,%esp
        if (waiting_thread==waiting_thread_list) {
c0101049:	a1 20 20 2b c0       	mov    0xc02b2020,%eax
c010104e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0101051:	75 0f                	jne    c0101062 <kernel_rpc_mark_as_init+0x76>
          waiting_thread_list=waiting_thread_list->next;
c0101053:	a1 20 20 2b c0       	mov    0xc02b2020,%eax
c0101058:	8b 40 0c             	mov    0xc(%eax),%eax
c010105b:	a3 20 20 2b c0       	mov    %eax,0xc02b2020
c0101060:	eb 12                	jmp    c0101074 <kernel_rpc_mark_as_init+0x88>
        } else if (prev) {
c0101062:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0101066:	74 0c                	je     c0101074 <kernel_rpc_mark_as_init+0x88>
          prev->next=waiting_thread->next;
c0101068:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010106b:	8b 50 0c             	mov    0xc(%eax),%edx
c010106e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101071:	89 50 0c             	mov    %edx,0xc(%eax)
        }
        kfree(waiting_thread);
c0101074:	83 ec 0c             	sub    $0xc,%esp
c0101077:	ff 75 f0             	pushl  -0x10(%ebp)
c010107a:	e8 0d f7 ff ff       	call   c010078c <kfree>
c010107f:	83 c4 10             	add    $0x10,%esp
c0101082:	eb 06                	jmp    c010108a <kernel_rpc_mark_as_init+0x9e>
      } else {
        prev=waiting_thread;
c0101084:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101087:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (rpc_waiting_thread* waiting_thread=waiting_thread_list;waiting_thread!=NULL;waiting_thread=waiting_thread->next) {
c010108a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010108d:	8b 40 0c             	mov    0xc(%eax),%eax
c0101090:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0101093:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0101097:	75 89                	jne    c0101022 <kernel_rpc_mark_as_init+0x36>
      }
    }
  }
}
c0101099:	90                   	nop
c010109a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010109d:	c9                   	leave  
c010109e:	c3                   	ret    

c010109f <is_proc_scheduled>:
/**
 * Check whether a process is scheduled
 * \param index The PID to check
 * \return whether the process is scheduled
 */
static char is_proc_scheduled(pid_t index) {
c010109f:	55                   	push   %ebp
c01010a0:	89 e5                	mov    %esp,%ebp
c01010a2:	53                   	push   %ebx
c01010a3:	83 ec 10             	sub    $0x10,%esp
  size_t byte=index/8;
c01010a6:	8b 45 08             	mov    0x8(%ebp),%eax
c01010a9:	85 c0                	test   %eax,%eax
c01010ab:	79 03                	jns    c01010b0 <is_proc_scheduled+0x11>
c01010ad:	83 c0 07             	add    $0x7,%eax
c01010b0:	c1 f8 03             	sar    $0x3,%eax
c01010b3:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=index%8;
c01010b6:	8b 45 08             	mov    0x8(%ebp),%eax
c01010b9:	25 07 00 00 80       	and    $0x80000007,%eax
c01010be:	85 c0                	test   %eax,%eax
c01010c0:	79 05                	jns    c01010c7 <is_proc_scheduled+0x28>
c01010c2:	48                   	dec    %eax
c01010c3:	83 c8 f8             	or     $0xfffffff8,%eax
c01010c6:	40                   	inc    %eax
c01010c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char entry=proc_schedule_bmap[byte];
c01010ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01010cd:	05 40 90 1c c0       	add    $0xc01c9040,%eax
c01010d2:	8a 00                	mov    (%eax),%al
c01010d4:	88 45 f3             	mov    %al,-0xd(%ebp)
  return (entry&(1<<bit))>0;
c01010d7:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
c01010db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01010de:	bb 01 00 00 00       	mov    $0x1,%ebx
c01010e3:	88 c1                	mov    %al,%cl
c01010e5:	d3 e3                	shl    %cl,%ebx
c01010e7:	89 d8                	mov    %ebx,%eax
c01010e9:	21 d0                	and    %edx,%eax
c01010eb:	85 c0                	test   %eax,%eax
c01010ed:	0f 9f c0             	setg   %al
}
c01010f0:	83 c4 10             	add    $0x10,%esp
c01010f3:	5b                   	pop    %ebx
c01010f4:	5d                   	pop    %ebp
c01010f5:	c3                   	ret    

c01010f6 <mark_proc_scheduled>:

/**
 * Mark a process as scheduled
 * \param index The PID to mark
 */
static void mark_proc_scheduled(pid_t index) {
c01010f6:	55                   	push   %ebp
c01010f7:	89 e5                	mov    %esp,%ebp
c01010f9:	53                   	push   %ebx
c01010fa:	83 ec 14             	sub    $0x14,%esp
  if (is_proc_scheduled(index)) {
c01010fd:	ff 75 08             	pushl  0x8(%ebp)
c0101100:	e8 9a ff ff ff       	call   c010109f <is_proc_scheduled>
c0101105:	83 c4 04             	add    $0x4,%esp
c0101108:	84 c0                	test   %al,%al
c010110a:	74 18                	je     c0101124 <mark_proc_scheduled+0x2e>
    serial_printf("Attempt to schedule a thread in a process with a scheduled thread! (PID %d)\n",index);
c010110c:	83 ec 08             	sub    $0x8,%esp
c010110f:	ff 75 08             	pushl  0x8(%ebp)
c0101112:	68 fc 60 10 c0       	push   $0xc01060fc
c0101117:	e8 39 2d 00 00       	call   c0103e55 <serial_printf>
c010111c:	83 c4 10             	add    $0x10,%esp
    halt();
c010111f:	e8 3c 2f 00 00       	call   c0104060 <halt>
  }
  size_t byte=index/8;
c0101124:	8b 45 08             	mov    0x8(%ebp),%eax
c0101127:	85 c0                	test   %eax,%eax
c0101129:	79 03                	jns    c010112e <mark_proc_scheduled+0x38>
c010112b:	83 c0 07             	add    $0x7,%eax
c010112e:	c1 f8 03             	sar    $0x3,%eax
c0101131:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t bit=index%8;
c0101134:	8b 45 08             	mov    0x8(%ebp),%eax
c0101137:	25 07 00 00 80       	and    $0x80000007,%eax
c010113c:	85 c0                	test   %eax,%eax
c010113e:	79 05                	jns    c0101145 <mark_proc_scheduled+0x4f>
c0101140:	48                   	dec    %eax
c0101141:	83 c8 f8             	or     $0xfffffff8,%eax
c0101144:	40                   	inc    %eax
c0101145:	89 45 f0             	mov    %eax,-0x10(%ebp)
  proc_schedule_bmap[byte]=proc_schedule_bmap[byte]|(1<<bit);
c0101148:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010114b:	05 40 90 1c c0       	add    $0xc01c9040,%eax
c0101150:	8a 10                	mov    (%eax),%dl
c0101152:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101155:	bb 01 00 00 00       	mov    $0x1,%ebx
c010115a:	88 c1                	mov    %al,%cl
c010115c:	d3 e3                	shl    %cl,%ebx
c010115e:	89 d8                	mov    %ebx,%eax
c0101160:	09 c2                	or     %eax,%edx
c0101162:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101165:	05 40 90 1c c0       	add    $0xc01c9040,%eax
c010116a:	88 10                	mov    %dl,(%eax)
}
c010116c:	90                   	nop
c010116d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0101170:	c9                   	leave  
c0101171:	c3                   	ret    

c0101172 <unmark_proc_scheduled>:

/**
 * Unmark a process as scheduled
 * \param index The PID to unmark
 */
static void unmark_proc_scheduled(pid_t index) {
c0101172:	55                   	push   %ebp
c0101173:	89 e5                	mov    %esp,%ebp
c0101175:	53                   	push   %ebx
c0101176:	83 ec 10             	sub    $0x10,%esp
  size_t byte=index/8;
c0101179:	8b 45 08             	mov    0x8(%ebp),%eax
c010117c:	85 c0                	test   %eax,%eax
c010117e:	79 03                	jns    c0101183 <unmark_proc_scheduled+0x11>
c0101180:	83 c0 07             	add    $0x7,%eax
c0101183:	c1 f8 03             	sar    $0x3,%eax
c0101186:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=index%8;
c0101189:	8b 45 08             	mov    0x8(%ebp),%eax
c010118c:	25 07 00 00 80       	and    $0x80000007,%eax
c0101191:	85 c0                	test   %eax,%eax
c0101193:	79 05                	jns    c010119a <unmark_proc_scheduled+0x28>
c0101195:	48                   	dec    %eax
c0101196:	83 c8 f8             	or     $0xfffffff8,%eax
c0101199:	40                   	inc    %eax
c010119a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  proc_schedule_bmap[byte]=proc_schedule_bmap[byte]&(~(1<<bit));
c010119d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01011a0:	05 40 90 1c c0       	add    $0xc01c9040,%eax
c01011a5:	8a 10                	mov    (%eax),%dl
c01011a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01011aa:	bb 01 00 00 00       	mov    $0x1,%ebx
c01011af:	88 c1                	mov    %al,%cl
c01011b1:	d3 e3                	shl    %cl,%ebx
c01011b3:	89 d8                	mov    %ebx,%eax
c01011b5:	f7 d0                	not    %eax
c01011b7:	21 c2                	and    %eax,%edx
c01011b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01011bc:	05 40 90 1c c0       	add    $0xc01c9040,%eax
c01011c1:	88 10                	mov    %dl,(%eax)
}
c01011c3:	90                   	nop
c01011c4:	83 c4 10             	add    $0x10,%esp
c01011c7:	5b                   	pop    %ebx
c01011c8:	5d                   	pop    %ebp
c01011c9:	c3                   	ret    

c01011ca <schedule_thread>:

/**
 * Schedules a thread if the thread's prcess does not have a scheduled thread
 * \param thread The thread to schedule
 */
void schedule_thread(Thread* thread) {
c01011ca:	55                   	push   %ebp
c01011cb:	89 e5                	mov    %esp,%ebp
c01011cd:	83 ec 08             	sub    $0x8,%esp
  if(!is_proc_scheduled(thread->process->pid)) {
c01011d0:	8b 45 08             	mov    0x8(%ebp),%eax
c01011d3:	8b 40 28             	mov    0x28(%eax),%eax
c01011d6:	8b 40 04             	mov    0x4(%eax),%eax
c01011d9:	50                   	push   %eax
c01011da:	e8 c0 fe ff ff       	call   c010109f <is_proc_scheduled>
c01011df:	83 c4 04             	add    $0x4,%esp
c01011e2:	84 c0                	test   %al,%al
c01011e4:	0f 85 b4 00 00 00    	jne    c010129e <schedule_thread+0xd4>
    if (ready_to_run_head) {
c01011ea:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c01011ef:	85 c0                	test   %eax,%eax
c01011f1:	74 5f                	je     c0101252 <schedule_thread+0x88>
      thread->state=THREAD_READY;
c01011f3:	8b 45 08             	mov    0x8(%ebp),%eax
c01011f6:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
      // ready_to_run_tail->next_ready_to_run=thread;
      // thread->prev_ready_to_run=ready_to_run_tail;
      // ready_to_run_tail=thread;
      if (thread==ready_to_run_head) {
c01011fd:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101202:	39 45 08             	cmp    %eax,0x8(%ebp)
c0101205:	75 15                	jne    c010121c <schedule_thread+0x52>
        serial_printf("TASKING DATA STRUCTURES CORRUPT!!!!\n");
c0101207:	83 ec 0c             	sub    $0xc,%esp
c010120a:	68 4c 61 10 c0       	push   $0xc010614c
c010120f:	e8 41 2c 00 00       	call   c0103e55 <serial_printf>
c0101214:	83 c4 10             	add    $0x10,%esp
        halt();
c0101217:	e8 44 2e 00 00       	call   c0104060 <halt>
      }
      thread->next_ready_to_run=ready_to_run_head;
c010121c:	8b 15 2c 20 2b c0    	mov    0xc02b202c,%edx
c0101222:	8b 45 08             	mov    0x8(%ebp),%eax
c0101225:	89 50 20             	mov    %edx,0x20(%eax)
      ready_to_run_head->prev_ready_to_run=thread;
c0101228:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c010122d:	8b 55 08             	mov    0x8(%ebp),%edx
c0101230:	89 50 24             	mov    %edx,0x24(%eax)
      ready_to_run_head=thread;
c0101233:	8b 45 08             	mov    0x8(%ebp),%eax
c0101236:	a3 2c 20 2b c0       	mov    %eax,0xc02b202c
      mark_proc_scheduled(thread->process->pid);
c010123b:	8b 45 08             	mov    0x8(%ebp),%eax
c010123e:	8b 40 28             	mov    0x28(%eax),%eax
c0101241:	8b 40 04             	mov    0x4(%eax),%eax
c0101244:	83 ec 0c             	sub    $0xc,%esp
c0101247:	50                   	push   %eax
c0101248:	e8 a9 fe ff ff       	call   c01010f6 <mark_proc_scheduled>
c010124d:	83 c4 10             	add    $0x10,%esp
    } else {
      thread->state=THREAD_RUNNING;
      current_thread=thread;
    }
  }
}
c0101250:	eb 4c                	jmp    c010129e <schedule_thread+0xd4>
    } else if (current_thread) {
c0101252:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101257:	85 c0                	test   %eax,%eax
c0101259:	74 31                	je     c010128c <schedule_thread+0xc2>
      thread->state=THREAD_READY;
c010125b:	8b 45 08             	mov    0x8(%ebp),%eax
c010125e:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
      ready_to_run_head=thread;
c0101265:	8b 45 08             	mov    0x8(%ebp),%eax
c0101268:	a3 2c 20 2b c0       	mov    %eax,0xc02b202c
      ready_to_run_tail=thread;
c010126d:	8b 45 08             	mov    0x8(%ebp),%eax
c0101270:	a3 30 20 2b c0       	mov    %eax,0xc02b2030
      mark_proc_scheduled(thread->process->pid);
c0101275:	8b 45 08             	mov    0x8(%ebp),%eax
c0101278:	8b 40 28             	mov    0x28(%eax),%eax
c010127b:	8b 40 04             	mov    0x4(%eax),%eax
c010127e:	83 ec 0c             	sub    $0xc,%esp
c0101281:	50                   	push   %eax
c0101282:	e8 6f fe ff ff       	call   c01010f6 <mark_proc_scheduled>
c0101287:	83 c4 10             	add    $0x10,%esp
}
c010128a:	eb 12                	jmp    c010129e <schedule_thread+0xd4>
      thread->state=THREAD_RUNNING;
c010128c:	8b 45 08             	mov    0x8(%ebp),%eax
c010128f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
      current_thread=thread;
c0101296:	8b 45 08             	mov    0x8(%ebp),%eax
c0101299:	a3 20 90 1c c0       	mov    %eax,0xc01c9020
}
c010129e:	90                   	nop
c010129f:	c9                   	leave  
c01012a0:	c3                   	ret    

c01012a1 <tasking_create_task>:

void tasking_create_task(void* eip,void* address_space,char kmode,void* param1,void* param2,char isThread,char is_irq_handler) {
c01012a1:	55                   	push   %ebp
c01012a2:	89 e5                	mov    %esp,%ebp
c01012a4:	83 ec 28             	sub    $0x28,%esp
c01012a7:	8b 4d 10             	mov    0x10(%ebp),%ecx
c01012aa:	8b 55 1c             	mov    0x1c(%ebp),%edx
c01012ad:	8b 45 20             	mov    0x20(%ebp),%eax
c01012b0:	88 4d e4             	mov    %cl,-0x1c(%ebp)
c01012b3:	88 55 e0             	mov    %dl,-0x20(%ebp)
c01012b6:	88 45 dc             	mov    %al,-0x24(%ebp)
  if (next_pid>MAX_PROCS && !isThread) {
c01012b9:	a1 24 20 2b c0       	mov    0xc02b2024,%eax
c01012be:	3d 00 80 00 00       	cmp    $0x8000,%eax
c01012c3:	7e 1b                	jle    c01012e0 <tasking_create_task+0x3f>
c01012c5:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
c01012c9:	75 15                	jne    c01012e0 <tasking_create_task+0x3f>
    serial_printf("Failed to create a process, as 32k processes have been created already.\n");
c01012cb:	83 ec 0c             	sub    $0xc,%esp
c01012ce:	68 74 61 10 c0       	push   $0xc0106174
c01012d3:	e8 7d 2b 00 00       	call   c0103e55 <serial_printf>
c01012d8:	83 c4 10             	add    $0x10,%esp
    halt(); //Cannot ever create more than 32k processes, as I don't currently reuse PIDs.
c01012db:	e8 80 2d 00 00       	call   c0104060 <halt>
  }
  pid_t pid=isThread ? (pid_t)param2 : next_pid++;
c01012e0:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
c01012e4:	75 10                	jne    c01012f6 <tasking_create_task+0x55>
c01012e6:	a1 24 20 2b c0       	mov    0xc02b2024,%eax
c01012eb:	8d 50 01             	lea    0x1(%eax),%edx
c01012ee:	89 15 24 20 2b c0    	mov    %edx,0xc02b2024
c01012f4:	eb 03                	jmp    c01012f9 <tasking_create_task+0x58>
c01012f6:	8b 45 18             	mov    0x18(%ebp),%eax
c01012f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  Process* proc=&processes[pid];
c01012fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01012ff:	89 d0                	mov    %edx,%eax
c0101301:	01 c0                	add    %eax,%eax
c0101303:	01 d0                	add    %edx,%eax
c0101305:	c1 e0 03             	shl    $0x3,%eax
c0101308:	05 20 90 10 c0       	add    $0xc0109020,%eax
c010130d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  Thread* thread=kmalloc(sizeof(Thread));
c0101310:	83 ec 0c             	sub    $0xc,%esp
c0101313:	6a 38                	push   $0x38
c0101315:	e8 07 f3 ff ff       	call   c0100621 <kmalloc>
c010131a:	83 c4 10             	add    $0x10,%esp
c010131d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  proc->num_threads++;
c0101320:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101323:	8b 40 0c             	mov    0xc(%eax),%eax
c0101326:	8d 50 01             	lea    0x1(%eax),%edx
c0101329:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010132c:	89 50 0c             	mov    %edx,0xc(%eax)
  thread->process=proc;
c010132f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101332:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0101335:	89 50 28             	mov    %edx,0x28(%eax)
  thread->errno=0;
c0101338:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010133b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  thread->tid=proc->next_tid++;
c0101342:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101345:	8b 40 08             	mov    0x8(%eax),%eax
c0101348:	8d 48 01             	lea    0x1(%eax),%ecx
c010134b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010134e:	89 4a 08             	mov    %ecx,0x8(%edx)
c0101351:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0101354:	89 42 0c             	mov    %eax,0xc(%edx)
  thread->prev_ready_to_run=NULL;
c0101357:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010135a:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
  thread->next_ready_to_run=NULL;
c0101361:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101364:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  thread->prev_thread_in_process=NULL;
c010136b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010136e:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  thread->state=THREAD_READY;
c0101375:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101378:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
  if (isThread) {
c010137f:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
c0101383:	74 29                	je     c01013ae <tasking_create_task+0x10d>
    thread->address_space=proc->first_thread->address_space;
c0101385:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101388:	8b 40 14             	mov    0x14(%eax),%eax
c010138b:	8b 50 08             	mov    0x8(%eax),%edx
c010138e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101391:	89 50 08             	mov    %edx,0x8(%eax)
    thread->next_thread_in_process=proc->first_thread;
c0101394:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101397:	8b 50 14             	mov    0x14(%eax),%edx
c010139a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010139d:	89 50 18             	mov    %edx,0x18(%eax)
    proc->first_thread->prev_thread_in_process=thread;
c01013a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01013a3:	8b 40 14             	mov    0x14(%eax),%eax
c01013a6:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01013a9:	89 50 1c             	mov    %edx,0x1c(%eax)
c01013ac:	eb 43                	jmp    c01013f1 <tasking_create_task+0x150>
  } else {
    thread->address_space=address_space;
c01013ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01013b1:	8b 55 0c             	mov    0xc(%ebp),%edx
c01013b4:	89 50 08             	mov    %edx,0x8(%eax)
    thread->next_thread_in_process=NULL;
c01013b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01013ba:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
    proc->priv=current_thread ? current_thread->process->priv : 1;
c01013c1:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c01013c6:	85 c0                	test   %eax,%eax
c01013c8:	74 0c                	je     c01013d6 <tasking_create_task+0x135>
c01013ca:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c01013cf:	8b 40 28             	mov    0x28(%eax),%eax
c01013d2:	8a 00                	mov    (%eax),%al
c01013d4:	eb 02                	jmp    c01013d8 <tasking_create_task+0x137>
c01013d6:	b0 01                	mov    $0x1,%al
c01013d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01013db:	88 02                	mov    %al,(%edx)
    proc->pid=pid;
c01013dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01013e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01013e3:	89 50 04             	mov    %edx,0x4(%eax)
    num_procs++;
c01013e6:	a1 28 20 2b c0       	mov    0xc02b2028,%eax
c01013eb:	40                   	inc    %eax
c01013ec:	a3 28 20 2b c0       	mov    %eax,0xc02b2028
  }
  proc->first_thread=thread;
c01013f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01013f4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01013f7:	89 50 14             	mov    %edx,0x14(%eax)
  setup_kstack(thread,param1,param2,kmode,eip,is_irq_handler);
c01013fa:	0f be 55 dc          	movsbl -0x24(%ebp),%edx
c01013fe:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c0101402:	83 ec 08             	sub    $0x8,%esp
c0101405:	52                   	push   %edx
c0101406:	ff 75 08             	pushl  0x8(%ebp)
c0101409:	50                   	push   %eax
c010140a:	ff 75 18             	pushl  0x18(%ebp)
c010140d:	ff 75 14             	pushl  0x14(%ebp)
c0101410:	ff 75 ec             	pushl  -0x14(%ebp)
c0101413:	e8 0a 28 00 00       	call   c0103c22 <setup_kstack>
c0101418:	83 c4 20             	add    $0x20,%esp
  schedule_thread(thread);
c010141b:	83 ec 0c             	sub    $0xc,%esp
c010141e:	ff 75 ec             	pushl  -0x14(%ebp)
c0101421:	e8 a4 fd ff ff       	call   c01011ca <schedule_thread>
c0101426:	83 c4 10             	add    $0x10,%esp
  serial_printf("Created thread with PID %d and TID %d.\n",proc->pid,thread->tid);
c0101429:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010142c:	8b 50 0c             	mov    0xc(%eax),%edx
c010142f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101432:	8b 40 04             	mov    0x4(%eax),%eax
c0101435:	83 ec 04             	sub    $0x4,%esp
c0101438:	52                   	push   %edx
c0101439:	50                   	push   %eax
c010143a:	68 c0 61 10 c0       	push   $0xc01061c0
c010143f:	e8 11 2a 00 00       	call   c0103e55 <serial_printf>
c0101444:	83 c4 10             	add    $0x10,%esp
  serial_printf("Structure values:\n");
c0101447:	83 ec 0c             	sub    $0xc,%esp
c010144a:	68 e8 61 10 c0       	push   $0xc01061e8
c010144f:	e8 01 2a 00 00       	call   c0103e55 <serial_printf>
c0101454:	83 c4 10             	add    $0x10,%esp
  serial_printf("kernel_esp=%x\n",thread->kernel_esp);
c0101457:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010145a:	8b 00                	mov    (%eax),%eax
c010145c:	83 ec 08             	sub    $0x8,%esp
c010145f:	50                   	push   %eax
c0101460:	68 fb 61 10 c0       	push   $0xc01061fb
c0101465:	e8 eb 29 00 00       	call   c0103e55 <serial_printf>
c010146a:	83 c4 10             	add    $0x10,%esp
  serial_printf("kernel_esp_top=%x\n",thread->kernel_esp_top);
c010146d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101470:	8b 40 04             	mov    0x4(%eax),%eax
c0101473:	83 ec 08             	sub    $0x8,%esp
c0101476:	50                   	push   %eax
c0101477:	68 0a 62 10 c0       	push   $0xc010620a
c010147c:	e8 d4 29 00 00       	call   c0103e55 <serial_printf>
c0101481:	83 c4 10             	add    $0x10,%esp
  serial_printf("address_space=%x\n",thread->address_space);
c0101484:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101487:	8b 40 08             	mov    0x8(%eax),%eax
c010148a:	83 ec 08             	sub    $0x8,%esp
c010148d:	50                   	push   %eax
c010148e:	68 1d 62 10 c0       	push   $0xc010621d
c0101493:	e8 bd 29 00 00       	call   c0103e55 <serial_printf>
c0101498:	83 c4 10             	add    $0x10,%esp
  serial_printf("tid=%d\n",thread->tid);
c010149b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010149e:	8b 40 0c             	mov    0xc(%eax),%eax
c01014a1:	83 ec 08             	sub    $0x8,%esp
c01014a4:	50                   	push   %eax
c01014a5:	68 2f 62 10 c0       	push   $0xc010622f
c01014aa:	e8 a6 29 00 00       	call   c0103e55 <serial_printf>
c01014af:	83 c4 10             	add    $0x10,%esp
  serial_printf("state=%d\n",thread->state);
c01014b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01014b5:	8b 40 10             	mov    0x10(%eax),%eax
c01014b8:	83 ec 08             	sub    $0x8,%esp
c01014bb:	50                   	push   %eax
c01014bc:	68 37 62 10 c0       	push   $0xc0106237
c01014c1:	e8 8f 29 00 00       	call   c0103e55 <serial_printf>
c01014c6:	83 c4 10             	add    $0x10,%esp
  serial_printf("next_thread_in_process=%x\n",thread->next_thread_in_process);
c01014c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01014cc:	8b 40 18             	mov    0x18(%eax),%eax
c01014cf:	83 ec 08             	sub    $0x8,%esp
c01014d2:	50                   	push   %eax
c01014d3:	68 41 62 10 c0       	push   $0xc0106241
c01014d8:	e8 78 29 00 00       	call   c0103e55 <serial_printf>
c01014dd:	83 c4 10             	add    $0x10,%esp
  serial_printf("next_ready_to_run=%x\n",thread->next_ready_to_run);
c01014e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01014e3:	8b 40 20             	mov    0x20(%eax),%eax
c01014e6:	83 ec 08             	sub    $0x8,%esp
c01014e9:	50                   	push   %eax
c01014ea:	68 5c 62 10 c0       	push   $0xc010625c
c01014ef:	e8 61 29 00 00       	call   c0103e55 <serial_printf>
c01014f4:	83 c4 10             	add    $0x10,%esp
  serial_printf("prev_ready_to_run=%x\n",thread->prev_ready_to_run);
c01014f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01014fa:	8b 40 24             	mov    0x24(%eax),%eax
c01014fd:	83 ec 08             	sub    $0x8,%esp
c0101500:	50                   	push   %eax
c0101501:	68 72 62 10 c0       	push   $0xc0106272
c0101506:	e8 4a 29 00 00       	call   c0103e55 <serial_printf>
c010150b:	83 c4 10             	add    $0x10,%esp
  serial_printf("process=%x\n",thread->process);
c010150e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101511:	8b 40 28             	mov    0x28(%eax),%eax
c0101514:	83 ec 08             	sub    $0x8,%esp
c0101517:	50                   	push   %eax
c0101518:	68 88 62 10 c0       	push   $0xc0106288
c010151d:	e8 33 29 00 00       	call   c0103e55 <serial_printf>
c0101522:	83 c4 10             	add    $0x10,%esp
}
c0101525:	90                   	nop
c0101526:	c9                   	leave  
c0101527:	c3                   	ret    

c0101528 <tasking_init>:

void tasking_init() {
c0101528:	55                   	push   %ebp
c0101529:	89 e5                	mov    %esp,%ebp
c010152b:	83 ec 18             	sub    $0x18,%esp
  for (size_t i = 0; i < MAX_PROCS; i++) {
c010152e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0101535:	eb 24                	jmp    c010155b <tasking_init+0x33>
    memset(&processes[i],0,sizeof(Process));
c0101537:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010153a:	89 d0                	mov    %edx,%eax
c010153c:	01 c0                	add    %eax,%eax
c010153e:	01 d0                	add    %edx,%eax
c0101540:	c1 e0 03             	shl    $0x3,%eax
c0101543:	05 20 90 10 c0       	add    $0xc0109020,%eax
c0101548:	83 ec 04             	sub    $0x4,%esp
c010154b:	6a 18                	push   $0x18
c010154d:	6a 00                	push   $0x0
c010154f:	50                   	push   %eax
c0101550:	e8 b2 3c 00 00       	call   c0105207 <memset>
c0101555:	83 c4 10             	add    $0x10,%esp
  for (size_t i = 0; i < MAX_PROCS; i++) {
c0101558:	ff 45 f4             	incl   -0xc(%ebp)
c010155b:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
c0101562:	76 d3                	jbe    c0101537 <tasking_init+0xf>
  }

  tasking_create_task(NULL,get_address_space(),1,NULL,NULL,0,0);
c0101564:	e8 a4 21 00 00       	call   c010370d <get_address_space>
c0101569:	83 ec 04             	sub    $0x4,%esp
c010156c:	6a 00                	push   $0x0
c010156e:	6a 00                	push   $0x0
c0101570:	6a 00                	push   $0x0
c0101572:	6a 00                	push   $0x0
c0101574:	6a 01                	push   $0x1
c0101576:	50                   	push   %eax
c0101577:	6a 00                	push   $0x0
c0101579:	e8 23 fd ff ff       	call   c01012a1 <tasking_create_task>
c010157e:	83 c4 20             	add    $0x20,%esp
}
c0101581:	90                   	nop
c0101582:	c9                   	leave  
c0101583:	c3                   	ret    

c0101584 <tasking_is_privleged>:

char tasking_is_privleged() {
c0101584:	55                   	push   %ebp
c0101585:	89 e5                	mov    %esp,%ebp
  return current_thread->process->priv;
c0101587:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c010158c:	8b 40 28             	mov    0x28(%eax),%eax
c010158f:	8a 00                	mov    (%eax),%al
}
c0101591:	5d                   	pop    %ebp
c0101592:	c3                   	ret    

c0101593 <tasking_get_PID>:

pid_t tasking_get_PID() {
c0101593:	55                   	push   %ebp
c0101594:	89 e5                	mov    %esp,%ebp
  return current_thread->process->pid;
c0101596:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c010159b:	8b 40 28             	mov    0x28(%eax),%eax
c010159e:	8b 40 04             	mov    0x4(%eax),%eax
}
c01015a1:	5d                   	pop    %ebp
c01015a2:	c3                   	ret    

c01015a3 <tasking_get_TID>:

pid_t tasking_get_TID() {
c01015a3:	55                   	push   %ebp
c01015a4:	89 e5                	mov    %esp,%ebp
  return current_thread->tid;
c01015a6:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c01015ab:	8b 40 0c             	mov    0xc(%eax),%eax
}
c01015ae:	5d                   	pop    %ebp
c01015af:	c3                   	ret    

c01015b0 <tasking_get_errno_address>:

int* tasking_get_errno_address() {
c01015b0:	55                   	push   %ebp
c01015b1:	89 e5                	mov    %esp,%ebp
  return &current_thread->errno;
c01015b3:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c01015b8:	83 c0 14             	add    $0x14,%eax
}
c01015bb:	5d                   	pop    %ebp
c01015bc:	c3                   	ret    

c01015bd <tasking_new_thread>:

pid_t tasking_new_thread(void* start,pid_t pid,void* param,char is_irq_handler) {
c01015bd:	55                   	push   %ebp
c01015be:	89 e5                	mov    %esp,%ebp
c01015c0:	83 ec 18             	sub    $0x18,%esp
c01015c3:	8b 45 14             	mov    0x14(%ebp),%eax
c01015c6:	88 45 f4             	mov    %al,-0xc(%ebp)
  tasking_create_task(start,NULL,0,param,(void*)pid,1,is_irq_handler);
c01015c9:	0f be 55 f4          	movsbl -0xc(%ebp),%edx
c01015cd:	8b 45 0c             	mov    0xc(%ebp),%eax
c01015d0:	83 ec 04             	sub    $0x4,%esp
c01015d3:	52                   	push   %edx
c01015d4:	6a 01                	push   $0x1
c01015d6:	50                   	push   %eax
c01015d7:	ff 75 10             	pushl  0x10(%ebp)
c01015da:	6a 00                	push   $0x0
c01015dc:	6a 00                	push   $0x0
c01015de:	ff 75 08             	pushl  0x8(%ebp)
c01015e1:	e8 bb fc ff ff       	call   c01012a1 <tasking_create_task>
c01015e6:	83 c4 20             	add    $0x20,%esp
  return processes[pid].first_thread->tid;
c01015e9:	8b 55 0c             	mov    0xc(%ebp),%edx
c01015ec:	89 d0                	mov    %edx,%eax
c01015ee:	01 c0                	add    %eax,%eax
c01015f0:	01 d0                	add    %edx,%eax
c01015f2:	c1 e0 03             	shl    $0x3,%eax
c01015f5:	05 34 90 10 c0       	add    $0xc0109034,%eax
c01015fa:	8b 00                	mov    (%eax),%eax
c01015fc:	8b 40 0c             	mov    0xc(%eax),%eax
}
c01015ff:	c9                   	leave  
c0101600:	c3                   	ret    

c0101601 <get_next_ready_thread>:
 * Get the next ready thread in a list of threads, starting at the specified thread's next thread
 * \param thread The start thread
 * \param thread_to_skip A thread to skip even if it's ready
 * \return the next ready thread
 */
static Thread* get_next_ready_thread(Thread* thread,Thread* thread_to_skip) {
c0101601:	55                   	push   %ebp
c0101602:	89 e5                	mov    %esp,%ebp
c0101604:	83 ec 10             	sub    $0x10,%esp
  while (thread&&(thread->state!=THREAD_READY||thread==thread_to_skip)) { \
    thread=thread->next_thread_in_process; \
  }
  //end define
#endif
  Thread* start_of_list=thread->process->first_thread;
c0101607:	8b 45 08             	mov    0x8(%ebp),%eax
c010160a:	8b 40 28             	mov    0x28(%eax),%eax
c010160d:	8b 40 14             	mov    0x14(%eax),%eax
c0101610:	89 45 fc             	mov    %eax,-0x4(%ebp)
  thread=thread->next_thread_in_process;
c0101613:	8b 45 08             	mov    0x8(%ebp),%eax
c0101616:	8b 40 18             	mov    0x18(%eax),%eax
c0101619:	89 45 08             	mov    %eax,0x8(%ebp)
  HELPER;
c010161c:	eb 09                	jmp    c0101627 <get_next_ready_thread+0x26>
c010161e:	8b 45 08             	mov    0x8(%ebp),%eax
c0101621:	8b 40 18             	mov    0x18(%eax),%eax
c0101624:	89 45 08             	mov    %eax,0x8(%ebp)
c0101627:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010162b:	74 13                	je     c0101640 <get_next_ready_thread+0x3f>
c010162d:	8b 45 08             	mov    0x8(%ebp),%eax
c0101630:	8b 40 10             	mov    0x10(%eax),%eax
c0101633:	83 f8 01             	cmp    $0x1,%eax
c0101636:	75 e6                	jne    c010161e <get_next_ready_thread+0x1d>
c0101638:	8b 45 08             	mov    0x8(%ebp),%eax
c010163b:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010163e:	74 de                	je     c010161e <get_next_ready_thread+0x1d>
  if (!thread) {
c0101640:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0101644:	75 2a                	jne    c0101670 <get_next_ready_thread+0x6f>
    thread=start_of_list;
c0101646:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0101649:	89 45 08             	mov    %eax,0x8(%ebp)
    HELPER;
c010164c:	eb 09                	jmp    c0101657 <get_next_ready_thread+0x56>
c010164e:	8b 45 08             	mov    0x8(%ebp),%eax
c0101651:	8b 40 18             	mov    0x18(%eax),%eax
c0101654:	89 45 08             	mov    %eax,0x8(%ebp)
c0101657:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010165b:	74 13                	je     c0101670 <get_next_ready_thread+0x6f>
c010165d:	8b 45 08             	mov    0x8(%ebp),%eax
c0101660:	8b 40 10             	mov    0x10(%eax),%eax
c0101663:	83 f8 01             	cmp    $0x1,%eax
c0101666:	75 e6                	jne    c010164e <get_next_ready_thread+0x4d>
c0101668:	8b 45 08             	mov    0x8(%ebp),%eax
c010166b:	3b 45 0c             	cmp    0xc(%ebp),%eax
c010166e:	74 de                	je     c010164e <get_next_ready_thread+0x4d>
  }
  return thread;
c0101670:	8b 45 08             	mov    0x8(%ebp),%eax
#undef HELPER
}
c0101673:	c9                   	leave  
c0101674:	c3                   	ret    

c0101675 <switch_to_thread>:

/**
 * Switch to a thread and schedule the next ready thread in the current process, if there is one.
 * \param thread The thread to switch to
 */
void switch_to_thread(Thread* thread) {
c0101675:	55                   	push   %ebp
c0101676:	89 e5                	mov    %esp,%ebp
c0101678:	83 ec 18             	sub    $0x18,%esp
  // Unlink the thread from the list of ready-to-run threads
  if (thread!=ready_to_run_head) {
c010167b:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101680:	39 45 08             	cmp    %eax,0x8(%ebp)
c0101683:	74 2a                	je     c01016af <switch_to_thread+0x3a>
    thread->prev_ready_to_run->next_ready_to_run=thread->next_ready_to_run;
c0101685:	8b 45 08             	mov    0x8(%ebp),%eax
c0101688:	8b 40 24             	mov    0x24(%eax),%eax
c010168b:	8b 55 08             	mov    0x8(%ebp),%edx
c010168e:	8b 52 20             	mov    0x20(%edx),%edx
c0101691:	89 50 20             	mov    %edx,0x20(%eax)
    if (thread->next_ready_to_run) {
c0101694:	8b 45 08             	mov    0x8(%ebp),%eax
c0101697:	8b 40 20             	mov    0x20(%eax),%eax
c010169a:	85 c0                	test   %eax,%eax
c010169c:	74 2f                	je     c01016cd <switch_to_thread+0x58>
      thread->next_ready_to_run->prev_ready_to_run=thread->prev_ready_to_run;
c010169e:	8b 45 08             	mov    0x8(%ebp),%eax
c01016a1:	8b 40 20             	mov    0x20(%eax),%eax
c01016a4:	8b 55 08             	mov    0x8(%ebp),%edx
c01016a7:	8b 52 24             	mov    0x24(%edx),%edx
c01016aa:	89 50 24             	mov    %edx,0x24(%eax)
c01016ad:	eb 1e                	jmp    c01016cd <switch_to_thread+0x58>
    }
  } else {
    ready_to_run_head=thread->next_ready_to_run;
c01016af:	8b 45 08             	mov    0x8(%ebp),%eax
c01016b2:	8b 40 20             	mov    0x20(%eax),%eax
c01016b5:	a3 2c 20 2b c0       	mov    %eax,0xc02b202c
    if (ready_to_run_head==NULL) {
c01016ba:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c01016bf:	85 c0                	test   %eax,%eax
c01016c1:	75 0a                	jne    c01016cd <switch_to_thread+0x58>
      ready_to_run_tail=NULL;
c01016c3:	c7 05 30 20 2b c0 00 	movl   $0x0,0xc02b2030
c01016ca:	00 00 00 
    }
  }
  unmark_proc_scheduled(thread->process->pid);
c01016cd:	8b 45 08             	mov    0x8(%ebp),%eax
c01016d0:	8b 40 28             	mov    0x28(%eax),%eax
c01016d3:	8b 40 04             	mov    0x4(%eax),%eax
c01016d6:	50                   	push   %eax
c01016d7:	e8 96 fa ff ff       	call   c0101172 <unmark_proc_scheduled>
c01016dc:	83 c4 04             	add    $0x4,%esp
  thread->prev_ready_to_run=NULL;
c01016df:	8b 45 08             	mov    0x8(%ebp),%eax
c01016e2:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
  thread->next_ready_to_run=NULL;
c01016e9:	8b 45 08             	mov    0x8(%ebp),%eax
c01016ec:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  if (current_thread->state==THREAD_RUNNING) {
c01016f3:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c01016f8:	8b 40 10             	mov    0x10(%eax),%eax
c01016fb:	85 c0                	test   %eax,%eax
c01016fd:	75 0c                	jne    c010170b <switch_to_thread+0x96>
    current_thread->state=THREAD_READY;
c01016ff:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101704:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
  }
  //Get the next ready thread in the current process
  Thread* current_thread_next_ready=get_next_ready_thread(current_thread,thread);
c010170b:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101710:	ff 75 08             	pushl  0x8(%ebp)
c0101713:	50                   	push   %eax
c0101714:	e8 e8 fe ff ff       	call   c0101601 <get_next_ready_thread>
c0101719:	83 c4 08             	add    $0x8,%esp
c010171c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!current_thread_next_ready) {
c010171f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0101723:	75 11                	jne    c0101736 <switch_to_thread+0xc1>
    //This process is fully blocked, try the process of the thread we're yielding to
    current_thread_next_ready=get_next_ready_thread(thread,thread);
c0101725:	ff 75 08             	pushl  0x8(%ebp)
c0101728:	ff 75 08             	pushl  0x8(%ebp)
c010172b:	e8 d1 fe ff ff       	call   c0101601 <get_next_ready_thread>
c0101730:	83 c4 08             	add    $0x8,%esp
c0101733:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if (current_thread_next_ready) {  
c0101736:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010173a:	74 0e                	je     c010174a <switch_to_thread+0xd5>
    schedule_thread(current_thread_next_ready);
c010173c:	83 ec 0c             	sub    $0xc,%esp
c010173f:	ff 75 f4             	pushl  -0xc(%ebp)
c0101742:	e8 83 fa ff ff       	call   c01011ca <schedule_thread>
c0101747:	83 c4 10             	add    $0x10,%esp
  }
  thread->state=THREAD_RUNNING;
c010174a:	8b 45 08             	mov    0x8(%ebp),%eax
c010174d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  serial_printf("Switching to PID %d TID %d.\n",thread->process->pid,thread->tid);
c0101754:	8b 45 08             	mov    0x8(%ebp),%eax
c0101757:	8b 50 0c             	mov    0xc(%eax),%edx
c010175a:	8b 45 08             	mov    0x8(%ebp),%eax
c010175d:	8b 40 28             	mov    0x28(%eax),%eax
c0101760:	8b 40 04             	mov    0x4(%eax),%eax
c0101763:	83 ec 04             	sub    $0x4,%esp
c0101766:	52                   	push   %edx
c0101767:	50                   	push   %eax
c0101768:	68 94 62 10 c0       	push   $0xc0106294
c010176d:	e8 e3 26 00 00       	call   c0103e55 <serial_printf>
c0101772:	83 c4 10             	add    $0x10,%esp
  switch_to_thread_asm(thread);
c0101775:	83 ec 0c             	sub    $0xc,%esp
c0101778:	ff 75 08             	pushl  0x8(%ebp)
c010177b:	e8 10 2b 00 00       	call   c0104290 <switch_to_thread_asm>
c0101780:	83 c4 10             	add    $0x10,%esp
  if (thread_to_be_freed) {
c0101783:	a1 34 20 2b c0       	mov    0xc02b2034,%eax
c0101788:	85 c0                	test   %eax,%eax
c010178a:	74 65                	je     c01017f1 <switch_to_thread+0x17c>
    serial_printf("Freeing PID %d TID %d.\n",thread_to_be_freed->process->pid,thread_to_be_freed->tid);
c010178c:	a1 34 20 2b c0       	mov    0xc02b2034,%eax
c0101791:	8b 50 0c             	mov    0xc(%eax),%edx
c0101794:	a1 34 20 2b c0       	mov    0xc02b2034,%eax
c0101799:	8b 40 28             	mov    0x28(%eax),%eax
c010179c:	8b 40 04             	mov    0x4(%eax),%eax
c010179f:	83 ec 04             	sub    $0x4,%esp
c01017a2:	52                   	push   %edx
c01017a3:	50                   	push   %eax
c01017a4:	68 b1 62 10 c0       	push   $0xc01062b1
c01017a9:	e8 a7 26 00 00       	call   c0103e55 <serial_printf>
c01017ae:	83 c4 10             	add    $0x10,%esp
    if (thread_to_be_freed->prev_thread_in_process) {
c01017b1:	a1 34 20 2b c0       	mov    0xc02b2034,%eax
c01017b6:	8b 40 1c             	mov    0x1c(%eax),%eax
c01017b9:	85 c0                	test   %eax,%eax
c01017bb:	74 14                	je     c01017d1 <switch_to_thread+0x15c>
      thread_to_be_freed->prev_thread_in_process->next_thread_in_process = thread_to_be_freed->next_thread_in_process;
c01017bd:	8b 15 34 20 2b c0    	mov    0xc02b2034,%edx
c01017c3:	a1 34 20 2b c0       	mov    0xc02b2034,%eax
c01017c8:	8b 40 1c             	mov    0x1c(%eax),%eax
c01017cb:	8b 52 18             	mov    0x18(%edx),%edx
c01017ce:	89 50 18             	mov    %edx,0x18(%eax)
    }
    if (thread_to_be_freed->next_thread_in_process) {
c01017d1:	a1 34 20 2b c0       	mov    0xc02b2034,%eax
c01017d6:	8b 40 18             	mov    0x18(%eax),%eax
c01017d9:	85 c0                	test   %eax,%eax
c01017db:	74 14                	je     c01017f1 <switch_to_thread+0x17c>
      thread_to_be_freed->next_thread_in_process->prev_thread_in_process = thread_to_be_freed->prev_thread_in_process;
c01017dd:	8b 15 34 20 2b c0    	mov    0xc02b2034,%edx
c01017e3:	a1 34 20 2b c0       	mov    0xc02b2034,%eax
c01017e8:	8b 40 18             	mov    0x18(%eax),%eax
c01017eb:	8b 52 1c             	mov    0x1c(%edx),%edx
c01017ee:	89 50 1c             	mov    %edx,0x1c(%eax)
    }
    /* free_kstack(thread_to_be_freed->kernel_esp); */
    /* kfree(thread_to_be_freed); */
  }
}
c01017f1:	90                   	nop
c01017f2:	c9                   	leave  
c01017f3:	c3                   	ret    

c01017f4 <tasking_yield>:

void tasking_yield() {
c01017f4:	55                   	push   %ebp
c01017f5:	89 e5                	mov    %esp,%ebp
c01017f7:	83 ec 08             	sub    $0x8,%esp
  if (ready_to_run_head) {
c01017fa:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c01017ff:	85 c0                	test   %eax,%eax
c0101801:	74 3b                	je     c010183e <tasking_yield+0x4a>
    serial_printf("Attempting to switch to PID %d TID %d\n",ready_to_run_head->process->pid,ready_to_run_head->tid);
c0101803:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101808:	8b 50 0c             	mov    0xc(%eax),%edx
c010180b:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101810:	8b 40 28             	mov    0x28(%eax),%eax
c0101813:	8b 40 04             	mov    0x4(%eax),%eax
c0101816:	83 ec 04             	sub    $0x4,%esp
c0101819:	52                   	push   %edx
c010181a:	50                   	push   %eax
c010181b:	68 cc 62 10 c0       	push   $0xc01062cc
c0101820:	e8 30 26 00 00       	call   c0103e55 <serial_printf>
c0101825:	83 c4 10             	add    $0x10,%esp
    switch_to_thread(ready_to_run_head);
c0101828:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c010182d:	83 ec 0c             	sub    $0xc,%esp
c0101830:	50                   	push   %eax
c0101831:	e8 3f fe ff ff       	call   c0101675 <switch_to_thread>
c0101836:	83 c4 10             	add    $0x10,%esp
c0101839:	e9 c6 00 00 00       	jmp    c0101904 <tasking_yield+0x110>
  } else {
    if (NUM_UNBLOCKED_THREADS(current_thread->process)>1) {
c010183e:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101843:	8b 40 28             	mov    0x28(%eax),%eax
c0101846:	8b 50 0c             	mov    0xc(%eax),%edx
c0101849:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c010184e:	8b 40 28             	mov    0x28(%eax),%eax
c0101851:	8b 40 10             	mov    0x10(%eax),%eax
c0101854:	29 c2                	sub    %eax,%edx
c0101856:	89 d0                	mov    %edx,%eax
c0101858:	83 f8 01             	cmp    $0x1,%eax
c010185b:	7e 15                	jle    c0101872 <tasking_yield+0x7e>
      // Thread* thread=get_next_ready_thread(current_thread,current_thread);
      // schedule_thread(thread);
      // yield();
      serial_printf("The ready to run list is empty, and the current process has other unblocked threads? This is an invalid state! Halting!\n");
c010185d:	83 ec 0c             	sub    $0xc,%esp
c0101860:	68 f4 62 10 c0       	push   $0xc01062f4
c0101865:	e8 eb 25 00 00       	call   c0103e55 <serial_printf>
c010186a:	83 c4 10             	add    $0x10,%esp
      halt();
c010186d:	e8 ee 27 00 00       	call   c0104060 <halt>
    } else if (NUM_UNBLOCKED_THREADS(current_thread->process)==1) {
c0101872:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101877:	8b 40 28             	mov    0x28(%eax),%eax
c010187a:	8b 50 0c             	mov    0xc(%eax),%edx
c010187d:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101882:	8b 40 28             	mov    0x28(%eax),%eax
c0101885:	8b 40 10             	mov    0x10(%eax),%eax
c0101888:	29 c2                	sub    %eax,%edx
c010188a:	89 d0                	mov    %edx,%eax
c010188c:	83 f8 01             	cmp    $0x1,%eax
c010188f:	74 72                	je     c0101903 <tasking_yield+0x10f>
      return;
    } else {
      if (num_procs==0) {
c0101891:	a1 28 20 2b c0       	mov    0xc02b2028,%eax
c0101896:	85 c0                	test   %eax,%eax
c0101898:	75 13                	jne    c01018ad <tasking_yield+0xb9>
        serial_printf("All processes exited, halting\n");
c010189a:	83 ec 0c             	sub    $0xc,%esp
c010189d:	68 70 63 10 c0       	push   $0xc0106370
c01018a2:	e8 ae 25 00 00       	call   c0103e55 <serial_printf>
c01018a7:	83 c4 10             	add    $0x10,%esp
        asm volatile("cli");
c01018aa:	fa                   	cli    
        for(;;);
c01018ab:	eb fe                	jmp    c01018ab <tasking_yield+0xb7>
        halt();
      } else {
        serial_printf("All threads in all processes blocked, waiting for an IRQ which unblocks a thread\n");
c01018ad:	83 ec 0c             	sub    $0xc,%esp
c01018b0:	68 90 63 10 c0       	push   $0xc0106390
c01018b5:	e8 9b 25 00 00       	call   c0103e55 <serial_printf>
c01018ba:	83 c4 10             	add    $0x10,%esp
        // All threads in all processes blocked, so wait for an IRQ whose handler unblocks a thread.
        do { wait_for_unblocked_thread_asm(); } while (ready_to_run_head==NULL);
c01018bd:	e8 34 2a 00 00       	call   c01042f6 <wait_for_unblocked_thread_asm>
c01018c2:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c01018c7:	85 c0                	test   %eax,%eax
c01018c9:	74 f2                	je     c01018bd <tasking_yield+0xc9>
      }
      serial_printf("Attempting to switch to PID %d TID %d\n",ready_to_run_head->process->pid,ready_to_run_head->tid);
c01018cb:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c01018d0:	8b 50 0c             	mov    0xc(%eax),%edx
c01018d3:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c01018d8:	8b 40 28             	mov    0x28(%eax),%eax
c01018db:	8b 40 04             	mov    0x4(%eax),%eax
c01018de:	83 ec 04             	sub    $0x4,%esp
c01018e1:	52                   	push   %edx
c01018e2:	50                   	push   %eax
c01018e3:	68 cc 62 10 c0       	push   $0xc01062cc
c01018e8:	e8 68 25 00 00       	call   c0103e55 <serial_printf>
c01018ed:	83 c4 10             	add    $0x10,%esp
      switch_to_thread(ready_to_run_head);
c01018f0:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c01018f5:	83 ec 0c             	sub    $0xc,%esp
c01018f8:	50                   	push   %eax
c01018f9:	e8 77 fd ff ff       	call   c0101675 <switch_to_thread>
c01018fe:	83 c4 10             	add    $0x10,%esp
c0101901:	eb 01                	jmp    c0101904 <tasking_yield+0x110>
      return;
c0101903:	90                   	nop
    }
  }
}
c0101904:	c9                   	leave  
c0101905:	c3                   	ret    

c0101906 <tasking_block>:

void tasking_block(thread_state newstate) {
c0101906:	55                   	push   %ebp
c0101907:	89 e5                	mov    %esp,%ebp
c0101909:	83 ec 18             	sub    $0x18,%esp
  if (ready_to_run_head==current_thread) {
c010190c:	8b 15 2c 20 2b c0    	mov    0xc02b202c,%edx
c0101912:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101917:	39 c2                	cmp    %eax,%edx
c0101919:	75 20                	jne    c010193b <tasking_block+0x35>
    ready_to_run_head=ready_to_run_head->next_ready_to_run;
c010191b:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101920:	8b 40 20             	mov    0x20(%eax),%eax
c0101923:	a3 2c 20 2b c0       	mov    %eax,0xc02b202c
    if (ready_to_run_head==NULL) {
c0101928:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c010192d:	85 c0                	test   %eax,%eax
c010192f:	75 0a                	jne    c010193b <tasking_block+0x35>
      ready_to_run_tail=NULL;
c0101931:	c7 05 30 20 2b c0 00 	movl   $0x0,0xc02b2030
c0101938:	00 00 00 
    }
  }
  if (ready_to_run_tail==current_thread) {
c010193b:	8b 15 30 20 2b c0    	mov    0xc02b2030,%edx
c0101941:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101946:	39 c2                	cmp    %eax,%edx
c0101948:	75 20                	jne    c010196a <tasking_block+0x64>
    ready_to_run_tail=ready_to_run_tail->prev_ready_to_run;
c010194a:	a1 30 20 2b c0       	mov    0xc02b2030,%eax
c010194f:	8b 40 24             	mov    0x24(%eax),%eax
c0101952:	a3 30 20 2b c0       	mov    %eax,0xc02b2030
    if (ready_to_run_tail==NULL) {
c0101957:	a1 30 20 2b c0       	mov    0xc02b2030,%eax
c010195c:	85 c0                	test   %eax,%eax
c010195e:	75 0a                	jne    c010196a <tasking_block+0x64>
      ready_to_run_head=NULL;
c0101960:	c7 05 2c 20 2b c0 00 	movl   $0x0,0xc02b202c
c0101967:	00 00 00 
    }
  }
  if (ready_to_run_head&&ready_to_run_head->next_ready_to_run) {
c010196a:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c010196f:	85 c0                	test   %eax,%eax
c0101971:	74 5f                	je     c01019d2 <tasking_block+0xcc>
c0101973:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101978:	8b 40 20             	mov    0x20(%eax),%eax
c010197b:	85 c0                	test   %eax,%eax
c010197d:	74 53                	je     c01019d2 <tasking_block+0xcc>
    for (Thread* thread=ready_to_run_head->next_ready_to_run;thread!=NULL;thread=thread->next_ready_to_run) {
c010197f:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101984:	8b 40 20             	mov    0x20(%eax),%eax
c0101987:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010198a:	eb 3d                	jmp    c01019c9 <tasking_block+0xc3>
      if (thread==current_thread) {
c010198c:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101991:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0101994:	75 2a                	jne    c01019c0 <tasking_block+0xba>
        thread->prev_ready_to_run->next_ready_to_run=thread->next_ready_to_run;
c0101996:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101999:	8b 40 24             	mov    0x24(%eax),%eax
c010199c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010199f:	8b 52 20             	mov    0x20(%edx),%edx
c01019a2:	89 50 20             	mov    %edx,0x20(%eax)
        if (thread->next_ready_to_run) {
c01019a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01019a8:	8b 40 20             	mov    0x20(%eax),%eax
c01019ab:	85 c0                	test   %eax,%eax
c01019ad:	74 22                	je     c01019d1 <tasking_block+0xcb>
          thread->next_ready_to_run->prev_ready_to_run=thread->prev_ready_to_run;
c01019af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01019b2:	8b 40 20             	mov    0x20(%eax),%eax
c01019b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01019b8:	8b 52 24             	mov    0x24(%edx),%edx
c01019bb:	89 50 24             	mov    %edx,0x24(%eax)
        }
        break;
c01019be:	eb 11                	jmp    c01019d1 <tasking_block+0xcb>
    for (Thread* thread=ready_to_run_head->next_ready_to_run;thread!=NULL;thread=thread->next_ready_to_run) {
c01019c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01019c3:	8b 40 20             	mov    0x20(%eax),%eax
c01019c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
c01019c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01019cd:	75 bd                	jne    c010198c <tasking_block+0x86>
c01019cf:	eb 01                	jmp    c01019d2 <tasking_block+0xcc>
        break;
c01019d1:	90                   	nop
      }
    }
  }
  for (Thread* thread=current_thread->process->first_thread;thread!=NULL;thread=thread->next_thread_in_process) {
c01019d2:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c01019d7:	8b 40 28             	mov    0x28(%eax),%eax
c01019da:	8b 40 14             	mov    0x14(%eax),%eax
c01019dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01019e0:	eb 24                	jmp    c0101a06 <tasking_block+0x100>
    if (thread->tid==current_thread->tid) {
c01019e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01019e5:	8b 50 0c             	mov    0xc(%eax),%edx
c01019e8:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c01019ed:	8b 40 0c             	mov    0xc(%eax),%eax
c01019f0:	39 c2                	cmp    %eax,%edx
c01019f2:	75 09                	jne    c01019fd <tasking_block+0xf7>
      thread->state=newstate;
c01019f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01019f7:	8b 55 08             	mov    0x8(%ebp),%edx
c01019fa:	89 50 10             	mov    %edx,0x10(%eax)
  for (Thread* thread=current_thread->process->first_thread;thread!=NULL;thread=thread->next_thread_in_process) {
c01019fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101a00:	8b 40 18             	mov    0x18(%eax),%eax
c0101a03:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0101a06:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0101a0a:	75 d6                	jne    c01019e2 <tasking_block+0xdc>
    }
  }
  current_thread->process->num_threads_blocked++;
c0101a0c:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101a11:	8b 40 28             	mov    0x28(%eax),%eax
c0101a14:	8b 50 10             	mov    0x10(%eax),%edx
c0101a17:	42                   	inc    %edx
c0101a18:	89 50 10             	mov    %edx,0x10(%eax)
  if (current_thread->process->num_threads_blocked==current_thread->process->num_threads) {
c0101a1b:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101a20:	8b 40 28             	mov    0x28(%eax),%eax
c0101a23:	8b 50 10             	mov    0x10(%eax),%edx
c0101a26:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101a2b:	8b 40 28             	mov    0x28(%eax),%eax
c0101a2e:	8b 40 0c             	mov    0xc(%eax),%eax
c0101a31:	39 c2                	cmp    %eax,%edx
c0101a33:	75 14                	jne    c0101a49 <tasking_block+0x143>
    unmark_proc_scheduled(current_thread->process->pid);
c0101a35:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101a3a:	8b 40 28             	mov    0x28(%eax),%eax
c0101a3d:	8b 40 04             	mov    0x4(%eax),%eax
c0101a40:	50                   	push   %eax
c0101a41:	e8 2c f7 ff ff       	call   c0101172 <unmark_proc_scheduled>
c0101a46:	83 c4 04             	add    $0x4,%esp
  }
  tasking_yield();
c0101a49:	e8 a6 fd ff ff       	call   c01017f4 <tasking_yield>
}
c0101a4e:	90                   	nop
c0101a4f:	c9                   	leave  
c0101a50:	c3                   	ret    

c0101a51 <get_thread>:
 * Get a thread 
 * \param pid The PID of the thread
 * \param tid The TID of the thread
 * \return the thread wih the specified PID and TID
 */
static Thread* get_thread(pid_t pid,pid_t tid) {
c0101a51:	55                   	push   %ebp
c0101a52:	89 e5                	mov    %esp,%ebp
c0101a54:	83 ec 18             	sub    $0x18,%esp
  if (processes[pid].num_threads==0) {
c0101a57:	8b 55 08             	mov    0x8(%ebp),%edx
c0101a5a:	89 d0                	mov    %edx,%eax
c0101a5c:	01 c0                	add    %eax,%eax
c0101a5e:	01 d0                	add    %edx,%eax
c0101a60:	c1 e0 03             	shl    $0x3,%eax
c0101a63:	05 2c 90 10 c0       	add    $0xc010902c,%eax
c0101a68:	8b 00                	mov    (%eax),%eax
c0101a6a:	85 c0                	test   %eax,%eax
c0101a6c:	75 1d                	jne    c0101a8b <get_thread+0x3a>
    serial_printf("PID %d does not exist!\n",pid);
c0101a6e:	83 ec 08             	sub    $0x8,%esp
c0101a71:	ff 75 08             	pushl  0x8(%ebp)
c0101a74:	68 e2 63 10 c0       	push   $0xc01063e2
c0101a79:	e8 d7 23 00 00       	call   c0103e55 <serial_printf>
c0101a7e:	83 c4 10             	add    $0x10,%esp
    return NULL;
c0101a81:	b8 00 00 00 00       	mov    $0x0,%eax
c0101a86:	e9 87 00 00 00       	jmp    c0101b12 <get_thread+0xc1>
  }
  Thread* thread=processes[pid].first_thread;
c0101a8b:	8b 55 08             	mov    0x8(%ebp),%edx
c0101a8e:	89 d0                	mov    %edx,%eax
c0101a90:	01 c0                	add    %eax,%eax
c0101a92:	01 d0                	add    %edx,%eax
c0101a94:	c1 e0 03             	shl    $0x3,%eax
c0101a97:	05 34 90 10 c0       	add    $0xc0109034,%eax
c0101a9c:	8b 00                	mov    (%eax),%eax
c0101a9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (;thread!=NULL;thread=thread->next_thread_in_process) {
c0101aa1:	eb 14                	jmp    c0101ab7 <get_thread+0x66>
    if (thread->tid==tid) {
c0101aa3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101aa6:	8b 40 0c             	mov    0xc(%eax),%eax
c0101aa9:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0101aac:	74 11                	je     c0101abf <get_thread+0x6e>
  for (;thread!=NULL;thread=thread->next_thread_in_process) {
c0101aae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101ab1:	8b 40 18             	mov    0x18(%eax),%eax
c0101ab4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0101ab7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0101abb:	75 e6                	jne    c0101aa3 <get_thread+0x52>
c0101abd:	eb 01                	jmp    c0101ac0 <get_thread+0x6f>
      break;
c0101abf:	90                   	nop
    }
  }
  if (!thread) {
c0101ac0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0101ac4:	75 1d                	jne    c0101ae3 <get_thread+0x92>
    serial_printf("PID %d TID %d does not exist!\n",pid,thread);
c0101ac6:	83 ec 04             	sub    $0x4,%esp
c0101ac9:	ff 75 f4             	pushl  -0xc(%ebp)
c0101acc:	ff 75 08             	pushl  0x8(%ebp)
c0101acf:	68 fc 63 10 c0       	push   $0xc01063fc
c0101ad4:	e8 7c 23 00 00       	call   c0103e55 <serial_printf>
c0101ad9:	83 c4 10             	add    $0x10,%esp
    return NULL;
c0101adc:	b8 00 00 00 00       	mov    $0x0,%eax
c0101ae1:	eb 2f                	jmp    c0101b12 <get_thread+0xc1>
  }
  if (thread->tid!=tid) {
c0101ae3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101ae6:	8b 40 0c             	mov    0xc(%eax),%eax
c0101ae9:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0101aec:	74 21                	je     c0101b0f <get_thread+0xbe>
    serial_printf("Error! Got wrong thread! (Wanted TID %d, got TID %d)\n",tid,thread->tid);
c0101aee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101af1:	8b 40 0c             	mov    0xc(%eax),%eax
c0101af4:	83 ec 04             	sub    $0x4,%esp
c0101af7:	50                   	push   %eax
c0101af8:	ff 75 0c             	pushl  0xc(%ebp)
c0101afb:	68 1c 64 10 c0       	push   $0xc010641c
c0101b00:	e8 50 23 00 00       	call   c0103e55 <serial_printf>
c0101b05:	83 c4 10             	add    $0x10,%esp
    return NULL;
c0101b08:	b8 00 00 00 00       	mov    $0x0,%eax
c0101b0d:	eb 03                	jmp    c0101b12 <get_thread+0xc1>
  }
  return thread;
c0101b0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0101b12:	c9                   	leave  
c0101b13:	c3                   	ret    

c0101b14 <tasking_unblock>:

void tasking_unblock(pid_t pid,pid_t tid) {
c0101b14:	55                   	push   %ebp
c0101b15:	89 e5                	mov    %esp,%ebp
c0101b17:	83 ec 18             	sub    $0x18,%esp
  serial_printf("Unblocking PID %d TID %d\n",pid,tid);
c0101b1a:	83 ec 04             	sub    $0x4,%esp
c0101b1d:	ff 75 0c             	pushl  0xc(%ebp)
c0101b20:	ff 75 08             	pushl  0x8(%ebp)
c0101b23:	68 52 64 10 c0       	push   $0xc0106452
c0101b28:	e8 28 23 00 00       	call   c0103e55 <serial_printf>
c0101b2d:	83 c4 10             	add    $0x10,%esp
  Thread* thread=get_thread(pid,tid);
c0101b30:	83 ec 08             	sub    $0x8,%esp
c0101b33:	ff 75 0c             	pushl  0xc(%ebp)
c0101b36:	ff 75 08             	pushl  0x8(%ebp)
c0101b39:	e8 13 ff ff ff       	call   c0101a51 <get_thread>
c0101b3e:	83 c4 10             	add    $0x10,%esp
c0101b41:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (thread==NULL) {
c0101b44:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0101b48:	74 59                	je     c0101ba3 <tasking_unblock+0x8f>
    return;
  }
  if (thread->state==THREAD_EXITED||thread->state==THREAD_READY||thread->state==THREAD_RUNNING) {
c0101b4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101b4d:	8b 40 10             	mov    0x10(%eax),%eax
c0101b50:	83 f8 02             	cmp    $0x2,%eax
c0101b53:	74 15                	je     c0101b6a <tasking_unblock+0x56>
c0101b55:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101b58:	8b 40 10             	mov    0x10(%eax),%eax
c0101b5b:	83 f8 01             	cmp    $0x1,%eax
c0101b5e:	74 0a                	je     c0101b6a <tasking_unblock+0x56>
c0101b60:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101b63:	8b 40 10             	mov    0x10(%eax),%eax
c0101b66:	85 c0                	test   %eax,%eax
c0101b68:	75 12                	jne    c0101b7c <tasking_unblock+0x68>
    serial_printf("Tried to unblock an exited/ready/running thread!\n");
c0101b6a:	83 ec 0c             	sub    $0xc,%esp
c0101b6d:	68 6c 64 10 c0       	push   $0xc010646c
c0101b72:	e8 de 22 00 00       	call   c0103e55 <serial_printf>
c0101b77:	83 c4 10             	add    $0x10,%esp
    return;
c0101b7a:	eb 28                	jmp    c0101ba4 <tasking_unblock+0x90>
  }
  thread->state=THREAD_READY;
c0101b7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101b7f:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
  thread->process->num_threads_blocked--;
c0101b86:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101b89:	8b 40 28             	mov    0x28(%eax),%eax
c0101b8c:	8b 50 10             	mov    0x10(%eax),%edx
c0101b8f:	4a                   	dec    %edx
c0101b90:	89 50 10             	mov    %edx,0x10(%eax)
  schedule_thread(thread);
c0101b93:	83 ec 0c             	sub    $0xc,%esp
c0101b96:	ff 75 f4             	pushl  -0xc(%ebp)
c0101b99:	e8 2c f6 ff ff       	call   c01011ca <schedule_thread>
c0101b9e:	83 c4 10             	add    $0x10,%esp
c0101ba1:	eb 01                	jmp    c0101ba4 <tasking_unblock+0x90>
    return;
c0101ba3:	90                   	nop
}
c0101ba4:	c9                   	leave  
c0101ba5:	c3                   	ret    

c0101ba6 <tasking_exit>:

void tasking_exit(int code) {
c0101ba6:	55                   	push   %ebp
c0101ba7:	89 e5                	mov    %esp,%ebp
c0101ba9:	83 ec 18             	sub    $0x18,%esp
  serial_printf("PID %d is exiting with code %d.\n",current_thread->process->pid,code);
c0101bac:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101bb1:	8b 40 28             	mov    0x28(%eax),%eax
c0101bb4:	8b 40 04             	mov    0x4(%eax),%eax
c0101bb7:	83 ec 04             	sub    $0x4,%esp
c0101bba:	ff 75 08             	pushl  0x8(%ebp)
c0101bbd:	50                   	push   %eax
c0101bbe:	68 a0 64 10 c0       	push   $0xc01064a0
c0101bc3:	e8 8d 22 00 00       	call   c0103e55 <serial_printf>
c0101bc8:	83 c4 10             	add    $0x10,%esp
  if (ready_to_run_head&&SAME_PROC(ready_to_run_head,current_thread)) {
c0101bcb:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101bd0:	85 c0                	test   %eax,%eax
c0101bd2:	74 3a                	je     c0101c0e <tasking_exit+0x68>
c0101bd4:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101bd9:	8b 40 28             	mov    0x28(%eax),%eax
c0101bdc:	8b 50 04             	mov    0x4(%eax),%edx
c0101bdf:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101be4:	8b 40 28             	mov    0x28(%eax),%eax
c0101be7:	8b 40 04             	mov    0x4(%eax),%eax
c0101bea:	39 c2                	cmp    %eax,%edx
c0101bec:	75 20                	jne    c0101c0e <tasking_exit+0x68>
    ready_to_run_head=ready_to_run_head->next_ready_to_run;
c0101bee:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101bf3:	8b 40 20             	mov    0x20(%eax),%eax
c0101bf6:	a3 2c 20 2b c0       	mov    %eax,0xc02b202c
    if (ready_to_run_head==NULL) {
c0101bfb:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101c00:	85 c0                	test   %eax,%eax
c0101c02:	75 0a                	jne    c0101c0e <tasking_exit+0x68>
      ready_to_run_tail=NULL;
c0101c04:	c7 05 30 20 2b c0 00 	movl   $0x0,0xc02b2030
c0101c0b:	00 00 00 
    }
  }
  if (ready_to_run_tail&&SAME_PROC(ready_to_run_tail,current_thread)) {
c0101c0e:	a1 30 20 2b c0       	mov    0xc02b2030,%eax
c0101c13:	85 c0                	test   %eax,%eax
c0101c15:	74 3a                	je     c0101c51 <tasking_exit+0xab>
c0101c17:	a1 30 20 2b c0       	mov    0xc02b2030,%eax
c0101c1c:	8b 40 28             	mov    0x28(%eax),%eax
c0101c1f:	8b 50 04             	mov    0x4(%eax),%edx
c0101c22:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101c27:	8b 40 28             	mov    0x28(%eax),%eax
c0101c2a:	8b 40 04             	mov    0x4(%eax),%eax
c0101c2d:	39 c2                	cmp    %eax,%edx
c0101c2f:	75 20                	jne    c0101c51 <tasking_exit+0xab>
    ready_to_run_tail=ready_to_run_tail->prev_ready_to_run;
c0101c31:	a1 30 20 2b c0       	mov    0xc02b2030,%eax
c0101c36:	8b 40 24             	mov    0x24(%eax),%eax
c0101c39:	a3 30 20 2b c0       	mov    %eax,0xc02b2030
    if (ready_to_run_tail==NULL) {
c0101c3e:	a1 30 20 2b c0       	mov    0xc02b2030,%eax
c0101c43:	85 c0                	test   %eax,%eax
c0101c45:	75 0a                	jne    c0101c51 <tasking_exit+0xab>
      ready_to_run_head=NULL;
c0101c47:	c7 05 2c 20 2b c0 00 	movl   $0x0,0xc02b202c
c0101c4e:	00 00 00 

    }
  }
  if (ready_to_run_head&&ready_to_run_head->next_ready_to_run) {
c0101c51:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101c56:	85 c0                	test   %eax,%eax
c0101c58:	74 6d                	je     c0101cc7 <tasking_exit+0x121>
c0101c5a:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101c5f:	8b 40 20             	mov    0x20(%eax),%eax
c0101c62:	85 c0                	test   %eax,%eax
c0101c64:	74 61                	je     c0101cc7 <tasking_exit+0x121>
    for (Thread* thread=ready_to_run_head->next_ready_to_run;thread!=NULL;thread=thread->next_ready_to_run) {
c0101c66:	a1 2c 20 2b c0       	mov    0xc02b202c,%eax
c0101c6b:	8b 40 20             	mov    0x20(%eax),%eax
c0101c6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0101c71:	eb 4b                	jmp    c0101cbe <tasking_exit+0x118>
      if (SAME_PROC(thread,current_thread)) {
c0101c73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101c76:	8b 40 28             	mov    0x28(%eax),%eax
c0101c79:	8b 50 04             	mov    0x4(%eax),%edx
c0101c7c:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101c81:	8b 40 28             	mov    0x28(%eax),%eax
c0101c84:	8b 40 04             	mov    0x4(%eax),%eax
c0101c87:	39 c2                	cmp    %eax,%edx
c0101c89:	75 2a                	jne    c0101cb5 <tasking_exit+0x10f>
        thread->prev_ready_to_run->next_ready_to_run=thread->next_ready_to_run;
c0101c8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101c8e:	8b 40 24             	mov    0x24(%eax),%eax
c0101c91:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101c94:	8b 52 20             	mov    0x20(%edx),%edx
c0101c97:	89 50 20             	mov    %edx,0x20(%eax)
        if (thread->next_ready_to_run) {
c0101c9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101c9d:	8b 40 20             	mov    0x20(%eax),%eax
c0101ca0:	85 c0                	test   %eax,%eax
c0101ca2:	74 22                	je     c0101cc6 <tasking_exit+0x120>
          thread->next_ready_to_run->prev_ready_to_run=thread->prev_ready_to_run;
c0101ca4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101ca7:	8b 40 20             	mov    0x20(%eax),%eax
c0101caa:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101cad:	8b 52 24             	mov    0x24(%edx),%edx
c0101cb0:	89 50 24             	mov    %edx,0x24(%eax)
        }
        break;
c0101cb3:	eb 11                	jmp    c0101cc6 <tasking_exit+0x120>
    for (Thread* thread=ready_to_run_head->next_ready_to_run;thread!=NULL;thread=thread->next_ready_to_run) {
c0101cb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101cb8:	8b 40 20             	mov    0x20(%eax),%eax
c0101cbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0101cbe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0101cc2:	75 af                	jne    c0101c73 <tasking_exit+0xcd>
c0101cc4:	eb 01                	jmp    c0101cc7 <tasking_exit+0x121>
        break;
c0101cc6:	90                   	nop
      }
    }
  }
  unmark_proc_scheduled(current_thread->process->pid);
c0101cc7:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101ccc:	8b 40 28             	mov    0x28(%eax),%eax
c0101ccf:	8b 40 04             	mov    0x4(%eax),%eax
c0101cd2:	83 ec 0c             	sub    $0xc,%esp
c0101cd5:	50                   	push   %eax
c0101cd6:	e8 97 f4 ff ff       	call   c0101172 <unmark_proc_scheduled>
c0101cdb:	83 c4 10             	add    $0x10,%esp
  for (Thread* thread=current_thread->process->first_thread;thread!=NULL;thread=thread->next_thread_in_process) {
c0101cde:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101ce3:	8b 40 28             	mov    0x28(%eax),%eax
c0101ce6:	8b 40 14             	mov    0x14(%eax),%eax
c0101ce9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0101cec:	e9 81 00 00 00       	jmp    c0101d72 <tasking_exit+0x1cc>
    if (thread->state!=THREAD_EXITED) {
c0101cf1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101cf4:	8b 40 10             	mov    0x10(%eax),%eax
c0101cf7:	83 f8 02             	cmp    $0x2,%eax
c0101cfa:	74 6d                	je     c0101d69 <tasking_exit+0x1c3>
      thread->state=THREAD_EXITED;
c0101cfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101cff:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
      if (thread==current_thread->process->first_thread && kernel_rpc_is_init(current_thread->process->pid)) {
c0101d06:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101d0b:	8b 40 28             	mov    0x28(%eax),%eax
c0101d0e:	8b 40 14             	mov    0x14(%eax),%eax
c0101d11:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0101d14:	75 1b                	jne    c0101d31 <tasking_exit+0x18b>
c0101d16:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101d1b:	8b 40 28             	mov    0x28(%eax),%eax
c0101d1e:	8b 40 04             	mov    0x4(%eax),%eax
c0101d21:	83 ec 0c             	sub    $0xc,%esp
c0101d24:	50                   	push   %eax
c0101d25:	e8 6b ee ff ff       	call   c0100b95 <kernel_rpc_is_init>
c0101d2a:	83 c4 10             	add    $0x10,%esp
c0101d2d:	84 c0                	test   %al,%al
c0101d2f:	75 37                	jne    c0101d68 <tasking_exit+0x1c2>
        continue;
      }
      if (thread!=current_thread) {
c0101d31:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101d36:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0101d39:	74 21                	je     c0101d5c <tasking_exit+0x1b6>
        free_kstack(thread->kernel_esp);
c0101d3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101d3e:	8b 00                	mov    (%eax),%eax
c0101d40:	83 ec 0c             	sub    $0xc,%esp
c0101d43:	50                   	push   %eax
c0101d44:	e8 78 20 00 00       	call   c0103dc1 <free_kstack>
c0101d49:	83 c4 10             	add    $0x10,%esp
        kfree(thread);
c0101d4c:	83 ec 0c             	sub    $0xc,%esp
c0101d4f:	ff 75 f0             	pushl  -0x10(%ebp)
c0101d52:	e8 35 ea ff ff       	call   c010078c <kfree>
c0101d57:	83 c4 10             	add    $0x10,%esp
c0101d5a:	eb 0d                	jmp    c0101d69 <tasking_exit+0x1c3>
      } else {
        thread_to_be_freed = current_thread;
c0101d5c:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101d61:	a3 34 20 2b c0       	mov    %eax,0xc02b2034
c0101d66:	eb 01                	jmp    c0101d69 <tasking_exit+0x1c3>
        continue;
c0101d68:	90                   	nop
  for (Thread* thread=current_thread->process->first_thread;thread!=NULL;thread=thread->next_thread_in_process) {
c0101d69:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101d6c:	8b 40 18             	mov    0x18(%eax),%eax
c0101d6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0101d72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0101d76:	0f 85 75 ff ff ff    	jne    c0101cf1 <tasking_exit+0x14b>
      }
    }
  }
  current_thread->process->num_threads_blocked=current_thread->process->num_threads;
c0101d7c:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101d81:	8b 50 28             	mov    0x28(%eax),%edx
c0101d84:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101d89:	8b 40 28             	mov    0x28(%eax),%eax
c0101d8c:	8b 52 0c             	mov    0xc(%edx),%edx
c0101d8f:	89 50 10             	mov    %edx,0x10(%eax)
  num_procs--;
c0101d92:	a1 28 20 2b c0       	mov    0xc02b2028,%eax
c0101d97:	48                   	dec    %eax
c0101d98:	a3 28 20 2b c0       	mov    %eax,0xc02b2028
  tasking_yield();
c0101d9d:	e8 52 fa ff ff       	call   c01017f4 <tasking_yield>
}
c0101da2:	90                   	nop
c0101da3:	c9                   	leave  
c0101da4:	c3                   	ret    

c0101da5 <tasking_get_address_space>:

void* tasking_get_address_space(pid_t pid) {
c0101da5:	55                   	push   %ebp
c0101da6:	89 e5                	mov    %esp,%ebp
  return processes[pid].first_thread->address_space;
c0101da8:	8b 55 08             	mov    0x8(%ebp),%edx
c0101dab:	89 d0                	mov    %edx,%eax
c0101dad:	01 c0                	add    %eax,%eax
c0101daf:	01 d0                	add    %edx,%eax
c0101db1:	c1 e0 03             	shl    $0x3,%eax
c0101db4:	05 34 90 10 c0       	add    $0xc0109034,%eax
c0101db9:	8b 00                	mov    (%eax),%eax
c0101dbb:	8b 40 08             	mov    0x8(%eax),%eax
}
c0101dbe:	5d                   	pop    %ebp
c0101dbf:	c3                   	ret    

c0101dc0 <tasking_set_rpc_calling_thread>:

void tasking_set_rpc_calling_thread(pid_t pid,pid_t tid) {
c0101dc0:	55                   	push   %ebp
c0101dc1:	89 e5                	mov    %esp,%ebp
c0101dc3:	83 ec 18             	sub    $0x18,%esp
  Thread* thread=get_thread(pid,tid);
c0101dc6:	83 ec 08             	sub    $0x8,%esp
c0101dc9:	ff 75 0c             	pushl  0xc(%ebp)
c0101dcc:	ff 75 08             	pushl  0x8(%ebp)
c0101dcf:	e8 7d fc ff ff       	call   c0101a51 <get_thread>
c0101dd4:	83 c4 10             	add    $0x10,%esp
c0101dd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  thread->rpc_calling_pid=current_thread->process->pid;
c0101dda:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101ddf:	8b 40 28             	mov    0x28(%eax),%eax
c0101de2:	8b 50 04             	mov    0x4(%eax),%edx
c0101de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101de8:	89 50 2c             	mov    %edx,0x2c(%eax)
  thread->rpc_calling_tid=current_thread->tid;
c0101deb:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101df0:	8b 50 0c             	mov    0xc(%eax),%edx
c0101df3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101df6:	89 50 30             	mov    %edx,0x30(%eax)
}
c0101df9:	90                   	nop
c0101dfa:	c9                   	leave  
c0101dfb:	c3                   	ret    

c0101dfc <tasking_get_rpc_calling_thread>:

pid_t tasking_get_rpc_calling_thread(pid_t* tid) {
c0101dfc:	55                   	push   %ebp
c0101dfd:	89 e5                	mov    %esp,%ebp
  *tid=current_thread->rpc_calling_tid;
c0101dff:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101e04:	8b 50 30             	mov    0x30(%eax),%edx
c0101e07:	8b 45 08             	mov    0x8(%ebp),%eax
c0101e0a:	89 10                	mov    %edx,(%eax)
  return current_thread->rpc_calling_pid;
c0101e0c:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101e11:	8b 40 2c             	mov    0x2c(%eax),%eax
} 
c0101e14:	5d                   	pop    %ebp
c0101e15:	c3                   	ret    

c0101e16 <tasking_set_rpc_ret_buf>:

void tasking_set_rpc_ret_buf(void* buf) {
c0101e16:	55                   	push   %ebp
c0101e17:	89 e5                	mov    %esp,%ebp
c0101e19:	83 ec 18             	sub    $0x18,%esp
  pid_t tid;
  pid_t pid=tasking_get_rpc_calling_thread(&tid);
c0101e1c:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0101e1f:	50                   	push   %eax
c0101e20:	e8 d7 ff ff ff       	call   c0101dfc <tasking_get_rpc_calling_thread>
c0101e25:	83 c4 04             	add    $0x4,%esp
c0101e28:	89 45 f4             	mov    %eax,-0xc(%ebp)
  Thread* thread=get_thread(pid,tid);
c0101e2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101e2e:	83 ec 08             	sub    $0x8,%esp
c0101e31:	50                   	push   %eax
c0101e32:	ff 75 f4             	pushl  -0xc(%ebp)
c0101e35:	e8 17 fc ff ff       	call   c0101a51 <get_thread>
c0101e3a:	83 c4 10             	add    $0x10,%esp
c0101e3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  thread->rpc_ret_buf=buf;
c0101e40:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101e43:	8b 55 08             	mov    0x8(%ebp),%edx
c0101e46:	89 50 34             	mov    %edx,0x34(%eax)
}
c0101e49:	90                   	nop
c0101e4a:	c9                   	leave  
c0101e4b:	c3                   	ret    

c0101e4c <tasking_get_rpc_ret_buf>:

void* tasking_get_rpc_ret_buf() {
c0101e4c:	55                   	push   %ebp
c0101e4d:	89 e5                	mov    %esp,%ebp
  return current_thread->rpc_ret_buf;
c0101e4f:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101e54:	8b 40 34             	mov    0x34(%eax),%eax
}
c0101e57:	5d                   	pop    %ebp
c0101e58:	c3                   	ret    

c0101e59 <tasking_thread_exit>:

void tasking_thread_exit() {
c0101e59:	55                   	push   %ebp
c0101e5a:	89 e5                	mov    %esp,%ebp
c0101e5c:	83 ec 08             	sub    $0x8,%esp
  serial_printf("PID %d TID %d is exiting\n",current_thread->process->pid,current_thread->tid);
c0101e5f:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101e64:	8b 50 0c             	mov    0xc(%eax),%edx
c0101e67:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101e6c:	8b 40 28             	mov    0x28(%eax),%eax
c0101e6f:	8b 40 04             	mov    0x4(%eax),%eax
c0101e72:	83 ec 04             	sub    $0x4,%esp
c0101e75:	52                   	push   %edx
c0101e76:	50                   	push   %eax
c0101e77:	68 c1 64 10 c0       	push   $0xc01064c1
c0101e7c:	e8 d4 1f 00 00       	call   c0103e55 <serial_printf>
c0101e81:	83 c4 10             	add    $0x10,%esp
  tasking_block(THREAD_EXITED);
c0101e84:	83 ec 0c             	sub    $0xc,%esp
c0101e87:	6a 02                	push   $0x2
c0101e89:	e8 78 fa ff ff       	call   c0101906 <tasking_block>
c0101e8e:	83 c4 10             	add    $0x10,%esp
  thread_to_be_freed=current_thread;
c0101e91:	a1 20 90 1c c0       	mov    0xc01c9020,%eax
c0101e96:	a3 34 20 2b c0       	mov    %eax,0xc02b2034
}
c0101e9b:	90                   	nop
c0101e9c:	c9                   	leave  
c0101e9d:	c3                   	ret    

c0101e9e <tasking_check_proc_exists>:

char tasking_check_proc_exists(pid_t pid) {
c0101e9e:	55                   	push   %ebp
c0101e9f:	89 e5                	mov    %esp,%ebp
c0101ea1:	83 ec 18             	sub    $0x18,%esp
  if (processes[pid].num_threads==0) {
c0101ea4:	8b 55 08             	mov    0x8(%ebp),%edx
c0101ea7:	89 d0                	mov    %edx,%eax
c0101ea9:	01 c0                	add    %eax,%eax
c0101eab:	01 d0                	add    %edx,%eax
c0101ead:	c1 e0 03             	shl    $0x3,%eax
c0101eb0:	05 2c 90 10 c0       	add    $0xc010902c,%eax
c0101eb5:	8b 00                	mov    (%eax),%eax
c0101eb7:	85 c0                	test   %eax,%eax
c0101eb9:	75 04                	jne    c0101ebf <tasking_check_proc_exists+0x21>
    return 0;
c0101ebb:	b0 00                	mov    $0x0,%al
c0101ebd:	eb 71                	jmp    c0101f30 <tasking_check_proc_exists+0x92>
  }
  char num_exited_threads=0;
c0101ebf:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  for (Thread* thread=processes[pid].first_thread;thread!=NULL;thread=thread->next_thread_in_process) {
c0101ec3:	8b 55 08             	mov    0x8(%ebp),%edx
c0101ec6:	89 d0                	mov    %edx,%eax
c0101ec8:	01 c0                	add    %eax,%eax
c0101eca:	01 d0                	add    %edx,%eax
c0101ecc:	c1 e0 03             	shl    $0x3,%eax
c0101ecf:	05 34 90 10 c0       	add    $0xc0109034,%eax
c0101ed4:	8b 00                	mov    (%eax),%eax
c0101ed6:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0101ed9:	eb 1b                	jmp    c0101ef6 <tasking_check_proc_exists+0x58>
    if (thread->state==THREAD_EXITED) {
c0101edb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101ede:	8b 40 10             	mov    0x10(%eax),%eax
c0101ee1:	83 f8 02             	cmp    $0x2,%eax
c0101ee4:	75 07                	jne    c0101eed <tasking_check_proc_exists+0x4f>
      num_exited_threads++;
c0101ee6:	8a 45 f7             	mov    -0x9(%ebp),%al
c0101ee9:	40                   	inc    %eax
c0101eea:	88 45 f7             	mov    %al,-0x9(%ebp)
  for (Thread* thread=processes[pid].first_thread;thread!=NULL;thread=thread->next_thread_in_process) {
c0101eed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101ef0:	8b 40 18             	mov    0x18(%eax),%eax
c0101ef3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0101ef6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0101efa:	75 df                	jne    c0101edb <tasking_check_proc_exists+0x3d>
    }
  }
  if ((num_exited_threads=processes[pid].num_threads)&&kernel_get_num_rpc_funcs(pid)==0) {
c0101efc:	8b 55 08             	mov    0x8(%ebp),%edx
c0101eff:	89 d0                	mov    %edx,%eax
c0101f01:	01 c0                	add    %eax,%eax
c0101f03:	01 d0                	add    %edx,%eax
c0101f05:	c1 e0 03             	shl    $0x3,%eax
c0101f08:	05 2c 90 10 c0       	add    $0xc010902c,%eax
c0101f0d:	8b 00                	mov    (%eax),%eax
c0101f0f:	88 45 f7             	mov    %al,-0x9(%ebp)
c0101f12:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0101f16:	74 16                	je     c0101f2e <tasking_check_proc_exists+0x90>
c0101f18:	83 ec 0c             	sub    $0xc,%esp
c0101f1b:	ff 75 08             	pushl  0x8(%ebp)
c0101f1e:	e8 ba f0 ff ff       	call   c0100fdd <kernel_get_num_rpc_funcs>
c0101f23:	83 c4 10             	add    $0x10,%esp
c0101f26:	85 c0                	test   %eax,%eax
c0101f28:	75 04                	jne    c0101f2e <tasking_check_proc_exists+0x90>
    return 0;
c0101f2a:	b0 00                	mov    $0x0,%al
c0101f2c:	eb 02                	jmp    c0101f30 <tasking_check_proc_exists+0x92>
  } else {
    return 1;
c0101f2e:	b0 01                	mov    $0x1,%al
  }
}
c0101f30:	c9                   	leave  
c0101f31:	c3                   	ret    

c0101f32 <timer_handler>:

/**
 * Interrupt handler for the timer interrupt
 * \param r The saved state of the CPU when the interrupt occured
*/
void timer_handler(registers_t* r) {
c0101f32:	55                   	push   %ebp
c0101f33:	89 e5                	mov    %esp,%ebp
c0101f35:	83 ec 08             	sub    $0x8,%esp
  tasking_yield();
c0101f38:	e8 b7 f8 ff ff       	call   c01017f4 <tasking_yield>
}
c0101f3d:	90                   	nop
c0101f3e:	c9                   	leave  
c0101f3f:	c3                   	ret    

c0101f40 <set_char>:
/**
 * Set a character on the screen
 * \param x The character index to set
 * \param c The character to write 
*/
static void set_char(int x,char c) {
c0101f40:	55                   	push   %ebp
c0101f41:	89 e5                	mov    %esp,%ebp
c0101f43:	83 ec 04             	sub    $0x4,%esp
c0101f46:	8b 45 0c             	mov    0xc(%ebp),%eax
c0101f49:	88 45 fc             	mov    %al,-0x4(%ebp)
  screen[x*2]=c;
c0101f4c:	8b 15 38 20 2b c0    	mov    0xc02b2038,%edx
c0101f52:	8b 45 08             	mov    0x8(%ebp),%eax
c0101f55:	01 c0                	add    %eax,%eax
c0101f57:	01 c2                	add    %eax,%edx
c0101f59:	8a 45 fc             	mov    -0x4(%ebp),%al
c0101f5c:	88 02                	mov    %al,(%edx)
  screen[x*2+1]=(VGA_BLACK<<4)|VGA_WHITE;
c0101f5e:	8b 15 38 20 2b c0    	mov    0xc02b2038,%edx
c0101f64:	8b 45 08             	mov    0x8(%ebp),%eax
c0101f67:	01 c0                	add    %eax,%eax
c0101f69:	40                   	inc    %eax
c0101f6a:	01 d0                	add    %edx,%eax
c0101f6c:	c6 00 0f             	movb   $0xf,(%eax)
}
c0101f6f:	90                   	nop
c0101f70:	c9                   	leave  
c0101f71:	c3                   	ret    

c0101f72 <vga_init>:

void vga_init(char* addr) {
c0101f72:	55                   	push   %ebp
c0101f73:	89 e5                	mov    %esp,%ebp
  screen=addr;
c0101f75:	8b 45 08             	mov    0x8(%ebp),%eax
c0101f78:	a3 38 20 2b c0       	mov    %eax,0xc02b2038
}
c0101f7d:	90                   	nop
c0101f7e:	5d                   	pop    %ebp
c0101f7f:	c3                   	ret    

c0101f80 <vga_write_string>:

void vga_write_string(const char* string) {
c0101f80:	55                   	push   %ebp
c0101f81:	89 e5                	mov    %esp,%ebp
c0101f83:	83 ec 18             	sub    $0x18,%esp
  for (size_t i=0;i<strlen(string);i++) {
c0101f86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0101f8d:	eb 3b                	jmp    c0101fca <vga_write_string+0x4a>
    if (string[i]=='\n') continue;
c0101f8f:	8b 55 08             	mov    0x8(%ebp),%edx
c0101f92:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101f95:	01 d0                	add    %edx,%eax
c0101f97:	8a 00                	mov    (%eax),%al
c0101f99:	3c 0a                	cmp    $0xa,%al
c0101f9b:	74 29                	je     c0101fc6 <vga_write_string+0x46>
    set_char(x,string[i]);
c0101f9d:	8b 55 08             	mov    0x8(%ebp),%edx
c0101fa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101fa3:	01 d0                	add    %edx,%eax
c0101fa5:	8a 00                	mov    (%eax),%al
c0101fa7:	0f be d0             	movsbl %al,%edx
c0101faa:	a1 3c 20 2b c0       	mov    0xc02b203c,%eax
c0101faf:	52                   	push   %edx
c0101fb0:	50                   	push   %eax
c0101fb1:	e8 8a ff ff ff       	call   c0101f40 <set_char>
c0101fb6:	83 c4 08             	add    $0x8,%esp
    x++;
c0101fb9:	a1 3c 20 2b c0       	mov    0xc02b203c,%eax
c0101fbe:	40                   	inc    %eax
c0101fbf:	a3 3c 20 2b c0       	mov    %eax,0xc02b203c
c0101fc4:	eb 01                	jmp    c0101fc7 <vga_write_string+0x47>
    if (string[i]=='\n') continue;
c0101fc6:	90                   	nop
  for (size_t i=0;i<strlen(string);i++) {
c0101fc7:	ff 45 f4             	incl   -0xc(%ebp)
c0101fca:	83 ec 0c             	sub    $0xc,%esp
c0101fcd:	ff 75 08             	pushl  0x8(%ebp)
c0101fd0:	e8 c3 32 00 00       	call   c0105298 <strlen>
c0101fd5:	83 c4 10             	add    $0x10,%esp
c0101fd8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0101fdb:	72 b2                	jb     c0101f8f <vga_write_string+0xf>
  }
}
c0101fdd:	90                   	nop
c0101fde:	90                   	nop
c0101fdf:	c9                   	leave  
c0101fe0:	c3                   	ret    

c0101fe1 <cpu_init>:
 * \file 
*/

#include "gdt.h"

void cpu_init() {
c0101fe1:	55                   	push   %ebp
c0101fe2:	89 e5                	mov    %esp,%ebp
c0101fe4:	83 ec 08             	sub    $0x8,%esp
  gdt_init();
c0101fe7:	e8 c7 01 00 00       	call   c01021b3 <gdt_init>
}
c0101fec:	90                   	nop
c0101fed:	c9                   	leave  
c0101fee:	c3                   	ret    

c0101fef <set_entry>:
 * \param base The base of the GDT entry.
 * \param limit The limit of the GDT entry.
 * \param access The access byte of the GDT entry.
*/

static void set_entry(int i,uint32_t base,uint32_t limit,uint8_t access) {
c0101fef:	55                   	push   %ebp
c0101ff0:	89 e5                	mov    %esp,%ebp
c0101ff2:	83 ec 14             	sub    $0x14,%esp
c0101ff5:	8b 45 14             	mov    0x14(%ebp),%eax
c0101ff8:	88 45 ec             	mov    %al,-0x14(%ebp)
  gdt[i].limit_low16=limit&0xFFFF;
c0101ffb:	8b 45 10             	mov    0x10(%ebp),%eax
c0101ffe:	8b 55 08             	mov    0x8(%ebp),%edx
c0102001:	66 89 04 d5 40 20 2b 	mov    %ax,-0x3fd4dfc0(,%edx,8)
c0102008:	c0 
  gdt[i].base_low16=base&0xFFFFF;
c0102009:	8b 45 0c             	mov    0xc(%ebp),%eax
c010200c:	8b 55 08             	mov    0x8(%ebp),%edx
c010200f:	66 89 04 d5 42 20 2b 	mov    %ax,-0x3fd4dfbe(,%edx,8)
c0102016:	c0 
  gdt[i].base_mid8=(base&0xFF0000)>>16;
c0102017:	8b 45 0c             	mov    0xc(%ebp),%eax
c010201a:	c1 e8 10             	shr    $0x10,%eax
c010201d:	88 c2                	mov    %al,%dl
c010201f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102022:	88 14 c5 44 20 2b c0 	mov    %dl,-0x3fd4dfbc(,%eax,8)
  gdt[i].access=access;
c0102029:	8b 45 08             	mov    0x8(%ebp),%eax
c010202c:	8a 55 ec             	mov    -0x14(%ebp),%dl
c010202f:	88 14 c5 45 20 2b c0 	mov    %dl,-0x3fd4dfbb(,%eax,8)
  uint8_t limit_high4=(limit&0xF0000)>>16;
c0102036:	8b 45 10             	mov    0x10(%ebp),%eax
c0102039:	c1 e8 10             	shr    $0x10,%eax
c010203c:	83 e0 0f             	and    $0xf,%eax
c010203f:	88 45 ff             	mov    %al,-0x1(%ebp)
  gdt[i].limit_flags=0xC0|limit_high4;
c0102042:	8a 45 ff             	mov    -0x1(%ebp),%al
c0102045:	83 c8 c0             	or     $0xffffffc0,%eax
c0102048:	88 c2                	mov    %al,%dl
c010204a:	8b 45 08             	mov    0x8(%ebp),%eax
c010204d:	88 14 c5 46 20 2b c0 	mov    %dl,-0x3fd4dfba(,%eax,8)
  gdt[i].base_high8=(base&0xFF000000)>>24;
c0102054:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102057:	c1 e8 18             	shr    $0x18,%eax
c010205a:	88 c2                	mov    %al,%dl
c010205c:	8b 45 08             	mov    0x8(%ebp),%eax
c010205f:	88 14 c5 47 20 2b c0 	mov    %dl,-0x3fd4dfb9(,%eax,8)
}
c0102066:	90                   	nop
c0102067:	c9                   	leave  
c0102068:	c3                   	ret    

c0102069 <write_tss>:
 * \param num The GDT entry to set.
 * \param ss0 The kernel stack selector.
 * \param esp0 The kernel stack pointer.
*/

static void write_tss(int32_t num, uint16_t ss0, uint32_t esp0) {
c0102069:	55                   	push   %ebp
c010206a:	89 e5                	mov    %esp,%ebp
c010206c:	83 ec 28             	sub    $0x28,%esp
c010206f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102072:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  // Firstly, let's compute the base and limit of our entry into the GDT.
  uint32_t base = (uint32_t) &tss;
c0102076:	c7 45 f4 40 a0 1c c0 	movl   $0xc01ca040,-0xc(%ebp)
  uint32_t limit = base + sizeof(tss_entry);
c010207d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102080:	05 69 20 00 00       	add    $0x2069,%eax
c0102085:	89 45 f0             	mov    %eax,-0x10(%ebp)

  // Now, add our TSS descriptor's address to the GDT.
  gdt[num].limit_low16=limit&0xFFFF;
c0102088:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010208b:	8b 55 08             	mov    0x8(%ebp),%edx
c010208e:	66 89 04 d5 40 20 2b 	mov    %ax,-0x3fd4dfc0(,%edx,8)
c0102095:	c0 
  gdt[num].base_low16=base&0xFFFFF;
c0102096:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102099:	8b 55 08             	mov    0x8(%ebp),%edx
c010209c:	66 89 04 d5 42 20 2b 	mov    %ax,-0x3fd4dfbe(,%edx,8)
c01020a3:	c0 
  gdt[num].base_mid8=(base&0xFF0000)>>16;
c01020a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01020a7:	c1 e8 10             	shr    $0x10,%eax
c01020aa:	88 c2                	mov    %al,%dl
c01020ac:	8b 45 08             	mov    0x8(%ebp),%eax
c01020af:	88 14 c5 44 20 2b c0 	mov    %dl,-0x3fd4dfbc(,%eax,8)
  gdt[num].access=0xe9;
c01020b6:	8b 45 08             	mov    0x8(%ebp),%eax
c01020b9:	c6 04 c5 45 20 2b c0 	movb   $0xe9,-0x3fd4dfbb(,%eax,8)
c01020c0:	e9 
  gdt[num].limit_flags=(limit&0xF0000)>>16;
c01020c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01020c4:	c1 e8 10             	shr    $0x10,%eax
c01020c7:	83 e0 0f             	and    $0xf,%eax
c01020ca:	88 c2                	mov    %al,%dl
c01020cc:	8b 45 08             	mov    0x8(%ebp),%eax
c01020cf:	88 14 c5 46 20 2b c0 	mov    %dl,-0x3fd4dfba(,%eax,8)
  gdt[num].base_high8=(base&0xFF000000)>>24;
c01020d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01020d9:	c1 e8 18             	shr    $0x18,%eax
c01020dc:	88 c2                	mov    %al,%dl
c01020de:	8b 45 08             	mov    0x8(%ebp),%eax
c01020e1:	88 14 c5 47 20 2b c0 	mov    %dl,-0x3fd4dfb9(,%eax,8)

  // Ensure the descriptor is initially zero.
  memset((void*)&tss,0,sizeof(tss));
c01020e8:	83 ec 04             	sub    $0x4,%esp
c01020eb:	68 69 20 00 00       	push   $0x2069
c01020f0:	6a 00                	push   $0x0
c01020f2:	68 40 a0 1c c0       	push   $0xc01ca040
c01020f7:	e8 0b 31 00 00       	call   c0105207 <memset>
c01020fc:	83 c4 10             	add    $0x10,%esp
  tss.ss0  = ss0;  // Set the kernel stack segment.
c01020ff:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0102103:	a3 48 a0 1c c0       	mov    %eax,0xc01ca048
  tss.esp0 = esp0; // Set the kernel stack pointer.
c0102108:	8b 45 10             	mov    0x10(%ebp),%eax
c010210b:	a3 44 a0 1c c0       	mov    %eax,0xc01ca044

  //Set the last byte to 0xFF (End marker for IOPB)
  tss.set_ff=0xFF;
c0102110:	c6 05 a8 c0 1c c0 ff 	movb   $0xff,0xc01cc0a8

  // Now, set the offset for the IOPB
  // (All ports are already OK from the zeroing)
  tss.iomap_base=104;
c0102117:	66 c7 05 a6 a0 1c c0 	movw   $0x68,0xc01ca0a6
c010211e:	68 00 
  // segments should be loaded when the processor switches to kernel mode. Therefore
  // they are just our normal kernel code/data segments - 0x08 and 0x10 respectively,
  // but with the last two bits set, making 0x0b and 0x13. The setting of these bits
  // sets the RPL (requested privilege level) to 3, meaning that this TSS can be used
  // to switch to kernel mode from ring 3.
  tss.cs = 0x0b;
c0102120:	c7 05 8c a0 1c c0 0b 	movl   $0xb,0xc01ca08c
c0102127:	00 00 00 
  tss.ss = tss.ds = tss.es = tss.fs = tss.gs = 0x13;
c010212a:	c7 05 9c a0 1c c0 13 	movl   $0x13,0xc01ca09c
c0102131:	00 00 00 
c0102134:	a1 9c a0 1c c0       	mov    0xc01ca09c,%eax
c0102139:	a3 98 a0 1c c0       	mov    %eax,0xc01ca098
c010213e:	a1 98 a0 1c c0       	mov    0xc01ca098,%eax
c0102143:	a3 88 a0 1c c0       	mov    %eax,0xc01ca088
c0102148:	a1 88 a0 1c c0       	mov    0xc01ca088,%eax
c010214d:	a3 94 a0 1c c0       	mov    %eax,0xc01ca094
c0102152:	a1 94 a0 1c c0       	mov    0xc01ca094,%eax
c0102157:	a3 90 a0 1c c0       	mov    %eax,0xc01ca090
}
c010215c:	90                   	nop
c010215d:	c9                   	leave  
c010215e:	c3                   	ret    

c010215f <allow_all_ports>:

void allow_all_ports() {
c010215f:	55                   	push   %ebp
c0102160:	89 e5                	mov    %esp,%ebp
c0102162:	83 ec 10             	sub    $0x10,%esp
  for (int i=0;i<8192;i++) {
c0102165:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010216c:	eb 0e                	jmp    c010217c <allow_all_ports+0x1d>
    tss.iopb[i]=0;
c010216e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102171:	05 a8 a0 1c c0       	add    $0xc01ca0a8,%eax
c0102176:	c6 00 00             	movb   $0x0,(%eax)
  for (int i=0;i<8192;i++) {
c0102179:	ff 45 fc             	incl   -0x4(%ebp)
c010217c:	81 7d fc ff 1f 00 00 	cmpl   $0x1fff,-0x4(%ebp)
c0102183:	7e e9                	jle    c010216e <allow_all_ports+0xf>
  }
}
c0102185:	90                   	nop
c0102186:	90                   	nop
c0102187:	c9                   	leave  
c0102188:	c3                   	ret    

c0102189 <block_all_ports>:

void block_all_ports() {
c0102189:	55                   	push   %ebp
c010218a:	89 e5                	mov    %esp,%ebp
c010218c:	83 ec 10             	sub    $0x10,%esp
  for (int i=0;i<8192;i++) {
c010218f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0102196:	eb 0e                	jmp    c01021a6 <block_all_ports+0x1d>
    tss.iopb[i]=0xFF;
c0102198:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010219b:	05 a8 a0 1c c0       	add    $0xc01ca0a8,%eax
c01021a0:	c6 00 ff             	movb   $0xff,(%eax)
  for (int i=0;i<8192;i++) {
c01021a3:	ff 45 fc             	incl   -0x4(%ebp)
c01021a6:	81 7d fc ff 1f 00 00 	cmpl   $0x1fff,-0x4(%ebp)
c01021ad:	7e e9                	jle    c0102198 <block_all_ports+0xf>
  }
}
c01021af:	90                   	nop
c01021b0:	90                   	nop
c01021b1:	c9                   	leave  
c01021b2:	c3                   	ret    

c01021b3 <gdt_init>:

void gdt_init() {
c01021b3:	55                   	push   %ebp
c01021b4:	89 e5                	mov    %esp,%ebp
c01021b6:	83 ec 08             	sub    $0x8,%esp
  set_entry(0,0,0,0);
c01021b9:	6a 00                	push   $0x0
c01021bb:	6a 00                	push   $0x0
c01021bd:	6a 00                	push   $0x0
c01021bf:	6a 00                	push   $0x0
c01021c1:	e8 29 fe ff ff       	call   c0101fef <set_entry>
c01021c6:	83 c4 10             	add    $0x10,%esp
  set_entry(1,0,0xFFFFF,0b10011010);
c01021c9:	68 9a 00 00 00       	push   $0x9a
c01021ce:	68 ff ff 0f 00       	push   $0xfffff
c01021d3:	6a 00                	push   $0x0
c01021d5:	6a 01                	push   $0x1
c01021d7:	e8 13 fe ff ff       	call   c0101fef <set_entry>
c01021dc:	83 c4 10             	add    $0x10,%esp
  set_entry(2,0,0xFFFFF,0b10010010);
c01021df:	68 92 00 00 00       	push   $0x92
c01021e4:	68 ff ff 0f 00       	push   $0xfffff
c01021e9:	6a 00                	push   $0x0
c01021eb:	6a 02                	push   $0x2
c01021ed:	e8 fd fd ff ff       	call   c0101fef <set_entry>
c01021f2:	83 c4 10             	add    $0x10,%esp
  set_entry(3,0,0xFFFFF,0b11111010);
c01021f5:	68 fa 00 00 00       	push   $0xfa
c01021fa:	68 ff ff 0f 00       	push   $0xfffff
c01021ff:	6a 00                	push   $0x0
c0102201:	6a 03                	push   $0x3
c0102203:	e8 e7 fd ff ff       	call   c0101fef <set_entry>
c0102208:	83 c4 10             	add    $0x10,%esp
  set_entry(4,0,0xFFFFF,0b11110010);
c010220b:	68 f2 00 00 00       	push   $0xf2
c0102210:	68 ff ff 0f 00       	push   $0xfffff
c0102215:	6a 00                	push   $0x0
c0102217:	6a 04                	push   $0x4
c0102219:	e8 d1 fd ff ff       	call   c0101fef <set_entry>
c010221e:	83 c4 10             	add    $0x10,%esp
  write_tss(5,0x10,int_stack_top+0xC0000000);
c0102221:	a1 58 cd 3e c0       	mov    0xc03ecd58,%eax
c0102226:	2d 00 00 00 40       	sub    $0x40000000,%eax
c010222b:	83 ec 04             	sub    $0x4,%esp
c010222e:	50                   	push   %eax
c010222f:	6a 10                	push   $0x10
c0102231:	6a 05                	push   $0x5
c0102233:	e8 31 fe ff ff       	call   c0102069 <write_tss>
c0102238:	83 c4 10             	add    $0x10,%esp
  gdt_desc.size=(sizeof(gdt_entry)*NUM_ENTRIES)-1;
c010223b:	66 c7 05 70 20 2b c0 	movw   $0x2f,0xc02b2070
c0102242:	2f 00 
  gdt_desc.address=gdt;
c0102244:	c7 05 72 20 2b c0 40 	movl   $0xc02b2040,0xc02b2072
c010224b:	20 2b c0 
                mov %%ax, %%ds; \
                mov %%ax, %%ss; \
                mov %%ax, %%es; \
                mov %%ax, %%fs; \
                mov %%ax, %%gs; \
              "::"a"((uint32_t)&gdt_desc));
c010224e:	b8 70 20 2b c0       	mov    $0xc02b2070,%eax
  asm volatile(" \
c0102253:	0f 01 10             	lgdtl  (%eax)
c0102256:	ea 5d 22 10 c0 08 00 	ljmp   $0x8,$0xc010225d

c010225d <gdt_init_asm_code_upd>:
c010225d:	66 b8 10 00          	mov    $0x10,%ax
c0102261:	8e d8                	mov    %eax,%ds
c0102263:	8e d0                	mov    %eax,%ss
c0102265:	8e c0                	mov    %eax,%es
c0102267:	8e e0                	mov    %eax,%fs
c0102269:	8e e8                	mov    %eax,%gs
  asm volatile("mov $0x2B, %ax; \
c010226b:	66 b8 2b 00          	mov    $0x2b,%ax
c010226f:	0f 00 d8             	ltr    %ax
    ltr %ax; \
  ");
}
c0102272:	90                   	nop
c0102273:	c9                   	leave  
c0102274:	c3                   	ret    

c0102275 <idt_set_gate>:

#define LOW_16(address) (uint16_t)((address) & 0xFFFF) //!< Macro to get the low 16 bits of an address
#define HIGH_16(address) (uint16_t)(((address) >> 16) & 0xFFFF) //!< Macro to get the high 16 bits of an address


void idt_set_gate(int n,uint32_t handler) {
c0102275:	55                   	push   %ebp
c0102276:	89 e5                	mov    %esp,%ebp
  idt[n].low_offset=LOW_16(handler);
c0102278:	8b 45 0c             	mov    0xc(%ebp),%eax
c010227b:	8b 55 08             	mov    0x8(%ebp),%edx
c010227e:	66 89 04 d5 00 d0 1c 	mov    %ax,-0x3fe33000(,%edx,8)
c0102285:	c0 
  idt[n].sel=0x08;
c0102286:	8b 45 08             	mov    0x8(%ebp),%eax
c0102289:	66 c7 04 c5 02 d0 1c 	movw   $0x8,-0x3fe32ffe(,%eax,8)
c0102290:	c0 08 00 
  idt[n].always0=0;
c0102293:	8b 45 08             	mov    0x8(%ebp),%eax
c0102296:	c6 04 c5 04 d0 1c c0 	movb   $0x0,-0x3fe32ffc(,%eax,8)
c010229d:	00 
  idt[n].flags=0xEE;
c010229e:	8b 45 08             	mov    0x8(%ebp),%eax
c01022a1:	c6 04 c5 05 d0 1c c0 	movb   $0xee,-0x3fe32ffb(,%eax,8)
c01022a8:	ee 
  idt[n].high_offset=HIGH_16(handler);
c01022a9:	8b 45 0c             	mov    0xc(%ebp),%eax
c01022ac:	c1 e8 10             	shr    $0x10,%eax
c01022af:	8b 55 08             	mov    0x8(%ebp),%edx
c01022b2:	66 89 04 d5 06 d0 1c 	mov    %ax,-0x3fe32ffa(,%edx,8)
c01022b9:	c0 
}
c01022ba:	90                   	nop
c01022bb:	5d                   	pop    %ebp
c01022bc:	c3                   	ret    

c01022bd <load_idt>:

void load_idt() {
c01022bd:	55                   	push   %ebp
c01022be:	89 e5                	mov    %esp,%ebp
  idt_reg.base=&idt[0];
c01022c0:	c7 05 7a 20 2b c0 00 	movl   $0xc01cd000,0xc02b207a
c01022c7:	d0 1c c0 
  idt_reg.limit=IDT_ENTRIES * sizeof(idt_gate_t) - 1;
c01022ca:	66 c7 05 78 20 2b c0 	movw   $0x7ff,0xc02b2078
c01022d1:	ff 07 
  /* Don't make the mistake of loading &idt -- always load &idt_reg */
  asm volatile("lidtl (%0)":: "r" (&idt_reg));
c01022d3:	b8 78 20 2b c0       	mov    $0xc02b2078,%eax
c01022d8:	0f 01 18             	lidtl  (%eax)
}
c01022db:	90                   	nop
c01022dc:	5d                   	pop    %ebp
c01022dd:	c3                   	ret    

c01022de <isr_install>:

static char waiting_for_exception_return[32768]={0};
static registers_t* exception_return_value[32768]={0};
static void* exception_handler_address[32768]={NULL};

void isr_install() {
c01022de:	55                   	push   %ebp
c01022df:	89 e5                	mov    %esp,%ebp
c01022e1:	83 ec 08             	sub    $0x8,%esp
    idt_set_gate(0,(uint32_t)isr0);
c01022e4:	b8 bd 40 10 c0       	mov    $0xc01040bd,%eax
c01022e9:	83 ec 08             	sub    $0x8,%esp
c01022ec:	50                   	push   %eax
c01022ed:	6a 00                	push   $0x0
c01022ef:	e8 81 ff ff ff       	call   c0102275 <idt_set_gate>
c01022f4:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(1,(uint32_t)isr1);
c01022f7:	b8 c4 40 10 c0       	mov    $0xc01040c4,%eax
c01022fc:	83 ec 08             	sub    $0x8,%esp
c01022ff:	50                   	push   %eax
c0102300:	6a 01                	push   $0x1
c0102302:	e8 6e ff ff ff       	call   c0102275 <idt_set_gate>
c0102307:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(2,(uint32_t)isr2);
c010230a:	b8 cb 40 10 c0       	mov    $0xc01040cb,%eax
c010230f:	83 ec 08             	sub    $0x8,%esp
c0102312:	50                   	push   %eax
c0102313:	6a 02                	push   $0x2
c0102315:	e8 5b ff ff ff       	call   c0102275 <idt_set_gate>
c010231a:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(3,(uint32_t)isr3);
c010231d:	b8 d2 40 10 c0       	mov    $0xc01040d2,%eax
c0102322:	83 ec 08             	sub    $0x8,%esp
c0102325:	50                   	push   %eax
c0102326:	6a 03                	push   $0x3
c0102328:	e8 48 ff ff ff       	call   c0102275 <idt_set_gate>
c010232d:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(4,(uint32_t)isr4);
c0102330:	b8 d9 40 10 c0       	mov    $0xc01040d9,%eax
c0102335:	83 ec 08             	sub    $0x8,%esp
c0102338:	50                   	push   %eax
c0102339:	6a 04                	push   $0x4
c010233b:	e8 35 ff ff ff       	call   c0102275 <idt_set_gate>
c0102340:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(5,(uint32_t)isr5);
c0102343:	b8 e0 40 10 c0       	mov    $0xc01040e0,%eax
c0102348:	83 ec 08             	sub    $0x8,%esp
c010234b:	50                   	push   %eax
c010234c:	6a 05                	push   $0x5
c010234e:	e8 22 ff ff ff       	call   c0102275 <idt_set_gate>
c0102353:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(6,(uint32_t)isr6);
c0102356:	b8 e7 40 10 c0       	mov    $0xc01040e7,%eax
c010235b:	83 ec 08             	sub    $0x8,%esp
c010235e:	50                   	push   %eax
c010235f:	6a 06                	push   $0x6
c0102361:	e8 0f ff ff ff       	call   c0102275 <idt_set_gate>
c0102366:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(7,(uint32_t)isr7);
c0102369:	b8 ee 40 10 c0       	mov    $0xc01040ee,%eax
c010236e:	83 ec 08             	sub    $0x8,%esp
c0102371:	50                   	push   %eax
c0102372:	6a 07                	push   $0x7
c0102374:	e8 fc fe ff ff       	call   c0102275 <idt_set_gate>
c0102379:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(8,(uint32_t)isr8);
c010237c:	b8 f8 40 10 c0       	mov    $0xc01040f8,%eax
c0102381:	83 ec 08             	sub    $0x8,%esp
c0102384:	50                   	push   %eax
c0102385:	6a 08                	push   $0x8
c0102387:	e8 e9 fe ff ff       	call   c0102275 <idt_set_gate>
c010238c:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(9,(uint32_t)isr9);
c010238f:	b8 00 41 10 c0       	mov    $0xc0104100,%eax
c0102394:	83 ec 08             	sub    $0x8,%esp
c0102397:	50                   	push   %eax
c0102398:	6a 09                	push   $0x9
c010239a:	e8 d6 fe ff ff       	call   c0102275 <idt_set_gate>
c010239f:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(10,(uint32_t)isr10);
c01023a2:	b8 0a 41 10 c0       	mov    $0xc010410a,%eax
c01023a7:	83 ec 08             	sub    $0x8,%esp
c01023aa:	50                   	push   %eax
c01023ab:	6a 0a                	push   $0xa
c01023ad:	e8 c3 fe ff ff       	call   c0102275 <idt_set_gate>
c01023b2:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(11,(uint32_t)isr11);
c01023b5:	b8 12 41 10 c0       	mov    $0xc0104112,%eax
c01023ba:	83 ec 08             	sub    $0x8,%esp
c01023bd:	50                   	push   %eax
c01023be:	6a 0b                	push   $0xb
c01023c0:	e8 b0 fe ff ff       	call   c0102275 <idt_set_gate>
c01023c5:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(12,(uint32_t)isr12);
c01023c8:	b8 1a 41 10 c0       	mov    $0xc010411a,%eax
c01023cd:	83 ec 08             	sub    $0x8,%esp
c01023d0:	50                   	push   %eax
c01023d1:	6a 0c                	push   $0xc
c01023d3:	e8 9d fe ff ff       	call   c0102275 <idt_set_gate>
c01023d8:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(13,(uint32_t)isr13);
c01023db:	b8 22 41 10 c0       	mov    $0xc0104122,%eax
c01023e0:	83 ec 08             	sub    $0x8,%esp
c01023e3:	50                   	push   %eax
c01023e4:	6a 0d                	push   $0xd
c01023e6:	e8 8a fe ff ff       	call   c0102275 <idt_set_gate>
c01023eb:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(14,(uint32_t)isr14);
c01023ee:	b8 2a 41 10 c0       	mov    $0xc010412a,%eax
c01023f3:	83 ec 08             	sub    $0x8,%esp
c01023f6:	50                   	push   %eax
c01023f7:	6a 0e                	push   $0xe
c01023f9:	e8 77 fe ff ff       	call   c0102275 <idt_set_gate>
c01023fe:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(15,(uint32_t)isr15);
c0102401:	b8 32 41 10 c0       	mov    $0xc0104132,%eax
c0102406:	83 ec 08             	sub    $0x8,%esp
c0102409:	50                   	push   %eax
c010240a:	6a 0f                	push   $0xf
c010240c:	e8 64 fe ff ff       	call   c0102275 <idt_set_gate>
c0102411:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(16,(uint32_t)isr16);
c0102414:	b8 3c 41 10 c0       	mov    $0xc010413c,%eax
c0102419:	83 ec 08             	sub    $0x8,%esp
c010241c:	50                   	push   %eax
c010241d:	6a 10                	push   $0x10
c010241f:	e8 51 fe ff ff       	call   c0102275 <idt_set_gate>
c0102424:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(17,(uint32_t)isr17);
c0102427:	b8 46 41 10 c0       	mov    $0xc0104146,%eax
c010242c:	83 ec 08             	sub    $0x8,%esp
c010242f:	50                   	push   %eax
c0102430:	6a 11                	push   $0x11
c0102432:	e8 3e fe ff ff       	call   c0102275 <idt_set_gate>
c0102437:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(18,(uint32_t)isr18);
c010243a:	b8 50 41 10 c0       	mov    $0xc0104150,%eax
c010243f:	83 ec 08             	sub    $0x8,%esp
c0102442:	50                   	push   %eax
c0102443:	6a 12                	push   $0x12
c0102445:	e8 2b fe ff ff       	call   c0102275 <idt_set_gate>
c010244a:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(19,(uint32_t)isr19);
c010244d:	b8 5a 41 10 c0       	mov    $0xc010415a,%eax
c0102452:	83 ec 08             	sub    $0x8,%esp
c0102455:	50                   	push   %eax
c0102456:	6a 13                	push   $0x13
c0102458:	e8 18 fe ff ff       	call   c0102275 <idt_set_gate>
c010245d:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(20,(uint32_t)isr20);
c0102460:	b8 64 41 10 c0       	mov    $0xc0104164,%eax
c0102465:	83 ec 08             	sub    $0x8,%esp
c0102468:	50                   	push   %eax
c0102469:	6a 14                	push   $0x14
c010246b:	e8 05 fe ff ff       	call   c0102275 <idt_set_gate>
c0102470:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(21,(uint32_t)isr21);
c0102473:	b8 6e 41 10 c0       	mov    $0xc010416e,%eax
c0102478:	83 ec 08             	sub    $0x8,%esp
c010247b:	50                   	push   %eax
c010247c:	6a 15                	push   $0x15
c010247e:	e8 f2 fd ff ff       	call   c0102275 <idt_set_gate>
c0102483:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(22,(uint32_t)isr22);
c0102486:	b8 78 41 10 c0       	mov    $0xc0104178,%eax
c010248b:	83 ec 08             	sub    $0x8,%esp
c010248e:	50                   	push   %eax
c010248f:	6a 16                	push   $0x16
c0102491:	e8 df fd ff ff       	call   c0102275 <idt_set_gate>
c0102496:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(23,(uint32_t)isr23);
c0102499:	b8 82 41 10 c0       	mov    $0xc0104182,%eax
c010249e:	83 ec 08             	sub    $0x8,%esp
c01024a1:	50                   	push   %eax
c01024a2:	6a 17                	push   $0x17
c01024a4:	e8 cc fd ff ff       	call   c0102275 <idt_set_gate>
c01024a9:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(24,(uint32_t)isr24);
c01024ac:	b8 8c 41 10 c0       	mov    $0xc010418c,%eax
c01024b1:	83 ec 08             	sub    $0x8,%esp
c01024b4:	50                   	push   %eax
c01024b5:	6a 18                	push   $0x18
c01024b7:	e8 b9 fd ff ff       	call   c0102275 <idt_set_gate>
c01024bc:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(25,(uint32_t)isr25);
c01024bf:	b8 96 41 10 c0       	mov    $0xc0104196,%eax
c01024c4:	83 ec 08             	sub    $0x8,%esp
c01024c7:	50                   	push   %eax
c01024c8:	6a 19                	push   $0x19
c01024ca:	e8 a6 fd ff ff       	call   c0102275 <idt_set_gate>
c01024cf:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(26,(uint32_t)isr26);
c01024d2:	b8 a0 41 10 c0       	mov    $0xc01041a0,%eax
c01024d7:	83 ec 08             	sub    $0x8,%esp
c01024da:	50                   	push   %eax
c01024db:	6a 1a                	push   $0x1a
c01024dd:	e8 93 fd ff ff       	call   c0102275 <idt_set_gate>
c01024e2:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(27,(uint32_t)isr27);
c01024e5:	b8 aa 41 10 c0       	mov    $0xc01041aa,%eax
c01024ea:	83 ec 08             	sub    $0x8,%esp
c01024ed:	50                   	push   %eax
c01024ee:	6a 1b                	push   $0x1b
c01024f0:	e8 80 fd ff ff       	call   c0102275 <idt_set_gate>
c01024f5:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(28,(uint32_t)isr28);
c01024f8:	b8 b4 41 10 c0       	mov    $0xc01041b4,%eax
c01024fd:	83 ec 08             	sub    $0x8,%esp
c0102500:	50                   	push   %eax
c0102501:	6a 1c                	push   $0x1c
c0102503:	e8 6d fd ff ff       	call   c0102275 <idt_set_gate>
c0102508:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(29,(uint32_t)isr29);
c010250b:	b8 be 41 10 c0       	mov    $0xc01041be,%eax
c0102510:	83 ec 08             	sub    $0x8,%esp
c0102513:	50                   	push   %eax
c0102514:	6a 1d                	push   $0x1d
c0102516:	e8 5a fd ff ff       	call   c0102275 <idt_set_gate>
c010251b:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(30,(uint32_t)isr30);
c010251e:	b8 c8 41 10 c0       	mov    $0xc01041c8,%eax
c0102523:	83 ec 08             	sub    $0x8,%esp
c0102526:	50                   	push   %eax
c0102527:	6a 1e                	push   $0x1e
c0102529:	e8 47 fd ff ff       	call   c0102275 <idt_set_gate>
c010252e:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(31,(uint32_t)isr31);
c0102531:	b8 d2 41 10 c0       	mov    $0xc01041d2,%eax
c0102536:	83 ec 08             	sub    $0x8,%esp
c0102539:	50                   	push   %eax
c010253a:	6a 1f                	push   $0x1f
c010253c:	e8 34 fd ff ff       	call   c0102275 <idt_set_gate>
c0102541:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(80,(uint32_t)isr80);
c0102544:	b8 dc 41 10 c0       	mov    $0xc01041dc,%eax
c0102549:	83 ec 08             	sub    $0x8,%esp
c010254c:	50                   	push   %eax
c010254d:	6a 50                	push   $0x50
c010254f:	e8 21 fd ff ff       	call   c0102275 <idt_set_gate>
c0102554:	83 c4 10             	add    $0x10,%esp
    // Remap the PIC
    port_byte_out(0x20,0x11);
c0102557:	83 ec 08             	sub    $0x8,%esp
c010255a:	6a 11                	push   $0x11
c010255c:	6a 20                	push   $0x20
c010255e:	e8 54 2b 00 00       	call   c01050b7 <port_byte_out>
c0102563:	83 c4 10             	add    $0x10,%esp
    port_byte_out(0xA0,0x11);
c0102566:	83 ec 08             	sub    $0x8,%esp
c0102569:	6a 11                	push   $0x11
c010256b:	68 a0 00 00 00       	push   $0xa0
c0102570:	e8 42 2b 00 00       	call   c01050b7 <port_byte_out>
c0102575:	83 c4 10             	add    $0x10,%esp
    port_byte_out(0x21,0x20);
c0102578:	83 ec 08             	sub    $0x8,%esp
c010257b:	6a 20                	push   $0x20
c010257d:	6a 21                	push   $0x21
c010257f:	e8 33 2b 00 00       	call   c01050b7 <port_byte_out>
c0102584:	83 c4 10             	add    $0x10,%esp
    port_byte_out(0xA1,0x28);
c0102587:	83 ec 08             	sub    $0x8,%esp
c010258a:	6a 28                	push   $0x28
c010258c:	68 a1 00 00 00       	push   $0xa1
c0102591:	e8 21 2b 00 00       	call   c01050b7 <port_byte_out>
c0102596:	83 c4 10             	add    $0x10,%esp
    port_byte_out(0x21,0x04);
c0102599:	83 ec 08             	sub    $0x8,%esp
c010259c:	6a 04                	push   $0x4
c010259e:	6a 21                	push   $0x21
c01025a0:	e8 12 2b 00 00       	call   c01050b7 <port_byte_out>
c01025a5:	83 c4 10             	add    $0x10,%esp
    port_byte_out(0xA1,0x02);
c01025a8:	83 ec 08             	sub    $0x8,%esp
c01025ab:	6a 02                	push   $0x2
c01025ad:	68 a1 00 00 00       	push   $0xa1
c01025b2:	e8 00 2b 00 00       	call   c01050b7 <port_byte_out>
c01025b7:	83 c4 10             	add    $0x10,%esp
    port_byte_out(0x21,0x01);
c01025ba:	83 ec 08             	sub    $0x8,%esp
c01025bd:	6a 01                	push   $0x1
c01025bf:	6a 21                	push   $0x21
c01025c1:	e8 f1 2a 00 00       	call   c01050b7 <port_byte_out>
c01025c6:	83 c4 10             	add    $0x10,%esp
    port_byte_out(0xA1,0x01);
c01025c9:	83 ec 08             	sub    $0x8,%esp
c01025cc:	6a 01                	push   $0x1
c01025ce:	68 a1 00 00 00       	push   $0xa1
c01025d3:	e8 df 2a 00 00       	call   c01050b7 <port_byte_out>
c01025d8:	83 c4 10             	add    $0x10,%esp
    port_byte_out(0x21,0x0);
c01025db:	83 ec 08             	sub    $0x8,%esp
c01025de:	6a 00                	push   $0x0
c01025e0:	6a 21                	push   $0x21
c01025e2:	e8 d0 2a 00 00       	call   c01050b7 <port_byte_out>
c01025e7:	83 c4 10             	add    $0x10,%esp
    port_byte_out(0xA1,0x0);
c01025ea:	83 ec 08             	sub    $0x8,%esp
c01025ed:	6a 00                	push   $0x0
c01025ef:	68 a1 00 00 00       	push   $0xa1
c01025f4:	e8 be 2a 00 00       	call   c01050b7 <port_byte_out>
c01025f9:	83 c4 10             	add    $0x10,%esp

    // Install the IRQs
    idt_set_gate(32,(uint32_t)irq0);
c01025fc:	b8 e6 41 10 c0       	mov    $0xc01041e6,%eax
c0102601:	83 ec 08             	sub    $0x8,%esp
c0102604:	50                   	push   %eax
c0102605:	6a 20                	push   $0x20
c0102607:	e8 69 fc ff ff       	call   c0102275 <idt_set_gate>
c010260c:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(33,(uint32_t)irq1);
c010260f:	b8 f0 41 10 c0       	mov    $0xc01041f0,%eax
c0102614:	83 ec 08             	sub    $0x8,%esp
c0102617:	50                   	push   %eax
c0102618:	6a 21                	push   $0x21
c010261a:	e8 56 fc ff ff       	call   c0102275 <idt_set_gate>
c010261f:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(34,(uint32_t)irq2);
c0102622:	b8 fa 41 10 c0       	mov    $0xc01041fa,%eax
c0102627:	83 ec 08             	sub    $0x8,%esp
c010262a:	50                   	push   %eax
c010262b:	6a 22                	push   $0x22
c010262d:	e8 43 fc ff ff       	call   c0102275 <idt_set_gate>
c0102632:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(35,(uint32_t)irq3);
c0102635:	b8 04 42 10 c0       	mov    $0xc0104204,%eax
c010263a:	83 ec 08             	sub    $0x8,%esp
c010263d:	50                   	push   %eax
c010263e:	6a 23                	push   $0x23
c0102640:	e8 30 fc ff ff       	call   c0102275 <idt_set_gate>
c0102645:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(36,(uint32_t)irq4);
c0102648:	b8 0e 42 10 c0       	mov    $0xc010420e,%eax
c010264d:	83 ec 08             	sub    $0x8,%esp
c0102650:	50                   	push   %eax
c0102651:	6a 24                	push   $0x24
c0102653:	e8 1d fc ff ff       	call   c0102275 <idt_set_gate>
c0102658:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(37,(uint32_t)irq5);
c010265b:	b8 18 42 10 c0       	mov    $0xc0104218,%eax
c0102660:	83 ec 08             	sub    $0x8,%esp
c0102663:	50                   	push   %eax
c0102664:	6a 25                	push   $0x25
c0102666:	e8 0a fc ff ff       	call   c0102275 <idt_set_gate>
c010266b:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(38,(uint32_t)irq6);
c010266e:	b8 22 42 10 c0       	mov    $0xc0104222,%eax
c0102673:	83 ec 08             	sub    $0x8,%esp
c0102676:	50                   	push   %eax
c0102677:	6a 26                	push   $0x26
c0102679:	e8 f7 fb ff ff       	call   c0102275 <idt_set_gate>
c010267e:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(39,(uint32_t)irq7);
c0102681:	b8 2c 42 10 c0       	mov    $0xc010422c,%eax
c0102686:	83 ec 08             	sub    $0x8,%esp
c0102689:	50                   	push   %eax
c010268a:	6a 27                	push   $0x27
c010268c:	e8 e4 fb ff ff       	call   c0102275 <idt_set_gate>
c0102691:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(40,(uint32_t)irq8);
c0102694:	b8 36 42 10 c0       	mov    $0xc0104236,%eax
c0102699:	83 ec 08             	sub    $0x8,%esp
c010269c:	50                   	push   %eax
c010269d:	6a 28                	push   $0x28
c010269f:	e8 d1 fb ff ff       	call   c0102275 <idt_set_gate>
c01026a4:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(41,(uint32_t)irq9);
c01026a7:	b8 40 42 10 c0       	mov    $0xc0104240,%eax
c01026ac:	83 ec 08             	sub    $0x8,%esp
c01026af:	50                   	push   %eax
c01026b0:	6a 29                	push   $0x29
c01026b2:	e8 be fb ff ff       	call   c0102275 <idt_set_gate>
c01026b7:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(42,(uint32_t)irq10);
c01026ba:	b8 4a 42 10 c0       	mov    $0xc010424a,%eax
c01026bf:	83 ec 08             	sub    $0x8,%esp
c01026c2:	50                   	push   %eax
c01026c3:	6a 2a                	push   $0x2a
c01026c5:	e8 ab fb ff ff       	call   c0102275 <idt_set_gate>
c01026ca:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(43,(uint32_t)irq11);
c01026cd:	b8 54 42 10 c0       	mov    $0xc0104254,%eax
c01026d2:	83 ec 08             	sub    $0x8,%esp
c01026d5:	50                   	push   %eax
c01026d6:	6a 2b                	push   $0x2b
c01026d8:	e8 98 fb ff ff       	call   c0102275 <idt_set_gate>
c01026dd:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(44,(uint32_t)irq12);
c01026e0:	b8 5e 42 10 c0       	mov    $0xc010425e,%eax
c01026e5:	83 ec 08             	sub    $0x8,%esp
c01026e8:	50                   	push   %eax
c01026e9:	6a 2c                	push   $0x2c
c01026eb:	e8 85 fb ff ff       	call   c0102275 <idt_set_gate>
c01026f0:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(45,(uint32_t)irq13);
c01026f3:	b8 68 42 10 c0       	mov    $0xc0104268,%eax
c01026f8:	83 ec 08             	sub    $0x8,%esp
c01026fb:	50                   	push   %eax
c01026fc:	6a 2d                	push   $0x2d
c01026fe:	e8 72 fb ff ff       	call   c0102275 <idt_set_gate>
c0102703:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(46,(uint32_t)irq14);
c0102706:	b8 72 42 10 c0       	mov    $0xc0104272,%eax
c010270b:	83 ec 08             	sub    $0x8,%esp
c010270e:	50                   	push   %eax
c010270f:	6a 2e                	push   $0x2e
c0102711:	e8 5f fb ff ff       	call   c0102275 <idt_set_gate>
c0102716:	83 c4 10             	add    $0x10,%esp
    idt_set_gate(47,(uint32_t)irq15);
c0102719:	b8 7c 42 10 c0       	mov    $0xc010427c,%eax
c010271e:	83 ec 08             	sub    $0x8,%esp
c0102721:	50                   	push   %eax
c0102722:	6a 2f                	push   $0x2f
c0102724:	e8 4c fb ff ff       	call   c0102275 <idt_set_gate>
c0102729:	83 c4 10             	add    $0x10,%esp

    load_idt();
c010272c:	e8 8c fb ff ff       	call   c01022bd <load_idt>
    
    asm volatile("sti");
c0102731:	fb                   	sti    
}
c0102732:	90                   	nop
c0102733:	c9                   	leave  
c0102734:	c3                   	ret    

c0102735 <isr_handler>:

/**
 * Handler for non-PIC interrupts
 * \param r The saved state of the CPU
*/
void isr_handler(registers_t* r) {
c0102735:	55                   	push   %ebp
c0102736:	89 e5                	mov    %esp,%ebp
c0102738:	53                   	push   %ebx
c0102739:	83 ec 24             	sub    $0x24,%esp
  if (r->int_no!=80 && r->int_no!=14) {
c010273c:	8b 45 08             	mov    0x8(%ebp),%eax
c010273f:	8b 40 24             	mov    0x24(%eax),%eax
c0102742:	83 f8 50             	cmp    $0x50,%eax
c0102745:	74 24                	je     c010276b <isr_handler+0x36>
c0102747:	8b 45 08             	mov    0x8(%ebp),%eax
c010274a:	8b 40 24             	mov    0x24(%eax),%eax
c010274d:	83 f8 0e             	cmp    $0xe,%eax
c0102750:	74 19                	je     c010276b <isr_handler+0x36>
    serial_write_string(exception_messages[r->int_no]);
c0102752:	8b 45 08             	mov    0x8(%ebp),%eax
c0102755:	8b 40 24             	mov    0x24(%eax),%eax
c0102758:	8b 04 85 20 80 10 c0 	mov    -0x3fef7fe0(,%eax,4),%eax
c010275f:	83 ec 0c             	sub    $0xc,%esp
c0102762:	50                   	push   %eax
c0102763:	e8 b0 16 00 00       	call   c0103e18 <serial_write_string>
c0102768:	83 c4 10             	add    $0x10,%esp
  }
  switch (r->int_no) {
c010276b:	8b 45 08             	mov    0x8(%ebp),%eax
c010276e:	8b 40 24             	mov    0x24(%eax),%eax
c0102771:	83 f8 0e             	cmp    $0xe,%eax
c0102774:	74 0e                	je     c0102784 <isr_handler+0x4f>
c0102776:	83 f8 50             	cmp    $0x50,%eax
c0102779:	0f 84 ee 01 00 00    	je     c010296d <isr_handler+0x238>
c010277f:	e9 1a 06 00 00       	jmp    c0102d9e <isr_handler+0x669>
    case 14: {
      serial_write_string("PAGE FAULT\n");
c0102784:	83 ec 0c             	sub    $0xc,%esp
c0102787:	68 18 66 10 c0       	push   $0xc0106618
c010278c:	e8 87 16 00 00       	call   c0103e18 <serial_write_string>
c0102791:	83 c4 10             	add    $0x10,%esp
      void* addr;
      asm("movl %%cr2,%0": "=r"(addr));
c0102794:	0f 20 d0             	mov    %cr2,%eax
c0102797:	89 45 ec             	mov    %eax,-0x14(%ebp)
      serial_write_string("In PID ");
c010279a:	83 ec 0c             	sub    $0xc,%esp
c010279d:	68 24 66 10 c0       	push   $0xc0106624
c01027a2:	e8 71 16 00 00       	call   c0103e18 <serial_write_string>
c01027a7:	83 c4 10             	add    $0x10,%esp
      char str[11];
      int_to_ascii(tasking_get_PID(),str);
c01027aa:	e8 e4 ed ff ff       	call   c0101593 <tasking_get_PID>
c01027af:	83 ec 08             	sub    $0x8,%esp
c01027b2:	8d 55 dd             	lea    -0x23(%ebp),%edx
c01027b5:	52                   	push   %edx
c01027b6:	50                   	push   %eax
c01027b7:	e8 a6 2b 00 00       	call   c0105362 <int_to_ascii>
c01027bc:	83 c4 10             	add    $0x10,%esp
      serial_write_string(str);
c01027bf:	83 ec 0c             	sub    $0xc,%esp
c01027c2:	8d 45 dd             	lea    -0x23(%ebp),%eax
c01027c5:	50                   	push   %eax
c01027c6:	e8 4d 16 00 00       	call   c0103e18 <serial_write_string>
c01027cb:	83 c4 10             	add    $0x10,%esp
      if (r->err_code==0) {
c01027ce:	8b 45 08             	mov    0x8(%ebp),%eax
c01027d1:	8b 40 28             	mov    0x28(%eax),%eax
c01027d4:	85 c0                	test   %eax,%eax
c01027d6:	75 15                	jne    c01027ed <isr_handler+0xb8>
        serial_write_string(", kernel process tried to read a non-present page entry at address ");
c01027d8:	83 ec 0c             	sub    $0xc,%esp
c01027db:	68 2c 66 10 c0       	push   $0xc010662c
c01027e0:	e8 33 16 00 00       	call   c0103e18 <serial_write_string>
c01027e5:	83 c4 10             	add    $0x10,%esp
c01027e8:	e9 cf 00 00 00       	jmp    c01028bc <isr_handler+0x187>
      } else if (r->err_code==1) {
c01027ed:	8b 45 08             	mov    0x8(%ebp),%eax
c01027f0:	8b 40 28             	mov    0x28(%eax),%eax
c01027f3:	83 f8 01             	cmp    $0x1,%eax
c01027f6:	75 15                	jne    c010280d <isr_handler+0xd8>
        serial_write_string(", kernel process tried to read a page and caused a protection fault at address ");
c01027f8:	83 ec 0c             	sub    $0xc,%esp
c01027fb:	68 70 66 10 c0       	push   $0xc0106670
c0102800:	e8 13 16 00 00       	call   c0103e18 <serial_write_string>
c0102805:	83 c4 10             	add    $0x10,%esp
c0102808:	e9 af 00 00 00       	jmp    c01028bc <isr_handler+0x187>
      } else if (r->err_code==2) {
c010280d:	8b 45 08             	mov    0x8(%ebp),%eax
c0102810:	8b 40 28             	mov    0x28(%eax),%eax
c0102813:	83 f8 02             	cmp    $0x2,%eax
c0102816:	75 15                	jne    c010282d <isr_handler+0xf8>
        serial_write_string(", kernel process tried to write to a non-present page entry at address ");
c0102818:	83 ec 0c             	sub    $0xc,%esp
c010281b:	68 c0 66 10 c0       	push   $0xc01066c0
c0102820:	e8 f3 15 00 00       	call   c0103e18 <serial_write_string>
c0102825:	83 c4 10             	add    $0x10,%esp
c0102828:	e9 8f 00 00 00       	jmp    c01028bc <isr_handler+0x187>
      } else if (r->err_code==3) {
c010282d:	8b 45 08             	mov    0x8(%ebp),%eax
c0102830:	8b 40 28             	mov    0x28(%eax),%eax
c0102833:	83 f8 03             	cmp    $0x3,%eax
c0102836:	75 12                	jne    c010284a <isr_handler+0x115>
        serial_write_string(", kernel process tried to write a page and caused a protection fault at address ");
c0102838:	83 ec 0c             	sub    $0xc,%esp
c010283b:	68 08 67 10 c0       	push   $0xc0106708
c0102840:	e8 d3 15 00 00       	call   c0103e18 <serial_write_string>
c0102845:	83 c4 10             	add    $0x10,%esp
c0102848:	eb 72                	jmp    c01028bc <isr_handler+0x187>
      } else if (r->err_code==4) {
c010284a:	8b 45 08             	mov    0x8(%ebp),%eax
c010284d:	8b 40 28             	mov    0x28(%eax),%eax
c0102850:	83 f8 04             	cmp    $0x4,%eax
c0102853:	75 12                	jne    c0102867 <isr_handler+0x132>
        serial_write_string(", user process tried to read a non-present page entry at address ");
c0102855:	83 ec 0c             	sub    $0xc,%esp
c0102858:	68 5c 67 10 c0       	push   $0xc010675c
c010285d:	e8 b6 15 00 00       	call   c0103e18 <serial_write_string>
c0102862:	83 c4 10             	add    $0x10,%esp
c0102865:	eb 55                	jmp    c01028bc <isr_handler+0x187>
      } else if (r->err_code==5) {
c0102867:	8b 45 08             	mov    0x8(%ebp),%eax
c010286a:	8b 40 28             	mov    0x28(%eax),%eax
c010286d:	83 f8 05             	cmp    $0x5,%eax
c0102870:	75 12                	jne    c0102884 <isr_handler+0x14f>
        serial_write_string(", user process tried to read a page and caused a protection fault at address ");
c0102872:	83 ec 0c             	sub    $0xc,%esp
c0102875:	68 a0 67 10 c0       	push   $0xc01067a0
c010287a:	e8 99 15 00 00       	call   c0103e18 <serial_write_string>
c010287f:	83 c4 10             	add    $0x10,%esp
c0102882:	eb 38                	jmp    c01028bc <isr_handler+0x187>
      } else if (r->err_code==6) {
c0102884:	8b 45 08             	mov    0x8(%ebp),%eax
c0102887:	8b 40 28             	mov    0x28(%eax),%eax
c010288a:	83 f8 06             	cmp    $0x6,%eax
c010288d:	75 12                	jne    c01028a1 <isr_handler+0x16c>
        serial_write_string(", user process tried to write to a non-present page entry at address ");
c010288f:	83 ec 0c             	sub    $0xc,%esp
c0102892:	68 f0 67 10 c0       	push   $0xc01067f0
c0102897:	e8 7c 15 00 00       	call   c0103e18 <serial_write_string>
c010289c:	83 c4 10             	add    $0x10,%esp
c010289f:	eb 1b                	jmp    c01028bc <isr_handler+0x187>
      } else if (r->err_code==7) {
c01028a1:	8b 45 08             	mov    0x8(%ebp),%eax
c01028a4:	8b 40 28             	mov    0x28(%eax),%eax
c01028a7:	83 f8 07             	cmp    $0x7,%eax
c01028aa:	75 10                	jne    c01028bc <isr_handler+0x187>
        serial_write_string(", user process tried to write a page and caused a protection fault at address ");
c01028ac:	83 ec 0c             	sub    $0xc,%esp
c01028af:	68 38 68 10 c0       	push   $0xc0106838
c01028b4:	e8 5f 15 00 00       	call   c0103e18 <serial_write_string>
c01028b9:	83 c4 10             	add    $0x10,%esp
      }
      str[0]='\0';
c01028bc:	c6 45 dd 00          	movb   $0x0,-0x23(%ebp)
      hex_to_ascii((unsigned int)addr,str);
c01028c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01028c3:	83 ec 08             	sub    $0x8,%esp
c01028c6:	8d 55 dd             	lea    -0x23(%ebp),%edx
c01028c9:	52                   	push   %edx
c01028ca:	50                   	push   %eax
c01028cb:	e8 23 2b 00 00       	call   c01053f3 <hex_to_ascii>
c01028d0:	83 c4 10             	add    $0x10,%esp
      serial_write_string(str);
c01028d3:	83 ec 0c             	sub    $0xc,%esp
c01028d6:	8d 45 dd             	lea    -0x23(%ebp),%eax
c01028d9:	50                   	push   %eax
c01028da:	e8 39 15 00 00       	call   c0103e18 <serial_write_string>
c01028df:	83 c4 10             	add    $0x10,%esp
      serial_write_string(".\n");
c01028e2:	83 ec 0c             	sub    $0xc,%esp
c01028e5:	68 87 68 10 c0       	push   $0xc0106887
c01028ea:	e8 29 15 00 00       	call   c0103e18 <serial_write_string>
c01028ef:	83 c4 10             	add    $0x10,%esp
      serial_printf("EAX: %x EBX: %x ECX: %x EDX: %x\n", r->eax, r->ebx, r->ecx, r->edx);
c01028f2:	8b 45 08             	mov    0x8(%ebp),%eax
c01028f5:	8b 58 18             	mov    0x18(%eax),%ebx
c01028f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01028fb:	8b 48 1c             	mov    0x1c(%eax),%ecx
c01028fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0102901:	8b 50 14             	mov    0x14(%eax),%edx
c0102904:	8b 45 08             	mov    0x8(%ebp),%eax
c0102907:	8b 40 20             	mov    0x20(%eax),%eax
c010290a:	83 ec 0c             	sub    $0xc,%esp
c010290d:	53                   	push   %ebx
c010290e:	51                   	push   %ecx
c010290f:	52                   	push   %edx
c0102910:	50                   	push   %eax
c0102911:	68 8c 68 10 c0       	push   $0xc010688c
c0102916:	e8 3a 15 00 00       	call   c0103e55 <serial_printf>
c010291b:	83 c4 20             	add    $0x20,%esp
      serial_printf("ESI: %x EDI: %x ESP: %x EBP: %x\n", r->esi, r->edi, r->useresp, r->ebp);
c010291e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102921:	8b 58 0c             	mov    0xc(%eax),%ebx
c0102924:	8b 45 08             	mov    0x8(%ebp),%eax
c0102927:	8b 48 38             	mov    0x38(%eax),%ecx
c010292a:	8b 45 08             	mov    0x8(%ebp),%eax
c010292d:	8b 50 04             	mov    0x4(%eax),%edx
c0102930:	8b 45 08             	mov    0x8(%ebp),%eax
c0102933:	8b 40 08             	mov    0x8(%eax),%eax
c0102936:	83 ec 0c             	sub    $0xc,%esp
c0102939:	53                   	push   %ebx
c010293a:	51                   	push   %ecx
c010293b:	52                   	push   %edx
c010293c:	50                   	push   %eax
c010293d:	68 b0 68 10 c0       	push   $0xc01068b0
c0102942:	e8 0e 15 00 00       	call   c0103e55 <serial_printf>
c0102947:	83 c4 20             	add    $0x20,%esp
      serial_printf("EIP: %x, EFLAGS: %x", r->eip, r->eflags);
c010294a:	8b 45 08             	mov    0x8(%ebp),%eax
c010294d:	8b 50 34             	mov    0x34(%eax),%edx
c0102950:	8b 45 08             	mov    0x8(%ebp),%eax
c0102953:	8b 40 2c             	mov    0x2c(%eax),%eax
c0102956:	83 ec 04             	sub    $0x4,%esp
c0102959:	52                   	push   %edx
c010295a:	50                   	push   %eax
c010295b:	68 d1 68 10 c0       	push   $0xc01068d1
c0102960:	e8 f0 14 00 00       	call   c0103e55 <serial_printf>
c0102965:	83 c4 10             	add    $0x10,%esp
      //   //   set_table_entry(dir_entry,table_entry,((dir_entry*1024)+table_entry)*0x1000,1,1,1);
      //   //   set_directory_entry(dir_entry,dir_entry,1,1,1);
      //   // }
      //   // return;
      // }
      halt();
c0102968:	e8 f3 16 00 00       	call   c0104060 <halt>
      break;
    case 80:
      switch (r->eax) {
c010296d:	8b 45 08             	mov    0x8(%ebp),%eax
c0102970:	8b 40 20             	mov    0x20(%eax),%eax
c0102973:	83 f8 1c             	cmp    $0x1c,%eax
c0102976:	0f 87 22 04 00 00    	ja     c0102d9e <isr_handler+0x669>
c010297c:	8b 04 85 80 69 10 c0 	mov    -0x3fef9680(,%eax,4),%eax
c0102983:	ff e0                	jmp    *%eax
      case SYSCALL_CREATEPROC:
        tasking_create_task((void*)r->ebx,(void*)r->ecx,0,(void*)r->edx,(void*)r->esi,0,0);
c0102985:	8b 45 08             	mov    0x8(%ebp),%eax
c0102988:	8b 40 08             	mov    0x8(%eax),%eax
c010298b:	89 c3                	mov    %eax,%ebx
c010298d:	8b 45 08             	mov    0x8(%ebp),%eax
c0102990:	8b 40 18             	mov    0x18(%eax),%eax
c0102993:	89 c1                	mov    %eax,%ecx
c0102995:	8b 45 08             	mov    0x8(%ebp),%eax
c0102998:	8b 40 1c             	mov    0x1c(%eax),%eax
c010299b:	89 c2                	mov    %eax,%edx
c010299d:	8b 45 08             	mov    0x8(%ebp),%eax
c01029a0:	8b 40 14             	mov    0x14(%eax),%eax
c01029a3:	83 ec 04             	sub    $0x4,%esp
c01029a6:	6a 00                	push   $0x0
c01029a8:	6a 00                	push   $0x0
c01029aa:	53                   	push   %ebx
c01029ab:	51                   	push   %ecx
c01029ac:	6a 00                	push   $0x0
c01029ae:	52                   	push   %edx
c01029af:	50                   	push   %eax
c01029b0:	e8 ec e8 ff ff       	call   c01012a1 <tasking_create_task>
c01029b5:	83 c4 20             	add    $0x20,%esp
        break;
c01029b8:	e9 e1 03 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_YIELD:
        tasking_yield();
c01029bd:	e8 32 ee ff ff       	call   c01017f4 <tasking_yield>
        break;
c01029c2:	e9 d7 03 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_BLOCK:
        tasking_block(r->ebx);
c01029c7:	8b 45 08             	mov    0x8(%ebp),%eax
c01029ca:	8b 40 14             	mov    0x14(%eax),%eax
c01029cd:	83 ec 0c             	sub    $0xc,%esp
c01029d0:	50                   	push   %eax
c01029d1:	e8 30 ef ff ff       	call   c0101906 <tasking_block>
c01029d6:	83 c4 10             	add    $0x10,%esp
        break;
c01029d9:	e9 c0 03 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_UNBLOCK:
        tasking_unblock(r->ebx,r->ecx);
c01029de:	8b 45 08             	mov    0x8(%ebp),%eax
c01029e1:	8b 40 1c             	mov    0x1c(%eax),%eax
c01029e4:	89 c2                	mov    %eax,%edx
c01029e6:	8b 45 08             	mov    0x8(%ebp),%eax
c01029e9:	8b 40 14             	mov    0x14(%eax),%eax
c01029ec:	83 ec 08             	sub    $0x8,%esp
c01029ef:	52                   	push   %edx
c01029f0:	50                   	push   %eax
c01029f1:	e8 1e f1 ff ff       	call   c0101b14 <tasking_unblock>
c01029f6:	83 c4 10             	add    $0x10,%esp
        break;
c01029f9:	e9 a0 03 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_EXIT:
        tasking_exit((uint8_t)r->ebx);
c01029fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a01:	8b 40 14             	mov    0x14(%eax),%eax
c0102a04:	0f b6 c0             	movzbl %al,%eax
c0102a07:	83 ec 0c             	sub    $0xc,%esp
c0102a0a:	50                   	push   %eax
c0102a0b:	e8 96 f1 ff ff       	call   c0101ba6 <tasking_exit>
c0102a10:	83 c4 10             	add    $0x10,%esp
        break;
c0102a13:	e9 86 03 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_GET_ERRNO_ADDR:
        r->ebx=(uint32_t)tasking_get_errno_address();
c0102a18:	e8 93 eb ff ff       	call   c01015b0 <tasking_get_errno_address>
c0102a1d:	89 c2                	mov    %eax,%edx
c0102a1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a22:	89 50 14             	mov    %edx,0x14(%eax)
        break;
c0102a25:	e9 74 03 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_GET_PID:
        r->ebx=(pid_t)tasking_get_PID();
c0102a2a:	e8 64 eb ff ff       	call   c0101593 <tasking_get_PID>
c0102a2f:	89 c2                	mov    %eax,%edx
c0102a31:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a34:	89 50 14             	mov    %edx,0x14(%eax)
        break;
c0102a37:	e9 62 03 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_ALLOC_MEM:
        if ((void*)r->ecx==NULL) {
c0102a3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a3f:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102a42:	85 c0                	test   %eax,%eax
c0102a44:	75 1f                	jne    c0102a65 <isr_handler+0x330>
          r->ebx=(uint32_t)alloc_pages(r->ebx);
c0102a46:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a49:	8b 40 14             	mov    0x14(%eax),%eax
c0102a4c:	83 ec 0c             	sub    $0xc,%esp
c0102a4f:	50                   	push   %eax
c0102a50:	e8 bc 07 00 00       	call   c0103211 <alloc_pages>
c0102a55:	83 c4 10             	add    $0x10,%esp
c0102a58:	89 c2                	mov    %eax,%edx
c0102a5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a5d:	89 50 14             	mov    %edx,0x14(%eax)
        } else {
          alloc_pages_virt(r->ebx,(void*)r->ecx);
        }
        break;
c0102a60:	e9 39 03 00 00       	jmp    c0102d9e <isr_handler+0x669>
          alloc_pages_virt(r->ebx,(void*)r->ecx);
c0102a65:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a68:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102a6b:	89 c2                	mov    %eax,%edx
c0102a6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a70:	8b 40 14             	mov    0x14(%eax),%eax
c0102a73:	83 ec 08             	sub    $0x8,%esp
c0102a76:	52                   	push   %edx
c0102a77:	50                   	push   %eax
c0102a78:	e8 5b 08 00 00       	call   c01032d8 <alloc_pages_virt>
c0102a7d:	83 c4 10             	add    $0x10,%esp
        break;
c0102a80:	e9 19 03 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_PRIV_MAP_PAGES:
        if (!tasking_is_privleged()) {
c0102a85:	e8 fa ea ff ff       	call   c0101584 <tasking_is_privleged>
c0102a8a:	84 c0                	test   %al,%al
c0102a8c:	75 0f                	jne    c0102a9d <isr_handler+0x368>
          r->ebx=0;
c0102a8e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102a91:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
c0102a98:	e9 d9 03 00 00       	jmp    c0102e76 <isr_handler+0x741>
          return;
        }
        void* virt_addr=find_free_pages(r->ecx);
c0102a9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0102aa0:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102aa3:	83 ec 0c             	sub    $0xc,%esp
c0102aa6:	50                   	push   %eax
c0102aa7:	e8 a6 06 00 00       	call   c0103152 <find_free_pages>
c0102aac:	83 c4 10             	add    $0x10,%esp
c0102aaf:	89 45 f0             	mov    %eax,-0x10(%ebp)
        map_pages(virt_addr,(void*)r->ebx,r->ecx,1,1);
c0102ab2:	8b 45 08             	mov    0x8(%ebp),%eax
c0102ab5:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102ab8:	89 c2                	mov    %eax,%edx
c0102aba:	8b 45 08             	mov    0x8(%ebp),%eax
c0102abd:	8b 40 14             	mov    0x14(%eax),%eax
c0102ac0:	83 ec 0c             	sub    $0xc,%esp
c0102ac3:	6a 01                	push   $0x1
c0102ac5:	6a 01                	push   $0x1
c0102ac7:	52                   	push   %edx
c0102ac8:	50                   	push   %eax
c0102ac9:	ff 75 f0             	pushl  -0x10(%ebp)
c0102acc:	e8 d8 04 00 00       	call   c0102fa9 <map_pages>
c0102ad1:	83 c4 20             	add    $0x20,%esp
        r->ebx=(uint32_t)virt_addr;
c0102ad4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0102ad7:	8b 45 08             	mov    0x8(%ebp),%eax
c0102ada:	89 50 14             	mov    %edx,0x14(%eax)
        break;
c0102add:	e9 bc 02 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_NEW_ADDR_SPACE:
        r->ebx=(uint32_t)paging_new_address_space();
c0102ae2:	e8 1d 08 00 00       	call   c0103304 <paging_new_address_space>
c0102ae7:	89 c2                	mov    %eax,%edx
c0102ae9:	8b 45 08             	mov    0x8(%ebp),%eax
c0102aec:	89 50 14             	mov    %edx,0x14(%eax)
        break;
c0102aef:	e9 aa 02 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_ADDR_SPACES_COPY_DATA:
        if ((void*)r->esi!=NULL) {
c0102af4:	8b 45 08             	mov    0x8(%ebp),%eax
c0102af7:	8b 40 08             	mov    0x8(%eax),%eax
c0102afa:	85 c0                	test   %eax,%eax
c0102afc:	74 2d                	je     c0102b2b <isr_handler+0x3f6>
          address_spaces_copy_data((void*)r->ebx,(void*)r->ecx,r->edx,(void*)r->esi);
c0102afe:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b01:	8b 40 08             	mov    0x8(%eax),%eax
c0102b04:	89 c3                	mov    %eax,%ebx
c0102b06:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b09:	8b 40 18             	mov    0x18(%eax),%eax
c0102b0c:	8b 55 08             	mov    0x8(%ebp),%edx
c0102b0f:	8b 52 1c             	mov    0x1c(%edx),%edx
c0102b12:	89 d1                	mov    %edx,%ecx
c0102b14:	8b 55 08             	mov    0x8(%ebp),%edx
c0102b17:	8b 52 14             	mov    0x14(%edx),%edx
c0102b1a:	53                   	push   %ebx
c0102b1b:	50                   	push   %eax
c0102b1c:	51                   	push   %ecx
c0102b1d:	52                   	push   %edx
c0102b1e:	e8 1d d5 ff ff       	call   c0100040 <address_spaces_copy_data>
c0102b23:	83 c4 10             	add    $0x10,%esp
        } else {
          r->ebx=(uint32_t)address_spaces_put_data((void*)r->ebx,(void*)r->ecx,r->edx);
        }
        break;
c0102b26:	e9 73 02 00 00       	jmp    c0102d9e <isr_handler+0x669>
          r->ebx=(uint32_t)address_spaces_put_data((void*)r->ebx,(void*)r->ecx,r->edx);
c0102b2b:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b2e:	8b 40 18             	mov    0x18(%eax),%eax
c0102b31:	8b 55 08             	mov    0x8(%ebp),%edx
c0102b34:	8b 52 1c             	mov    0x1c(%edx),%edx
c0102b37:	89 d1                	mov    %edx,%ecx
c0102b39:	8b 55 08             	mov    0x8(%ebp),%edx
c0102b3c:	8b 52 14             	mov    0x14(%edx),%edx
c0102b3f:	83 ec 04             	sub    $0x4,%esp
c0102b42:	50                   	push   %eax
c0102b43:	51                   	push   %ecx
c0102b44:	52                   	push   %edx
c0102b45:	e8 51 d5 ff ff       	call   c010009b <address_spaces_put_data>
c0102b4a:	83 c4 10             	add    $0x10,%esp
c0102b4d:	89 c2                	mov    %eax,%edx
c0102b4f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b52:	89 50 14             	mov    %edx,0x14(%eax)
        break;
c0102b55:	e9 44 02 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_SERIAL_PRINT:
        serial_write_string((char*)r->ebx);
c0102b5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b5d:	8b 40 14             	mov    0x14(%eax),%eax
c0102b60:	83 ec 0c             	sub    $0xc,%esp
c0102b63:	50                   	push   %eax
c0102b64:	e8 af 12 00 00       	call   c0103e18 <serial_write_string>
c0102b69:	83 c4 10             	add    $0x10,%esp
        break;
c0102b6c:	e9 2d 02 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_GET_INITRD_SZ:
        r->ebx=initrd_sz;
c0102b71:	a1 00 90 10 c0       	mov    0xc0109000,%eax
c0102b76:	89 c2                	mov    %eax,%edx
c0102b78:	8b 45 08             	mov    0x8(%ebp),%eax
c0102b7b:	89 50 14             	mov    %edx,0x14(%eax)
        break;
c0102b7e:	e9 1b 02 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_COPY_INITRD:
        memcpy((char*)r->ebx,initrd,initrd_sz);
c0102b83:	a1 00 90 10 c0       	mov    0xc0109000,%eax
c0102b88:	89 c1                	mov    %eax,%ecx
c0102b8a:	a1 04 90 10 c0       	mov    0xc0109004,%eax
c0102b8f:	8b 55 08             	mov    0x8(%ebp),%edx
c0102b92:	8b 52 14             	mov    0x14(%edx),%edx
c0102b95:	83 ec 04             	sub    $0x4,%esp
c0102b98:	51                   	push   %ecx
c0102b99:	50                   	push   %eax
c0102b9a:	52                   	push   %edx
c0102b9b:	e8 28 26 00 00       	call   c01051c8 <memcpy>
c0102ba0:	83 c4 10             	add    $0x10,%esp
        break;
c0102ba3:	e9 f6 01 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_NEW_THREAD: {
        uint32_t tid=tasking_new_thread((void*)r->ebx,tasking_get_PID(),(void*)r->edx,0);
c0102ba8:	8b 45 08             	mov    0x8(%ebp),%eax
c0102bab:	8b 40 18             	mov    0x18(%eax),%eax
c0102bae:	89 c3                	mov    %eax,%ebx
c0102bb0:	e8 de e9 ff ff       	call   c0101593 <tasking_get_PID>
c0102bb5:	8b 55 08             	mov    0x8(%ebp),%edx
c0102bb8:	8b 52 14             	mov    0x14(%edx),%edx
c0102bbb:	6a 00                	push   $0x0
c0102bbd:	53                   	push   %ebx
c0102bbe:	50                   	push   %eax
c0102bbf:	52                   	push   %edx
c0102bc0:	e8 f8 e9 ff ff       	call   c01015bd <tasking_new_thread>
c0102bc5:	83 c4 10             	add    $0x10,%esp
c0102bc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if ((uint32_t*)r->ecx!=NULL) {
c0102bcb:	8b 45 08             	mov    0x8(%ebp),%eax
c0102bce:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102bd1:	85 c0                	test   %eax,%eax
c0102bd3:	0f 84 c4 01 00 00    	je     c0102d9d <isr_handler+0x668>
          *((uint32_t*)r->ecx)=tid;
c0102bd9:	8b 45 08             	mov    0x8(%ebp),%eax
c0102bdc:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102bdf:	89 c2                	mov    %eax,%edx
c0102be1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102be4:	89 02                	mov    %eax,(%edx)
        }
      }
      break;
c0102be6:	e9 b2 01 00 00       	jmp    c0102d9d <isr_handler+0x668>
      case SYSCALL_THREAD_EXIT:
        tasking_thread_exit();
c0102beb:	e8 69 f2 ff ff       	call   c0101e59 <tasking_thread_exit>
        break;
c0102bf0:	e9 a9 01 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_CALL_RPC:
        r->edi=(uint32_t)kernel_rpc_call((pid_t)r->ebx,(char*)r->ecx,(void*)r->edx,(size_t)r->esi);
c0102bf5:	8b 45 08             	mov    0x8(%ebp),%eax
c0102bf8:	8b 40 08             	mov    0x8(%eax),%eax
c0102bfb:	8b 55 08             	mov    0x8(%ebp),%edx
c0102bfe:	8b 52 18             	mov    0x18(%edx),%edx
c0102c01:	89 d3                	mov    %edx,%ebx
c0102c03:	8b 55 08             	mov    0x8(%ebp),%edx
c0102c06:	8b 52 1c             	mov    0x1c(%edx),%edx
c0102c09:	89 d1                	mov    %edx,%ecx
c0102c0b:	8b 55 08             	mov    0x8(%ebp),%edx
c0102c0e:	8b 52 14             	mov    0x14(%edx),%edx
c0102c11:	50                   	push   %eax
c0102c12:	53                   	push   %ebx
c0102c13:	51                   	push   %ecx
c0102c14:	52                   	push   %edx
c0102c15:	e8 d2 df ff ff       	call   c0100bec <kernel_rpc_call>
c0102c1a:	83 c4 10             	add    $0x10,%esp
c0102c1d:	89 c2                	mov    %eax,%edx
c0102c1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c22:	89 50 04             	mov    %edx,0x4(%eax)
        break;
c0102c25:	e9 74 01 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_REGISTER_RPC:
        kernel_rpc_register_func((char*)r->ebx,(rpc_func)r->ecx);
c0102c2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c2d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102c30:	89 c2                	mov    %eax,%edx
c0102c32:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c35:	8b 40 14             	mov    0x14(%eax),%eax
c0102c38:	83 ec 08             	sub    $0x8,%esp
c0102c3b:	52                   	push   %edx
c0102c3c:	50                   	push   %eax
c0102c3d:	e8 c4 e1 ff ff       	call   c0100e06 <kernel_rpc_register_func>
c0102c42:	83 c4 10             	add    $0x10,%esp
        break;
c0102c45:	e9 54 01 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_DEALLOCTATE_RPC_RET:
        kernel_rpc_deallocate_buf((void*)r->ebx,(size_t)r->ecx);
c0102c4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c4d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102c50:	8b 55 08             	mov    0x8(%ebp),%edx
c0102c53:	8b 52 14             	mov    0x14(%edx),%edx
c0102c56:	83 ec 08             	sub    $0x8,%esp
c0102c59:	50                   	push   %eax
c0102c5a:	52                   	push   %edx
c0102c5b:	e8 54 e2 ff ff       	call   c0100eb4 <kernel_rpc_deallocate_buf>
c0102c60:	83 c4 10             	add    $0x10,%esp
        break;
c0102c63:	e9 36 01 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_RPC_RET:
        kernel_rpc_return((void*)r->ebx,(size_t)r->ecx);
c0102c68:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c6b:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102c6e:	8b 55 08             	mov    0x8(%ebp),%edx
c0102c71:	8b 52 14             	mov    0x14(%edx),%edx
c0102c74:	83 ec 08             	sub    $0x8,%esp
c0102c77:	50                   	push   %eax
c0102c78:	52                   	push   %edx
c0102c79:	e8 5d e2 ff ff       	call   c0100edb <kernel_rpc_return>
c0102c7e:	83 c4 10             	add    $0x10,%esp
        break;
c0102c81:	e9 18 01 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_CHECK_PROC_EXISTS:
        r->ecx=tasking_check_proc_exists((pid_t)r->ebx);
c0102c86:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c89:	8b 40 14             	mov    0x14(%eax),%eax
c0102c8c:	83 ec 0c             	sub    $0xc,%esp
c0102c8f:	50                   	push   %eax
c0102c90:	e8 09 f2 ff ff       	call   c0101e9e <tasking_check_proc_exists>
c0102c95:	83 c4 10             	add    $0x10,%esp
c0102c98:	0f be d0             	movsbl %al,%edx
c0102c9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0102c9e:	89 50 1c             	mov    %edx,0x1c(%eax)
        break;
c0102ca1:	e9 f8 00 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_RPC_MARK_AS_INIT:
        kernel_rpc_mark_as_init();
c0102ca6:	e8 41 e3 ff ff       	call   c0100fec <kernel_rpc_mark_as_init>
        break;
c0102cab:	e9 ee 00 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_RPC_IS_INIT:
        r->ecx=kernel_rpc_is_init((pid_t)r->ebx);
c0102cb0:	8b 45 08             	mov    0x8(%ebp),%eax
c0102cb3:	8b 40 14             	mov    0x14(%eax),%eax
c0102cb6:	83 ec 0c             	sub    $0xc,%esp
c0102cb9:	50                   	push   %eax
c0102cba:	e8 d6 de ff ff       	call   c0100b95 <kernel_rpc_is_init>
c0102cbf:	83 c4 10             	add    $0x10,%esp
c0102cc2:	0f be d0             	movsbl %al,%edx
c0102cc5:	8b 45 08             	mov    0x8(%ebp),%eax
c0102cc8:	89 50 1c             	mov    %edx,0x1c(%eax)
        break;
c0102ccb:	e9 ce 00 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_REGISTER_IRQ_HANDLER:
        isr_register_handler((int)r->ebx,tasking_get_PID(),(void*)r->ecx);
c0102cd0:	8b 45 08             	mov    0x8(%ebp),%eax
c0102cd3:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102cd6:	89 c3                	mov    %eax,%ebx
c0102cd8:	e8 b6 e8 ff ff       	call   c0101593 <tasking_get_PID>
c0102cdd:	8b 55 08             	mov    0x8(%ebp),%edx
c0102ce0:	8b 52 14             	mov    0x14(%edx),%edx
c0102ce3:	83 ec 04             	sub    $0x4,%esp
c0102ce6:	53                   	push   %ebx
c0102ce7:	50                   	push   %eax
c0102ce8:	52                   	push   %edx
c0102ce9:	e8 8d 01 00 00       	call   c0102e7b <isr_register_handler>
c0102cee:	83 c4 10             	add    $0x10,%esp
        break;
c0102cf1:	e9 a8 00 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_SERIAL_PUTC:
        serial_putc_port((char)r->ebx,(int)r->ecx);
c0102cf6:	8b 45 08             	mov    0x8(%ebp),%eax
c0102cf9:	8b 40 1c             	mov    0x1c(%eax),%eax
c0102cfc:	89 c2                	mov    %eax,%edx
c0102cfe:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d01:	8b 40 14             	mov    0x14(%eax),%eax
c0102d04:	0f be c0             	movsbl %al,%eax
c0102d07:	83 ec 08             	sub    $0x8,%esp
c0102d0a:	52                   	push   %edx
c0102d0b:	50                   	push   %eax
c0102d0c:	e8 d6 0c 00 00       	call   c01039e7 <serial_putc_port>
c0102d11:	83 c4 10             	add    $0x10,%esp
        break;
c0102d14:	e9 85 00 00 00       	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_SERIAL_GETC:
        r->ebx=serial_getc_port((int)r->ebx);
c0102d19:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d1c:	8b 40 14             	mov    0x14(%eax),%eax
c0102d1f:	83 ec 0c             	sub    $0xc,%esp
c0102d22:	50                   	push   %eax
c0102d23:	e8 38 0d 00 00       	call   c0103a60 <serial_getc_port>
c0102d28:	83 c4 10             	add    $0x10,%esp
c0102d2b:	0f be d0             	movsbl %al,%edx
c0102d2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d31:	89 50 14             	mov    %edx,0x14(%eax)
        break;
c0102d34:	eb 68                	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_EXCEPTION_RETURN:
        serial_printf("RETURNING FROM USER EXCEPTION HANDLER\n");
c0102d36:	83 ec 0c             	sub    $0xc,%esp
c0102d39:	68 e8 68 10 c0       	push   $0xc01068e8
c0102d3e:	e8 12 11 00 00       	call   c0103e55 <serial_printf>
c0102d43:	83 c4 10             	add    $0x10,%esp
        waiting_for_exception_return[tasking_get_PID()]=0;
c0102d46:	e8 48 e8 ff ff       	call   c0101593 <tasking_get_PID>
c0102d4b:	c6 80 00 21 2b c0 00 	movb   $0x0,-0x3fd4df00(%eax)
        memcpy(exception_return_value[tasking_get_PID()], (registers_t*)r->ebx, sizeof(registers_t));
c0102d52:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d55:	8b 40 14             	mov    0x14(%eax),%eax
c0102d58:	89 c3                	mov    %eax,%ebx
c0102d5a:	e8 34 e8 ff ff       	call   c0101593 <tasking_get_PID>
c0102d5f:	8b 04 85 00 a1 2b c0 	mov    -0x3fd45f00(,%eax,4),%eax
c0102d66:	83 ec 04             	sub    $0x4,%esp
c0102d69:	6a 40                	push   $0x40
c0102d6b:	53                   	push   %ebx
c0102d6c:	50                   	push   %eax
c0102d6d:	e8 56 24 00 00       	call   c01051c8 <memcpy>
c0102d72:	83 c4 10             	add    $0x10,%esp
        break;
c0102d75:	eb 27                	jmp    c0102d9e <isr_handler+0x669>
      case SYSCALL_REGISTER_EXCEPTION_HANDLER:
        serial_printf("REGISTERING USER EXCEPTION HANDLER\n");
c0102d77:	83 ec 0c             	sub    $0xc,%esp
c0102d7a:	68 10 69 10 c0       	push   $0xc0106910
c0102d7f:	e8 d1 10 00 00       	call   c0103e55 <serial_printf>
c0102d84:	83 c4 10             	add    $0x10,%esp
        exception_handler_address[tasking_get_PID()]=(void*)r->ebx;
c0102d87:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d8a:	8b 58 14             	mov    0x14(%eax),%ebx
c0102d8d:	e8 01 e8 ff ff       	call   c0101593 <tasking_get_PID>
c0102d92:	89 da                	mov    %ebx,%edx
c0102d94:	89 14 85 00 a1 2d c0 	mov    %edx,-0x3fd25f00(,%eax,4)
        break;
c0102d9b:	eb 01                	jmp    c0102d9e <isr_handler+0x669>
      break;
c0102d9d:	90                   	nop
      }
    }
  }
  if (r->int_no!=3 || exception_handler_address[tasking_get_PID()]==NULL) {
c0102d9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102da1:	8b 40 24             	mov    0x24(%eax),%eax
c0102da4:	83 f8 03             	cmp    $0x3,%eax
c0102da7:	0f 85 c8 00 00 00    	jne    c0102e75 <isr_handler+0x740>
c0102dad:	e8 e1 e7 ff ff       	call   c0101593 <tasking_get_PID>
c0102db2:	8b 04 85 00 a1 2d c0 	mov    -0x3fd25f00(,%eax,4),%eax
c0102db9:	85 c0                	test   %eax,%eax
c0102dbb:	0f 84 b4 00 00 00    	je     c0102e75 <isr_handler+0x740>
      return;
  }
  if (waiting_for_exception_return[tasking_get_PID()]==1) {
c0102dc1:	e8 cd e7 ff ff       	call   c0101593 <tasking_get_PID>
c0102dc6:	8a 80 00 21 2b c0    	mov    -0x3fd4df00(%eax),%al
c0102dcc:	3c 01                	cmp    $0x1,%al
c0102dce:	75 15                	jne    c0102de5 <isr_handler+0x6b0>
      serial_printf("Exception handler thread had exception!\n");
c0102dd0:	83 ec 0c             	sub    $0xc,%esp
c0102dd3:	68 34 69 10 c0       	push   $0xc0106934
c0102dd8:	e8 78 10 00 00       	call   c0103e55 <serial_printf>
c0102ddd:	83 c4 10             	add    $0x10,%esp
      halt();
c0102de0:	e8 7b 12 00 00       	call   c0104060 <halt>
  }
  serial_printf("CALLING USER EXCEPTION HANDLER\n");
c0102de5:	83 ec 0c             	sub    $0xc,%esp
c0102de8:	68 60 69 10 c0       	push   $0xc0106960
c0102ded:	e8 63 10 00 00       	call   c0103e55 <serial_printf>
c0102df2:	83 c4 10             	add    $0x10,%esp
  waiting_for_exception_return[tasking_get_PID()]=1;
c0102df5:	e8 99 e7 ff ff       	call   c0101593 <tasking_get_PID>
c0102dfa:	c6 80 00 21 2b c0 01 	movb   $0x1,-0x3fd4df00(%eax)
  registers_t* r_copy=alloc_pages(1);
c0102e01:	83 ec 0c             	sub    $0xc,%esp
c0102e04:	6a 01                	push   $0x1
c0102e06:	e8 06 04 00 00       	call   c0103211 <alloc_pages>
c0102e0b:	83 c4 10             	add    $0x10,%esp
c0102e0e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  memcpy(r_copy,r,sizeof(registers_t));
c0102e11:	83 ec 04             	sub    $0x4,%esp
c0102e14:	6a 40                	push   $0x40
c0102e16:	ff 75 08             	pushl  0x8(%ebp)
c0102e19:	ff 75 e8             	pushl  -0x18(%ebp)
c0102e1c:	e8 a7 23 00 00       	call   c01051c8 <memcpy>
c0102e21:	83 c4 10             	add    $0x10,%esp
  tasking_new_thread(exception_handler_address[tasking_get_PID()],1,r_copy,1);
c0102e24:	e8 6a e7 ff ff       	call   c0101593 <tasking_get_PID>
c0102e29:	8b 04 85 00 a1 2d c0 	mov    -0x3fd25f00(,%eax,4),%eax
c0102e30:	6a 01                	push   $0x1
c0102e32:	ff 75 e8             	pushl  -0x18(%ebp)
c0102e35:	6a 01                	push   $0x1
c0102e37:	50                   	push   %eax
c0102e38:	e8 80 e7 ff ff       	call   c01015bd <tasking_new_thread>
c0102e3d:	83 c4 10             	add    $0x10,%esp
  while (waiting_for_exception_return[tasking_get_PID()]==1) { tasking_yield(); }
c0102e40:	eb 05                	jmp    c0102e47 <isr_handler+0x712>
c0102e42:	e8 ad e9 ff ff       	call   c01017f4 <tasking_yield>
c0102e47:	e8 47 e7 ff ff       	call   c0101593 <tasking_get_PID>
c0102e4c:	8a 80 00 21 2b c0    	mov    -0x3fd4df00(%eax),%al
c0102e52:	3c 01                	cmp    $0x1,%al
c0102e54:	74 ec                	je     c0102e42 <isr_handler+0x70d>
  memcpy(r, exception_return_value[tasking_get_PID()], sizeof(registers_t));
c0102e56:	e8 38 e7 ff ff       	call   c0101593 <tasking_get_PID>
c0102e5b:	8b 04 85 00 a1 2b c0 	mov    -0x3fd45f00(,%eax,4),%eax
c0102e62:	83 ec 04             	sub    $0x4,%esp
c0102e65:	6a 40                	push   $0x40
c0102e67:	50                   	push   %eax
c0102e68:	ff 75 08             	pushl  0x8(%ebp)
c0102e6b:	e8 58 23 00 00       	call   c01051c8 <memcpy>
c0102e70:	83 c4 10             	add    $0x10,%esp
c0102e73:	eb 01                	jmp    c0102e76 <isr_handler+0x741>
      return;
c0102e75:	90                   	nop
}
c0102e76:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0102e79:	c9                   	leave  
c0102e7a:	c3                   	ret    

c0102e7b <isr_register_handler>:


void isr_register_handler(int n,pid_t pid,void* handler) {
c0102e7b:	55                   	push   %ebp
c0102e7c:	89 e5                	mov    %esp,%ebp
    if (n>16) {
c0102e7e:	83 7d 08 10          	cmpl   $0x10,0x8(%ebp)
c0102e82:	7f 1c                	jg     c0102ea0 <isr_register_handler+0x25>
      return;
    }
    irq_handlers[n].pid = pid;
c0102e84:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e87:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102e8a:	89 14 c5 80 20 2b c0 	mov    %edx,-0x3fd4df80(,%eax,8)
    irq_handlers[n].handler = handler;
c0102e91:	8b 45 08             	mov    0x8(%ebp),%eax
c0102e94:	8b 55 10             	mov    0x10(%ebp),%edx
c0102e97:	89 14 c5 84 20 2b c0 	mov    %edx,-0x3fd4df7c(,%eax,8)
c0102e9e:	eb 01                	jmp    c0102ea1 <isr_register_handler+0x26>
      return;
c0102ea0:	90                   	nop
}
c0102ea1:	5d                   	pop    %ebp
c0102ea2:	c3                   	ret    

c0102ea3 <irq_handler>:

/**
 * Handler for PIC interrupts
 * \param r The saved state of the CPU
*/
void irq_handler(registers_t* r) {
c0102ea3:	55                   	push   %ebp
c0102ea4:	89 e5                	mov    %esp,%ebp
c0102ea6:	83 ec 18             	sub    $0x18,%esp
  /* After every interrupt we need to send an EOI to the PICs
    * or they will not send another interrupt again */
  if (r->int_no >= 40) port_byte_out(0xA0,0x20); /* slave */
c0102ea9:	8b 45 08             	mov    0x8(%ebp),%eax
c0102eac:	8b 40 24             	mov    0x24(%eax),%eax
c0102eaf:	83 f8 27             	cmp    $0x27,%eax
c0102eb2:	76 12                	jbe    c0102ec6 <irq_handler+0x23>
c0102eb4:	83 ec 08             	sub    $0x8,%esp
c0102eb7:	6a 20                	push   $0x20
c0102eb9:	68 a0 00 00 00       	push   $0xa0
c0102ebe:	e8 f4 21 00 00       	call   c01050b7 <port_byte_out>
c0102ec3:	83 c4 10             	add    $0x10,%esp
  port_byte_out(0x20,0x20); /* master */
c0102ec6:	83 ec 08             	sub    $0x8,%esp
c0102ec9:	6a 20                	push   $0x20
c0102ecb:	6a 20                	push   $0x20
c0102ecd:	e8 e5 21 00 00       	call   c01050b7 <port_byte_out>
c0102ed2:	83 c4 10             	add    $0x10,%esp
  /* Handle the interrupt in a more modular way */
  if (irq_handlers[r->int_no-32].handler!=NULL) {
c0102ed5:	8b 45 08             	mov    0x8(%ebp),%eax
c0102ed8:	8b 40 24             	mov    0x24(%eax),%eax
c0102edb:	83 e8 20             	sub    $0x20,%eax
c0102ede:	8b 04 c5 84 20 2b c0 	mov    -0x3fd4df7c(,%eax,8),%eax
c0102ee5:	85 c0                	test   %eax,%eax
c0102ee7:	74 6c                	je     c0102f55 <irq_handler+0xb2>
    isr_handler_info info = irq_handlers[r->int_no-32];
c0102ee9:	8b 45 08             	mov    0x8(%ebp),%eax
c0102eec:	8b 40 24             	mov    0x24(%eax),%eax
c0102eef:	83 e8 20             	sub    $0x20,%eax
c0102ef2:	8b 14 c5 84 20 2b c0 	mov    -0x3fd4df7c(,%eax,8),%edx
c0102ef9:	8b 04 c5 80 20 2b c0 	mov    -0x3fd4df80(,%eax,8),%eax
c0102f00:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0102f03:	89 55 f0             	mov    %edx,-0x10(%ebp)
    if(info.pid==0) {
c0102f06:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0102f09:	85 c0                	test   %eax,%eax
c0102f0b:	75 10                	jne    c0102f1d <irq_handler+0x7a>
      ((isr_t)info.handler)(r);
c0102f0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102f10:	83 ec 0c             	sub    $0xc,%esp
c0102f13:	ff 75 08             	pushl  0x8(%ebp)
c0102f16:	ff d0                	call   *%eax
c0102f18:	83 c4 10             	add    $0x10,%esp
      registers_t* user_r=alloc_pages(1);
      memcpy(user_r,r,sizeof(r));
      tasking_new_thread(info.handler,info.pid,(void*)(r),1);
    }
  }
}
c0102f1b:	eb 38                	jmp    c0102f55 <irq_handler+0xb2>
      registers_t* user_r=alloc_pages(1);
c0102f1d:	83 ec 0c             	sub    $0xc,%esp
c0102f20:	6a 01                	push   $0x1
c0102f22:	e8 ea 02 00 00       	call   c0103211 <alloc_pages>
c0102f27:	83 c4 10             	add    $0x10,%esp
c0102f2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy(user_r,r,sizeof(r));
c0102f2d:	83 ec 04             	sub    $0x4,%esp
c0102f30:	6a 04                	push   $0x4
c0102f32:	ff 75 08             	pushl  0x8(%ebp)
c0102f35:	ff 75 f4             	pushl  -0xc(%ebp)
c0102f38:	e8 8b 22 00 00       	call   c01051c8 <memcpy>
c0102f3d:	83 c4 10             	add    $0x10,%esp
      tasking_new_thread(info.handler,info.pid,(void*)(r),1);
c0102f40:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0102f43:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102f46:	6a 01                	push   $0x1
c0102f48:	ff 75 08             	pushl  0x8(%ebp)
c0102f4b:	52                   	push   %edx
c0102f4c:	50                   	push   %eax
c0102f4d:	e8 6b e6 ff ff       	call   c01015bd <tasking_new_thread>
c0102f52:	83 c4 10             	add    $0x10,%esp
}
c0102f55:	90                   	nop
c0102f56:	c9                   	leave  
c0102f57:	c3                   	ret    

c0102f58 <is_page_present>:
static pg_struct_entry kstack_page_tables[218*1024] __attribute__((aligned(4096))); //!< Page tables for thread kernel stacks
static pg_struct_entry kmalloc_page_tables[4*1024] __attribute__((aligned(4096))); //!< Page tables for the kmalloc heap
static pg_struct_entry* pagdirmap=(pg_struct_entry*)0xFFFFF000; //!< Pointer to the page directory entries in the recursive mapping
static pg_struct_entry* page_table_map=(pg_struct_entry*)0xFFC00000; //!< Pointer to the page table entries in the recursive mapping

char is_page_present(size_t page) {
c0102f58:	55                   	push   %ebp
c0102f59:	89 e5                	mov    %esp,%ebp
c0102f5b:	83 ec 10             	sub    $0x10,%esp
   int table=page>>10;
c0102f5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102f61:	c1 e8 0a             	shr    $0xa,%eax
c0102f64:	89 45 fc             	mov    %eax,-0x4(%ebp)
   page=page&0x3FF;
c0102f67:	81 65 08 ff 03 00 00 	andl   $0x3ff,0x8(%ebp)
   if (!pagdirmap[table].pres) {
c0102f6e:	a1 a0 80 10 c0       	mov    0xc01080a0,%eax
c0102f73:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0102f76:	c1 e2 02             	shl    $0x2,%edx
c0102f79:	01 d0                	add    %edx,%eax
c0102f7b:	8a 00                	mov    (%eax),%al
c0102f7d:	83 e0 01             	and    $0x1,%eax
c0102f80:	84 c0                	test   %al,%al
c0102f82:	75 04                	jne    c0102f88 <is_page_present+0x30>
     return 0;
c0102f84:	b0 00                	mov    $0x0,%al
c0102f86:	eb 1f                	jmp    c0102fa7 <is_page_present+0x4f>
   }
   return page_table_map[page+1024*table].pres;
c0102f88:	a1 a4 80 10 c0       	mov    0xc01080a4,%eax
c0102f8d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0102f90:	c1 e2 0a             	shl    $0xa,%edx
c0102f93:	89 d1                	mov    %edx,%ecx
c0102f95:	8b 55 08             	mov    0x8(%ebp),%edx
c0102f98:	01 ca                	add    %ecx,%edx
c0102f9a:	c1 e2 02             	shl    $0x2,%edx
c0102f9d:	01 d0                	add    %edx,%eax
c0102f9f:	8a 00                	mov    (%eax),%al
c0102fa1:	c1 e0 07             	shl    $0x7,%eax
c0102fa4:	c0 f8 07             	sar    $0x7,%al
}
c0102fa7:	c9                   	leave  
c0102fa8:	c3                   	ret    

c0102fa9 <map_pages>:

void map_pages(void* virt_addr_ptr,void* phys_addr_ptr,int num_pages,char usr,char wr) {
c0102fa9:	55                   	push   %ebp
c0102faa:	89 e5                	mov    %esp,%ebp
c0102fac:	83 ec 38             	sub    $0x38,%esp
c0102faf:	8b 55 14             	mov    0x14(%ebp),%edx
c0102fb2:	8b 45 18             	mov    0x18(%ebp),%eax
c0102fb5:	88 55 d4             	mov    %dl,-0x2c(%ebp)
c0102fb8:	88 45 d0             	mov    %al,-0x30(%ebp)
  uint32_t virt_addr=(uint32_t)virt_addr_ptr;
c0102fbb:	8b 45 08             	mov    0x8(%ebp),%eax
c0102fbe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  uint32_t phys_addr=(uint32_t)phys_addr_ptr;
c0102fc1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102fc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int dir_entry=(virt_addr&0xFFC00000)>>22;
c0102fc7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0102fca:	c1 e8 16             	shr    $0x16,%eax
c0102fcd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int table_entry=(virt_addr&0x3FF000)>>12;
c0102fd0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0102fd3:	c1 e8 0c             	shr    $0xc,%eax
c0102fd6:	25 ff 03 00 00       	and    $0x3ff,%eax
c0102fdb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for (int i=0;i<num_pages;i++) {
c0102fde:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0102fe5:	e9 58 01 00 00       	jmp    c0103142 <map_pages+0x199>
    if (!pagdirmap[dir_entry].pres) {
c0102fea:	a1 a0 80 10 c0       	mov    0xc01080a0,%eax
c0102fef:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0102ff2:	c1 e2 02             	shl    $0x2,%edx
c0102ff5:	01 d0                	add    %edx,%eax
c0102ff7:	8a 00                	mov    (%eax),%al
c0102ff9:	83 e0 01             	and    $0x1,%eax
c0102ffc:	84 c0                	test   %al,%al
c0102ffe:	0f 85 84 00 00 00    	jne    c0103088 <map_pages+0xdf>
      pg_struct_entry* entry=&pagdirmap[dir_entry];
c0103004:	a1 a0 80 10 c0       	mov    0xc01080a0,%eax
c0103009:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010300c:	c1 e2 02             	shl    $0x2,%edx
c010300f:	01 d0                	add    %edx,%eax
c0103011:	89 45 e0             	mov    %eax,-0x20(%ebp)
      entry->pgno=(uint32_t)pmem_alloc(1)>>12;
c0103014:	83 ec 0c             	sub    $0xc,%esp
c0103017:	6a 01                	push   $0x1
c0103019:	e8 02 da ff ff       	call   c0100a20 <pmem_alloc>
c010301e:	83 c4 10             	add    $0x10,%esp
c0103021:	c1 e8 0c             	shr    $0xc,%eax
c0103024:	c1 e0 0c             	shl    $0xc,%eax
c0103027:	89 c2                	mov    %eax,%edx
c0103029:	c1 fa 0c             	sar    $0xc,%edx
c010302c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010302f:	89 d1                	mov    %edx,%ecx
c0103031:	c1 e1 0c             	shl    $0xc,%ecx
c0103034:	8b 10                	mov    (%eax),%edx
c0103036:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c010303c:	09 ca                	or     %ecx,%edx
c010303e:	89 10                	mov    %edx,(%eax)
      entry->pres=1;
c0103040:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103043:	8a 10                	mov    (%eax),%dl
c0103045:	83 ca 01             	or     $0x1,%edx
c0103048:	88 10                	mov    %dl,(%eax)
      entry->usr=usr;
c010304a:	8a 45 d4             	mov    -0x2c(%ebp),%al
c010304d:	c1 e0 07             	shl    $0x7,%eax
c0103050:	88 c2                	mov    %al,%dl
c0103052:	c0 fa 07             	sar    $0x7,%dl
c0103055:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103058:	83 e2 01             	and    $0x1,%edx
c010305b:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c0103062:	8a 10                	mov    (%eax),%dl
c0103064:	83 e2 fb             	and    $0xfffffffb,%edx
c0103067:	09 ca                	or     %ecx,%edx
c0103069:	88 10                	mov    %dl,(%eax)
      entry->wr=wr;
c010306b:	8a 45 d0             	mov    -0x30(%ebp),%al
c010306e:	c1 e0 07             	shl    $0x7,%eax
c0103071:	88 c2                	mov    %al,%dl
c0103073:	c0 fa 07             	sar    $0x7,%dl
c0103076:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103079:	83 e2 01             	and    $0x1,%edx
c010307c:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
c010307f:	8a 10                	mov    (%eax),%dl
c0103081:	83 e2 fd             	and    $0xfffffffd,%edx
c0103084:	09 ca                	or     %ecx,%edx
c0103086:	88 10                	mov    %dl,(%eax)
    }
    pg_struct_entry* entry=&page_table_map[table_entry+1024*dir_entry];
c0103088:	a1 a4 80 10 c0       	mov    0xc01080a4,%eax
c010308d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0103090:	89 d1                	mov    %edx,%ecx
c0103092:	c1 e1 0a             	shl    $0xa,%ecx
c0103095:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0103098:	01 ca                	add    %ecx,%edx
c010309a:	c1 e2 02             	shl    $0x2,%edx
c010309d:	01 d0                	add    %edx,%eax
c010309f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (phys_addr_ptr==NULL) {
c01030a2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01030a6:	75 10                	jne    c01030b8 <map_pages+0x10f>
      phys_addr=(uint32_t)pmem_alloc(1);
c01030a8:	83 ec 0c             	sub    $0xc,%esp
c01030ab:	6a 01                	push   $0x1
c01030ad:	e8 6e d9 ff ff       	call   c0100a20 <pmem_alloc>
c01030b2:	83 c4 10             	add    $0x10,%esp
c01030b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    entry->pgno=phys_addr>>12;
c01030b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01030bb:	c1 e8 0c             	shr    $0xc,%eax
c01030be:	c1 e0 0c             	shl    $0xc,%eax
c01030c1:	89 c2                	mov    %eax,%edx
c01030c3:	c1 fa 0c             	sar    $0xc,%edx
c01030c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01030c9:	89 d1                	mov    %edx,%ecx
c01030cb:	c1 e1 0c             	shl    $0xc,%ecx
c01030ce:	8b 10                	mov    (%eax),%edx
c01030d0:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c01030d6:	09 ca                	or     %ecx,%edx
c01030d8:	89 10                	mov    %edx,(%eax)
    entry->pres=1;
c01030da:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01030dd:	8a 10                	mov    (%eax),%dl
c01030df:	83 ca 01             	or     $0x1,%edx
c01030e2:	88 10                	mov    %dl,(%eax)
    entry->usr=usr;
c01030e4:	8a 45 d4             	mov    -0x2c(%ebp),%al
c01030e7:	c1 e0 07             	shl    $0x7,%eax
c01030ea:	88 c2                	mov    %al,%dl
c01030ec:	c0 fa 07             	sar    $0x7,%dl
c01030ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01030f2:	83 e2 01             	and    $0x1,%edx
c01030f5:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c01030fc:	8a 10                	mov    (%eax),%dl
c01030fe:	83 e2 fb             	and    $0xfffffffb,%edx
c0103101:	09 ca                	or     %ecx,%edx
c0103103:	88 10                	mov    %dl,(%eax)
    entry->wr=wr;
c0103105:	8a 45 d0             	mov    -0x30(%ebp),%al
c0103108:	c1 e0 07             	shl    $0x7,%eax
c010310b:	88 c2                	mov    %al,%dl
c010310d:	c0 fa 07             	sar    $0x7,%dl
c0103110:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103113:	83 e2 01             	and    $0x1,%edx
c0103116:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
c0103119:	8a 10                	mov    (%eax),%dl
c010311b:	83 e2 fd             	and    $0xfffffffd,%edx
c010311e:	09 ca                	or     %ecx,%edx
c0103120:	88 10                	mov    %dl,(%eax)
    table_entry++;
c0103122:	ff 45 ec             	incl   -0x14(%ebp)
    if (table_entry==1024) {
c0103125:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
c010312c:	75 0a                	jne    c0103138 <map_pages+0x18f>
      table_entry=0;
c010312e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
      dir_entry++;
c0103135:	ff 45 f0             	incl   -0x10(%ebp)
    }
    phys_addr+=0x1000;
c0103138:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
  for (int i=0;i<num_pages;i++) {
c010313f:	ff 45 e8             	incl   -0x18(%ebp)
c0103142:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103145:	3b 45 10             	cmp    0x10(%ebp),%eax
c0103148:	0f 8c 9c fe ff ff    	jl     c0102fea <map_pages+0x41>
  }
}
c010314e:	90                   	nop
c010314f:	90                   	nop
c0103150:	c9                   	leave  
c0103151:	c3                   	ret    

c0103152 <find_free_pages>:

void* find_free_pages(int num_pages) {
c0103152:	55                   	push   %ebp
c0103153:	89 e5                	mov    %esp,%ebp
c0103155:	83 ec 28             	sub    $0x28,%esp
  size_t bmap_index;
  size_t remaining_blks;
  for(size_t i=1;i<131072;i++) {
c0103158:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c010315f:	eb 7d                	jmp    c01031de <find_free_pages+0x8c>
    char got_0=0;
c0103161:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
    remaining_blks=num_pages;
c0103165:	8b 45 08             	mov    0x8(%ebp),%eax
c0103168:	89 45 f0             	mov    %eax,-0x10(%ebp)
    size_t old_j;
    for (size_t j=i*8;;j++) {
c010316b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010316e:	c1 e0 03             	shl    $0x3,%eax
c0103171:	89 45 e0             	mov    %eax,-0x20(%ebp)
      char bit=is_page_present(j);
c0103174:	ff 75 e0             	pushl  -0x20(%ebp)
c0103177:	e8 dc fd ff ff       	call   c0102f58 <is_page_present>
c010317c:	83 c4 04             	add    $0x4,%esp
c010317f:	88 45 df             	mov    %al,-0x21(%ebp)
      if (got_0) {
c0103182:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
c0103186:	74 27                	je     c01031af <find_free_pages+0x5d>
        if (bit) {
c0103188:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
c010318c:	74 1c                	je     c01031aa <find_free_pages+0x58>
          if (remaining_blks==0) {
c010318e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0103192:	75 08                	jne    c010319c <find_free_pages+0x4a>
              bmap_index=old_j;
c0103194:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103197:	89 45 f4             	mov    %eax,-0xc(%ebp)
              break;
c010319a:	eb 39                	jmp    c01031d5 <find_free_pages+0x83>
          } else {
            i+=j/8;
c010319c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010319f:	c1 e8 03             	shr    $0x3,%eax
c01031a2:	01 45 ec             	add    %eax,-0x14(%ebp)
            i--;
c01031a5:	ff 4d ec             	decl   -0x14(%ebp)
            break;
c01031a8:	eb 2b                	jmp    c01031d5 <find_free_pages+0x83>
          }
        } else {
          remaining_blks--;
c01031aa:	ff 4d f0             	decl   -0x10(%ebp)
c01031ad:	eb 13                	jmp    c01031c2 <find_free_pages+0x70>
        }
      } else {
        if (!bit) {
c01031af:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
c01031b3:	75 0d                	jne    c01031c2 <find_free_pages+0x70>
          got_0=1;
c01031b5:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
          old_j=j;
c01031b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01031bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          remaining_blks--;
c01031bf:	ff 4d f0             	decl   -0x10(%ebp)
        }
      }
      if (remaining_blks==0) {
c01031c2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01031c6:	75 08                	jne    c01031d0 <find_free_pages+0x7e>
        bmap_index=old_j;
c01031c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01031cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
        break;
c01031ce:	eb 05                	jmp    c01031d5 <find_free_pages+0x83>
    for (size_t j=i*8;;j++) {
c01031d0:	ff 45 e0             	incl   -0x20(%ebp)
c01031d3:	eb 9f                	jmp    c0103174 <find_free_pages+0x22>
      }
    }
    if (remaining_blks==0) {
c01031d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01031d9:	74 12                	je     c01031ed <find_free_pages+0x9b>
  for(size_t i=1;i<131072;i++) {
c01031db:	ff 45 ec             	incl   -0x14(%ebp)
c01031de:	81 7d ec ff ff 01 00 	cmpl   $0x1ffff,-0x14(%ebp)
c01031e5:	0f 86 76 ff ff ff    	jbe    c0103161 <find_free_pages+0xf>
c01031eb:	eb 01                	jmp    c01031ee <find_free_pages+0x9c>
      break;
c01031ed:	90                   	nop
    }
  }
  if (remaining_blks!=0) {
c01031ee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01031f2:	74 15                	je     c0103209 <find_free_pages+0xb7>
    vga_write_string("[PANIC] Out of memory");
c01031f4:	83 ec 0c             	sub    $0xc,%esp
c01031f7:	68 f4 69 10 c0       	push   $0xc01069f4
c01031fc:	e8 7f ed ff ff       	call   c0101f80 <vga_write_string>
c0103201:	83 c4 10             	add    $0x10,%esp
    halt();
c0103204:	e8 57 0e 00 00       	call   c0104060 <halt>
  }
  return (void*)(bmap_index<<12);
c0103209:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010320c:	c1 e0 0c             	shl    $0xc,%eax
}
c010320f:	c9                   	leave  
c0103210:	c3                   	ret    

c0103211 <alloc_pages>:

void* alloc_pages(int num_pages) {
c0103211:	55                   	push   %ebp
c0103212:	89 e5                	mov    %esp,%ebp
c0103214:	83 ec 18             	sub    $0x18,%esp
  void* addr=find_free_pages(num_pages);
c0103217:	83 ec 0c             	sub    $0xc,%esp
c010321a:	ff 75 08             	pushl  0x8(%ebp)
c010321d:	e8 30 ff ff ff       	call   c0103152 <find_free_pages>
c0103222:	83 c4 10             	add    $0x10,%esp
c0103225:	89 45 f4             	mov    %eax,-0xc(%ebp)
  map_pages(addr,NULL,num_pages,1,1);
c0103228:	83 ec 0c             	sub    $0xc,%esp
c010322b:	6a 01                	push   $0x1
c010322d:	6a 01                	push   $0x1
c010322f:	ff 75 08             	pushl  0x8(%ebp)
c0103232:	6a 00                	push   $0x0
c0103234:	ff 75 f4             	pushl  -0xc(%ebp)
c0103237:	e8 6d fd ff ff       	call   c0102fa9 <map_pages>
c010323c:	83 c4 20             	add    $0x20,%esp
  return addr;
c010323f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0103242:	c9                   	leave  
c0103243:	c3                   	ret    

c0103244 <virt_to_phys>:

void* virt_to_phys(void* virt_addr_arg) {
c0103244:	55                   	push   %ebp
c0103245:	89 e5                	mov    %esp,%ebp
c0103247:	83 ec 10             	sub    $0x10,%esp
  uint32_t virt_addr=(uint32_t)virt_addr_arg;
c010324a:	8b 45 08             	mov    0x8(%ebp),%eax
c010324d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  int offset=virt_addr&0x3FF;
c0103250:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103253:	25 ff 03 00 00       	and    $0x3ff,%eax
c0103258:	89 45 f8             	mov    %eax,-0x8(%ebp)
  virt_addr=virt_addr&0xFFFFFC00;
c010325b:	81 65 fc 00 fc ff ff 	andl   $0xfffffc00,-0x4(%ebp)
  if (!is_page_present(virt_addr>>12)) return NULL;
c0103262:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103265:	c1 e8 0c             	shr    $0xc,%eax
c0103268:	50                   	push   %eax
c0103269:	e8 ea fc ff ff       	call   c0102f58 <is_page_present>
c010326e:	83 c4 04             	add    $0x4,%esp
c0103271:	84 c0                	test   %al,%al
c0103273:	75 07                	jne    c010327c <virt_to_phys+0x38>
c0103275:	b8 00 00 00 00       	mov    $0x0,%eax
c010327a:	eb 5a                	jmp    c01032d6 <virt_to_phys+0x92>
  int dir_idx=(virt_addr&0xFFC00000)>>22;
c010327c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010327f:	c1 e8 16             	shr    $0x16,%eax
c0103282:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int tbl_idx=(virt_addr&0x3FFC00)>>12;
c0103285:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0103288:	c1 e8 0c             	shr    $0xc,%eax
c010328b:	25 ff 03 00 00       	and    $0x3ff,%eax
c0103290:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (!pagdirmap[dir_idx].pres) {
c0103293:	a1 a0 80 10 c0       	mov    0xc01080a0,%eax
c0103298:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010329b:	c1 e2 02             	shl    $0x2,%edx
c010329e:	01 d0                	add    %edx,%eax
c01032a0:	8a 00                	mov    (%eax),%al
c01032a2:	83 e0 01             	and    $0x1,%eax
c01032a5:	84 c0                	test   %al,%al
c01032a7:	75 07                	jne    c01032b0 <virt_to_phys+0x6c>
    return 0;
c01032a9:	b8 00 00 00 00       	mov    $0x0,%eax
c01032ae:	eb 26                	jmp    c01032d6 <virt_to_phys+0x92>
  }
  return (void*)(((page_table_map[tbl_idx+1024*dir_idx].pgno)<<12)+offset);
c01032b0:	a1 a4 80 10 c0       	mov    0xc01080a4,%eax
c01032b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01032b8:	89 d1                	mov    %edx,%ecx
c01032ba:	c1 e1 0a             	shl    $0xa,%ecx
c01032bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01032c0:	01 ca                	add    %ecx,%edx
c01032c2:	c1 e2 02             	shl    $0x2,%edx
c01032c5:	01 d0                	add    %edx,%eax
c01032c7:	8b 00                	mov    (%eax),%eax
c01032c9:	c1 f8 0c             	sar    $0xc,%eax
c01032cc:	c1 e0 0c             	shl    $0xc,%eax
c01032cf:	89 c2                	mov    %eax,%edx
c01032d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01032d4:	01 d0                	add    %edx,%eax
}
c01032d6:	c9                   	leave  
c01032d7:	c3                   	ret    

c01032d8 <alloc_pages_virt>:


void alloc_pages_virt(int num_pages,void* addr) {
c01032d8:	55                   	push   %ebp
c01032d9:	89 e5                	mov    %esp,%ebp
c01032db:	83 ec 08             	sub    $0x8,%esp
  map_pages(addr,NULL,num_pages,1,1);
c01032de:	83 ec 0c             	sub    $0xc,%esp
c01032e1:	6a 01                	push   $0x1
c01032e3:	6a 01                	push   $0x1
c01032e5:	ff 75 08             	pushl  0x8(%ebp)
c01032e8:	6a 00                	push   $0x0
c01032ea:	ff 75 0c             	pushl  0xc(%ebp)
c01032ed:	e8 b7 fc ff ff       	call   c0102fa9 <map_pages>
c01032f2:	83 c4 20             	add    $0x20,%esp
}
c01032f5:	90                   	nop
c01032f6:	c9                   	leave  
c01032f7:	c3                   	ret    

c01032f8 <invl_page>:

/**
 * Invalidates a page in the TLB,
 * \param addr The address of the page to invalidate.
*/
static void invl_page(void* addr) {
c01032f8:	55                   	push   %ebp
c01032f9:	89 e5                	mov    %esp,%ebp
  asm volatile("invlpg (%0)"::"r"(addr):"memory");
c01032fb:	8b 45 08             	mov    0x8(%ebp),%eax
c01032fe:	0f 01 38             	invlpg (%eax)
}
c0103301:	90                   	nop
c0103302:	5d                   	pop    %ebp
c0103303:	c3                   	ret    

c0103304 <paging_new_address_space>:

void* paging_new_address_space() {
c0103304:	55                   	push   %ebp
c0103305:	89 e5                	mov    %esp,%ebp
c0103307:	83 ec 18             	sub    $0x18,%esp
  void* dir=pmem_alloc(1);
c010330a:	83 ec 0c             	sub    $0xc,%esp
c010330d:	6a 01                	push   $0x1
c010330f:	e8 0c d7 ff ff       	call   c0100a20 <pmem_alloc>
c0103314:	83 c4 10             	add    $0x10,%esp
c0103317:	89 45 f0             	mov    %eax,-0x10(%ebp)
  pg_struct_entry* freepg=find_free_pages(1);
c010331a:	83 ec 0c             	sub    $0xc,%esp
c010331d:	6a 01                	push   $0x1
c010331f:	e8 2e fe ff ff       	call   c0103152 <find_free_pages>
c0103324:	83 c4 10             	add    $0x10,%esp
c0103327:	89 45 ec             	mov    %eax,-0x14(%ebp)
  map_pages(freepg,dir,1,0,1);
c010332a:	83 ec 0c             	sub    $0xc,%esp
c010332d:	6a 01                	push   $0x1
c010332f:	6a 00                	push   $0x0
c0103331:	6a 01                	push   $0x1
c0103333:	ff 75 f0             	pushl  -0x10(%ebp)
c0103336:	ff 75 ec             	pushl  -0x14(%ebp)
c0103339:	e8 6b fc ff ff       	call   c0102fa9 <map_pages>
c010333e:	83 c4 20             	add    $0x20,%esp
  for (size_t i=0;i<1024;i++) {
c0103341:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0103348:	eb 1e                	jmp    c0103368 <paging_new_address_space+0x64>
    freepg[i]=page_directory[i];
c010334a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010334d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0103354:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103357:	01 c2                	add    %eax,%edx
c0103359:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010335c:	8b 04 85 00 b0 2f c0 	mov    -0x3fd05000(,%eax,4),%eax
c0103363:	89 02                	mov    %eax,(%edx)
  for (size_t i=0;i<1024;i++) {
c0103365:	ff 45 f4             	incl   -0xc(%ebp)
c0103368:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c010336f:	76 d9                	jbe    c010334a <paging_new_address_space+0x46>
  }
  pg_struct_entry* entry=&freepg[1023];
c0103371:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103374:	05 fc 0f 00 00       	add    $0xffc,%eax
c0103379:	89 45 e8             	mov    %eax,-0x18(%ebp)
  entry->pres=1;
c010337c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010337f:	8a 10                	mov    (%eax),%dl
c0103381:	83 ca 01             	or     $0x1,%edx
c0103384:	88 10                	mov    %dl,(%eax)
  entry->wr=1;
c0103386:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103389:	8a 10                	mov    (%eax),%dl
c010338b:	83 ca 02             	or     $0x2,%edx
c010338e:	88 10                	mov    %dl,(%eax)
  entry->pgno=(uint32_t)dir>>12;
c0103390:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103393:	c1 e8 0c             	shr    $0xc,%eax
c0103396:	c1 e0 0c             	shl    $0xc,%eax
c0103399:	89 c2                	mov    %eax,%edx
c010339b:	c1 fa 0c             	sar    $0xc,%edx
c010339e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01033a1:	89 d1                	mov    %edx,%ecx
c01033a3:	c1 e1 0c             	shl    $0xc,%ecx
c01033a6:	8b 10                	mov    (%eax),%edx
c01033a8:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c01033ae:	09 ca                	or     %ecx,%edx
c01033b0:	89 10                	mov    %edx,(%eax)
  unmap_pages(freepg,1,0);
c01033b2:	83 ec 04             	sub    $0x4,%esp
c01033b5:	6a 00                	push   $0x0
c01033b7:	6a 01                	push   $0x1
c01033b9:	ff 75 ec             	pushl  -0x14(%ebp)
c01033bc:	e8 14 00 00 00       	call   c01033d5 <unmap_pages>
c01033c1:	83 c4 10             	add    $0x10,%esp
  return dir;
c01033c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c01033c7:	c9                   	leave  
c01033c8:	c3                   	ret    

c01033c9 <load_address_space>:

void load_address_space(void* address_space) {
c01033c9:	55                   	push   %ebp
c01033ca:	89 e5                	mov    %esp,%ebp
  asm volatile("movl %0, %%eax; movl %%eax, %%cr3;":"=m"(address_space)::"%eax");
c01033cc:	8b 45 08             	mov    0x8(%ebp),%eax
c01033cf:	0f 22 d8             	mov    %eax,%cr3
}
c01033d2:	90                   	nop
c01033d3:	5d                   	pop    %ebp
c01033d4:	c3                   	ret    

c01033d5 <unmap_pages>:

void unmap_pages(void* start_virt,int num_pages,int free_phys) {
c01033d5:	55                   	push   %ebp
c01033d6:	89 e5                	mov    %esp,%ebp
c01033d8:	83 ec 28             	sub    $0x28,%esp
  uint32_t virt_addr=(uint32_t)start_virt;
c01033db:	8b 45 08             	mov    0x8(%ebp),%eax
c01033de:	89 45 e8             	mov    %eax,-0x18(%ebp)
  int dir_entry=(virt_addr&0xFFC00000)>>22;
c01033e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01033e4:	c1 e8 16             	shr    $0x16,%eax
c01033e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int table_entry=(virt_addr&0x3FF000)>>12;
c01033ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01033ed:	c1 e8 0c             	shr    $0xc,%eax
c01033f0:	25 ff 03 00 00       	and    $0x3ff,%eax
c01033f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (int i=0;i<=num_pages;i++) {
c01033f8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c01033ff:	e9 8b 00 00 00       	jmp    c010348f <unmap_pages+0xba>
    if (page_table_map[dir_entry].pres) {
c0103404:	a1 a4 80 10 c0       	mov    0xc01080a4,%eax
c0103409:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010340c:	c1 e2 02             	shl    $0x2,%edx
c010340f:	01 d0                	add    %edx,%eax
c0103411:	8a 00                	mov    (%eax),%al
c0103413:	83 e0 01             	and    $0x1,%eax
c0103416:	84 c0                	test   %al,%al
c0103418:	74 72                	je     c010348c <unmap_pages+0xb7>
      pg_struct_entry* entry=&page_table_map[table_entry+1024*dir_entry];
c010341a:	a1 a4 80 10 c0       	mov    0xc01080a4,%eax
c010341f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0103422:	89 d1                	mov    %edx,%ecx
c0103424:	c1 e1 0a             	shl    $0xa,%ecx
c0103427:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010342a:	01 ca                	add    %ecx,%edx
c010342c:	c1 e2 02             	shl    $0x2,%edx
c010342f:	01 d0                	add    %edx,%eax
c0103431:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      entry->pres=0;
c0103434:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103437:	8a 10                	mov    (%eax),%dl
c0103439:	83 e2 fe             	and    $0xfffffffe,%edx
c010343c:	88 10                	mov    %dl,(%eax)
      if (free_phys) {
c010343e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0103442:	74 19                	je     c010345d <unmap_pages+0x88>
        pmem_free((void*)(entry->pgno<<12),1);
c0103444:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103447:	8b 00                	mov    (%eax),%eax
c0103449:	c1 f8 0c             	sar    $0xc,%eax
c010344c:	c1 e0 0c             	shl    $0xc,%eax
c010344f:	83 ec 08             	sub    $0x8,%esp
c0103452:	6a 01                	push   $0x1
c0103454:	50                   	push   %eax
c0103455:	e8 b4 d6 ff ff       	call   c0100b0e <pmem_free>
c010345a:	83 c4 10             	add    $0x10,%esp
      }
      invl_page(start_virt+(i*4096));
c010345d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103460:	c1 e0 0c             	shl    $0xc,%eax
c0103463:	89 c2                	mov    %eax,%edx
c0103465:	8b 45 08             	mov    0x8(%ebp),%eax
c0103468:	01 d0                	add    %edx,%eax
c010346a:	83 ec 0c             	sub    $0xc,%esp
c010346d:	50                   	push   %eax
c010346e:	e8 85 fe ff ff       	call   c01032f8 <invl_page>
c0103473:	83 c4 10             	add    $0x10,%esp
      table_entry++;
c0103476:	ff 45 f0             	incl   -0x10(%ebp)
      if (table_entry==1024) {
c0103479:	81 7d f0 00 04 00 00 	cmpl   $0x400,-0x10(%ebp)
c0103480:	75 0a                	jne    c010348c <unmap_pages+0xb7>
        dir_entry++;
c0103482:	ff 45 f4             	incl   -0xc(%ebp)
        table_entry=0;
c0103485:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (int i=0;i<=num_pages;i++) {
c010348c:	ff 45 ec             	incl   -0x14(%ebp)
c010348f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103492:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0103495:	0f 8e 69 ff ff ff    	jle    c0103404 <unmap_pages+0x2f>
      }
    }
  }
}
c010349b:	90                   	nop
c010349c:	90                   	nop
c010349d:	c9                   	leave  
c010349e:	c3                   	ret    

c010349f <paging_readonly_idt>:
extern int idt;

/**
 * Makes the IDT readonly
*/
void paging_readonly_idt() {
c010349f:	55                   	push   %ebp
c01034a0:	89 e5                	mov    %esp,%ebp
c01034a2:	83 ec 18             	sub    $0x18,%esp
  void* idt_addr=&idt;
c01034a5:	c7 45 f4 00 d0 1c c0 	movl   $0xc01cd000,-0xc(%ebp)
  void* idt_phys=virt_to_phys(idt_addr);
c01034ac:	ff 75 f4             	pushl  -0xc(%ebp)
c01034af:	e8 90 fd ff ff       	call   c0103244 <virt_to_phys>
c01034b4:	83 c4 04             	add    $0x4,%esp
c01034b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  map_pages(idt_addr,idt_phys,1,0,0);
c01034ba:	83 ec 0c             	sub    $0xc,%esp
c01034bd:	6a 00                	push   $0x0
c01034bf:	6a 00                	push   $0x0
c01034c1:	6a 01                	push   $0x1
c01034c3:	ff 75 f0             	pushl  -0x10(%ebp)
c01034c6:	ff 75 f4             	pushl  -0xc(%ebp)
c01034c9:	e8 db fa ff ff       	call   c0102fa9 <map_pages>
c01034ce:	83 c4 20             	add    $0x20,%esp
  invl_page(idt_addr);
c01034d1:	83 ec 0c             	sub    $0xc,%esp
c01034d4:	ff 75 f4             	pushl  -0xc(%ebp)
c01034d7:	e8 1c fe ff ff       	call   c01032f8 <invl_page>
c01034dc:	83 c4 10             	add    $0x10,%esp
}
c01034df:	90                   	nop
c01034e0:	c9                   	leave  
c01034e1:	c3                   	ret    

c01034e2 <paging_init>:

void paging_init() {
c01034e2:	55                   	push   %ebp
c01034e3:	89 e5                	mov    %esp,%ebp
c01034e5:	83 ec 48             	sub    $0x48,%esp
  for (size_t i=0;i<NUM_KERN_FRAMES;i++) {
c01034e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01034ef:	eb 44                	jmp    c0103535 <paging_init+0x53>
    pg_struct_entry* entry=&kern_page_tables[i];
c01034f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01034f4:	c1 e0 02             	shl    $0x2,%eax
c01034f7:	05 00 c0 2f c0       	add    $0xc02fc000,%eax
c01034fc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    entry->pres=1;
c01034ff:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0103502:	8a 10                	mov    (%eax),%dl
c0103504:	83 ca 01             	or     $0x1,%edx
c0103507:	88 10                	mov    %dl,(%eax)
    entry->wr=1;
c0103509:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c010350c:	8a 10                	mov    (%eax),%dl
c010350e:	83 ca 02             	or     $0x2,%edx
c0103511:	88 10                	mov    %dl,(%eax)
    entry->pgno=i;
c0103513:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103516:	c1 e0 0c             	shl    $0xc,%eax
c0103519:	89 c2                	mov    %eax,%edx
c010351b:	c1 fa 0c             	sar    $0xc,%edx
c010351e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0103521:	89 d1                	mov    %edx,%ecx
c0103523:	c1 e1 0c             	shl    $0xc,%ecx
c0103526:	8b 10                	mov    (%eax),%edx
c0103528:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c010352e:	09 ca                	or     %ecx,%edx
c0103530:	89 10                	mov    %edx,(%eax)
  for (size_t i=0;i<NUM_KERN_FRAMES;i++) {
c0103532:	ff 45 f4             	incl   -0xc(%ebp)
c0103535:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%ebp)
c010353c:	76 b3                	jbe    c01034f1 <paging_init+0xf>
  }
  for (size_t i=0;i<218*1024;i++) {
c010353e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0103545:	eb 1b                	jmp    c0103562 <paging_init+0x80>
    pg_struct_entry* entry=&kstack_page_tables[i];
c0103547:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010354a:	c1 e0 02             	shl    $0x2,%eax
c010354d:	05 00 00 30 c0       	add    $0xc0300000,%eax
c0103552:	89 45 c8             	mov    %eax,-0x38(%ebp)
    entry->pres=0;
c0103555:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0103558:	8a 10                	mov    (%eax),%dl
c010355a:	83 e2 fe             	and    $0xfffffffe,%edx
c010355d:	88 10                	mov    %dl,(%eax)
  for (size_t i=0;i<218*1024;i++) {
c010355f:	ff 45 f0             	incl   -0x10(%ebp)
c0103562:	81 7d f0 ff 67 03 00 	cmpl   $0x367ff,-0x10(%ebp)
c0103569:	76 dc                	jbe    c0103547 <paging_init+0x65>
  }
  for (size_t i=0;i<4*1024;i++) {
c010356b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0103572:	eb 51                	jmp    c01035c5 <paging_init+0xe3>
    pg_struct_entry* entry=&kmalloc_page_tables[i];
c0103574:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103577:	c1 e0 02             	shl    $0x2,%eax
c010357a:	05 00 a0 3d c0       	add    $0xc03da000,%eax
c010357f:	89 45 cc             	mov    %eax,-0x34(%ebp)
    entry->pres=1;
c0103582:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0103585:	8a 10                	mov    (%eax),%dl
c0103587:	83 ca 01             	or     $0x1,%edx
c010358a:	88 10                	mov    %dl,(%eax)
    entry->wr=1;
c010358c:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010358f:	8a 10                	mov    (%eax),%dl
c0103591:	83 ca 02             	or     $0x2,%edx
c0103594:	88 10                	mov    %dl,(%eax)
    entry->pgno=(uint32_t)pmem_alloc(1)>>12;
c0103596:	83 ec 0c             	sub    $0xc,%esp
c0103599:	6a 01                	push   $0x1
c010359b:	e8 80 d4 ff ff       	call   c0100a20 <pmem_alloc>
c01035a0:	83 c4 10             	add    $0x10,%esp
c01035a3:	c1 e8 0c             	shr    $0xc,%eax
c01035a6:	c1 e0 0c             	shl    $0xc,%eax
c01035a9:	89 c2                	mov    %eax,%edx
c01035ab:	c1 fa 0c             	sar    $0xc,%edx
c01035ae:	8b 45 cc             	mov    -0x34(%ebp),%eax
c01035b1:	89 d1                	mov    %edx,%ecx
c01035b3:	c1 e1 0c             	shl    $0xc,%ecx
c01035b6:	8b 10                	mov    (%eax),%edx
c01035b8:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c01035be:	09 ca                	or     %ecx,%edx
c01035c0:	89 10                	mov    %edx,(%eax)
  for (size_t i=0;i<4*1024;i++) {
c01035c2:	ff 45 ec             	incl   -0x14(%ebp)
c01035c5:	81 7d ec ff 0f 00 00 	cmpl   $0xfff,-0x14(%ebp)
c01035cc:	76 a6                	jbe    c0103574 <paging_init+0x92>
  }
  for (size_t i=0;i<NUM_KERN_FRAMES/1024;i++) {
c01035ce:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c01035d5:	eb 62                	jmp    c0103639 <paging_init+0x157>
    uint32_t entry_virt=(uint32_t)&(kern_page_tables[i*1024]);
c01035d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01035da:	c1 e0 0a             	shl    $0xa,%eax
c01035dd:	c1 e0 02             	shl    $0x2,%eax
c01035e0:	05 00 c0 2f c0       	add    $0xc02fc000,%eax
c01035e5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    pg_struct_entry* entry=&page_directory[i+768];
c01035e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01035eb:	05 00 03 00 00       	add    $0x300,%eax
c01035f0:	c1 e0 02             	shl    $0x2,%eax
c01035f3:	05 00 b0 2f c0       	add    $0xc02fb000,%eax
c01035f8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    entry->pres=1;
c01035fb:	8b 45 d0             	mov    -0x30(%ebp),%eax
c01035fe:	8a 10                	mov    (%eax),%dl
c0103600:	83 ca 01             	or     $0x1,%edx
c0103603:	88 10                	mov    %dl,(%eax)
    entry->wr=1;
c0103605:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0103608:	8a 10                	mov    (%eax),%dl
c010360a:	83 ca 02             	or     $0x2,%edx
c010360d:	88 10                	mov    %dl,(%eax)
    entry->pgno=((uint32_t)entry_virt-0xC0000000)>>12;
c010360f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0103612:	05 00 00 00 40       	add    $0x40000000,%eax
c0103617:	c1 e8 0c             	shr    $0xc,%eax
c010361a:	c1 e0 0c             	shl    $0xc,%eax
c010361d:	89 c2                	mov    %eax,%edx
c010361f:	c1 fa 0c             	sar    $0xc,%edx
c0103622:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0103625:	89 d1                	mov    %edx,%ecx
c0103627:	c1 e1 0c             	shl    $0xc,%ecx
c010362a:	8b 10                	mov    (%eax),%edx
c010362c:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0103632:	09 ca                	or     %ecx,%edx
c0103634:	89 10                	mov    %edx,(%eax)
  for (size_t i=0;i<NUM_KERN_FRAMES/1024;i++) {
c0103636:	ff 45 e8             	incl   -0x18(%ebp)
c0103639:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
c010363d:	76 98                	jbe    c01035d7 <paging_init+0xf5>
  }
  for (size_t i=0;i<4;i++) {
c010363f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0103646:	eb 62                	jmp    c01036aa <paging_init+0x1c8>
    uint32_t entry_virt=(uint32_t)&(kmalloc_page_tables[i*1024]);
c0103648:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010364b:	c1 e0 0a             	shl    $0xa,%eax
c010364e:	c1 e0 02             	shl    $0x2,%eax
c0103651:	05 00 a0 3d c0       	add    $0xc03da000,%eax
c0103656:	89 45 dc             	mov    %eax,-0x24(%ebp)
    pg_struct_entry* entry=&page_directory[i+1018];
c0103659:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010365c:	05 fa 03 00 00       	add    $0x3fa,%eax
c0103661:	c1 e0 02             	shl    $0x2,%eax
c0103664:	05 00 b0 2f c0       	add    $0xc02fb000,%eax
c0103669:	89 45 d8             	mov    %eax,-0x28(%ebp)
    entry->pres=1;
c010366c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010366f:	8a 10                	mov    (%eax),%dl
c0103671:	83 ca 01             	or     $0x1,%edx
c0103674:	88 10                	mov    %dl,(%eax)
    entry->wr=1;
c0103676:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0103679:	8a 10                	mov    (%eax),%dl
c010367b:	83 ca 02             	or     $0x2,%edx
c010367e:	88 10                	mov    %dl,(%eax)
    entry->pgno=((uint32_t)entry_virt-0xC0000000)>>12;
c0103680:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0103683:	05 00 00 00 40       	add    $0x40000000,%eax
c0103688:	c1 e8 0c             	shr    $0xc,%eax
c010368b:	c1 e0 0c             	shl    $0xc,%eax
c010368e:	89 c2                	mov    %eax,%edx
c0103690:	c1 fa 0c             	sar    $0xc,%edx
c0103693:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0103696:	89 d1                	mov    %edx,%ecx
c0103698:	c1 e1 0c             	shl    $0xc,%ecx
c010369b:	8b 10                	mov    (%eax),%edx
c010369d:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c01036a3:	09 ca                	or     %ecx,%edx
c01036a5:	89 10                	mov    %edx,(%eax)
  for (size_t i=0;i<4;i++) {
c01036a7:	ff 45 e4             	incl   -0x1c(%ebp)
c01036aa:	83 7d e4 03          	cmpl   $0x3,-0x1c(%ebp)
c01036ae:	76 98                	jbe    c0103648 <paging_init+0x166>
  }
  pg_struct_entry* entry=&page_directory[1023];
c01036b0:	c7 45 e0 fc bf 2f c0 	movl   $0xc02fbffc,-0x20(%ebp)
  entry->pres=1;
c01036b7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01036ba:	8a 10                	mov    (%eax),%dl
c01036bc:	83 ca 01             	or     $0x1,%edx
c01036bf:	88 10                	mov    %dl,(%eax)
  entry->wr=1;
c01036c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01036c4:	8a 10                	mov    (%eax),%dl
c01036c6:	83 ca 02             	or     $0x2,%edx
c01036c9:	88 10                	mov    %dl,(%eax)
  entry->pgno=((uint32_t)page_directory-0xC0000000)>>12;
c01036cb:	b8 00 b0 2f c0       	mov    $0xc02fb000,%eax
c01036d0:	05 00 00 00 40       	add    $0x40000000,%eax
c01036d5:	c1 e8 0c             	shr    $0xc,%eax
c01036d8:	c1 e0 0c             	shl    $0xc,%eax
c01036db:	89 c2                	mov    %eax,%edx
c01036dd:	c1 fa 0c             	sar    $0xc,%edx
c01036e0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01036e3:	89 d1                	mov    %edx,%ecx
c01036e5:	c1 e1 0c             	shl    $0xc,%ecx
c01036e8:	8b 10                	mov    (%eax),%edx
c01036ea:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c01036f0:	09 ca                	or     %ecx,%edx
c01036f2:	89 10                	mov    %edx,(%eax)
  load_address_space((uint32_t*)((uint32_t)page_directory-0xC0000000));
c01036f4:	b8 00 b0 2f c0       	mov    $0xc02fb000,%eax
c01036f9:	05 00 00 00 40       	add    $0x40000000,%eax
c01036fe:	83 ec 0c             	sub    $0xc,%esp
c0103701:	50                   	push   %eax
c0103702:	e8 c2 fc ff ff       	call   c01033c9 <load_address_space>
c0103707:	83 c4 10             	add    $0x10,%esp
}
c010370a:	90                   	nop
c010370b:	c9                   	leave  
c010370c:	c3                   	ret    

c010370d <get_address_space>:

void* get_address_space() {
c010370d:	55                   	push   %ebp
c010370e:	89 e5                	mov    %esp,%ebp
c0103710:	83 ec 10             	sub    $0x10,%esp
  void* address_space;
  asm volatile("movl %%cr3, %%eax; movl %%eax, %0;":"=m"(address_space)::"%eax");
c0103713:	0f 20 d8             	mov    %cr3,%eax
c0103716:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return address_space;
c0103719:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c010371c:	c9                   	leave  
c010371d:	c3                   	ret    

c010371e <dealloc_pages>:

void dealloc_pages(int num_pages,void* addr) {
c010371e:	55                   	push   %ebp
c010371f:	89 e5                	mov    %esp,%ebp
c0103721:	83 ec 08             	sub    $0x8,%esp
  pmem_free((void*)((uint32_t)virt_to_phys(addr)>>12),num_pages);
c0103724:	ff 75 0c             	pushl  0xc(%ebp)
c0103727:	e8 18 fb ff ff       	call   c0103244 <virt_to_phys>
c010372c:	83 c4 04             	add    $0x4,%esp
c010372f:	c1 e8 0c             	shr    $0xc,%eax
c0103732:	83 ec 08             	sub    $0x8,%esp
c0103735:	ff 75 08             	pushl  0x8(%ebp)
c0103738:	50                   	push   %eax
c0103739:	e8 d0 d3 ff ff       	call   c0100b0e <pmem_free>
c010373e:	83 c4 10             	add    $0x10,%esp
  unmap_pages(addr,num_pages,1);
c0103741:	83 ec 04             	sub    $0x4,%esp
c0103744:	6a 01                	push   $0x1
c0103746:	ff 75 08             	pushl  0x8(%ebp)
c0103749:	ff 75 0c             	pushl  0xc(%ebp)
c010374c:	e8 84 fc ff ff       	call   c01033d5 <unmap_pages>
c0103751:	83 c4 10             	add    $0x10,%esp
}
c0103754:	90                   	nop
c0103755:	c9                   	leave  
c0103756:	c3                   	ret    

c0103757 <configure>:
/**
 * Configure a serial port with a specified baud rate.
 * \param com The number of the serial port to configure
 * \param rate The baud rate to set the serial port to. 
*/
static void configure(int com, int rate) {
c0103757:	55                   	push   %ebp
c0103758:	89 e5                	mov    %esp,%ebp
c010375a:	83 ec 08             	sub    $0x8,%esp
  configured[com]=1;
c010375d:	8b 45 08             	mov    0x8(%ebp),%eax
c0103760:	05 00 e0 3d c0       	add    $0xc03de000,%eax
c0103765:	c6 00 01             	movb   $0x1,(%eax)
  port_byte_out(LINE_CMD_PORT(com),0x80); // Enable DLAB
c0103768:	8b 45 08             	mov    0x8(%ebp),%eax
c010376b:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c0103772:	83 c0 03             	add    $0x3,%eax
c0103775:	0f b7 c0             	movzwl %ax,%eax
c0103778:	83 ec 08             	sub    $0x8,%esp
c010377b:	68 80 00 00 00       	push   $0x80
c0103780:	50                   	push   %eax
c0103781:	e8 31 19 00 00       	call   c01050b7 <port_byte_out>
c0103786:	83 c4 10             	add    $0x10,%esp
  port_byte_out(DATA_PORT(com),((115200/rate)>>8)&0xFF); //Write high byte of divisor
c0103789:	b8 00 c2 01 00       	mov    $0x1c200,%eax
c010378e:	99                   	cltd   
c010378f:	f7 7d 0c             	idivl  0xc(%ebp)
c0103792:	c1 f8 08             	sar    $0x8,%eax
c0103795:	0f b6 d0             	movzbl %al,%edx
c0103798:	8b 45 08             	mov    0x8(%ebp),%eax
c010379b:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c01037a2:	0f b7 c0             	movzwl %ax,%eax
c01037a5:	83 ec 08             	sub    $0x8,%esp
c01037a8:	52                   	push   %edx
c01037a9:	50                   	push   %eax
c01037aa:	e8 08 19 00 00       	call   c01050b7 <port_byte_out>
c01037af:	83 c4 10             	add    $0x10,%esp
  port_byte_out(DATA_PORT(com),(115200/rate)&0xFF); //Write low byte of divisor
c01037b2:	b8 00 c2 01 00       	mov    $0x1c200,%eax
c01037b7:	99                   	cltd   
c01037b8:	f7 7d 0c             	idivl  0xc(%ebp)
c01037bb:	0f b6 d0             	movzbl %al,%edx
c01037be:	8b 45 08             	mov    0x8(%ebp),%eax
c01037c1:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c01037c8:	0f b7 c0             	movzwl %ax,%eax
c01037cb:	83 ec 08             	sub    $0x8,%esp
c01037ce:	52                   	push   %edx
c01037cf:	50                   	push   %eax
c01037d0:	e8 e2 18 00 00       	call   c01050b7 <port_byte_out>
c01037d5:	83 c4 10             	add    $0x10,%esp
  port_byte_out(LINE_CMD_PORT(com),0x03); //Disable DLAB and set 8N1 trasmission mode 
c01037d8:	8b 45 08             	mov    0x8(%ebp),%eax
c01037db:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c01037e2:	83 c0 03             	add    $0x3,%eax
c01037e5:	0f b7 c0             	movzwl %ax,%eax
c01037e8:	83 ec 08             	sub    $0x8,%esp
c01037eb:	6a 03                	push   $0x3
c01037ed:	50                   	push   %eax
c01037ee:	e8 c4 18 00 00       	call   c01050b7 <port_byte_out>
c01037f3:	83 c4 10             	add    $0x10,%esp
  port_byte_out(FIFO_PORT(com),0xC7); //Enable & clear FIFOs and set Data Ready interrupt level to 14.
c01037f6:	8b 45 08             	mov    0x8(%ebp),%eax
c01037f9:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c0103800:	83 c0 02             	add    $0x2,%eax
c0103803:	0f b7 c0             	movzwl %ax,%eax
c0103806:	83 ec 08             	sub    $0x8,%esp
c0103809:	68 c7 00 00 00       	push   $0xc7
c010380e:	50                   	push   %eax
c010380f:	e8 a3 18 00 00       	call   c01050b7 <port_byte_out>
c0103814:	83 c4 10             	add    $0x10,%esp
  port_byte_out(MODEM_CMD_PORT(com),0x03); //Enable DTR and RTS
c0103817:	8b 45 08             	mov    0x8(%ebp),%eax
c010381a:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c0103821:	83 c0 04             	add    $0x4,%eax
c0103824:	0f b7 c0             	movzwl %ax,%eax
c0103827:	83 ec 08             	sub    $0x8,%esp
c010382a:	6a 03                	push   $0x3
c010382c:	50                   	push   %eax
c010382d:	e8 85 18 00 00       	call   c01050b7 <port_byte_out>
c0103832:	83 c4 10             	add    $0x10,%esp
  port_byte_out(INT_PORT(com),0x0); //Disable interrupts
c0103835:	8b 45 08             	mov    0x8(%ebp),%eax
c0103838:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c010383f:	40                   	inc    %eax
c0103840:	0f b7 c0             	movzwl %ax,%eax
c0103843:	83 ec 08             	sub    $0x8,%esp
c0103846:	6a 00                	push   $0x0
c0103848:	50                   	push   %eax
c0103849:	e8 69 18 00 00       	call   c01050b7 <port_byte_out>
c010384e:	83 c4 10             	add    $0x10,%esp
  serial_printf("Port %d configured\n",com);
c0103851:	83 ec 08             	sub    $0x8,%esp
c0103854:	ff 75 08             	pushl  0x8(%ebp)
c0103857:	68 0a 6a 10 c0       	push   $0xc0106a0a
c010385c:	e8 f4 05 00 00       	call   c0103e55 <serial_printf>
c0103861:	83 c4 10             	add    $0x10,%esp
}
c0103864:	90                   	nop
c0103865:	c9                   	leave  
c0103866:	c3                   	ret    

c0103867 <serial_init>:

void serial_init() {
c0103867:	55                   	push   %ebp
c0103868:	89 e5                	mov    %esp,%ebp
c010386a:	83 ec 08             	sub    $0x8,%esp
  port_byte_out(SCRATCH_PORT(0),0xaa);
c010386d:	a1 a8 80 10 c0       	mov    0xc01080a8,%eax
c0103872:	83 c0 07             	add    $0x7,%eax
c0103875:	0f b7 c0             	movzwl %ax,%eax
c0103878:	83 ec 08             	sub    $0x8,%esp
c010387b:	68 aa 00 00 00       	push   $0xaa
c0103880:	50                   	push   %eax
c0103881:	e8 31 18 00 00       	call   c01050b7 <port_byte_out>
c0103886:	83 c4 10             	add    $0x10,%esp
  if (port_byte_in(SCRATCH_PORT(0))==0xaa) {
c0103889:	a1 a8 80 10 c0       	mov    0xc01080a8,%eax
c010388e:	83 c0 07             	add    $0x7,%eax
c0103891:	0f b7 c0             	movzwl %ax,%eax
c0103894:	83 ec 0c             	sub    $0xc,%esp
c0103897:	50                   	push   %eax
c0103898:	e8 ff 17 00 00       	call   c010509c <port_byte_in>
c010389d:	83 c4 10             	add    $0x10,%esp
c01038a0:	3c aa                	cmp    $0xaa,%al
c01038a2:	75 12                	jne    c01038b6 <serial_init+0x4f>
    configure(0,9600);
c01038a4:	83 ec 08             	sub    $0x8,%esp
c01038a7:	68 80 25 00 00       	push   $0x2580
c01038ac:	6a 00                	push   $0x0
c01038ae:	e8 a4 fe ff ff       	call   c0103757 <configure>
c01038b3:	83 c4 10             	add    $0x10,%esp
  }
  port_byte_out(SCRATCH_PORT(1),0xaa);
c01038b6:	a1 ac 80 10 c0       	mov    0xc01080ac,%eax
c01038bb:	83 c0 07             	add    $0x7,%eax
c01038be:	0f b7 c0             	movzwl %ax,%eax
c01038c1:	83 ec 08             	sub    $0x8,%esp
c01038c4:	68 aa 00 00 00       	push   $0xaa
c01038c9:	50                   	push   %eax
c01038ca:	e8 e8 17 00 00       	call   c01050b7 <port_byte_out>
c01038cf:	83 c4 10             	add    $0x10,%esp
  if (port_byte_in(SCRATCH_PORT(1))==0xaa) {
c01038d2:	a1 ac 80 10 c0       	mov    0xc01080ac,%eax
c01038d7:	83 c0 07             	add    $0x7,%eax
c01038da:	0f b7 c0             	movzwl %ax,%eax
c01038dd:	83 ec 0c             	sub    $0xc,%esp
c01038e0:	50                   	push   %eax
c01038e1:	e8 b6 17 00 00       	call   c010509c <port_byte_in>
c01038e6:	83 c4 10             	add    $0x10,%esp
c01038e9:	3c aa                	cmp    $0xaa,%al
c01038eb:	75 12                	jne    c01038ff <serial_init+0x98>
    configure(1,9600);
c01038ed:	83 ec 08             	sub    $0x8,%esp
c01038f0:	68 80 25 00 00       	push   $0x2580
c01038f5:	6a 01                	push   $0x1
c01038f7:	e8 5b fe ff ff       	call   c0103757 <configure>
c01038fc:	83 c4 10             	add    $0x10,%esp
  }
}
c01038ff:	90                   	nop
c0103900:	c9                   	leave  
c0103901:	c3                   	ret    

c0103902 <serial_putc>:

void serial_putc(char c) {
c0103902:	55                   	push   %ebp
c0103903:	89 e5                	mov    %esp,%ebp
c0103905:	83 ec 18             	sub    $0x18,%esp
c0103908:	8b 45 08             	mov    0x8(%ebp),%eax
c010390b:	88 45 f4             	mov    %al,-0xc(%ebp)
  if (!configured[0]) return;
c010390e:	a0 00 e0 3d c0       	mov    0xc03de000,%al
c0103913:	84 c0                	test   %al,%al
c0103915:	74 52                	je     c0103969 <serial_putc+0x67>
  if (c=='\n') serial_putc('\r');
c0103917:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c010391b:	75 0d                	jne    c010392a <serial_putc+0x28>
c010391d:	83 ec 0c             	sub    $0xc,%esp
c0103920:	6a 0d                	push   $0xd
c0103922:	e8 db ff ff ff       	call   c0103902 <serial_putc>
c0103927:	83 c4 10             	add    $0x10,%esp
  while(!IS_TRANSMIT_FIFO_EMPTY(0));
c010392a:	90                   	nop
c010392b:	a1 a8 80 10 c0       	mov    0xc01080a8,%eax
c0103930:	83 c0 05             	add    $0x5,%eax
c0103933:	0f b7 c0             	movzwl %ax,%eax
c0103936:	83 ec 0c             	sub    $0xc,%esp
c0103939:	50                   	push   %eax
c010393a:	e8 5d 17 00 00       	call   c010509c <port_byte_in>
c010393f:	83 c4 10             	add    $0x10,%esp
c0103942:	0f b6 c0             	movzbl %al,%eax
c0103945:	83 e0 20             	and    $0x20,%eax
c0103948:	85 c0                	test   %eax,%eax
c010394a:	74 df                	je     c010392b <serial_putc+0x29>
  port_byte_out(DATA_PORT(0),c);
c010394c:	8a 45 f4             	mov    -0xc(%ebp),%al
c010394f:	0f b6 d0             	movzbl %al,%edx
c0103952:	a1 a8 80 10 c0       	mov    0xc01080a8,%eax
c0103957:	0f b7 c0             	movzwl %ax,%eax
c010395a:	83 ec 08             	sub    $0x8,%esp
c010395d:	52                   	push   %edx
c010395e:	50                   	push   %eax
c010395f:	e8 53 17 00 00       	call   c01050b7 <port_byte_out>
c0103964:	83 c4 10             	add    $0x10,%esp
c0103967:	eb 01                	jmp    c010396a <serial_putc+0x68>
  if (!configured[0]) return;
c0103969:	90                   	nop
}
c010396a:	c9                   	leave  
c010396b:	c3                   	ret    

c010396c <serial_getc>:

char serial_getc() {
c010396c:	55                   	push   %ebp
c010396d:	89 e5                	mov    %esp,%ebp
c010396f:	83 ec 08             	sub    $0x8,%esp
  serial_printf("Port 0 byte read requested\n");
c0103972:	83 ec 0c             	sub    $0xc,%esp
c0103975:	68 1e 6a 10 c0       	push   $0xc0106a1e
c010397a:	e8 d6 04 00 00       	call   c0103e55 <serial_printf>
c010397f:	83 c4 10             	add    $0x10,%esp
  if (!configured[0]) return 0;
c0103982:	a0 00 e0 3d c0       	mov    0xc03de000,%al
c0103987:	84 c0                	test   %al,%al
c0103989:	75 04                	jne    c010398f <serial_getc+0x23>
c010398b:	b0 00                	mov    $0x0,%al
c010398d:	eb 56                	jmp    c01039e5 <serial_getc+0x79>
  serial_printf("Port 0 reading byte\n");
c010398f:	83 ec 0c             	sub    $0xc,%esp
c0103992:	68 3a 6a 10 c0       	push   $0xc0106a3a
c0103997:	e8 b9 04 00 00       	call   c0103e55 <serial_printf>
c010399c:	83 c4 10             	add    $0x10,%esp
  while(!IS_RECEIVE_FIFO_READY(0));
c010399f:	90                   	nop
c01039a0:	a1 a8 80 10 c0       	mov    0xc01080a8,%eax
c01039a5:	83 c0 05             	add    $0x5,%eax
c01039a8:	0f b7 c0             	movzwl %ax,%eax
c01039ab:	83 ec 0c             	sub    $0xc,%esp
c01039ae:	50                   	push   %eax
c01039af:	e8 e8 16 00 00       	call   c010509c <port_byte_in>
c01039b4:	83 c4 10             	add    $0x10,%esp
c01039b7:	0f b6 c0             	movzbl %al,%eax
c01039ba:	83 e0 01             	and    $0x1,%eax
c01039bd:	85 c0                	test   %eax,%eax
c01039bf:	74 df                	je     c01039a0 <serial_getc+0x34>
  serial_printf("Port 0 read byte\n");
c01039c1:	83 ec 0c             	sub    $0xc,%esp
c01039c4:	68 4f 6a 10 c0       	push   $0xc0106a4f
c01039c9:	e8 87 04 00 00       	call   c0103e55 <serial_printf>
c01039ce:	83 c4 10             	add    $0x10,%esp
  return port_byte_in(DATA_PORT(0));
c01039d1:	a1 a8 80 10 c0       	mov    0xc01080a8,%eax
c01039d6:	0f b7 c0             	movzwl %ax,%eax
c01039d9:	83 ec 0c             	sub    $0xc,%esp
c01039dc:	50                   	push   %eax
c01039dd:	e8 ba 16 00 00       	call   c010509c <port_byte_in>
c01039e2:	83 c4 10             	add    $0x10,%esp
}
c01039e5:	c9                   	leave  
c01039e6:	c3                   	ret    

c01039e7 <serial_putc_port>:

void serial_putc_port(char c, int port) {
c01039e7:	55                   	push   %ebp
c01039e8:	89 e5                	mov    %esp,%ebp
c01039ea:	83 ec 18             	sub    $0x18,%esp
c01039ed:	8b 45 08             	mov    0x8(%ebp),%eax
c01039f0:	88 45 f4             	mov    %al,-0xc(%ebp)
  if (!configured[port]) return;
c01039f3:	8b 45 0c             	mov    0xc(%ebp),%eax
c01039f6:	05 00 e0 3d c0       	add    $0xc03de000,%eax
c01039fb:	8a 00                	mov    (%eax),%al
c01039fd:	84 c0                	test   %al,%al
c01039ff:	74 5c                	je     c0103a5d <serial_putc_port+0x76>
  if (c=='\n') serial_putc('\r');
c0103a01:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c0103a05:	75 0d                	jne    c0103a14 <serial_putc_port+0x2d>
c0103a07:	83 ec 0c             	sub    $0xc,%esp
c0103a0a:	6a 0d                	push   $0xd
c0103a0c:	e8 f1 fe ff ff       	call   c0103902 <serial_putc>
c0103a11:	83 c4 10             	add    $0x10,%esp
  while(!IS_TRANSMIT_FIFO_EMPTY(port));
c0103a14:	90                   	nop
c0103a15:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103a18:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c0103a1f:	83 c0 05             	add    $0x5,%eax
c0103a22:	0f b7 c0             	movzwl %ax,%eax
c0103a25:	83 ec 0c             	sub    $0xc,%esp
c0103a28:	50                   	push   %eax
c0103a29:	e8 6e 16 00 00       	call   c010509c <port_byte_in>
c0103a2e:	83 c4 10             	add    $0x10,%esp
c0103a31:	0f b6 c0             	movzbl %al,%eax
c0103a34:	83 e0 20             	and    $0x20,%eax
c0103a37:	85 c0                	test   %eax,%eax
c0103a39:	74 da                	je     c0103a15 <serial_putc_port+0x2e>
  port_byte_out(DATA_PORT(port),c);
c0103a3b:	8a 45 f4             	mov    -0xc(%ebp),%al
c0103a3e:	0f b6 d0             	movzbl %al,%edx
c0103a41:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103a44:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c0103a4b:	0f b7 c0             	movzwl %ax,%eax
c0103a4e:	83 ec 08             	sub    $0x8,%esp
c0103a51:	52                   	push   %edx
c0103a52:	50                   	push   %eax
c0103a53:	e8 5f 16 00 00       	call   c01050b7 <port_byte_out>
c0103a58:	83 c4 10             	add    $0x10,%esp
c0103a5b:	eb 01                	jmp    c0103a5e <serial_putc_port+0x77>
  if (!configured[port]) return;
c0103a5d:	90                   	nop
}
c0103a5e:	c9                   	leave  
c0103a5f:	c3                   	ret    

c0103a60 <serial_getc_port>:

char serial_getc_port(int port) {
c0103a60:	55                   	push   %ebp
c0103a61:	89 e5                	mov    %esp,%ebp
c0103a63:	83 ec 08             	sub    $0x8,%esp
  serial_printf("Port %d byte read requested\n",port);
c0103a66:	83 ec 08             	sub    $0x8,%esp
c0103a69:	ff 75 08             	pushl  0x8(%ebp)
c0103a6c:	68 61 6a 10 c0       	push   $0xc0106a61
c0103a71:	e8 df 03 00 00       	call   c0103e55 <serial_printf>
c0103a76:	83 c4 10             	add    $0x10,%esp
  if (!configured[port]) return 0;
c0103a79:	8b 45 08             	mov    0x8(%ebp),%eax
c0103a7c:	05 00 e0 3d c0       	add    $0xc03de000,%eax
c0103a81:	8a 00                	mov    (%eax),%al
c0103a83:	84 c0                	test   %al,%al
c0103a85:	75 04                	jne    c0103a8b <serial_getc_port+0x2b>
c0103a87:	b0 00                	mov    $0x0,%al
c0103a89:	eb 66                	jmp    c0103af1 <serial_getc_port+0x91>
  serial_printf("Port %d reading byte\n",port);
c0103a8b:	83 ec 08             	sub    $0x8,%esp
c0103a8e:	ff 75 08             	pushl  0x8(%ebp)
c0103a91:	68 7e 6a 10 c0       	push   $0xc0106a7e
c0103a96:	e8 ba 03 00 00       	call   c0103e55 <serial_printf>
c0103a9b:	83 c4 10             	add    $0x10,%esp
  while(!IS_RECEIVE_FIFO_READY(port));
c0103a9e:	90                   	nop
c0103a9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0103aa2:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c0103aa9:	83 c0 05             	add    $0x5,%eax
c0103aac:	0f b7 c0             	movzwl %ax,%eax
c0103aaf:	83 ec 0c             	sub    $0xc,%esp
c0103ab2:	50                   	push   %eax
c0103ab3:	e8 e4 15 00 00       	call   c010509c <port_byte_in>
c0103ab8:	83 c4 10             	add    $0x10,%esp
c0103abb:	0f b6 c0             	movzbl %al,%eax
c0103abe:	83 e0 01             	and    $0x1,%eax
c0103ac1:	85 c0                	test   %eax,%eax
c0103ac3:	74 da                	je     c0103a9f <serial_getc_port+0x3f>
  serial_printf("Port %d read byte\n",port);
c0103ac5:	83 ec 08             	sub    $0x8,%esp
c0103ac8:	ff 75 08             	pushl  0x8(%ebp)
c0103acb:	68 94 6a 10 c0       	push   $0xc0106a94
c0103ad0:	e8 80 03 00 00       	call   c0103e55 <serial_printf>
c0103ad5:	83 c4 10             	add    $0x10,%esp
  return port_byte_in(DATA_PORT(port));
c0103ad8:	8b 45 08             	mov    0x8(%ebp),%eax
c0103adb:	8b 04 85 a8 80 10 c0 	mov    -0x3fef7f58(,%eax,4),%eax
c0103ae2:	0f b7 c0             	movzwl %ax,%eax
c0103ae5:	83 ec 0c             	sub    $0xc,%esp
c0103ae8:	50                   	push   %eax
c0103ae9:	e8 ae 15 00 00       	call   c010509c <port_byte_in>
c0103aee:	83 c4 10             	add    $0x10,%esp
}
c0103af1:	c9                   	leave  
c0103af2:	c3                   	ret    

c0103af3 <is_kstack_allocated>:
/**
 * Check whether a kernel stack is allocated
 * \param index The kernel stack to check
 * \return whether the kernel stack is allocated
*/
static char is_kstack_allocated(size_t index) {
c0103af3:	55                   	push   %ebp
c0103af4:	89 e5                	mov    %esp,%ebp
c0103af6:	53                   	push   %ebx
c0103af7:	83 ec 10             	sub    $0x10,%esp
  size_t byte=index/8;
c0103afa:	8b 45 08             	mov    0x8(%ebp),%eax
c0103afd:	c1 e8 03             	shr    $0x3,%eax
c0103b00:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=index%8;
c0103b03:	8b 45 08             	mov    0x8(%ebp),%eax
c0103b06:	83 e0 07             	and    $0x7,%eax
c0103b09:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char entry=kstack_bmap[byte];
c0103b0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0103b0f:	05 20 e0 3d c0       	add    $0xc03de020,%eax
c0103b14:	8a 00                	mov    (%eax),%al
c0103b16:	88 45 f3             	mov    %al,-0xd(%ebp)
  return (entry&(1<<bit))>0;
c0103b19:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
c0103b1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103b20:	bb 01 00 00 00       	mov    $0x1,%ebx
c0103b25:	88 c1                	mov    %al,%cl
c0103b27:	d3 e3                	shl    %cl,%ebx
c0103b29:	89 d8                	mov    %ebx,%eax
c0103b2b:	21 d0                	and    %edx,%eax
c0103b2d:	85 c0                	test   %eax,%eax
c0103b2f:	0f 9f c0             	setg   %al
}
c0103b32:	83 c4 10             	add    $0x10,%esp
c0103b35:	5b                   	pop    %ebx
c0103b36:	5d                   	pop    %ebp
c0103b37:	c3                   	ret    

c0103b38 <mark_kstack_allocated>:

/**
 * Mark that a kernel stack is allocated
 * \param index The kernel stack to mark
*/
static void mark_kstack_allocated(size_t index) {
c0103b38:	55                   	push   %ebp
c0103b39:	89 e5                	mov    %esp,%ebp
c0103b3b:	53                   	push   %ebx
c0103b3c:	83 ec 10             	sub    $0x10,%esp
  size_t byte=index/8;
c0103b3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0103b42:	c1 e8 03             	shr    $0x3,%eax
c0103b45:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t bit=index%8;
c0103b48:	8b 45 08             	mov    0x8(%ebp),%eax
c0103b4b:	83 e0 07             	and    $0x7,%eax
c0103b4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  kstack_bmap[byte]=kstack_bmap[byte]|(1<<bit);
c0103b51:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0103b54:	05 20 e0 3d c0       	add    $0xc03de020,%eax
c0103b59:	8a 10                	mov    (%eax),%dl
c0103b5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103b5e:	bb 01 00 00 00       	mov    $0x1,%ebx
c0103b63:	88 c1                	mov    %al,%cl
c0103b65:	d3 e3                	shl    %cl,%ebx
c0103b67:	89 d8                	mov    %ebx,%eax
c0103b69:	09 c2                	or     %eax,%edx
c0103b6b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0103b6e:	05 20 e0 3d c0       	add    $0xc03de020,%eax
c0103b73:	88 10                	mov    %dl,(%eax)
}
c0103b75:	90                   	nop
c0103b76:	83 c4 10             	add    $0x10,%esp
c0103b79:	5b                   	pop    %ebx
c0103b7a:	5d                   	pop    %ebp
c0103b7b:	c3                   	ret    

c0103b7c <new_kstack>:

/**
 * Allocate a kernel stack for a thread
 * \return The number of the new kernel stack, or -1 if none are unallocated.
*/
static int new_kstack() {
c0103b7c:	55                   	push   %ebp
c0103b7d:	89 e5                	mov    %esp,%ebp
c0103b7f:	83 ec 18             	sub    $0x18,%esp
  int num=-1;
c0103b82:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
  for (int i=0;i<(218*1024);i++) {
c0103b89:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0103b90:	eb 1b                	jmp    c0103bad <new_kstack+0x31>
    if (is_kstack_allocated(i)==0) {
c0103b92:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103b95:	50                   	push   %eax
c0103b96:	e8 58 ff ff ff       	call   c0103af3 <is_kstack_allocated>
c0103b9b:	83 c4 04             	add    $0x4,%esp
c0103b9e:	84 c0                	test   %al,%al
c0103ba0:	75 08                	jne    c0103baa <new_kstack+0x2e>
      num=i;
c0103ba2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103ba5:	89 45 f4             	mov    %eax,-0xc(%ebp)
      break;
c0103ba8:	eb 0c                	jmp    c0103bb6 <new_kstack+0x3a>
  for (int i=0;i<(218*1024);i++) {
c0103baa:	ff 45 f0             	incl   -0x10(%ebp)
c0103bad:	81 7d f0 ff 67 03 00 	cmpl   $0x367ff,-0x10(%ebp)
c0103bb4:	7e dc                	jle    c0103b92 <new_kstack+0x16>
    }
  }
  if (num==-1) {
c0103bb6:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0103bba:	75 07                	jne    c0103bc3 <new_kstack+0x47>
    return -1;
c0103bbc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0103bc1:	eb 5d                	jmp    c0103c20 <new_kstack+0xa4>
  }
  mark_kstack_allocated(num);
c0103bc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103bc6:	50                   	push   %eax
c0103bc7:	e8 6c ff ff ff       	call   c0103b38 <mark_kstack_allocated>
c0103bcc:	83 c4 04             	add    $0x4,%esp
  if (!is_page_present(((uint32_t)((char*)kstacks+num*0x1000))>>12)) {
c0103bcf:	a1 b8 80 10 c0       	mov    0xc01080b8,%eax
c0103bd4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0103bd7:	c1 e2 0c             	shl    $0xc,%edx
c0103bda:	01 d0                	add    %edx,%eax
c0103bdc:	c1 e8 0c             	shr    $0xc,%eax
c0103bdf:	83 ec 0c             	sub    $0xc,%esp
c0103be2:	50                   	push   %eax
c0103be3:	e8 70 f3 ff ff       	call   c0102f58 <is_page_present>
c0103be8:	83 c4 10             	add    $0x10,%esp
c0103beb:	84 c0                	test   %al,%al
c0103bed:	75 2e                	jne    c0103c1d <new_kstack+0xa1>
    map_pages(((char*)kstacks+num*0x1000),pmem_alloc(1),1,1,1);
c0103bef:	83 ec 0c             	sub    $0xc,%esp
c0103bf2:	6a 01                	push   $0x1
c0103bf4:	e8 27 ce ff ff       	call   c0100a20 <pmem_alloc>
c0103bf9:	83 c4 10             	add    $0x10,%esp
c0103bfc:	8b 15 b8 80 10 c0    	mov    0xc01080b8,%edx
c0103c02:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0103c05:	c1 e1 0c             	shl    $0xc,%ecx
c0103c08:	01 ca                	add    %ecx,%edx
c0103c0a:	83 ec 0c             	sub    $0xc,%esp
c0103c0d:	6a 01                	push   $0x1
c0103c0f:	6a 01                	push   $0x1
c0103c11:	6a 01                	push   $0x1
c0103c13:	50                   	push   %eax
c0103c14:	52                   	push   %edx
c0103c15:	e8 8f f3 ff ff       	call   c0102fa9 <map_pages>
c0103c1a:	83 c4 20             	add    $0x20,%esp
  }
  return num;
c0103c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0103c20:	c9                   	leave  
c0103c21:	c3                   	ret    

c0103c22 <setup_kstack>:

void setup_kstack(Thread* thread,void* param1,void* param2,char kmode,void* eip,char is_irq_handler) {
c0103c22:	55                   	push   %ebp
c0103c23:	89 e5                	mov    %esp,%ebp
c0103c25:	83 ec 38             	sub    $0x38,%esp
c0103c28:	8b 55 14             	mov    0x14(%ebp),%edx
c0103c2b:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0103c2e:	88 55 d4             	mov    %dl,-0x2c(%ebp)
c0103c31:	88 45 d0             	mov    %al,-0x30(%ebp)
  serial_printf("Setup kstack for TID %d, PID %d\n", thread->tid, thread->process->pid);
c0103c34:	8b 45 08             	mov    0x8(%ebp),%eax
c0103c37:	8b 40 28             	mov    0x28(%eax),%eax
c0103c3a:	8b 50 04             	mov    0x4(%eax),%edx
c0103c3d:	8b 45 08             	mov    0x8(%ebp),%eax
c0103c40:	8b 40 0c             	mov    0xc(%eax),%eax
c0103c43:	83 ec 04             	sub    $0x4,%esp
c0103c46:	52                   	push   %edx
c0103c47:	50                   	push   %eax
c0103c48:	68 a8 6a 10 c0       	push   $0xc0106aa8
c0103c4d:	e8 03 02 00 00       	call   c0103e55 <serial_printf>
c0103c52:	83 c4 10             	add    $0x10,%esp
  size_t kstack_num=new_kstack();
c0103c55:	e8 22 ff ff ff       	call   c0103b7c <new_kstack>
c0103c5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (kmode) {
c0103c5d:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
c0103c61:	74 4a                	je     c0103cad <setup_kstack+0x8b>
    size_t top_idx=(1024*(kstack_num+1));
c0103c63:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103c66:	40                   	inc    %eax
c0103c67:	c1 e0 0a             	shl    $0xa,%eax
c0103c6a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    thread->kernel_esp=((void*)(&kstacks[top_idx-5]));
c0103c6d:	a1 b8 80 10 c0       	mov    0xc01080b8,%eax
c0103c72:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0103c75:	81 c2 fb ff ff 3f    	add    $0x3ffffffb,%edx
c0103c7b:	c1 e2 02             	shl    $0x2,%edx
c0103c7e:	01 c2                	add    %eax,%edx
c0103c80:	8b 45 08             	mov    0x8(%ebp),%eax
c0103c83:	89 10                	mov    %edx,(%eax)
    thread->kernel_esp_top=thread->kernel_esp;
c0103c85:	8b 45 08             	mov    0x8(%ebp),%eax
c0103c88:	8b 10                	mov    (%eax),%edx
c0103c8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0103c8d:	89 50 04             	mov    %edx,0x4(%eax)
    kstacks[top_idx-1]=(void*)eip;
c0103c90:	a1 b8 80 10 c0       	mov    0xc01080b8,%eax
c0103c95:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0103c98:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
c0103c9e:	c1 e2 02             	shl    $0x2,%edx
c0103ca1:	01 c2                	add    %eax,%edx
c0103ca3:	8b 45 18             	mov    0x18(%ebp),%eax
c0103ca6:	89 02                	mov    %eax,(%edx)
    }
    serial_printf("User stack outside space: %x\n", user_stack);
    kstacks[top_idx-2]=(void*)user_stack;
    kstacks[top_idx-1]=(void*)eip;
  }
}
c0103ca8:	e9 11 01 00 00       	jmp    c0103dbe <setup_kstack+0x19c>
    size_t top_idx=(1024*(kstack_num+1));
c0103cad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103cb0:	40                   	inc    %eax
c0103cb1:	c1 e0 0a             	shl    $0xa,%eax
c0103cb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    thread->kernel_esp=((void*)(&kstacks[top_idx-7]));
c0103cb7:	a1 b8 80 10 c0       	mov    0xc01080b8,%eax
c0103cbc:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0103cbf:	81 c2 f9 ff ff 3f    	add    $0x3ffffff9,%edx
c0103cc5:	c1 e2 02             	shl    $0x2,%edx
c0103cc8:	01 c2                	add    %eax,%edx
c0103cca:	8b 45 08             	mov    0x8(%ebp),%eax
c0103ccd:	89 10                	mov    %edx,(%eax)
    thread->kernel_esp_top=thread->kernel_esp;
c0103ccf:	8b 45 08             	mov    0x8(%ebp),%eax
c0103cd2:	8b 10                	mov    (%eax),%edx
c0103cd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0103cd7:	89 50 04             	mov    %edx,0x4(%eax)
    RUN_IN_ADDRESS_SPACE(thread->address_space,{
c0103cda:	e8 2e fa ff ff       	call   c010370d <get_address_space>
c0103cdf:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0103ce2:	8b 45 08             	mov    0x8(%ebp),%eax
c0103ce5:	8b 40 08             	mov    0x8(%eax),%eax
c0103ce8:	83 ec 0c             	sub    $0xc,%esp
c0103ceb:	50                   	push   %eax
c0103cec:	e8 d8 f6 ff ff       	call   c01033c9 <load_address_space>
c0103cf1:	83 c4 10             	add    $0x10,%esp
c0103cf4:	83 ec 0c             	sub    $0xc,%esp
c0103cf7:	6a 02                	push   $0x2
c0103cf9:	e8 13 f5 ff ff       	call   c0103211 <alloc_pages>
c0103cfe:	83 c4 10             	add    $0x10,%esp
c0103d01:	05 00 20 00 00       	add    $0x2000,%eax
c0103d06:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0103d09:	83 6d e8 08          	subl   $0x8,-0x18(%ebp)
c0103d0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103d10:	8b 55 10             	mov    0x10(%ebp),%edx
c0103d13:	89 10                	mov    %edx,(%eax)
c0103d15:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103d18:	8d 50 04             	lea    0x4(%eax),%edx
c0103d1b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103d1e:	89 02                	mov    %eax,(%edx)
c0103d20:	83 ec 08             	sub    $0x8,%esp
c0103d23:	ff 75 e8             	pushl  -0x18(%ebp)
c0103d26:	68 cc 6a 10 c0       	push   $0xc0106acc
c0103d2b:	e8 25 01 00 00       	call   c0103e55 <serial_printf>
c0103d30:	83 c4 10             	add    $0x10,%esp
c0103d33:	83 ec 0c             	sub    $0xc,%esp
c0103d36:	ff 75 ec             	pushl  -0x14(%ebp)
c0103d39:	e8 8b f6 ff ff       	call   c01033c9 <load_address_space>
c0103d3e:	83 c4 10             	add    $0x10,%esp
    if (is_irq_handler) {
c0103d41:	80 7d d0 00          	cmpb   $0x0,-0x30(%ebp)
c0103d45:	74 1b                	je     c0103d62 <setup_kstack+0x140>
      kstacks[top_idx-3]=(void*)task_init_no_int;
c0103d47:	a1 b8 80 10 c0       	mov    0xc01080b8,%eax
c0103d4c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0103d4f:	81 c2 fd ff ff 3f    	add    $0x3ffffffd,%edx
c0103d55:	c1 e2 02             	shl    $0x2,%edx
c0103d58:	01 d0                	add    %edx,%eax
c0103d5a:	c7 00 e0 42 10 c0    	movl   $0xc01042e0,(%eax)
c0103d60:	eb 19                	jmp    c0103d7b <setup_kstack+0x159>
    kstacks[top_idx-3]=(void*)task_init;
c0103d62:	a1 b8 80 10 c0       	mov    0xc01080b8,%eax
c0103d67:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0103d6a:	81 c2 fd ff ff 3f    	add    $0x3ffffffd,%edx
c0103d70:	c1 e2 02             	shl    $0x2,%edx
c0103d73:	01 d0                	add    %edx,%eax
c0103d75:	c7 00 c3 42 10 c0    	movl   $0xc01042c3,(%eax)
    serial_printf("User stack outside space: %x\n", user_stack);
c0103d7b:	83 ec 08             	sub    $0x8,%esp
c0103d7e:	ff 75 e8             	pushl  -0x18(%ebp)
c0103d81:	68 ed 6a 10 c0       	push   $0xc0106aed
c0103d86:	e8 ca 00 00 00       	call   c0103e55 <serial_printf>
c0103d8b:	83 c4 10             	add    $0x10,%esp
    kstacks[top_idx-2]=(void*)user_stack;
c0103d8e:	a1 b8 80 10 c0       	mov    0xc01080b8,%eax
c0103d93:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0103d96:	81 c2 fe ff ff 3f    	add    $0x3ffffffe,%edx
c0103d9c:	c1 e2 02             	shl    $0x2,%edx
c0103d9f:	01 c2                	add    %eax,%edx
c0103da1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103da4:	89 02                	mov    %eax,(%edx)
    kstacks[top_idx-1]=(void*)eip;
c0103da6:	a1 b8 80 10 c0       	mov    0xc01080b8,%eax
c0103dab:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0103dae:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
c0103db4:	c1 e2 02             	shl    $0x2,%edx
c0103db7:	01 c2                	add    %eax,%edx
c0103db9:	8b 45 18             	mov    0x18(%ebp),%eax
c0103dbc:	89 02                	mov    %eax,(%edx)
}
c0103dbe:	90                   	nop
c0103dbf:	c9                   	leave  
c0103dc0:	c3                   	ret    

c0103dc1 <free_kstack>:

void free_kstack(void* stack_ptr) {
c0103dc1:	55                   	push   %ebp
c0103dc2:	89 e5                	mov    %esp,%ebp
c0103dc4:	53                   	push   %ebx
c0103dc5:	83 ec 10             	sub    $0x10,%esp
  uint32_t stack=(uint32_t)stack_ptr;
c0103dc8:	8b 45 08             	mov    0x8(%ebp),%eax
c0103dcb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  stack-=0xC8000000;
c0103dce:	81 45 f8 00 00 00 38 	addl   $0x38000000,-0x8(%ebp)
  stack=stack>>12;
c0103dd5:	c1 6d f8 0c          	shrl   $0xc,-0x8(%ebp)
  size_t byte=stack/8;
c0103dd9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0103ddc:	c1 e8 03             	shr    $0x3,%eax
c0103ddf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t bit=stack%8;
c0103de2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0103de5:	83 e0 07             	and    $0x7,%eax
c0103de8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  kstack_bmap[byte]=kstack_bmap[byte]&(~(1<<bit));
c0103deb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103dee:	05 20 e0 3d c0       	add    $0xc03de020,%eax
c0103df3:	8a 10                	mov    (%eax),%dl
c0103df5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103df8:	bb 01 00 00 00       	mov    $0x1,%ebx
c0103dfd:	88 c1                	mov    %al,%cl
c0103dff:	d3 e3                	shl    %cl,%ebx
c0103e01:	89 d8                	mov    %ebx,%eax
c0103e03:	f7 d0                	not    %eax
c0103e05:	21 c2                	and    %eax,%edx
c0103e07:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103e0a:	05 20 e0 3d c0       	add    $0xc03de020,%eax
c0103e0f:	88 10                	mov    %dl,(%eax)
}
c0103e11:	90                   	nop
c0103e12:	83 c4 10             	add    $0x10,%esp
c0103e15:	5b                   	pop    %ebx
c0103e16:	5d                   	pop    %ebp
c0103e17:	c3                   	ret    

c0103e18 <serial_write_string>:
#include "serial.h"
#include <stdint.h>
#include <stdarg.h>
#include <string.h>

void serial_write_string(const char* s) {
c0103e18:	55                   	push   %ebp
c0103e19:	89 e5                	mov    %esp,%ebp
c0103e1b:	83 ec 18             	sub    $0x18,%esp
  for (int i=0;s[i]!='\0';i++) {
c0103e1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0103e25:	eb 1c                	jmp    c0103e43 <serial_write_string+0x2b>
    serial_putc(s[i]);
c0103e27:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0103e2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e2d:	01 d0                	add    %edx,%eax
c0103e2f:	8a 00                	mov    (%eax),%al
c0103e31:	0f be c0             	movsbl %al,%eax
c0103e34:	83 ec 0c             	sub    $0xc,%esp
c0103e37:	50                   	push   %eax
c0103e38:	e8 c5 fa ff ff       	call   c0103902 <serial_putc>
c0103e3d:	83 c4 10             	add    $0x10,%esp
  for (int i=0;s[i]!='\0';i++) {
c0103e40:	ff 45 f4             	incl   -0xc(%ebp)
c0103e43:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0103e46:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e49:	01 d0                	add    %edx,%eax
c0103e4b:	8a 00                	mov    (%eax),%al
c0103e4d:	84 c0                	test   %al,%al
c0103e4f:	75 d6                	jne    c0103e27 <serial_write_string+0xf>
  }
}
c0103e51:	90                   	nop
c0103e52:	90                   	nop
c0103e53:	c9                   	leave  
c0103e54:	c3                   	ret    

c0103e55 <serial_printf>:

void serial_printf(const char* format,...) {
c0103e55:	55                   	push   %ebp
c0103e56:	89 e5                	mov    %esp,%ebp
c0103e58:	83 ec 38             	sub    $0x38,%esp
  va_list arg;
  va_start(arg,format);
c0103e5b:	8d 45 0c             	lea    0xc(%ebp),%eax
c0103e5e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  for(;*format!='\0';format++) {
c0103e61:	e9 21 01 00 00       	jmp    c0103f87 <serial_printf+0x132>
    if(*format!='%') {
c0103e66:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e69:	8a 00                	mov    (%eax),%al
c0103e6b:	3c 25                	cmp    $0x25,%al
c0103e6d:	74 19                	je     c0103e88 <serial_printf+0x33>
      serial_putc(*format);
c0103e6f:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e72:	8a 00                	mov    (%eax),%al
c0103e74:	0f be c0             	movsbl %al,%eax
c0103e77:	83 ec 0c             	sub    $0xc,%esp
c0103e7a:	50                   	push   %eax
c0103e7b:	e8 82 fa ff ff       	call   c0103902 <serial_putc>
c0103e80:	83 c4 10             	add    $0x10,%esp
      continue;
c0103e83:	e9 fc 00 00 00       	jmp    c0103f84 <serial_printf+0x12f>
    }
    format++;
c0103e88:	ff 45 08             	incl   0x8(%ebp)
    switch(*format) {
c0103e8b:	8b 45 08             	mov    0x8(%ebp),%eax
c0103e8e:	8a 00                	mov    (%eax),%al
c0103e90:	0f be c0             	movsbl %al,%eax
c0103e93:	83 f8 78             	cmp    $0x78,%eax
c0103e96:	0f 84 b4 00 00 00    	je     c0103f50 <serial_printf+0xfb>
c0103e9c:	83 f8 78             	cmp    $0x78,%eax
c0103e9f:	0f 8f df 00 00 00    	jg     c0103f84 <serial_printf+0x12f>
c0103ea5:	83 f8 73             	cmp    $0x73,%eax
c0103ea8:	0f 84 84 00 00 00    	je     c0103f32 <serial_printf+0xdd>
c0103eae:	83 f8 73             	cmp    $0x73,%eax
c0103eb1:	0f 8f cd 00 00 00    	jg     c0103f84 <serial_printf+0x12f>
c0103eb7:	83 f8 63             	cmp    $0x63,%eax
c0103eba:	74 0a                	je     c0103ec6 <serial_printf+0x71>
c0103ebc:	83 f8 64             	cmp    $0x64,%eax
c0103ebf:	74 2a                	je     c0103eeb <serial_printf+0x96>
c0103ec1:	e9 be 00 00 00       	jmp    c0103f84 <serial_printf+0x12f>
      case 'c': {
        int i=va_arg(arg,int);
c0103ec6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103ec9:	8d 50 04             	lea    0x4(%eax),%edx
c0103ecc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0103ecf:	8b 00                	mov    (%eax),%eax
c0103ed1:	89 45 e8             	mov    %eax,-0x18(%ebp)
        serial_putc(i);
c0103ed4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103ed7:	0f be c0             	movsbl %al,%eax
c0103eda:	83 ec 0c             	sub    $0xc,%esp
c0103edd:	50                   	push   %eax
c0103ede:	e8 1f fa ff ff       	call   c0103902 <serial_putc>
c0103ee3:	83 c4 10             	add    $0x10,%esp
        break;
c0103ee6:	e9 99 00 00 00       	jmp    c0103f84 <serial_printf+0x12f>
      }
      case 'd': {
        int i=va_arg(arg,int); 		//Fetch Decimal/Integer argument
c0103eeb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103eee:	8d 50 04             	lea    0x4(%eax),%edx
c0103ef1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0103ef4:	8b 00                	mov    (%eax),%eax
c0103ef6:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i<0) {
c0103ef9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0103efd:	79 10                	jns    c0103f0f <serial_printf+0xba>
          i=-i;
c0103eff:	f7 5d f4             	negl   -0xc(%ebp)
          serial_putc('-');
c0103f02:	83 ec 0c             	sub    $0xc,%esp
c0103f05:	6a 2d                	push   $0x2d
c0103f07:	e8 f6 f9 ff ff       	call   c0103902 <serial_putc>
c0103f0c:	83 c4 10             	add    $0x10,%esp
        }
        char str[11];
        int_to_ascii(i,str);
c0103f0f:	83 ec 08             	sub    $0x8,%esp
c0103f12:	8d 45 d9             	lea    -0x27(%ebp),%eax
c0103f15:	50                   	push   %eax
c0103f16:	ff 75 f4             	pushl  -0xc(%ebp)
c0103f19:	e8 44 14 00 00       	call   c0105362 <int_to_ascii>
c0103f1e:	83 c4 10             	add    $0x10,%esp
        serial_write_string(str);
c0103f21:	83 ec 0c             	sub    $0xc,%esp
c0103f24:	8d 45 d9             	lea    -0x27(%ebp),%eax
c0103f27:	50                   	push   %eax
c0103f28:	e8 eb fe ff ff       	call   c0103e18 <serial_write_string>
c0103f2d:	83 c4 10             	add    $0x10,%esp
        break;
c0103f30:	eb 52                	jmp    c0103f84 <serial_printf+0x12f>
      //   int i=va_arg(arg,unsigned int); //Fetch Octal representation
      // 	puts(convert(i,8));
      // 	break;
      // }
      case 's': {
        char* s=va_arg(arg,char*);
c0103f32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103f35:	8d 50 04             	lea    0x4(%eax),%edx
c0103f38:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0103f3b:	8b 00                	mov    (%eax),%eax
c0103f3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        serial_write_string(s);
c0103f40:	83 ec 0c             	sub    $0xc,%esp
c0103f43:	ff 75 ec             	pushl  -0x14(%ebp)
c0103f46:	e8 cd fe ff ff       	call   c0103e18 <serial_write_string>
c0103f4b:	83 c4 10             	add    $0x10,%esp
        break;
c0103f4e:	eb 34                	jmp    c0103f84 <serial_printf+0x12f>
      }
      case 'x': {
        unsigned int i=va_arg(arg,unsigned int);
c0103f50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103f53:	8d 50 04             	lea    0x4(%eax),%edx
c0103f56:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0103f59:	8b 00                	mov    (%eax),%eax
c0103f5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        char str[11];
        str[0]='\0';
c0103f5e:	c6 45 ce 00          	movb   $0x0,-0x32(%ebp)
        hex_to_ascii(i,str);
c0103f62:	83 ec 08             	sub    $0x8,%esp
c0103f65:	8d 45 ce             	lea    -0x32(%ebp),%eax
c0103f68:	50                   	push   %eax
c0103f69:	ff 75 f0             	pushl  -0x10(%ebp)
c0103f6c:	e8 82 14 00 00       	call   c01053f3 <hex_to_ascii>
c0103f71:	83 c4 10             	add    $0x10,%esp
        serial_write_string(str);
c0103f74:	83 ec 0c             	sub    $0xc,%esp
c0103f77:	8d 45 ce             	lea    -0x32(%ebp),%eax
c0103f7a:	50                   	push   %eax
c0103f7b:	e8 98 fe ff ff       	call   c0103e18 <serial_write_string>
c0103f80:	83 c4 10             	add    $0x10,%esp
        break;
c0103f83:	90                   	nop
  for(;*format!='\0';format++) {
c0103f84:	ff 45 08             	incl   0x8(%ebp)
c0103f87:	8b 45 08             	mov    0x8(%ebp),%eax
c0103f8a:	8a 00                	mov    (%eax),%al
c0103f8c:	84 c0                	test   %al,%al
c0103f8e:	0f 85 d2 fe ff ff    	jne    c0103e66 <serial_printf+0x11>
      }
    }
  }
}
c0103f94:	90                   	nop
c0103f95:	90                   	nop
c0103f96:	c9                   	leave  
c0103f97:	c3                   	ret    

c0103f98 <timer_init>:
#include "../../cpu/serial.h"
#include <cpu/ports.h>

void timer_handler(registers_t* r);

void timer_init(int freq) {
c0103f98:	55                   	push   %ebp
c0103f99:	89 e5                	mov    %esp,%ebp
c0103f9b:	83 ec 18             	sub    $0x18,%esp
  int div=1193180/freq;
c0103f9e:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
c0103fa3:	99                   	cltd   
c0103fa4:	f7 7d 08             	idivl  0x8(%ebp)
c0103fa7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (div>65535) {
c0103faa:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
c0103fb1:	7e 44                	jle    c0103ff7 <timer_init+0x5f>
    serial_printf("Frequency of %dHz too slow, min freq is 18 Hz\n");
c0103fb3:	83 ec 0c             	sub    $0xc,%esp
c0103fb6:	68 0c 6b 10 c0       	push   $0xc0106b0c
c0103fbb:	e8 95 fe ff ff       	call   c0103e55 <serial_printf>
c0103fc0:	83 c4 10             	add    $0x10,%esp
    div=65535;
c0103fc3:	c7 45 f4 ff ff 00 00 	movl   $0xffff,-0xc(%ebp)
    freq=18;
c0103fca:	c7 45 08 12 00 00 00 	movl   $0x12,0x8(%ebp)
  if (div==0) {
c0103fd1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0103fd5:	75 36                	jne    c010400d <timer_init+0x75>
    serial_printf("Frequency of %dHz too slow, max freq is 1193180 Hz\n");
c0103fd7:	83 ec 0c             	sub    $0xc,%esp
c0103fda:	68 3c 6b 10 c0       	push   $0xc0106b3c
c0103fdf:	e8 71 fe ff ff       	call   c0103e55 <serial_printf>
c0103fe4:	83 c4 10             	add    $0x10,%esp
    div=1;
c0103fe7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    freq=1193180;
c0103fee:	c7 45 08 dc 34 12 00 	movl   $0x1234dc,0x8(%ebp)
c0103ff5:	eb 16                	jmp    c010400d <timer_init+0x75>
  }
  } else {
    serial_printf("Setting PIT to %dHz using divisor of %d\n",freq,div);
c0103ff7:	83 ec 04             	sub    $0x4,%esp
c0103ffa:	ff 75 f4             	pushl  -0xc(%ebp)
c0103ffd:	ff 75 08             	pushl  0x8(%ebp)
c0104000:	68 70 6b 10 c0       	push   $0xc0106b70
c0104005:	e8 4b fe ff ff       	call   c0103e55 <serial_printf>
c010400a:	83 c4 10             	add    $0x10,%esp
  }
  isr_register_handler(0,0,timer_handler);
c010400d:	83 ec 04             	sub    $0x4,%esp
c0104010:	68 32 1f 10 c0       	push   $0xc0101f32
c0104015:	6a 00                	push   $0x0
c0104017:	6a 00                	push   $0x0
c0104019:	e8 5d ee ff ff       	call   c0102e7b <isr_register_handler>
c010401e:	83 c4 10             	add    $0x10,%esp
  port_byte_out(0x43,0b00110110); // Set timer 0 to lobyte/hibyte access, and mode 3 (square wave generator)
c0104021:	83 ec 08             	sub    $0x8,%esp
c0104024:	6a 36                	push   $0x36
c0104026:	6a 43                	push   $0x43
c0104028:	e8 8a 10 00 00       	call   c01050b7 <port_byte_out>
c010402d:	83 c4 10             	add    $0x10,%esp
  port_byte_out(0x40,div&0xFF); 
c0104030:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104033:	0f b6 c0             	movzbl %al,%eax
c0104036:	83 ec 08             	sub    $0x8,%esp
c0104039:	50                   	push   %eax
c010403a:	6a 40                	push   $0x40
c010403c:	e8 76 10 00 00       	call   c01050b7 <port_byte_out>
c0104041:	83 c4 10             	add    $0x10,%esp
  port_byte_out(0x40,(div>>8)&0xFF);
c0104044:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104047:	c1 f8 08             	sar    $0x8,%eax
c010404a:	0f b6 c0             	movzbl %al,%eax
c010404d:	83 ec 08             	sub    $0x8,%esp
c0104050:	50                   	push   %eax
c0104051:	6a 40                	push   $0x40
c0104053:	e8 5f 10 00 00       	call   c01050b7 <port_byte_out>
c0104058:	83 c4 10             	add    $0x10,%esp
}
c010405b:	90                   	nop
c010405c:	c9                   	leave  
c010405d:	c3                   	ret    
c010405e:	66 90                	xchg   %ax,%ax

c0104060 <halt>:
c0104060:	fa                   	cli    

c0104061 <halt_label>:
c0104061:	f4                   	hlt    
c0104062:	eb fd                	jmp    c0104061 <halt_label>
c0104064:	66 90                	xchg   %ax,%ax
c0104066:	66 90                	xchg   %ax,%ax
c0104068:	66 90                	xchg   %ax,%ax
c010406a:	66 90                	xchg   %ax,%ax
c010406c:	66 90                	xchg   %ax,%ax
c010406e:	66 90                	xchg   %ax,%ax

c0104070 <isr_common_stub>:
c0104070:	60                   	pusha  
c0104071:	66 8c d8             	mov    %ds,%ax
c0104074:	50                   	push   %eax
c0104075:	66 b8 10 00          	mov    $0x10,%ax
c0104079:	8e d8                	mov    %eax,%ds
c010407b:	8e c0                	mov    %eax,%es
c010407d:	8e e0                	mov    %eax,%fs
c010407f:	8e e8                	mov    %eax,%gs
c0104081:	54                   	push   %esp
c0104082:	e8 ae e6 ff ff       	call   c0102735 <isr_handler>
c0104087:	58                   	pop    %eax
c0104088:	58                   	pop    %eax
c0104089:	8e d8                	mov    %eax,%ds
c010408b:	8e c0                	mov    %eax,%es
c010408d:	8e e0                	mov    %eax,%fs
c010408f:	8e e8                	mov    %eax,%gs
c0104091:	61                   	popa   
c0104092:	83 c4 08             	add    $0x8,%esp
c0104095:	cf                   	iret   

c0104096 <irq_common_stub>:
c0104096:	60                   	pusha  
c0104097:	66 8c d8             	mov    %ds,%ax
c010409a:	50                   	push   %eax
c010409b:	66 b8 10 00          	mov    $0x10,%ax
c010409f:	8e d8                	mov    %eax,%ds
c01040a1:	8e c0                	mov    %eax,%es
c01040a3:	8e e0                	mov    %eax,%fs
c01040a5:	8e e8                	mov    %eax,%gs
c01040a7:	54                   	push   %esp
c01040a8:	e8 f6 ed ff ff       	call   c0102ea3 <irq_handler>
c01040ad:	5b                   	pop    %ebx
c01040ae:	5b                   	pop    %ebx
c01040af:	8e db                	mov    %ebx,%ds
c01040b1:	8e c3                	mov    %ebx,%es
c01040b3:	8e e3                	mov    %ebx,%fs
c01040b5:	8e eb                	mov    %ebx,%gs
c01040b7:	61                   	popa   
c01040b8:	83 c4 08             	add    $0x8,%esp
c01040bb:	fb                   	sti    
c01040bc:	cf                   	iret   

c01040bd <isr0>:
c01040bd:	fa                   	cli    
c01040be:	6a 00                	push   $0x0
c01040c0:	6a 00                	push   $0x0
c01040c2:	eb ac                	jmp    c0104070 <isr_common_stub>

c01040c4 <isr1>:
c01040c4:	fa                   	cli    
c01040c5:	6a 00                	push   $0x0
c01040c7:	6a 01                	push   $0x1
c01040c9:	eb a5                	jmp    c0104070 <isr_common_stub>

c01040cb <isr2>:
c01040cb:	fa                   	cli    
c01040cc:	6a 00                	push   $0x0
c01040ce:	6a 02                	push   $0x2
c01040d0:	eb 9e                	jmp    c0104070 <isr_common_stub>

c01040d2 <isr3>:
c01040d2:	fa                   	cli    
c01040d3:	6a 00                	push   $0x0
c01040d5:	6a 03                	push   $0x3
c01040d7:	eb 97                	jmp    c0104070 <isr_common_stub>

c01040d9 <isr4>:
c01040d9:	fa                   	cli    
c01040da:	6a 00                	push   $0x0
c01040dc:	6a 04                	push   $0x4
c01040de:	eb 90                	jmp    c0104070 <isr_common_stub>

c01040e0 <isr5>:
c01040e0:	fa                   	cli    
c01040e1:	6a 00                	push   $0x0
c01040e3:	6a 05                	push   $0x5
c01040e5:	eb 89                	jmp    c0104070 <isr_common_stub>

c01040e7 <isr6>:
c01040e7:	fa                   	cli    
c01040e8:	6a 00                	push   $0x0
c01040ea:	6a 06                	push   $0x6
c01040ec:	eb 82                	jmp    c0104070 <isr_common_stub>

c01040ee <isr7>:
c01040ee:	fa                   	cli    
c01040ef:	6a 00                	push   $0x0
c01040f1:	6a 07                	push   $0x7
c01040f3:	e9 78 ff ff ff       	jmp    c0104070 <isr_common_stub>

c01040f8 <isr8>:
c01040f8:	fa                   	cli    
c01040f9:	6a 08                	push   $0x8
c01040fb:	e9 70 ff ff ff       	jmp    c0104070 <isr_common_stub>

c0104100 <isr9>:
c0104100:	fa                   	cli    
c0104101:	6a 00                	push   $0x0
c0104103:	6a 09                	push   $0x9
c0104105:	e9 66 ff ff ff       	jmp    c0104070 <isr_common_stub>

c010410a <isr10>:
c010410a:	fa                   	cli    
c010410b:	6a 0a                	push   $0xa
c010410d:	e9 5e ff ff ff       	jmp    c0104070 <isr_common_stub>

c0104112 <isr11>:
c0104112:	fa                   	cli    
c0104113:	6a 0b                	push   $0xb
c0104115:	e9 56 ff ff ff       	jmp    c0104070 <isr_common_stub>

c010411a <isr12>:
c010411a:	fa                   	cli    
c010411b:	6a 0c                	push   $0xc
c010411d:	e9 4e ff ff ff       	jmp    c0104070 <isr_common_stub>

c0104122 <isr13>:
c0104122:	fa                   	cli    
c0104123:	6a 0d                	push   $0xd
c0104125:	e9 46 ff ff ff       	jmp    c0104070 <isr_common_stub>

c010412a <isr14>:
c010412a:	fa                   	cli    
c010412b:	6a 0e                	push   $0xe
c010412d:	e9 3e ff ff ff       	jmp    c0104070 <isr_common_stub>

c0104132 <isr15>:
c0104132:	fa                   	cli    
c0104133:	6a 00                	push   $0x0
c0104135:	6a 0f                	push   $0xf
c0104137:	e9 34 ff ff ff       	jmp    c0104070 <isr_common_stub>

c010413c <isr16>:
c010413c:	fa                   	cli    
c010413d:	6a 00                	push   $0x0
c010413f:	6a 10                	push   $0x10
c0104141:	e9 2a ff ff ff       	jmp    c0104070 <isr_common_stub>

c0104146 <isr17>:
c0104146:	fa                   	cli    
c0104147:	6a 00                	push   $0x0
c0104149:	6a 11                	push   $0x11
c010414b:	e9 20 ff ff ff       	jmp    c0104070 <isr_common_stub>

c0104150 <isr18>:
c0104150:	fa                   	cli    
c0104151:	6a 00                	push   $0x0
c0104153:	6a 12                	push   $0x12
c0104155:	e9 16 ff ff ff       	jmp    c0104070 <isr_common_stub>

c010415a <isr19>:
c010415a:	fa                   	cli    
c010415b:	6a 00                	push   $0x0
c010415d:	6a 13                	push   $0x13
c010415f:	e9 0c ff ff ff       	jmp    c0104070 <isr_common_stub>

c0104164 <isr20>:
c0104164:	fa                   	cli    
c0104165:	6a 00                	push   $0x0
c0104167:	6a 14                	push   $0x14
c0104169:	e9 02 ff ff ff       	jmp    c0104070 <isr_common_stub>

c010416e <isr21>:
c010416e:	fa                   	cli    
c010416f:	6a 00                	push   $0x0
c0104171:	6a 15                	push   $0x15
c0104173:	e9 f8 fe ff ff       	jmp    c0104070 <isr_common_stub>

c0104178 <isr22>:
c0104178:	fa                   	cli    
c0104179:	6a 00                	push   $0x0
c010417b:	6a 16                	push   $0x16
c010417d:	e9 ee fe ff ff       	jmp    c0104070 <isr_common_stub>

c0104182 <isr23>:
c0104182:	fa                   	cli    
c0104183:	6a 00                	push   $0x0
c0104185:	6a 17                	push   $0x17
c0104187:	e9 e4 fe ff ff       	jmp    c0104070 <isr_common_stub>

c010418c <isr24>:
c010418c:	fa                   	cli    
c010418d:	6a 00                	push   $0x0
c010418f:	6a 18                	push   $0x18
c0104191:	e9 da fe ff ff       	jmp    c0104070 <isr_common_stub>

c0104196 <isr25>:
c0104196:	fa                   	cli    
c0104197:	6a 00                	push   $0x0
c0104199:	6a 19                	push   $0x19
c010419b:	e9 d0 fe ff ff       	jmp    c0104070 <isr_common_stub>

c01041a0 <isr26>:
c01041a0:	fa                   	cli    
c01041a1:	6a 00                	push   $0x0
c01041a3:	6a 1a                	push   $0x1a
c01041a5:	e9 c6 fe ff ff       	jmp    c0104070 <isr_common_stub>

c01041aa <isr27>:
c01041aa:	fa                   	cli    
c01041ab:	6a 00                	push   $0x0
c01041ad:	6a 1b                	push   $0x1b
c01041af:	e9 bc fe ff ff       	jmp    c0104070 <isr_common_stub>

c01041b4 <isr28>:
c01041b4:	fa                   	cli    
c01041b5:	6a 00                	push   $0x0
c01041b7:	6a 1c                	push   $0x1c
c01041b9:	e9 b2 fe ff ff       	jmp    c0104070 <isr_common_stub>

c01041be <isr29>:
c01041be:	fa                   	cli    
c01041bf:	6a 00                	push   $0x0
c01041c1:	6a 1d                	push   $0x1d
c01041c3:	e9 a8 fe ff ff       	jmp    c0104070 <isr_common_stub>

c01041c8 <isr30>:
c01041c8:	fa                   	cli    
c01041c9:	6a 00                	push   $0x0
c01041cb:	6a 1e                	push   $0x1e
c01041cd:	e9 9e fe ff ff       	jmp    c0104070 <isr_common_stub>

c01041d2 <isr31>:
c01041d2:	fa                   	cli    
c01041d3:	6a 00                	push   $0x0
c01041d5:	6a 1f                	push   $0x1f
c01041d7:	e9 94 fe ff ff       	jmp    c0104070 <isr_common_stub>

c01041dc <isr80>:
c01041dc:	fa                   	cli    
c01041dd:	6a 00                	push   $0x0
c01041df:	6a 50                	push   $0x50
c01041e1:	e9 8a fe ff ff       	jmp    c0104070 <isr_common_stub>

c01041e6 <irq0>:
c01041e6:	fa                   	cli    
c01041e7:	6a 00                	push   $0x0
c01041e9:	6a 20                	push   $0x20
c01041eb:	e9 a6 fe ff ff       	jmp    c0104096 <irq_common_stub>

c01041f0 <irq1>:
c01041f0:	fa                   	cli    
c01041f1:	6a 01                	push   $0x1
c01041f3:	6a 21                	push   $0x21
c01041f5:	e9 9c fe ff ff       	jmp    c0104096 <irq_common_stub>

c01041fa <irq2>:
c01041fa:	fa                   	cli    
c01041fb:	6a 02                	push   $0x2
c01041fd:	6a 22                	push   $0x22
c01041ff:	e9 92 fe ff ff       	jmp    c0104096 <irq_common_stub>

c0104204 <irq3>:
c0104204:	fa                   	cli    
c0104205:	6a 03                	push   $0x3
c0104207:	6a 23                	push   $0x23
c0104209:	e9 88 fe ff ff       	jmp    c0104096 <irq_common_stub>

c010420e <irq4>:
c010420e:	fa                   	cli    
c010420f:	6a 04                	push   $0x4
c0104211:	6a 24                	push   $0x24
c0104213:	e9 7e fe ff ff       	jmp    c0104096 <irq_common_stub>

c0104218 <irq5>:
c0104218:	fa                   	cli    
c0104219:	6a 05                	push   $0x5
c010421b:	6a 25                	push   $0x25
c010421d:	e9 74 fe ff ff       	jmp    c0104096 <irq_common_stub>

c0104222 <irq6>:
c0104222:	fa                   	cli    
c0104223:	6a 06                	push   $0x6
c0104225:	6a 26                	push   $0x26
c0104227:	e9 6a fe ff ff       	jmp    c0104096 <irq_common_stub>

c010422c <irq7>:
c010422c:	fa                   	cli    
c010422d:	6a 07                	push   $0x7
c010422f:	6a 27                	push   $0x27
c0104231:	e9 60 fe ff ff       	jmp    c0104096 <irq_common_stub>

c0104236 <irq8>:
c0104236:	fa                   	cli    
c0104237:	6a 08                	push   $0x8
c0104239:	6a 28                	push   $0x28
c010423b:	e9 56 fe ff ff       	jmp    c0104096 <irq_common_stub>

c0104240 <irq9>:
c0104240:	fa                   	cli    
c0104241:	6a 09                	push   $0x9
c0104243:	6a 29                	push   $0x29
c0104245:	e9 4c fe ff ff       	jmp    c0104096 <irq_common_stub>

c010424a <irq10>:
c010424a:	fa                   	cli    
c010424b:	6a 0a                	push   $0xa
c010424d:	6a 2a                	push   $0x2a
c010424f:	e9 42 fe ff ff       	jmp    c0104096 <irq_common_stub>

c0104254 <irq11>:
c0104254:	fa                   	cli    
c0104255:	6a 0b                	push   $0xb
c0104257:	6a 2b                	push   $0x2b
c0104259:	e9 38 fe ff ff       	jmp    c0104096 <irq_common_stub>

c010425e <irq12>:
c010425e:	fa                   	cli    
c010425f:	6a 0c                	push   $0xc
c0104261:	6a 2c                	push   $0x2c
c0104263:	e9 2e fe ff ff       	jmp    c0104096 <irq_common_stub>

c0104268 <irq13>:
c0104268:	fa                   	cli    
c0104269:	6a 0d                	push   $0xd
c010426b:	6a 2d                	push   $0x2d
c010426d:	e9 24 fe ff ff       	jmp    c0104096 <irq_common_stub>

c0104272 <irq14>:
c0104272:	fa                   	cli    
c0104273:	6a 0e                	push   $0xe
c0104275:	6a 2e                	push   $0x2e
c0104277:	e9 1a fe ff ff       	jmp    c0104096 <irq_common_stub>

c010427c <irq15>:
c010427c:	fa                   	cli    
c010427d:	6a 0f                	push   $0xf
c010427f:	6a 2f                	push   $0x2f
c0104281:	e9 10 fe ff ff       	jmp    c0104096 <irq_common_stub>
c0104286:	66 90                	xchg   %ax,%ax
c0104288:	66 90                	xchg   %ax,%ax
c010428a:	66 90                	xchg   %ax,%ax
c010428c:	66 90                	xchg   %ax,%ax
c010428e:	66 90                	xchg   %ax,%ax

c0104290 <switch_to_thread_asm>:
c0104290:	53                   	push   %ebx
c0104291:	56                   	push   %esi
c0104292:	57                   	push   %edi
c0104293:	55                   	push   %ebp
c0104294:	8b 3d 20 90 1c c0    	mov    0xc01c9020,%edi
c010429a:	89 27                	mov    %esp,(%edi)
c010429c:	8b 74 24 14          	mov    0x14(%esp),%esi
c01042a0:	89 35 20 90 1c c0    	mov    %esi,0xc01c9020
c01042a6:	8b 26                	mov    (%esi),%esp
c01042a8:	8b 46 08             	mov    0x8(%esi),%eax
c01042ab:	8b 5e 04             	mov    0x4(%esi),%ebx
c01042ae:	89 1d 44 a0 1c c0    	mov    %ebx,0xc01ca044
c01042b4:	0f 20 d9             	mov    %cr3,%ecx
c01042b7:	39 c8                	cmp    %ecx,%eax
c01042b9:	74 03                	je     c01042be <switch_to_thread_asm.doneVAS>
c01042bb:	0f 22 d8             	mov    %eax,%cr3

c01042be <switch_to_thread_asm.doneVAS>:
c01042be:	5d                   	pop    %ebp
c01042bf:	5f                   	pop    %edi
c01042c0:	5e                   	pop    %esi
c01042c1:	5b                   	pop    %ebx
c01042c2:	c3                   	ret    

c01042c3 <task_init>:
c01042c3:	59                   	pop    %ecx
c01042c4:	5b                   	pop    %ebx
c01042c5:	66 b8 23 00          	mov    $0x23,%ax
c01042c9:	8e d8                	mov    %eax,%ds
c01042cb:	8e c0                	mov    %eax,%es
c01042cd:	8e e0                	mov    %eax,%fs
c01042cf:	8e e8                	mov    %eax,%gs
c01042d1:	6a 23                	push   $0x23
c01042d3:	51                   	push   %ecx
c01042d4:	9c                   	pushf  
c01042d5:	58                   	pop    %eax
c01042d6:	0d 00 02 00 00       	or     $0x200,%eax
c01042db:	50                   	push   %eax
c01042dc:	6a 1b                	push   $0x1b
c01042de:	53                   	push   %ebx
c01042df:	cf                   	iret   

c01042e0 <task_init_no_int>:
c01042e0:	59                   	pop    %ecx
c01042e1:	5b                   	pop    %ebx
c01042e2:	66 b8 23 00          	mov    $0x23,%ax
c01042e6:	8e d8                	mov    %eax,%ds
c01042e8:	8e c0                	mov    %eax,%es
c01042ea:	8e e0                	mov    %eax,%fs
c01042ec:	8e e8                	mov    %eax,%gs
c01042ee:	6a 23                	push   $0x23
c01042f0:	51                   	push   %ecx
c01042f1:	9c                   	pushf  
c01042f2:	6a 1b                	push   $0x1b
c01042f4:	53                   	push   %ebx
c01042f5:	cf                   	iret   

c01042f6 <wait_for_unblocked_thread_asm>:
c01042f6:	fb                   	sti    
c01042f7:	f4                   	hlt    
c01042f8:	fa                   	cli    

c01042f9 <liballoc_memset>:


// ***********   HELPER FUNCTIONS  *******************************

static void *liballoc_memset(void* s, int c, size_t n)
{
c01042f9:	55                   	push   %ebp
c01042fa:	89 e5                	mov    %esp,%ebp
c01042fc:	83 ec 10             	sub    $0x10,%esp
	unsigned int i;
	for ( i = 0; i < n ; i++)
c01042ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0104306:	eb 10                	jmp    c0104318 <liballoc_memset+0x1f>
		((char*)s)[i] = c;
c0104308:	8b 55 08             	mov    0x8(%ebp),%edx
c010430b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010430e:	01 d0                	add    %edx,%eax
c0104310:	8b 55 0c             	mov    0xc(%ebp),%edx
c0104313:	88 10                	mov    %dl,(%eax)
	for ( i = 0; i < n ; i++)
c0104315:	ff 45 fc             	incl   -0x4(%ebp)
c0104318:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010431b:	3b 45 10             	cmp    0x10(%ebp),%eax
c010431e:	72 e8                	jb     c0104308 <liballoc_memset+0xf>
	
	return s;
c0104320:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0104323:	c9                   	leave  
c0104324:	c3                   	ret    

c0104325 <liballoc_memcpy>:
static void* liballoc_memcpy(void* s1, const void* s2, size_t n)
{
c0104325:	55                   	push   %ebp
c0104326:	89 e5                	mov    %esp,%ebp
c0104328:	83 ec 10             	sub    $0x10,%esp
  char *cdest;
  char *csrc;
  unsigned int *ldest = (unsigned int*)s1;
c010432b:	8b 45 08             	mov    0x8(%ebp),%eax
c010432e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int *lsrc  = (unsigned int*)s2;
c0104331:	8b 45 0c             	mov    0xc(%ebp),%eax
c0104334:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while ( n >= sizeof(unsigned int) )
c0104337:	eb 1a                	jmp    c0104353 <liballoc_memcpy+0x2e>
  {
      *ldest++ = *lsrc++;
c0104339:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010433c:	8d 42 04             	lea    0x4(%edx),%eax
c010433f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0104342:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104345:	8d 48 04             	lea    0x4(%eax),%ecx
c0104348:	89 4d f4             	mov    %ecx,-0xc(%ebp)
c010434b:	8b 12                	mov    (%edx),%edx
c010434d:	89 10                	mov    %edx,(%eax)
	  n -= sizeof(unsigned int);
c010434f:	83 6d 10 04          	subl   $0x4,0x10(%ebp)
  while ( n >= sizeof(unsigned int) )
c0104353:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
c0104357:	77 e0                	ja     c0104339 <liballoc_memcpy+0x14>
  }

  cdest = (char*)ldest;
c0104359:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010435c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  csrc  = (char*)lsrc;
c010435f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104362:	89 45 f8             	mov    %eax,-0x8(%ebp)
  
  while ( n > 0 )
c0104365:	eb 19                	jmp    c0104380 <liballoc_memcpy+0x5b>
  {
      *cdest++ = *csrc++;
c0104367:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010436a:	8d 42 01             	lea    0x1(%edx),%eax
c010436d:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0104370:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0104373:	8d 48 01             	lea    0x1(%eax),%ecx
c0104376:	89 4d fc             	mov    %ecx,-0x4(%ebp)
c0104379:	8a 12                	mov    (%edx),%dl
c010437b:	88 10                	mov    %dl,(%eax)
	  n -= 1;
c010437d:	ff 4d 10             	decl   0x10(%ebp)
  while ( n > 0 )
c0104380:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0104384:	75 e1                	jne    c0104367 <liballoc_memcpy+0x42>
  }
  
  return s1;
c0104386:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0104389:	c9                   	leave  
c010438a:	c3                   	ret    

c010438b <allocate_new_page>:


// ***************************************************************

static struct liballoc_major *allocate_new_page( unsigned int size )
{
c010438b:	55                   	push   %ebp
c010438c:	89 e5                	mov    %esp,%ebp
c010438e:	53                   	push   %ebx
c010438f:	83 ec 14             	sub    $0x14,%esp
	unsigned int st;
	struct liballoc_major *maj;

		// This is how much space is required.
		st  = size + sizeof(struct liballoc_major);
c0104392:	8b 45 08             	mov    0x8(%ebp),%eax
c0104395:	83 c0 18             	add    $0x18,%eax
c0104398:	89 45 f4             	mov    %eax,-0xc(%ebp)
		st += sizeof(struct liballoc_minor);
c010439b:	83 45 f4 18          	addl   $0x18,-0xc(%ebp)

				// Perfect amount of space?
		if ( (st % l_pageSize) == 0 )
c010439f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01043a2:	25 ff 0f 00 00       	and    $0xfff,%eax
c01043a7:	85 c0                	test   %eax,%eax
c01043a9:	75 0b                	jne    c01043b6 <allocate_new_page+0x2b>
			st  = st / (l_pageSize);
c01043ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01043ae:	c1 e8 0c             	shr    $0xc,%eax
c01043b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
c01043b4:	eb 0a                	jmp    c01043c0 <allocate_new_page+0x35>
		else
			st  = st / (l_pageSize) + 1;
c01043b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01043b9:	c1 e8 0c             	shr    $0xc,%eax
c01043bc:	40                   	inc    %eax
c01043bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
							// No, add the buffer. 

		
		// Make sure it's >= the minimum size.
		if ( st < l_pageCount ) st = l_pageCount;
c01043c0:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
c01043c4:	77 07                	ja     c01043cd <allocate_new_page+0x42>
c01043c6:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
		
		maj = (struct liballoc_major*)liballoc_alloc( st );
c01043cd:	83 ec 0c             	sub    $0xc,%esp
c01043d0:	ff 75 f4             	pushl  -0xc(%ebp)
c01043d3:	e8 41 0b 00 00       	call   c0104f19 <liballoc_alloc>
c01043d8:	83 c4 10             	add    $0x10,%esp
c01043db:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if ( maj == NULL ) 
c01043de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01043e2:	75 23                	jne    c0104407 <allocate_new_page+0x7c>
		{
			l_warningCount += 1;
c01043e4:	a1 38 4d 3e c0       	mov    0xc03e4d38,%eax
c01043e9:	8b 15 3c 4d 3e c0    	mov    0xc03e4d3c,%edx
c01043ef:	83 c0 01             	add    $0x1,%eax
c01043f2:	83 d2 00             	adc    $0x0,%edx
c01043f5:	a3 38 4d 3e c0       	mov    %eax,0xc03e4d38
c01043fa:	89 15 3c 4d 3e c0    	mov    %edx,0xc03e4d3c
			#if defined DEBUG || defined INFO
			serial_printf( "liballoc: WARNING: liballoc_alloc( %d ) return NULL\n", st );
			FLUSH();
			#endif
			return NULL;	// uh oh, we ran out of memory.
c0104400:	b8 00 00 00 00       	mov    $0x0,%eax
c0104405:	eb 68                	jmp    c010446f <allocate_new_page+0xe4>
		}
		
		maj->prev 	= NULL;
c0104407:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010440a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		maj->next 	= NULL;
c0104410:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104413:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		maj->pages 	= st;
c010441a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010441d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0104420:	89 50 08             	mov    %edx,0x8(%eax)
		maj->size 	= st * l_pageSize;
c0104423:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104426:	c1 e0 0c             	shl    $0xc,%eax
c0104429:	89 c2                	mov    %eax,%edx
c010442b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010442e:	89 50 0c             	mov    %edx,0xc(%eax)
		maj->usage 	= sizeof(struct liballoc_major);
c0104431:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104434:	c7 40 10 18 00 00 00 	movl   $0x18,0x10(%eax)
		maj->first 	= NULL;
c010443b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010443e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

		l_allocated += maj->size;
c0104445:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104448:	8b 40 0c             	mov    0xc(%eax),%eax
c010444b:	89 c1                	mov    %eax,%ecx
c010444d:	bb 00 00 00 00       	mov    $0x0,%ebx
c0104452:	a1 28 4d 3e c0       	mov    0xc03e4d28,%eax
c0104457:	8b 15 2c 4d 3e c0    	mov    0xc03e4d2c,%edx
c010445d:	01 c8                	add    %ecx,%eax
c010445f:	11 da                	adc    %ebx,%edx
c0104461:	a3 28 4d 3e c0       	mov    %eax,0xc03e4d28
c0104466:	89 15 2c 4d 3e c0    	mov    %edx,0xc03e4d2c
		serial_printf( "liballoc: Total memory usage = %d KB\n",  (int)((l_allocated / (1024))) );
		FLUSH();
		#endif
	
		
      return maj;
c010446c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c010446f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0104472:	c9                   	leave  
c0104473:	c3                   	ret    

c0104474 <malloc>:

	


void *PREFIX(malloc)(size_t req_size)
{
c0104474:	55                   	push   %ebp
c0104475:	89 e5                	mov    %esp,%ebp
c0104477:	53                   	push   %ebx
c0104478:	83 ec 44             	sub    $0x44,%esp
	int startedBet = 0;
c010447b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	unsigned long long bestSize = 0;
c0104482:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0104489:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	void *p = NULL;
c0104490:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uintptr_t diff;
	struct liballoc_major *maj;
	struct liballoc_minor *min;
	struct liballoc_minor *new_min;
	unsigned long size = req_size;
c0104497:	8b 45 08             	mov    0x8(%ebp),%eax
c010449a:	89 45 c8             	mov    %eax,-0x38(%ebp)

	// For alignment, we adjust size so there's enough space to align.
	if ( ALIGNMENT > 1 )
	{
		size += ALIGNMENT + ALIGN_INFO;
c010449d:	83 45 c8 20          	addl   $0x20,-0x38(%ebp)
	}
				// So, ideally, we really want an alignment of 0 or 1 in order
				// to save space.
	
	liballoc_lock();
c01044a1:	e8 43 0a 00 00       	call   c0104ee9 <liballoc_lock>

	if ( size == 0 )
c01044a6:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
c01044aa:	75 33                	jne    c01044df <malloc+0x6b>
	{
		l_warningCount += 1;
c01044ac:	a1 38 4d 3e c0       	mov    0xc03e4d38,%eax
c01044b1:	8b 15 3c 4d 3e c0    	mov    0xc03e4d3c,%edx
c01044b7:	83 c0 01             	add    $0x1,%eax
c01044ba:	83 d2 00             	adc    $0x0,%edx
c01044bd:	a3 38 4d 3e c0       	mov    %eax,0xc03e4d38
c01044c2:	89 15 3c 4d 3e c0    	mov    %edx,0xc03e4d3c
		#if defined DEBUG || defined INFO
		serial_printf( "liballoc: WARNING: alloc( 0 ) called from %x\n",
							__builtin_return_address(0) );
		FLUSH();
		#endif
		liballoc_unlock();
c01044c8:	e8 34 0a 00 00       	call   c0104f01 <liballoc_unlock>
		return PREFIX(malloc)(1);
c01044cd:	83 ec 0c             	sub    $0xc,%esp
c01044d0:	6a 01                	push   $0x1
c01044d2:	e8 9d ff ff ff       	call   c0104474 <malloc>
c01044d7:	83 c4 10             	add    $0x10,%esp
c01044da:	e9 1c 06 00 00       	jmp    c0104afb <malloc+0x687>
	}
	

	if ( l_memRoot == NULL )
c01044df:	a1 20 4d 3e c0       	mov    0xc03e4d20,%eax
c01044e4:	85 c0                	test   %eax,%eax
c01044e6:	75 2b                	jne    c0104513 <malloc+0x9f>
		//atexit( liballoc_dump );
		FLUSH();
		#endif
			
		// This is the first time we are being used.
		l_memRoot = allocate_new_page( size );
c01044e8:	83 ec 0c             	sub    $0xc,%esp
c01044eb:	ff 75 c8             	pushl  -0x38(%ebp)
c01044ee:	e8 98 fe ff ff       	call   c010438b <allocate_new_page>
c01044f3:	83 c4 10             	add    $0x10,%esp
c01044f6:	a3 20 4d 3e c0       	mov    %eax,0xc03e4d20
		if ( l_memRoot == NULL )
c01044fb:	a1 20 4d 3e c0       	mov    0xc03e4d20,%eax
c0104500:	85 c0                	test   %eax,%eax
c0104502:	75 0f                	jne    c0104513 <malloc+0x9f>
		{
		  liballoc_unlock();
c0104504:	e8 f8 09 00 00       	call   c0104f01 <liballoc_unlock>
		  #ifdef DEBUG
		  serial_printf( "liballoc: initial l_memRoot initialization failed\n", p); 
		  FLUSH();
		  #endif
		  return NULL;
c0104509:	b8 00 00 00 00       	mov    $0x0,%eax
c010450e:	e9 e8 05 00 00       	jmp    c0104afb <malloc+0x687>
	FLUSH();
	#endif

	// Now we need to bounce through every major and find enough space....

	maj = l_memRoot;
c0104513:	a1 20 4d 3e c0       	mov    0xc03e4d20,%eax
c0104518:	89 45 e0             	mov    %eax,-0x20(%ebp)
	startedBet = 0;
c010451b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	
	// Start at the best bet....
	if ( l_bestBet != NULL )
c0104522:	a1 24 4d 3e c0       	mov    0xc03e4d24,%eax
c0104527:	85 c0                	test   %eax,%eax
c0104529:	0f 84 b2 05 00 00    	je     c0104ae1 <malloc+0x66d>
	{
		bestSize = l_bestBet->size - l_bestBet->usage;
c010452f:	a1 24 4d 3e c0       	mov    0xc03e4d24,%eax
c0104534:	8b 50 0c             	mov    0xc(%eax),%edx
c0104537:	a1 24 4d 3e c0       	mov    0xc03e4d24,%eax
c010453c:	8b 40 10             	mov    0x10(%eax),%eax
c010453f:	29 c2                	sub    %eax,%edx
c0104541:	89 d0                	mov    %edx,%eax
c0104543:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0104546:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		if ( bestSize > (size + sizeof(struct liballoc_minor)))
c010454d:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0104550:	83 c0 18             	add    $0x18,%eax
c0104553:	ba 00 00 00 00       	mov    $0x0,%edx
c0104558:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c010455b:	89 d0                	mov    %edx,%eax
c010455d:	1b 45 ec             	sbb    -0x14(%ebp),%eax
c0104560:	0f 83 7b 05 00 00    	jae    c0104ae1 <malloc+0x66d>
		{
			maj = l_bestBet;
c0104566:	a1 24 4d 3e c0       	mov    0xc03e4d24,%eax
c010456b:	89 45 e0             	mov    %eax,-0x20(%ebp)
			startedBet = 1;
c010456e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
	}
	
	while ( maj != NULL )
c0104575:	e9 67 05 00 00       	jmp    c0104ae1 <malloc+0x66d>
	{
		diff  = maj->size - maj->usage;	
c010457a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010457d:	8b 50 0c             	mov    0xc(%eax),%edx
c0104580:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104583:	8b 40 10             	mov    0x10(%eax),%eax
c0104586:	29 c2                	sub    %eax,%edx
c0104588:	89 d0                	mov    %edx,%eax
c010458a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
										// free memory in the block

		if ( bestSize < diff )
c010458d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0104590:	ba 00 00 00 00       	mov    $0x0,%edx
c0104595:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0104598:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c010459b:	19 d1                	sbb    %edx,%ecx
c010459d:	73 15                	jae    c01045b4 <malloc+0x140>
		{
			// Hmm.. this one has more memory then our bestBet. Remember!
			l_bestBet = maj;
c010459f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01045a2:	a3 24 4d 3e c0       	mov    %eax,0xc03e4d24
			bestSize = diff;
c01045a7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c01045aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
c01045ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		
		
#ifdef USE_CASE1
			
		// CASE 1:  There is not enough space in this major block.
		if ( diff < (size + sizeof( struct liballoc_minor )) )
c01045b4:	8b 45 c8             	mov    -0x38(%ebp),%eax
c01045b7:	83 c0 18             	add    $0x18,%eax
c01045ba:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
c01045bd:	73 68                	jae    c0104627 <malloc+0x1b3>
			serial_printf( "CASE 1: Insufficient space in block %x\n", maj);
			FLUSH();
			#endif
				
				// Another major block next to this one?
			if ( maj->next != NULL ) 
c01045bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01045c2:	8b 40 04             	mov    0x4(%eax),%eax
c01045c5:	85 c0                	test   %eax,%eax
c01045c7:	74 0e                	je     c01045d7 <malloc+0x163>
			{
				maj = maj->next;		// Hop to that one.
c01045c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01045cc:	8b 40 04             	mov    0x4(%eax),%eax
c01045cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
				continue;
c01045d2:	e9 0a 05 00 00       	jmp    c0104ae1 <malloc+0x66d>
			}

			if ( startedBet == 1 )		// If we started at the best bet,
c01045d7:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c01045db:	75 14                	jne    c01045f1 <malloc+0x17d>
			{							// let's start all over again.
				maj = l_memRoot;
c01045dd:	a1 20 4d 3e c0       	mov    0xc03e4d20,%eax
c01045e2:	89 45 e0             	mov    %eax,-0x20(%ebp)
				startedBet = 0;
c01045e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				continue;
c01045ec:	e9 f0 04 00 00       	jmp    c0104ae1 <malloc+0x66d>
			}

			// Create a new major block next to this one and...
			maj->next = allocate_new_page( size );	// next one will be okay.
c01045f1:	83 ec 0c             	sub    $0xc,%esp
c01045f4:	ff 75 c8             	pushl  -0x38(%ebp)
c01045f7:	e8 8f fd ff ff       	call   c010438b <allocate_new_page>
c01045fc:	83 c4 10             	add    $0x10,%esp
c01045ff:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0104602:	89 42 04             	mov    %eax,0x4(%edx)
			if ( maj->next == NULL ) break;			// no more memory.
c0104605:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104608:	8b 40 04             	mov    0x4(%eax),%eax
c010460b:	85 c0                	test   %eax,%eax
c010460d:	0f 84 da 04 00 00    	je     c0104aed <malloc+0x679>
			maj->next->prev = maj;
c0104613:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104616:	8b 40 04             	mov    0x4(%eax),%eax
c0104619:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010461c:	89 10                	mov    %edx,(%eax)
			maj = maj->next;
c010461e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104621:	8b 40 04             	mov    0x4(%eax),%eax
c0104624:	89 45 e0             	mov    %eax,-0x20(%ebp)
#endif

#ifdef USE_CASE2
		
		// CASE 2: It's a brand new block.
		if ( maj->first == NULL )
c0104627:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010462a:	8b 40 14             	mov    0x14(%eax),%eax
c010462d:	85 c0                	test   %eax,%eax
c010462f:	0f 85 e3 00 00 00    	jne    c0104718 <malloc+0x2a4>
		{
			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
c0104635:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104638:	83 c0 18             	add    $0x18,%eax
c010463b:	89 c2                	mov    %eax,%edx
c010463d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104640:	89 50 14             	mov    %edx,0x14(%eax)

			
			maj->first->magic 		= LIBALLOC_MAGIC;
c0104643:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104646:	8b 40 14             	mov    0x14(%eax),%eax
c0104649:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
			maj->first->prev 		= NULL;
c0104650:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104653:	8b 40 14             	mov    0x14(%eax),%eax
c0104656:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			maj->first->next 		= NULL;
c010465c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010465f:	8b 40 14             	mov    0x14(%eax),%eax
c0104662:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			maj->first->block 		= maj;
c0104669:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010466c:	8b 40 14             	mov    0x14(%eax),%eax
c010466f:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0104672:	89 50 08             	mov    %edx,0x8(%eax)
			maj->first->size 		= size;
c0104675:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104678:	8b 40 14             	mov    0x14(%eax),%eax
c010467b:	8b 55 c8             	mov    -0x38(%ebp),%edx
c010467e:	89 50 10             	mov    %edx,0x10(%eax)
			maj->first->req_size 	= req_size;
c0104681:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104684:	8b 40 14             	mov    0x14(%eax),%eax
c0104687:	8b 55 08             	mov    0x8(%ebp),%edx
c010468a:	89 50 14             	mov    %edx,0x14(%eax)
			maj->usage 	+= size + sizeof( struct liballoc_minor );
c010468d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104690:	8b 50 10             	mov    0x10(%eax),%edx
c0104693:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0104696:	01 d0                	add    %edx,%eax
c0104698:	8d 50 18             	lea    0x18(%eax),%edx
c010469b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010469e:	89 50 10             	mov    %edx,0x10(%eax)


			l_inuse += size;
c01046a1:	8b 4d c8             	mov    -0x38(%ebp),%ecx
c01046a4:	bb 00 00 00 00       	mov    $0x0,%ebx
c01046a9:	a1 30 4d 3e c0       	mov    0xc03e4d30,%eax
c01046ae:	8b 15 34 4d 3e c0    	mov    0xc03e4d34,%edx
c01046b4:	01 c8                	add    %ecx,%eax
c01046b6:	11 da                	adc    %ebx,%edx
c01046b8:	a3 30 4d 3e c0       	mov    %eax,0xc03e4d30
c01046bd:	89 15 34 4d 3e c0    	mov    %edx,0xc03e4d34
			
			
			p = (void*)((uintptr_t)(maj->first) + sizeof( struct liballoc_minor ));
c01046c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01046c6:	8b 40 14             	mov    0x14(%eax),%eax
c01046c9:	83 c0 18             	add    $0x18,%eax
c01046cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			ALIGN( p );
c01046cf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01046d2:	83 c0 10             	add    $0x10,%eax
c01046d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c01046d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01046db:	83 e0 0f             	and    $0xf,%eax
c01046de:	89 45 d8             	mov    %eax,-0x28(%ebp)
c01046e1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c01046e5:	74 16                	je     c01046fd <malloc+0x289>
c01046e7:	b8 10 00 00 00       	mov    $0x10,%eax
c01046ec:	2b 45 d8             	sub    -0x28(%ebp),%eax
c01046ef:	89 45 d8             	mov    %eax,-0x28(%ebp)
c01046f2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01046f5:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01046f8:	01 d0                	add    %edx,%eax
c01046fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c01046fd:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0104700:	8d 50 10             	lea    0x10(%eax),%edx
c0104703:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104706:	83 e8 10             	sub    $0x10,%eax
c0104709:	88 10                	mov    %dl,(%eax)
			
			#ifdef DEBUG
			serial_printf( "CASE 2: returning %x\n", p); 
			FLUSH();
			#endif
			liballoc_unlock();		// release the lock
c010470b:	e8 f1 07 00 00       	call   c0104f01 <liballoc_unlock>
			return p;
c0104710:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104713:	e9 e3 03 00 00       	jmp    c0104afb <malloc+0x687>
#endif
				
#ifdef USE_CASE3

		// CASE 3: Block in use and enough space at the start of the block.
		diff =  (uintptr_t)(maj->first);
c0104718:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010471b:	8b 40 14             	mov    0x14(%eax),%eax
c010471e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		diff -= (uintptr_t)maj;
c0104721:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104724:	29 45 c4             	sub    %eax,-0x3c(%ebp)
		diff -= sizeof(struct liballoc_major);
c0104727:	83 6d c4 18          	subl   $0x18,-0x3c(%ebp)

		if ( diff >= (size + sizeof(struct liballoc_minor)) )
c010472b:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010472e:	83 c0 18             	add    $0x18,%eax
c0104731:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
c0104734:	0f 82 f5 00 00 00    	jb     c010482f <malloc+0x3bb>
		{
			// Yes, space in front. Squeeze in.
			maj->first->prev = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
c010473a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010473d:	8d 50 18             	lea    0x18(%eax),%edx
c0104740:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104743:	8b 40 14             	mov    0x14(%eax),%eax
c0104746:	89 10                	mov    %edx,(%eax)
			maj->first->prev->next = maj->first;
c0104748:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010474b:	8b 40 14             	mov    0x14(%eax),%eax
c010474e:	8b 00                	mov    (%eax),%eax
c0104750:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0104753:	8b 52 14             	mov    0x14(%edx),%edx
c0104756:	89 50 04             	mov    %edx,0x4(%eax)
			maj->first = maj->first->prev;
c0104759:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010475c:	8b 40 14             	mov    0x14(%eax),%eax
c010475f:	8b 10                	mov    (%eax),%edx
c0104761:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104764:	89 50 14             	mov    %edx,0x14(%eax)
				
			maj->first->magic 	= LIBALLOC_MAGIC;
c0104767:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010476a:	8b 40 14             	mov    0x14(%eax),%eax
c010476d:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
			maj->first->prev 	= NULL;
c0104774:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104777:	8b 40 14             	mov    0x14(%eax),%eax
c010477a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			maj->first->block 	= maj;
c0104780:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104783:	8b 40 14             	mov    0x14(%eax),%eax
c0104786:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0104789:	89 50 08             	mov    %edx,0x8(%eax)
			maj->first->size 	= size;
c010478c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010478f:	8b 40 14             	mov    0x14(%eax),%eax
c0104792:	8b 55 c8             	mov    -0x38(%ebp),%edx
c0104795:	89 50 10             	mov    %edx,0x10(%eax)
			maj->first->req_size 	= req_size;
c0104798:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010479b:	8b 40 14             	mov    0x14(%eax),%eax
c010479e:	8b 55 08             	mov    0x8(%ebp),%edx
c01047a1:	89 50 14             	mov    %edx,0x14(%eax)
			maj->usage 			+= size + sizeof( struct liballoc_minor );
c01047a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01047a7:	8b 50 10             	mov    0x10(%eax),%edx
c01047aa:	8b 45 c8             	mov    -0x38(%ebp),%eax
c01047ad:	01 d0                	add    %edx,%eax
c01047af:	8d 50 18             	lea    0x18(%eax),%edx
c01047b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01047b5:	89 50 10             	mov    %edx,0x10(%eax)

			l_inuse += size;
c01047b8:	8b 4d c8             	mov    -0x38(%ebp),%ecx
c01047bb:	bb 00 00 00 00       	mov    $0x0,%ebx
c01047c0:	a1 30 4d 3e c0       	mov    0xc03e4d30,%eax
c01047c5:	8b 15 34 4d 3e c0    	mov    0xc03e4d34,%edx
c01047cb:	01 c8                	add    %ecx,%eax
c01047cd:	11 da                	adc    %ebx,%edx
c01047cf:	a3 30 4d 3e c0       	mov    %eax,0xc03e4d30
c01047d4:	89 15 34 4d 3e c0    	mov    %edx,0xc03e4d34

			p = (void*)((uintptr_t)(maj->first) + sizeof( struct liballoc_minor ));
c01047da:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01047dd:	8b 40 14             	mov    0x14(%eax),%eax
c01047e0:	83 c0 18             	add    $0x18,%eax
c01047e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			ALIGN( p );
c01047e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01047e9:	83 c0 10             	add    $0x10,%eax
c01047ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c01047ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01047f2:	83 e0 0f             	and    $0xf,%eax
c01047f5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c01047f8:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c01047fc:	74 16                	je     c0104814 <malloc+0x3a0>
c01047fe:	b8 10 00 00 00       	mov    $0x10,%eax
c0104803:	2b 45 d4             	sub    -0x2c(%ebp),%eax
c0104806:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c0104809:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010480c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010480f:	01 d0                	add    %edx,%eax
c0104811:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0104814:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0104817:	8d 50 10             	lea    0x10(%eax),%edx
c010481a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010481d:	83 e8 10             	sub    $0x10,%eax
c0104820:	88 10                	mov    %dl,(%eax)

			#ifdef DEBUG
			serial_printf( "CASE 3: returning %x\n", p); 
			FLUSH();
			#endif
			liballoc_unlock();		// release the lock
c0104822:	e8 da 06 00 00       	call   c0104f01 <liballoc_unlock>
			return p;
c0104827:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010482a:	e9 cc 02 00 00       	jmp    c0104afb <malloc+0x687>


#ifdef USE_CASE4

		// CASE 4: There is enough space in this block. But is it contiguous?
		min = maj->first;
c010482f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104832:	8b 40 14             	mov    0x14(%eax),%eax
c0104835:	89 45 dc             	mov    %eax,-0x24(%ebp)
		
			// Looping within the block now...
		while ( min != NULL )
c0104838:	e9 47 02 00 00       	jmp    c0104a84 <malloc+0x610>
		{
				// CASE 4.1: End of minors in a block. Space from last and end?
				if ( min->next == NULL )
c010483d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104840:	8b 40 04             	mov    0x4(%eax),%eax
c0104843:	85 c0                	test   %eax,%eax
c0104845:	0f 85 11 01 00 00    	jne    c010495c <malloc+0x4e8>
				{
					// the rest of this block is free...  is it big enough?
					diff = (uintptr_t)(maj) + maj->size;
c010484b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010484e:	8b 50 0c             	mov    0xc(%eax),%edx
c0104851:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104854:	01 d0                	add    %edx,%eax
c0104856:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					diff -= (uintptr_t)min;
c0104859:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010485c:	29 45 c4             	sub    %eax,-0x3c(%ebp)
					diff -= sizeof( struct liballoc_minor );
c010485f:	83 6d c4 18          	subl   $0x18,-0x3c(%ebp)
					diff -= min->size; 
c0104863:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104866:	8b 40 10             	mov    0x10(%eax),%eax
c0104869:	29 45 c4             	sub    %eax,-0x3c(%ebp)
						// minus already existing usage..

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
c010486c:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010486f:	83 c0 18             	add    $0x18,%eax
c0104872:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
c0104875:	0f 82 e1 00 00 00    	jb     c010495c <malloc+0x4e8>
					{
						// yay....
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
c010487b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010487e:	8b 50 10             	mov    0x10(%eax),%edx
c0104881:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104884:	01 d0                	add    %edx,%eax
c0104886:	83 c0 18             	add    $0x18,%eax
c0104889:	89 c2                	mov    %eax,%edx
c010488b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010488e:	89 50 04             	mov    %edx,0x4(%eax)
						min->next->prev = min;
c0104891:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104894:	8b 40 04             	mov    0x4(%eax),%eax
c0104897:	8b 55 dc             	mov    -0x24(%ebp),%edx
c010489a:	89 10                	mov    %edx,(%eax)
						min = min->next;
c010489c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010489f:	8b 40 04             	mov    0x4(%eax),%eax
c01048a2:	89 45 dc             	mov    %eax,-0x24(%ebp)
						min->next = NULL;
c01048a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01048a8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
						min->magic = LIBALLOC_MAGIC;
c01048af:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01048b2:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
						min->block = maj;
c01048b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01048bc:	8b 55 e0             	mov    -0x20(%ebp),%edx
c01048bf:	89 50 08             	mov    %edx,0x8(%eax)
						min->size = size;
c01048c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01048c5:	8b 55 c8             	mov    -0x38(%ebp),%edx
c01048c8:	89 50 10             	mov    %edx,0x10(%eax)
						min->req_size = req_size;
c01048cb:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01048ce:	8b 55 08             	mov    0x8(%ebp),%edx
c01048d1:	89 50 14             	mov    %edx,0x14(%eax)
						maj->usage += size + sizeof( struct liballoc_minor );
c01048d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01048d7:	8b 50 10             	mov    0x10(%eax),%edx
c01048da:	8b 45 c8             	mov    -0x38(%ebp),%eax
c01048dd:	01 d0                	add    %edx,%eax
c01048df:	8d 50 18             	lea    0x18(%eax),%edx
c01048e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01048e5:	89 50 10             	mov    %edx,0x10(%eax)

						l_inuse += size;
c01048e8:	8b 4d c8             	mov    -0x38(%ebp),%ecx
c01048eb:	bb 00 00 00 00       	mov    $0x0,%ebx
c01048f0:	a1 30 4d 3e c0       	mov    0xc03e4d30,%eax
c01048f5:	8b 15 34 4d 3e c0    	mov    0xc03e4d34,%edx
c01048fb:	01 c8                	add    %ecx,%eax
c01048fd:	11 da                	adc    %ebx,%edx
c01048ff:	a3 30 4d 3e c0       	mov    %eax,0xc03e4d30
c0104904:	89 15 34 4d 3e c0    	mov    %edx,0xc03e4d34
						
						p = (void*)((uintptr_t)min + sizeof( struct liballoc_minor ));
c010490a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010490d:	83 c0 18             	add    $0x18,%eax
c0104910:	89 45 e4             	mov    %eax,-0x1c(%ebp)
						ALIGN( p );
c0104913:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104916:	83 c0 10             	add    $0x10,%eax
c0104919:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c010491c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010491f:	83 e0 0f             	and    $0xf,%eax
c0104922:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0104925:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
c0104929:	74 16                	je     c0104941 <malloc+0x4cd>
c010492b:	b8 10 00 00 00       	mov    $0x10,%eax
c0104930:	2b 45 d0             	sub    -0x30(%ebp),%eax
c0104933:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0104936:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0104939:	8b 45 d0             	mov    -0x30(%ebp),%eax
c010493c:	01 d0                	add    %edx,%eax
c010493e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0104941:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0104944:	8d 50 10             	lea    0x10(%eax),%edx
c0104947:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010494a:	83 e8 10             	sub    $0x10,%eax
c010494d:	88 10                	mov    %dl,(%eax)

						#ifdef DEBUG
						serial_printf( "CASE 4.1: returning %x\n", p); 
						FLUSH();
						#endif
						liballoc_unlock();		// release the lock
c010494f:	e8 ad 05 00 00       	call   c0104f01 <liballoc_unlock>
						return p;
c0104954:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104957:	e9 9f 01 00 00       	jmp    c0104afb <malloc+0x687>
				}



				// CASE 4.2: Is there space between two minors?
				if ( min->next != NULL )
c010495c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010495f:	8b 40 04             	mov    0x4(%eax),%eax
c0104962:	85 c0                	test   %eax,%eax
c0104964:	0f 84 11 01 00 00    	je     c0104a7b <malloc+0x607>
				{
					// is the difference between here and next big enough?
					diff  = (uintptr_t)(min->next);
c010496a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010496d:	8b 40 04             	mov    0x4(%eax),%eax
c0104970:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					diff -= (uintptr_t)min;
c0104973:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104976:	29 45 c4             	sub    %eax,-0x3c(%ebp)
					diff -= sizeof( struct liballoc_minor );
c0104979:	83 6d c4 18          	subl   $0x18,-0x3c(%ebp)
					diff -= min->size;
c010497d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104980:	8b 40 10             	mov    0x10(%eax),%eax
c0104983:	29 45 c4             	sub    %eax,-0x3c(%ebp)
										// minus our existing usage.

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
c0104986:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0104989:	83 c0 18             	add    $0x18,%eax
c010498c:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
c010498f:	0f 82 e6 00 00 00    	jb     c0104a7b <malloc+0x607>
					{
						// yay......
						new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
c0104995:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104998:	8b 50 10             	mov    0x10(%eax),%edx
c010499b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010499e:	01 d0                	add    %edx,%eax
c01049a0:	83 c0 18             	add    $0x18,%eax
c01049a3:	89 45 c0             	mov    %eax,-0x40(%ebp)

						new_min->magic = LIBALLOC_MAGIC;
c01049a6:	8b 45 c0             	mov    -0x40(%ebp),%eax
c01049a9:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
						new_min->next = min->next;
c01049b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01049b3:	8b 50 04             	mov    0x4(%eax),%edx
c01049b6:	8b 45 c0             	mov    -0x40(%ebp),%eax
c01049b9:	89 50 04             	mov    %edx,0x4(%eax)
						new_min->prev = min;
c01049bc:	8b 45 c0             	mov    -0x40(%ebp),%eax
c01049bf:	8b 55 dc             	mov    -0x24(%ebp),%edx
c01049c2:	89 10                	mov    %edx,(%eax)
						new_min->size = size;
c01049c4:	8b 45 c0             	mov    -0x40(%ebp),%eax
c01049c7:	8b 55 c8             	mov    -0x38(%ebp),%edx
c01049ca:	89 50 10             	mov    %edx,0x10(%eax)
						new_min->req_size = req_size;
c01049cd:	8b 45 c0             	mov    -0x40(%ebp),%eax
c01049d0:	8b 55 08             	mov    0x8(%ebp),%edx
c01049d3:	89 50 14             	mov    %edx,0x14(%eax)
						new_min->block = maj;
c01049d6:	8b 45 c0             	mov    -0x40(%ebp),%eax
c01049d9:	8b 55 e0             	mov    -0x20(%ebp),%edx
c01049dc:	89 50 08             	mov    %edx,0x8(%eax)
						min->next->prev = new_min;
c01049df:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01049e2:	8b 40 04             	mov    0x4(%eax),%eax
c01049e5:	8b 55 c0             	mov    -0x40(%ebp),%edx
c01049e8:	89 10                	mov    %edx,(%eax)
						min->next = new_min;
c01049ea:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01049ed:	8b 55 c0             	mov    -0x40(%ebp),%edx
c01049f0:	89 50 04             	mov    %edx,0x4(%eax)
						maj->usage += size + sizeof( struct liballoc_minor );
c01049f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01049f6:	8b 50 10             	mov    0x10(%eax),%edx
c01049f9:	8b 45 c8             	mov    -0x38(%ebp),%eax
c01049fc:	01 d0                	add    %edx,%eax
c01049fe:	8d 50 18             	lea    0x18(%eax),%edx
c0104a01:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104a04:	89 50 10             	mov    %edx,0x10(%eax)
						
						l_inuse += size;
c0104a07:	8b 4d c8             	mov    -0x38(%ebp),%ecx
c0104a0a:	bb 00 00 00 00       	mov    $0x0,%ebx
c0104a0f:	a1 30 4d 3e c0       	mov    0xc03e4d30,%eax
c0104a14:	8b 15 34 4d 3e c0    	mov    0xc03e4d34,%edx
c0104a1a:	01 c8                	add    %ecx,%eax
c0104a1c:	11 da                	adc    %ebx,%edx
c0104a1e:	a3 30 4d 3e c0       	mov    %eax,0xc03e4d30
c0104a23:	89 15 34 4d 3e c0    	mov    %edx,0xc03e4d34
						
						p = (void*)((uintptr_t)new_min + sizeof( struct liballoc_minor ));
c0104a29:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0104a2c:	83 c0 18             	add    $0x18,%eax
c0104a2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
						ALIGN( p );
c0104a32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104a35:	83 c0 10             	add    $0x10,%eax
c0104a38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0104a3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104a3e:	83 e0 0f             	and    $0xf,%eax
c0104a41:	89 45 cc             	mov    %eax,-0x34(%ebp)
c0104a44:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
c0104a48:	74 16                	je     c0104a60 <malloc+0x5ec>
c0104a4a:	b8 10 00 00 00       	mov    $0x10,%eax
c0104a4f:	2b 45 cc             	sub    -0x34(%ebp),%eax
c0104a52:	89 45 cc             	mov    %eax,-0x34(%ebp)
c0104a55:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0104a58:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0104a5b:	01 d0                	add    %edx,%eax
c0104a5d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0104a60:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0104a63:	8d 50 10             	lea    0x10(%eax),%edx
c0104a66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104a69:	83 e8 10             	sub    $0x10,%eax
c0104a6c:	88 10                	mov    %dl,(%eax)
						#ifdef DEBUG
						serial_printf( "CASE 4.2: returning %x\n", p); 
						FLUSH();
						#endif
						
						liballoc_unlock();		// release the lock
c0104a6e:	e8 8e 04 00 00       	call   c0104f01 <liballoc_unlock>
						return p;
c0104a73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104a76:	e9 80 00 00 00       	jmp    c0104afb <malloc+0x687>
					}
				}	// min->next != NULL

				min = min->next;
c0104a7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0104a7e:	8b 40 04             	mov    0x4(%eax),%eax
c0104a81:	89 45 dc             	mov    %eax,-0x24(%ebp)
		while ( min != NULL )
c0104a84:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0104a88:	0f 85 af fd ff ff    	jne    c010483d <malloc+0x3c9>
#endif

#ifdef USE_CASE5

		// CASE 5: Block full! Ensure next block and loop.
		if ( maj->next == NULL ) 
c0104a8e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104a91:	8b 40 04             	mov    0x4(%eax),%eax
c0104a94:	85 c0                	test   %eax,%eax
c0104a96:	75 40                	jne    c0104ad8 <malloc+0x664>
			#ifdef DEBUG
			serial_printf( "CASE 5: block full\n");
			FLUSH();
			#endif

			if ( startedBet == 1 )
c0104a98:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0104a9c:	75 11                	jne    c0104aaf <malloc+0x63b>
			{
				maj = l_memRoot;
c0104a9e:	a1 20 4d 3e c0       	mov    0xc03e4d20,%eax
c0104aa3:	89 45 e0             	mov    %eax,-0x20(%ebp)
				startedBet = 0;
c0104aa6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				continue;
c0104aad:	eb 32                	jmp    c0104ae1 <malloc+0x66d>
			}
				
			// we've run out. we need more...
			maj->next = allocate_new_page( size );		// next one guaranteed to be okay
c0104aaf:	83 ec 0c             	sub    $0xc,%esp
c0104ab2:	ff 75 c8             	pushl  -0x38(%ebp)
c0104ab5:	e8 d1 f8 ff ff       	call   c010438b <allocate_new_page>
c0104aba:	83 c4 10             	add    $0x10,%esp
c0104abd:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0104ac0:	89 42 04             	mov    %eax,0x4(%edx)
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
c0104ac3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104ac6:	8b 40 04             	mov    0x4(%eax),%eax
c0104ac9:	85 c0                	test   %eax,%eax
c0104acb:	74 23                	je     c0104af0 <malloc+0x67c>
			maj->next->prev = maj;
c0104acd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104ad0:	8b 40 04             	mov    0x4(%eax),%eax
c0104ad3:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0104ad6:	89 10                	mov    %edx,(%eax)

		}

#endif

		maj = maj->next;
c0104ad8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0104adb:	8b 40 04             	mov    0x4(%eax),%eax
c0104ade:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while ( maj != NULL )
c0104ae1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0104ae5:	0f 85 8f fa ff ff    	jne    c010457a <malloc+0x106>
c0104aeb:	eb 04                	jmp    c0104af1 <malloc+0x67d>
			if ( maj->next == NULL ) break;			// no more memory.
c0104aed:	90                   	nop
c0104aee:	eb 01                	jmp    c0104af1 <malloc+0x67d>
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
c0104af0:	90                   	nop
	} // while (maj != NULL)


	
	liballoc_unlock();		// release the lock
c0104af1:	e8 0b 04 00 00       	call   c0104f01 <liballoc_unlock>
	#if defined DEBUG || defined INFO
	serial_printf( "liballoc: WARNING: PREFIX(malloc)( %d ) returning NULL.\n", size);
	liballoc_dump();
	FLUSH();
	#endif
	return NULL;
c0104af6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0104afb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0104afe:	c9                   	leave  
c0104aff:	c3                   	ret    

c0104b00 <free>:




void PREFIX(free)(void *ptr)
{
c0104b00:	55                   	push   %ebp
c0104b01:	89 e5                	mov    %esp,%ebp
c0104b03:	53                   	push   %ebx
c0104b04:	83 ec 24             	sub    $0x24,%esp
	struct liballoc_minor *min;
	struct liballoc_major *maj;

	if ( ptr == NULL ) 
c0104b07:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0104b0b:	75 21                	jne    c0104b2e <free+0x2e>
	{
		l_warningCount += 1;
c0104b0d:	a1 38 4d 3e c0       	mov    0xc03e4d38,%eax
c0104b12:	8b 15 3c 4d 3e c0    	mov    0xc03e4d3c,%edx
c0104b18:	83 c0 01             	add    $0x1,%eax
c0104b1b:	83 d2 00             	adc    $0x0,%edx
c0104b1e:	a3 38 4d 3e c0       	mov    %eax,0xc03e4d38
c0104b23:	89 15 3c 4d 3e c0    	mov    %edx,0xc03e4d3c
		#if defined DEBUG || defined INFO
		serial_printf( "liballoc: WARNING: PREFIX(free)( NULL ) called from %x\n",
							__builtin_return_address(0) );
		FLUSH();
		#endif
		return;
c0104b29:	e9 29 02 00 00       	jmp    c0104d57 <free+0x257>
	}

	UNALIGN( ptr );
c0104b2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0104b31:	83 e8 10             	sub    $0x10,%eax
c0104b34:	8a 00                	mov    (%eax),%al
c0104b36:	0f be c0             	movsbl %al,%eax
c0104b39:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0104b3c:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c0104b40:	77 09                	ja     c0104b4b <free+0x4b>
c0104b42:	8b 45 08             	mov    0x8(%ebp),%eax
c0104b45:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0104b48:	89 45 08             	mov    %eax,0x8(%ebp)

	liballoc_lock();		// lockit
c0104b4b:	e8 99 03 00 00       	call   c0104ee9 <liballoc_lock>


	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
c0104b50:	8b 45 08             	mov    0x8(%ebp),%eax
c0104b53:	83 e8 18             	sub    $0x18,%eax
c0104b56:	89 45 f0             	mov    %eax,-0x10(%ebp)

	
	if ( min->magic != LIBALLOC_MAGIC ) 
c0104b59:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104b5c:	8b 40 0c             	mov    0xc(%eax),%eax
c0104b5f:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
c0104b64:	74 74                	je     c0104bda <free+0xda>
	{
		l_errorCount += 1;
c0104b66:	a1 40 4d 3e c0       	mov    0xc03e4d40,%eax
c0104b6b:	8b 15 44 4d 3e c0    	mov    0xc03e4d44,%edx
c0104b71:	83 c0 01             	add    $0x1,%eax
c0104b74:	83 d2 00             	adc    $0x0,%edx
c0104b77:	a3 40 4d 3e c0       	mov    %eax,0xc03e4d40
c0104b7c:	89 15 44 4d 3e c0    	mov    %edx,0xc03e4d44

		// Check for overrun errors. For all bytes of LIBALLOC_MAGIC 
		if ( 
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
c0104b82:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104b85:	8b 40 0c             	mov    0xc(%eax),%eax
c0104b88:	25 ff ff ff 00       	and    $0xffffff,%eax
		if ( 
c0104b8d:	3d de c0 01 00       	cmp    $0x1c0de,%eax
c0104b92:	74 20                	je     c0104bb4 <free+0xb4>
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
c0104b94:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104b97:	8b 40 0c             	mov    0xc(%eax),%eax
c0104b9a:	0f b7 c0             	movzwl %ax,%eax
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
c0104b9d:	3d de c0 00 00       	cmp    $0xc0de,%eax
c0104ba2:	74 10                	je     c0104bb4 <free+0xb4>
			((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF)) 
c0104ba4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104ba7:	8b 40 0c             	mov    0xc(%eax),%eax
c0104baa:	0f b6 c0             	movzbl %al,%eax
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
c0104bad:	3d de 00 00 00       	cmp    $0xde,%eax
c0104bb2:	75 1c                	jne    c0104bd0 <free+0xd0>
		   )
		{
			l_possibleOverruns += 1;
c0104bb4:	a1 48 4d 3e c0       	mov    0xc03e4d48,%eax
c0104bb9:	8b 15 4c 4d 3e c0    	mov    0xc03e4d4c,%edx
c0104bbf:	83 c0 01             	add    $0x1,%eax
c0104bc2:	83 d2 00             	adc    $0x0,%edx
c0104bc5:	a3 48 4d 3e c0       	mov    %eax,0xc03e4d48
c0104bca:	89 15 4c 4d 3e c0    	mov    %edx,0xc03e4d4c
			FLUSH();
			#endif
		}
			
		// being lied to...
		liballoc_unlock();		// release the lock
c0104bd0:	e8 2c 03 00 00       	call   c0104f01 <liballoc_unlock>
		return;
c0104bd5:	e9 7d 01 00 00       	jmp    c0104d57 <free+0x257>
				ptr );
	FLUSH();
	#endif
	

		maj = min->block;
c0104bda:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104bdd:	8b 40 08             	mov    0x8(%eax),%eax
c0104be0:	89 45 ec             	mov    %eax,-0x14(%ebp)

		l_inuse -= min->size;
c0104be3:	a1 30 4d 3e c0       	mov    0xc03e4d30,%eax
c0104be8:	8b 15 34 4d 3e c0    	mov    0xc03e4d34,%edx
c0104bee:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c0104bf1:	8b 49 10             	mov    0x10(%ecx),%ecx
c0104bf4:	bb 00 00 00 00       	mov    $0x0,%ebx
c0104bf9:	29 c8                	sub    %ecx,%eax
c0104bfb:	19 da                	sbb    %ebx,%edx
c0104bfd:	a3 30 4d 3e c0       	mov    %eax,0xc03e4d30
c0104c02:	89 15 34 4d 3e c0    	mov    %edx,0xc03e4d34

		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
c0104c08:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104c0b:	8b 50 10             	mov    0x10(%eax),%edx
c0104c0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104c11:	8b 40 10             	mov    0x10(%eax),%eax
c0104c14:	29 c2                	sub    %eax,%edx
c0104c16:	89 d0                	mov    %edx,%eax
c0104c18:	8d 50 e8             	lea    -0x18(%eax),%edx
c0104c1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104c1e:	89 50 10             	mov    %edx,0x10(%eax)
		min->magic  = LIBALLOC_DEAD;		// No mojo.
c0104c21:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104c24:	c7 40 0c ad de ad de 	movl   $0xdeaddead,0xc(%eax)

		if ( min->next != NULL ) min->next->prev = min->prev;
c0104c2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104c2e:	8b 40 04             	mov    0x4(%eax),%eax
c0104c31:	85 c0                	test   %eax,%eax
c0104c33:	74 0d                	je     c0104c42 <free+0x142>
c0104c35:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104c38:	8b 40 04             	mov    0x4(%eax),%eax
c0104c3b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0104c3e:	8b 12                	mov    (%edx),%edx
c0104c40:	89 10                	mov    %edx,(%eax)
		if ( min->prev != NULL ) min->prev->next = min->next;
c0104c42:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104c45:	8b 00                	mov    (%eax),%eax
c0104c47:	85 c0                	test   %eax,%eax
c0104c49:	74 0e                	je     c0104c59 <free+0x159>
c0104c4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104c4e:	8b 00                	mov    (%eax),%eax
c0104c50:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0104c53:	8b 52 04             	mov    0x4(%edx),%edx
c0104c56:	89 50 04             	mov    %edx,0x4(%eax)

		if ( min->prev == NULL ) maj->first = min->next;	
c0104c59:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104c5c:	8b 00                	mov    (%eax),%eax
c0104c5e:	85 c0                	test   %eax,%eax
c0104c60:	75 0c                	jne    c0104c6e <free+0x16e>
c0104c62:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0104c65:	8b 50 04             	mov    0x4(%eax),%edx
c0104c68:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104c6b:	89 50 14             	mov    %edx,0x14(%eax)
							// minor.


	// We need to clean up after the majors now....

	if ( maj->first == NULL )	// Block completely unused.
c0104c6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104c71:	8b 40 14             	mov    0x14(%eax),%eax
c0104c74:	85 c0                	test   %eax,%eax
c0104c76:	0f 85 93 00 00 00    	jne    c0104d0f <free+0x20f>
	{
		if ( l_memRoot == maj ) l_memRoot = maj->next;
c0104c7c:	a1 20 4d 3e c0       	mov    0xc03e4d20,%eax
c0104c81:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0104c84:	75 0b                	jne    c0104c91 <free+0x191>
c0104c86:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104c89:	8b 40 04             	mov    0x4(%eax),%eax
c0104c8c:	a3 20 4d 3e c0       	mov    %eax,0xc03e4d20
		if ( l_bestBet == maj ) l_bestBet = NULL;
c0104c91:	a1 24 4d 3e c0       	mov    0xc03e4d24,%eax
c0104c96:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0104c99:	75 0a                	jne    c0104ca5 <free+0x1a5>
c0104c9b:	c7 05 24 4d 3e c0 00 	movl   $0x0,0xc03e4d24
c0104ca2:	00 00 00 
		if ( maj->prev != NULL ) maj->prev->next = maj->next;
c0104ca5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104ca8:	8b 00                	mov    (%eax),%eax
c0104caa:	85 c0                	test   %eax,%eax
c0104cac:	74 0e                	je     c0104cbc <free+0x1bc>
c0104cae:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104cb1:	8b 00                	mov    (%eax),%eax
c0104cb3:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0104cb6:	8b 52 04             	mov    0x4(%edx),%edx
c0104cb9:	89 50 04             	mov    %edx,0x4(%eax)
		if ( maj->next != NULL ) maj->next->prev = maj->prev;
c0104cbc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104cbf:	8b 40 04             	mov    0x4(%eax),%eax
c0104cc2:	85 c0                	test   %eax,%eax
c0104cc4:	74 0d                	je     c0104cd3 <free+0x1d3>
c0104cc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104cc9:	8b 40 04             	mov    0x4(%eax),%eax
c0104ccc:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0104ccf:	8b 12                	mov    (%edx),%edx
c0104cd1:	89 10                	mov    %edx,(%eax)
		l_allocated -= maj->size;
c0104cd3:	a1 28 4d 3e c0       	mov    0xc03e4d28,%eax
c0104cd8:	8b 15 2c 4d 3e c0    	mov    0xc03e4d2c,%edx
c0104cde:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0104ce1:	8b 49 0c             	mov    0xc(%ecx),%ecx
c0104ce4:	bb 00 00 00 00       	mov    $0x0,%ebx
c0104ce9:	29 c8                	sub    %ecx,%eax
c0104ceb:	19 da                	sbb    %ebx,%edx
c0104ced:	a3 28 4d 3e c0       	mov    %eax,0xc03e4d28
c0104cf2:	89 15 2c 4d 3e c0    	mov    %edx,0xc03e4d2c

		liballoc_free( maj, maj->pages );
c0104cf8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104cfb:	8b 40 08             	mov    0x8(%eax),%eax
c0104cfe:	83 ec 08             	sub    $0x8,%esp
c0104d01:	50                   	push   %eax
c0104d02:	ff 75 ec             	pushl  -0x14(%ebp)
c0104d05:	e8 26 02 00 00       	call   c0104f30 <liballoc_free>
c0104d0a:	83 c4 10             	add    $0x10,%esp
c0104d0d:	eb 43                	jmp    c0104d52 <free+0x252>
	}
	else
	{
		if ( l_bestBet != NULL )
c0104d0f:	a1 24 4d 3e c0       	mov    0xc03e4d24,%eax
c0104d14:	85 c0                	test   %eax,%eax
c0104d16:	74 3a                	je     c0104d52 <free+0x252>
		{
			int bestSize = l_bestBet->size  - l_bestBet->usage;
c0104d18:	a1 24 4d 3e c0       	mov    0xc03e4d24,%eax
c0104d1d:	8b 50 0c             	mov    0xc(%eax),%edx
c0104d20:	a1 24 4d 3e c0       	mov    0xc03e4d24,%eax
c0104d25:	8b 40 10             	mov    0x10(%eax),%eax
c0104d28:	29 c2                	sub    %eax,%edx
c0104d2a:	89 d0                	mov    %edx,%eax
c0104d2c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			int majSize = maj->size - maj->usage;
c0104d2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104d32:	8b 50 0c             	mov    0xc(%eax),%edx
c0104d35:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104d38:	8b 40 10             	mov    0x10(%eax),%eax
c0104d3b:	29 c2                	sub    %eax,%edx
c0104d3d:	89 d0                	mov    %edx,%eax
c0104d3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if ( majSize > bestSize ) l_bestBet = maj;
c0104d42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0104d45:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0104d48:	7e 08                	jle    c0104d52 <free+0x252>
c0104d4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104d4d:	a3 24 4d 3e c0       	mov    %eax,0xc03e4d24
	#ifdef DEBUG
	serial_printf( "OK\n");
	FLUSH();
	#endif
	
	liballoc_unlock();		// release the lock
c0104d52:	e8 aa 01 00 00       	call   c0104f01 <liballoc_unlock>
}
c0104d57:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0104d5a:	c9                   	leave  
c0104d5b:	c3                   	ret    

c0104d5c <calloc>:




void* PREFIX(calloc)(size_t nobj, size_t size)
{
c0104d5c:	55                   	push   %ebp
c0104d5d:	89 e5                	mov    %esp,%ebp
c0104d5f:	83 ec 18             	sub    $0x18,%esp
       int real_size;
       void *p;

       real_size = nobj * size;
c0104d62:	8b 45 08             	mov    0x8(%ebp),%eax
c0104d65:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0104d69:	89 45 f4             	mov    %eax,-0xc(%ebp)
       
       p = PREFIX(malloc)( real_size );
c0104d6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104d6f:	83 ec 0c             	sub    $0xc,%esp
c0104d72:	50                   	push   %eax
c0104d73:	e8 fc f6 ff ff       	call   c0104474 <malloc>
c0104d78:	83 c4 10             	add    $0x10,%esp
c0104d7b:	89 45 f0             	mov    %eax,-0x10(%ebp)

       liballoc_memset( p, 0, real_size );
c0104d7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104d81:	83 ec 04             	sub    $0x4,%esp
c0104d84:	50                   	push   %eax
c0104d85:	6a 00                	push   $0x0
c0104d87:	ff 75 f0             	pushl  -0x10(%ebp)
c0104d8a:	e8 6a f5 ff ff       	call   c01042f9 <liballoc_memset>
c0104d8f:	83 c4 10             	add    $0x10,%esp

       return p;
c0104d92:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0104d95:	c9                   	leave  
c0104d96:	c3                   	ret    

c0104d97 <realloc>:



void*   PREFIX(realloc)(void *p, size_t size)
{
c0104d97:	55                   	push   %ebp
c0104d98:	89 e5                	mov    %esp,%ebp
c0104d9a:	83 ec 18             	sub    $0x18,%esp
	void *ptr;
	struct liballoc_minor *min;
	unsigned int real_size;
	
	// Honour the case of size == 0 => free old and return NULL
	if ( size == 0 )
c0104d9d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0104da1:	75 18                	jne    c0104dbb <realloc+0x24>
	{
		PREFIX(free)( p );
c0104da3:	83 ec 0c             	sub    $0xc,%esp
c0104da6:	ff 75 08             	pushl  0x8(%ebp)
c0104da9:	e8 52 fd ff ff       	call   c0104b00 <free>
c0104dae:	83 c4 10             	add    $0x10,%esp
		return NULL;
c0104db1:	b8 00 00 00 00       	mov    $0x0,%eax
c0104db6:	e9 2c 01 00 00       	jmp    c0104ee7 <realloc+0x150>
	}

	// In the case of a NULL pointer, return a simple malloc.
	if ( p == NULL ) return PREFIX(malloc)( size );
c0104dbb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0104dbf:	75 13                	jne    c0104dd4 <realloc+0x3d>
c0104dc1:	83 ec 0c             	sub    $0xc,%esp
c0104dc4:	ff 75 0c             	pushl  0xc(%ebp)
c0104dc7:	e8 a8 f6 ff ff       	call   c0104474 <malloc>
c0104dcc:	83 c4 10             	add    $0x10,%esp
c0104dcf:	e9 13 01 00 00       	jmp    c0104ee7 <realloc+0x150>

	// Unalign the pointer if required.
	ptr = p;
c0104dd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0104dd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	UNALIGN(ptr);
c0104dda:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104ddd:	83 e8 10             	sub    $0x10,%eax
c0104de0:	8a 00                	mov    (%eax),%al
c0104de2:	0f be c0             	movsbl %al,%eax
c0104de5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0104de8:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
c0104dec:	77 09                	ja     c0104df7 <realloc+0x60>
c0104dee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104df1:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0104df4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	liballoc_lock();		// lockit
c0104df7:	e8 ed 00 00 00       	call   c0104ee9 <liballoc_lock>

		min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
c0104dfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0104dff:	83 e8 18             	sub    $0x18,%eax
c0104e02:	89 45 ec             	mov    %eax,-0x14(%ebp)

		// Ensure it is a valid structure.
		if ( min->magic != LIBALLOC_MAGIC ) 
c0104e05:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104e08:	8b 40 0c             	mov    0xc(%eax),%eax
c0104e0b:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
c0104e10:	74 76                	je     c0104e88 <realloc+0xf1>
		{
			l_errorCount += 1;
c0104e12:	a1 40 4d 3e c0       	mov    0xc03e4d40,%eax
c0104e17:	8b 15 44 4d 3e c0    	mov    0xc03e4d44,%edx
c0104e1d:	83 c0 01             	add    $0x1,%eax
c0104e20:	83 d2 00             	adc    $0x0,%edx
c0104e23:	a3 40 4d 3e c0       	mov    %eax,0xc03e4d40
c0104e28:	89 15 44 4d 3e c0    	mov    %edx,0xc03e4d44
	
			// Check for overrun errors. For all bytes of LIBALLOC_MAGIC 
			if ( 
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
c0104e2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104e31:	8b 40 0c             	mov    0xc(%eax),%eax
c0104e34:	25 ff ff ff 00       	and    $0xffffff,%eax
			if ( 
c0104e39:	3d de c0 01 00       	cmp    $0x1c0de,%eax
c0104e3e:	74 20                	je     c0104e60 <realloc+0xc9>
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
c0104e40:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104e43:	8b 40 0c             	mov    0xc(%eax),%eax
c0104e46:	0f b7 c0             	movzwl %ax,%eax
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
c0104e49:	3d de c0 00 00       	cmp    $0xc0de,%eax
c0104e4e:	74 10                	je     c0104e60 <realloc+0xc9>
				((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF)) 
c0104e50:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104e53:	8b 40 0c             	mov    0xc(%eax),%eax
c0104e56:	0f b6 c0             	movzbl %al,%eax
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
c0104e59:	3d de 00 00 00       	cmp    $0xde,%eax
c0104e5e:	75 1c                	jne    c0104e7c <realloc+0xe5>
			   )
			{
				l_possibleOverruns += 1;
c0104e60:	a1 48 4d 3e c0       	mov    0xc03e4d48,%eax
c0104e65:	8b 15 4c 4d 3e c0    	mov    0xc03e4d4c,%edx
c0104e6b:	83 c0 01             	add    $0x1,%eax
c0104e6e:	83 d2 00             	adc    $0x0,%edx
c0104e71:	a3 48 4d 3e c0       	mov    %eax,0xc03e4d48
c0104e76:	89 15 4c 4d 3e c0    	mov    %edx,0xc03e4d4c
				FLUSH();
				#endif
			}
			
			// being lied to...
			liballoc_unlock();		// release the lock
c0104e7c:	e8 80 00 00 00       	call   c0104f01 <liballoc_unlock>
			return NULL;
c0104e81:	b8 00 00 00 00       	mov    $0x0,%eax
c0104e86:	eb 5f                	jmp    c0104ee7 <realloc+0x150>
		}	
		
		// Definitely a memory block.
		
		real_size = min->req_size;
c0104e88:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104e8b:	8b 40 14             	mov    0x14(%eax),%eax
c0104e8e:	89 45 e8             	mov    %eax,-0x18(%ebp)

		if ( real_size >= size ) 
c0104e91:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0104e94:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0104e97:	72 13                	jb     c0104eac <realloc+0x115>
		{
			min->req_size = size;
c0104e99:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0104e9c:	8b 55 0c             	mov    0xc(%ebp),%edx
c0104e9f:	89 50 14             	mov    %edx,0x14(%eax)
			liballoc_unlock();
c0104ea2:	e8 5a 00 00 00       	call   c0104f01 <liballoc_unlock>
			return p;
c0104ea7:	8b 45 08             	mov    0x8(%ebp),%eax
c0104eaa:	eb 3b                	jmp    c0104ee7 <realloc+0x150>
		}

	liballoc_unlock();
c0104eac:	e8 50 00 00 00       	call   c0104f01 <liballoc_unlock>

	// If we got here then we're reallocating to a block bigger than us.
	ptr = PREFIX(malloc)( size );					// We need to allocate new memory
c0104eb1:	83 ec 0c             	sub    $0xc,%esp
c0104eb4:	ff 75 0c             	pushl  0xc(%ebp)
c0104eb7:	e8 b8 f5 ff ff       	call   c0104474 <malloc>
c0104ebc:	83 c4 10             	add    $0x10,%esp
c0104ebf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	liballoc_memcpy( ptr, p, real_size );
c0104ec2:	83 ec 04             	sub    $0x4,%esp
c0104ec5:	ff 75 e8             	pushl  -0x18(%ebp)
c0104ec8:	ff 75 08             	pushl  0x8(%ebp)
c0104ecb:	ff 75 f4             	pushl  -0xc(%ebp)
c0104ece:	e8 52 f4 ff ff       	call   c0104325 <liballoc_memcpy>
c0104ed3:	83 c4 10             	add    $0x10,%esp
	PREFIX(free)( p );
c0104ed6:	83 ec 0c             	sub    $0xc,%esp
c0104ed9:	ff 75 08             	pushl  0x8(%ebp)
c0104edc:	e8 1f fc ff ff       	call   c0104b00 <free>
c0104ee1:	83 c4 10             	add    $0x10,%esp

	return ptr;
c0104ee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0104ee7:	c9                   	leave  
c0104ee8:	c3                   	ret    

c0104ee9 <liballoc_lock>:
#include <memory.h>
#include <pthread.h>

pthread_spinlock_t lock;

int liballoc_lock() {
c0104ee9:	55                   	push   %ebp
c0104eea:	89 e5                	mov    %esp,%ebp
c0104eec:	83 ec 08             	sub    $0x8,%esp
  return pthread_spin_lock(&lock);
c0104eef:	83 ec 0c             	sub    $0xc,%esp
c0104ef2:	68 00 d8 1c c0       	push   $0xc01cd800
c0104ef7:	e8 94 02 00 00       	call   c0105190 <pthread_spin_lock>
c0104efc:	83 c4 10             	add    $0x10,%esp
}
c0104eff:	c9                   	leave  
c0104f00:	c3                   	ret    

c0104f01 <liballoc_unlock>:

extern int liballoc_unlock() {
c0104f01:	55                   	push   %ebp
c0104f02:	89 e5                	mov    %esp,%ebp
c0104f04:	83 ec 08             	sub    $0x8,%esp
  return pthread_spin_unlock(&lock);
c0104f07:	83 ec 0c             	sub    $0xc,%esp
c0104f0a:	68 00 d8 1c c0       	push   $0xc01cd800
c0104f0f:	e8 97 02 00 00       	call   c01051ab <pthread_spin_unlock>
c0104f14:	83 c4 10             	add    $0x10,%esp
}
c0104f17:	c9                   	leave  
c0104f18:	c3                   	ret    

c0104f19 <liballoc_alloc>:

extern void* liballoc_alloc(size_t num_pages) {
c0104f19:	55                   	push   %ebp
c0104f1a:	89 e5                	mov    %esp,%ebp
c0104f1c:	83 ec 08             	sub    $0x8,%esp
  return alloc_memory(num_pages);
c0104f1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0104f22:	83 ec 0c             	sub    $0xc,%esp
c0104f25:	50                   	push   %eax
c0104f26:	e8 a1 00 00 00       	call   c0104fcc <alloc_memory>
c0104f2b:	83 c4 10             	add    $0x10,%esp
}
c0104f2e:	c9                   	leave  
c0104f2f:	c3                   	ret    

c0104f30 <liballoc_free>:

extern int liballoc_free(void* ptr,size_t num_pages) {
c0104f30:	55                   	push   %ebp
c0104f31:	89 e5                	mov    %esp,%ebp
  return 0;
c0104f33:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0104f38:	5d                   	pop    %ebp
c0104f39:	c3                   	ret    

c0104f3a <ceilf>:
float ceilf(float num) {
c0104f3a:	55                   	push   %ebp
c0104f3b:	89 e5                	mov    %esp,%ebp
c0104f3d:	83 ec 18             	sub    $0x18,%esp
  int inum=(int)num;
c0104f40:	d9 45 08             	flds   0x8(%ebp)
c0104f43:	d9 7d ee             	fnstcw -0x12(%ebp)
c0104f46:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
c0104f4a:	80 cc 0c             	or     $0xc,%ah
c0104f4d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
c0104f51:	d9 6d ec             	fldcw  -0x14(%ebp)
c0104f54:	db 5d fc             	fistpl -0x4(%ebp)
c0104f57:	d9 6d ee             	fldcw  -0x12(%ebp)
  if (num==(float)inum) {
c0104f5a:	db 45 fc             	fildl  -0x4(%ebp)
c0104f5d:	d9 45 08             	flds   0x8(%ebp)
c0104f60:	da e9                	fucompp 
c0104f62:	df e0                	fnstsw %ax
c0104f64:	80 e4 45             	and    $0x45,%ah
c0104f67:	80 f4 40             	xor    $0x40,%ah
c0104f6a:	75 05                	jne    c0104f71 <ceilf+0x37>
    return (float)inum;
c0104f6c:	db 45 fc             	fildl  -0x4(%ebp)
c0104f6f:	eb 0a                	jmp    c0104f7b <ceilf+0x41>
  }
  return (float)(inum+1);
c0104f71:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0104f74:	40                   	inc    %eax
c0104f75:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0104f78:	db 45 e8             	fildl  -0x18(%ebp)
}
c0104f7b:	c9                   	leave  
c0104f7c:	c3                   	ret    

c0104f7d <ceil>:

double ceil(double num) {
c0104f7d:	55                   	push   %ebp
c0104f7e:	89 e5                	mov    %esp,%ebp
c0104f80:	83 ec 20             	sub    $0x20,%esp
c0104f83:	8b 45 08             	mov    0x8(%ebp),%eax
c0104f86:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0104f89:	8b 45 0c             	mov    0xc(%ebp),%eax
c0104f8c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int inum=(int)num;
c0104f8f:	dd 45 e8             	fldl   -0x18(%ebp)
c0104f92:	d9 7d e6             	fnstcw -0x1a(%ebp)
c0104f95:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
c0104f99:	80 cc 0c             	or     $0xc,%ah
c0104f9c:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
c0104fa0:	d9 6d e4             	fldcw  -0x1c(%ebp)
c0104fa3:	db 5d fc             	fistpl -0x4(%ebp)
c0104fa6:	d9 6d e6             	fldcw  -0x1a(%ebp)
  if (num==(double)inum) {
c0104fa9:	db 45 fc             	fildl  -0x4(%ebp)
c0104fac:	dd 45 e8             	fldl   -0x18(%ebp)
c0104faf:	da e9                	fucompp 
c0104fb1:	df e0                	fnstsw %ax
c0104fb3:	80 e4 45             	and    $0x45,%ah
c0104fb6:	80 f4 40             	xor    $0x40,%ah
c0104fb9:	75 05                	jne    c0104fc0 <ceil+0x43>
    return (double)inum;
c0104fbb:	db 45 fc             	fildl  -0x4(%ebp)
c0104fbe:	eb 0a                	jmp    c0104fca <ceil+0x4d>
  }
  return (double)(inum+1);
c0104fc0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0104fc3:	40                   	inc    %eax
c0104fc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0104fc7:	db 45 e0             	fildl  -0x20(%ebp)
}
c0104fca:	c9                   	leave  
c0104fcb:	c3                   	ret    

c0104fcc <alloc_memory>:
#include <sys/syscalls.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void* alloc_memory(int num_pages) {
c0104fcc:	55                   	push   %ebp
c0104fcd:	89 e5                	mov    %esp,%ebp
c0104fcf:	53                   	push   %ebx
c0104fd0:	83 ec 10             	sub    $0x10,%esp
  void* address;
  asm volatile("  \
c0104fd3:	8b 45 08             	mov    0x8(%ebp),%eax
c0104fd6:	ba 00 00 00 00       	mov    $0x0,%edx
c0104fdb:	89 c3                	mov    %eax,%ebx
c0104fdd:	89 d1                	mov    %edx,%ecx
c0104fdf:	b8 07 00 00 00       	mov    $0x7,%eax
c0104fe4:	cd 50                	int    $0x50
c0104fe6:	89 d8                	mov    %ebx,%eax
c0104fe8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_ALLOC_MEM) ", %%eax; \
    int $80; \
  ":"=b"(address):"b"(num_pages),"c"(NULL));
  return address;
c0104feb:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0104fee:	83 c4 10             	add    $0x10,%esp
c0104ff1:	5b                   	pop    %ebx
c0104ff2:	5d                   	pop    %ebp
c0104ff3:	c3                   	ret    

c0104ff4 <alloc_memory_virt>:

void alloc_memory_virt(int num_pages,void* addr) {
c0104ff4:	55                   	push   %ebp
c0104ff5:	89 e5                	mov    %esp,%ebp
c0104ff7:	53                   	push   %ebx
  asm volatile("  \
c0104ff8:	8b 45 08             	mov    0x8(%ebp),%eax
c0104ffb:	8b 55 0c             	mov    0xc(%ebp),%edx
c0104ffe:	89 c3                	mov    %eax,%ebx
c0105000:	89 d1                	mov    %edx,%ecx
c0105002:	b8 07 00 00 00       	mov    $0x7,%eax
c0105007:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_ALLOC_MEM) ", %%eax; \
    int $80; \
  "::"b"(num_pages),"c"(addr));
}
c0105009:	90                   	nop
c010500a:	5b                   	pop    %ebx
c010500b:	5d                   	pop    %ebp
c010500c:	c3                   	ret    

c010500d <new_address_space>:

void* new_address_space() {
c010500d:	55                   	push   %ebp
c010500e:	89 e5                	mov    %esp,%ebp
c0105010:	53                   	push   %ebx
c0105011:	83 ec 10             	sub    $0x10,%esp
  void* address_space;
  asm volatile("  \
c0105014:	b8 09 00 00 00       	mov    $0x9,%eax
c0105019:	cd 50                	int    $0x50
c010501b:	89 d8                	mov    %ebx,%eax
c010501d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_NEW_ADDR_SPACE) ", %%eax; \
    int $80; \
  ":"=b"(address_space));
  return address_space;
c0105020:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0105023:	83 c4 10             	add    $0x10,%esp
c0105026:	5b                   	pop    %ebx
c0105027:	5d                   	pop    %ebp
c0105028:	c3                   	ret    

c0105029 <copy_data>:

void copy_data(void* address_space, void* data,size_t size,void* virt_addr) {
c0105029:	55                   	push   %ebp
c010502a:	89 e5                	mov    %esp,%ebp
c010502c:	56                   	push   %esi
c010502d:	53                   	push   %ebx
  asm volatile("  \
c010502e:	8b 45 08             	mov    0x8(%ebp),%eax
c0105031:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0105034:	8b 55 10             	mov    0x10(%ebp),%edx
c0105037:	8b 75 14             	mov    0x14(%ebp),%esi
c010503a:	89 c3                	mov    %eax,%ebx
c010503c:	b8 0a 00 00 00       	mov    $0xa,%eax
c0105041:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_ADDR_SPACES_COPY_DATA) ", %%eax; \
    int $80; \
  "::"b"(address_space),"c"(data),"d"(size),"S"(virt_addr));
}
c0105043:	90                   	nop
c0105044:	5b                   	pop    %ebx
c0105045:	5e                   	pop    %esi
c0105046:	5d                   	pop    %ebp
c0105047:	c3                   	ret    

c0105048 <put_data>:

void* put_data(void* address_space, void* data,size_t size) {
c0105048:	55                   	push   %ebp
c0105049:	89 e5                	mov    %esp,%ebp
c010504b:	56                   	push   %esi
c010504c:	53                   	push   %ebx
c010504d:	83 ec 10             	sub    $0x10,%esp
  void* virt_addr;
  asm volatile("  \
c0105050:	8b 45 08             	mov    0x8(%ebp),%eax
c0105053:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0105056:	8b 55 10             	mov    0x10(%ebp),%edx
c0105059:	be 00 00 00 00       	mov    $0x0,%esi
c010505e:	89 c3                	mov    %eax,%ebx
c0105060:	b8 0a 00 00 00       	mov    $0xa,%eax
c0105065:	cd 50                	int    $0x50
c0105067:	89 d8                	mov    %ebx,%eax
c0105069:	89 45 f4             	mov    %eax,-0xc(%ebp)
    mov $" QU(SYSCALL_ADDR_SPACES_COPY_DATA) ", %%eax; \
    int $80; \
  ":"=b"(virt_addr):"b"(address_space),"c"(data),"d"(size),"S"(NULL));
  return virt_addr;
c010506c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010506f:	83 c4 10             	add    $0x10,%esp
c0105072:	5b                   	pop    %ebx
c0105073:	5e                   	pop    %esi
c0105074:	5d                   	pop    %ebp
c0105075:	c3                   	ret    

c0105076 <map_phys>:

void* map_phys(void* phys_addr,size_t num_pages) {
c0105076:	55                   	push   %ebp
c0105077:	89 e5                	mov    %esp,%ebp
c0105079:	53                   	push   %ebx
c010507a:	83 ec 10             	sub    $0x10,%esp
  void* virt_addr;
  asm volatile("  \
c010507d:	8b 45 08             	mov    0x8(%ebp),%eax
c0105080:	8b 55 0c             	mov    0xc(%ebp),%edx
c0105083:	89 c3                	mov    %eax,%ebx
c0105085:	89 d1                	mov    %edx,%ecx
c0105087:	b8 08 00 00 00       	mov    $0x8,%eax
c010508c:	cd 50                	int    $0x50
c010508e:	89 d8                	mov    %ebx,%eax
c0105090:	89 45 f8             	mov    %eax,-0x8(%ebp)
    mov $" QU(SYSCALL_PRIV_MAP_PAGES) ", %%eax; \
    int $80; \
  ":"=b"(virt_addr):"b"(phys_addr),"c"(num_pages));
  return virt_addr;
c0105093:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0105096:	83 c4 10             	add    $0x10,%esp
c0105099:	5b                   	pop    %ebx
c010509a:	5d                   	pop    %ebp
c010509b:	c3                   	ret    

c010509c <port_byte_in>:
#include <stdint.h>

uint8_t port_byte_in(uint16_t port) {
c010509c:	55                   	push   %ebp
c010509d:	89 e5                	mov    %esp,%ebp
c010509f:	83 ec 14             	sub    $0x14,%esp
c01050a2:	8b 45 08             	mov    0x8(%ebp),%eax
c01050a5:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  uint8_t result;
  asm("in %%dx, %%al":"=a"(result):"d"(port));
c01050a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01050ac:	89 c2                	mov    %eax,%edx
c01050ae:	ec                   	in     (%dx),%al
c01050af:	88 45 ff             	mov    %al,-0x1(%ebp)
  return result;
c01050b2:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c01050b5:	c9                   	leave  
c01050b6:	c3                   	ret    

c01050b7 <port_byte_out>:

void port_byte_out(uint16_t port,uint8_t data) {
c01050b7:	55                   	push   %ebp
c01050b8:	89 e5                	mov    %esp,%ebp
c01050ba:	83 ec 08             	sub    $0x8,%esp
c01050bd:	8b 45 08             	mov    0x8(%ebp),%eax
c01050c0:	8b 55 0c             	mov    0xc(%ebp),%edx
c01050c3:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c01050c7:	88 d0                	mov    %dl,%al
c01050c9:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm("out %%al, %%dx":: "a"(data),"d"(port));
c01050cc:	8a 45 f8             	mov    -0x8(%ebp),%al
c01050cf:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01050d2:	ee                   	out    %al,(%dx)
}
c01050d3:	90                   	nop
c01050d4:	c9                   	leave  
c01050d5:	c3                   	ret    

c01050d6 <port_word_in>:

uint16_t port_word_in(uint16_t port) {
c01050d6:	55                   	push   %ebp
c01050d7:	89 e5                	mov    %esp,%ebp
c01050d9:	83 ec 14             	sub    $0x14,%esp
c01050dc:	8b 45 08             	mov    0x8(%ebp),%eax
c01050df:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  uint16_t result;
  asm("in %%dx, %%ax":"=a"(result):"d"(port));
c01050e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01050e6:	89 c2                	mov    %eax,%edx
c01050e8:	66 ed                	in     (%dx),%ax
c01050ea:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return result;
c01050ee:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
}
c01050f2:	c9                   	leave  
c01050f3:	c3                   	ret    

c01050f4 <port_word_out>:

void port_word_out(uint16_t port,uint16_t data) {
c01050f4:	55                   	push   %ebp
c01050f5:	89 e5                	mov    %esp,%ebp
c01050f7:	83 ec 08             	sub    $0x8,%esp
c01050fa:	8b 55 08             	mov    0x8(%ebp),%edx
c01050fd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105100:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0105104:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  asm("out %%ax, %%dx":: "a" (data), "d" (port));
c0105108:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010510b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010510e:	66 ef                	out    %ax,(%dx)
}
c0105110:	90                   	nop
c0105111:	c9                   	leave  
c0105112:	c3                   	ret    

c0105113 <port_long_in>:

uint32_t port_long_in(uint16_t port) {
c0105113:	55                   	push   %ebp
c0105114:	89 e5                	mov    %esp,%ebp
c0105116:	83 ec 14             	sub    $0x14,%esp
c0105119:	8b 45 08             	mov    0x8(%ebp),%eax
c010511c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  uint32_t result;
  asm("inl %%dx, %%eax":"=a"(result):"d"(port));
c0105120:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105123:	89 c2                	mov    %eax,%edx
c0105125:	ed                   	in     (%dx),%eax
c0105126:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return result;
c0105129:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c010512c:	c9                   	leave  
c010512d:	c3                   	ret    

c010512e <port_long_out>:

void port_long_out(uint16_t port,uint32_t data) {
c010512e:	55                   	push   %ebp
c010512f:	89 e5                	mov    %esp,%ebp
c0105131:	83 ec 04             	sub    $0x4,%esp
c0105134:	8b 45 08             	mov    0x8(%ebp),%eax
c0105137:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  asm("outl %%eax, %%dx":: "a" (data), "d" (port));
c010513b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010513e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0105141:	ef                   	out    %eax,(%dx)
}
c0105142:	90                   	nop
c0105143:	c9                   	leave  
c0105144:	c3                   	ret    

c0105145 <pthread_create>:
#include <__helpers.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start_routine)(void*), void *restrict arg) {
c0105145:	55                   	push   %ebp
c0105146:	89 e5                	mov    %esp,%ebp
c0105148:	53                   	push   %ebx
  if (thread==NULL) {
c0105149:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010514d:	75 07                	jne    c0105156 <pthread_create+0x11>
    return 1;
c010514f:	b8 01 00 00 00       	mov    $0x1,%eax
c0105154:	eb 17                	jmp    c010516d <pthread_create+0x28>
  }
  asm volatile("  \
c0105156:	8b 45 10             	mov    0x10(%ebp),%eax
c0105159:	8b 4d 08             	mov    0x8(%ebp),%ecx
c010515c:	8b 55 14             	mov    0x14(%ebp),%edx
c010515f:	89 c3                	mov    %eax,%ebx
c0105161:	b8 0e 00 00 00       	mov    $0xe,%eax
c0105166:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_NEW_THREAD) ", %%eax; \
    int $80; \
  "::"b"(start_routine),"c"(thread),"d"(arg));
  return 0;
c0105168:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010516d:	5b                   	pop    %ebx
c010516e:	5d                   	pop    %ebp
c010516f:	c3                   	ret    

c0105170 <pthread_exit>:

void pthread_exit(void *value_ptr) {
c0105170:	55                   	push   %ebp
c0105171:	89 e5                	mov    %esp,%ebp
  asm volatile("  \
c0105173:	b8 13 00 00 00       	mov    $0x13,%eax
c0105178:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_THREAD_EXIT) ", %eax; \
    int $80;");
}
c010517a:	90                   	nop
c010517b:	5d                   	pop    %ebp
c010517c:	c3                   	ret    

c010517d <pthread_spin_init>:

int pthread_spin_init(pthread_spinlock_t *lock, int pshared) {
c010517d:	55                   	push   %ebp
c010517e:	89 e5                	mov    %esp,%ebp
  *lock=0;
c0105180:	8b 45 08             	mov    0x8(%ebp),%eax
c0105183:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  return 0;
c0105189:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010518e:	5d                   	pop    %ebp
c010518f:	c3                   	ret    

c0105190 <pthread_spin_lock>:

int pthread_spin_lock(pthread_spinlock_t *lock) {
c0105190:	55                   	push   %ebp
c0105191:	89 e5                	mov    %esp,%ebp
c0105193:	83 ec 08             	sub    $0x8,%esp
  __pthread_spin_lock_helper(lock);
c0105196:	83 ec 0c             	sub    $0xc,%esp
c0105199:	ff 75 08             	pushl  0x8(%ebp)
c010519c:	e8 6f 05 00 00       	call   c0105710 <__pthread_spin_lock_helper>
c01051a1:	83 c4 10             	add    $0x10,%esp
  return 0;
c01051a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01051a9:	c9                   	leave  
c01051aa:	c3                   	ret    

c01051ab <pthread_spin_unlock>:

int pthread_spin_unlock(pthread_spinlock_t *lock) {
c01051ab:	55                   	push   %ebp
c01051ac:	89 e5                	mov    %esp,%ebp
  *lock=0;
c01051ae:	8b 45 08             	mov    0x8(%ebp),%eax
c01051b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  return 0;
c01051b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01051bc:	5d                   	pop    %ebp
c01051bd:	c3                   	ret    

c01051be <pthread_spin_destroy>:

int pthread_spin_destroy(pthread_spinlock_t *lock) {
c01051be:	55                   	push   %ebp
c01051bf:	89 e5                	mov    %esp,%ebp
  return 0;
c01051c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01051c6:	5d                   	pop    %ebp
c01051c7:	c3                   	ret    

c01051c8 <memcpy>:
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

void* memcpy(void* dest_ptr,const void* source_ptr,size_t len) {
c01051c8:	55                   	push   %ebp
c01051c9:	89 e5                	mov    %esp,%ebp
c01051cb:	83 ec 10             	sub    $0x10,%esp
    char* source=(char*)source_ptr;
c01051ce:	8b 45 0c             	mov    0xc(%ebp),%eax
c01051d1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char* dest=(char*)dest_ptr;
c01051d4:	8b 45 08             	mov    0x8(%ebp),%eax
c01051d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(size_t i=0;i<len;i++) {
c01051da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01051e1:	eb 17                	jmp    c01051fa <memcpy+0x32>
      dest[i]=source[i];
c01051e3:	8b 55 f8             	mov    -0x8(%ebp),%edx
c01051e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01051e9:	01 d0                	add    %edx,%eax
c01051eb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c01051ee:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01051f1:	01 ca                	add    %ecx,%edx
c01051f3:	8a 00                	mov    (%eax),%al
c01051f5:	88 02                	mov    %al,(%edx)
    for(size_t i=0;i<len;i++) {
c01051f7:	ff 45 fc             	incl   -0x4(%ebp)
c01051fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01051fd:	3b 45 10             	cmp    0x10(%ebp),%eax
c0105200:	72 e1                	jb     c01051e3 <memcpy+0x1b>
    }
    return dest_ptr;
c0105202:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0105205:	c9                   	leave  
c0105206:	c3                   	ret    

c0105207 <memset>:

void* memset(void *dest_ptr,int val,size_t len) {
c0105207:	55                   	push   %ebp
c0105208:	89 e5                	mov    %esp,%ebp
c010520a:	83 ec 10             	sub    $0x10,%esp
    char* dest=(char*)dest_ptr;
c010520d:	8b 45 08             	mov    0x8(%ebp),%eax
c0105210:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (size_t i=0;i<len;i++){
c0105213:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010521a:	eb 10                	jmp    c010522c <memset+0x25>
      dest[i]=(char)val;
c010521c:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010521f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0105222:	01 d0                	add    %edx,%eax
c0105224:	8b 55 0c             	mov    0xc(%ebp),%edx
c0105227:	88 10                	mov    %dl,(%eax)
    for (size_t i=0;i<len;i++){
c0105229:	ff 45 fc             	incl   -0x4(%ebp)
c010522c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010522f:	3b 45 10             	cmp    0x10(%ebp),%eax
c0105232:	72 e8                	jb     c010521c <memset+0x15>
    }
    return dest_ptr;
c0105234:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0105237:	c9                   	leave  
c0105238:	c3                   	ret    

c0105239 <strcmp>:

int strcmp(const char* s1,const char* s2) {
c0105239:	55                   	push   %ebp
c010523a:	89 e5                	mov    %esp,%ebp
c010523c:	83 ec 10             	sub    $0x10,%esp
    int i;
    for (i = 0; s1[i] == s2[i]; i++) {
c010523f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0105246:	eb 18                	jmp    c0105260 <strcmp+0x27>
        if (s1[i] == '\0') return 0;
c0105248:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010524b:	8b 45 08             	mov    0x8(%ebp),%eax
c010524e:	01 d0                	add    %edx,%eax
c0105250:	8a 00                	mov    (%eax),%al
c0105252:	84 c0                	test   %al,%al
c0105254:	75 07                	jne    c010525d <strcmp+0x24>
c0105256:	b8 00 00 00 00       	mov    $0x0,%eax
c010525b:	eb 39                	jmp    c0105296 <strcmp+0x5d>
    for (i = 0; s1[i] == s2[i]; i++) {
c010525d:	ff 45 fc             	incl   -0x4(%ebp)
c0105260:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0105263:	8b 45 08             	mov    0x8(%ebp),%eax
c0105266:	01 d0                	add    %edx,%eax
c0105268:	8a 10                	mov    (%eax),%dl
c010526a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c010526d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0105270:	01 c8                	add    %ecx,%eax
c0105272:	8a 00                	mov    (%eax),%al
c0105274:	38 c2                	cmp    %al,%dl
c0105276:	74 d0                	je     c0105248 <strcmp+0xf>
    }
    return s1[i] - s2[i];
c0105278:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010527b:	8b 45 08             	mov    0x8(%ebp),%eax
c010527e:	01 d0                	add    %edx,%eax
c0105280:	8a 00                	mov    (%eax),%al
c0105282:	0f be d0             	movsbl %al,%edx
c0105285:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c0105288:	8b 45 0c             	mov    0xc(%ebp),%eax
c010528b:	01 c8                	add    %ecx,%eax
c010528d:	8a 00                	mov    (%eax),%al
c010528f:	0f be c0             	movsbl %al,%eax
c0105292:	29 c2                	sub    %eax,%edx
c0105294:	89 d0                	mov    %edx,%eax
}
c0105296:	c9                   	leave  
c0105297:	c3                   	ret    

c0105298 <strlen>:

size_t strlen(const char* str) {
c0105298:	55                   	push   %ebp
c0105299:	89 e5                	mov    %esp,%ebp
c010529b:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for (i=0;str[i]!='\0';i++);
c010529e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01052a5:	eb 03                	jmp    c01052aa <strlen+0x12>
c01052a7:	ff 45 fc             	incl   -0x4(%ebp)
c01052aa:	8b 55 08             	mov    0x8(%ebp),%edx
c01052ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01052b0:	01 d0                	add    %edx,%eax
c01052b2:	8a 00                	mov    (%eax),%al
c01052b4:	84 c0                	test   %al,%al
c01052b6:	75 ef                	jne    c01052a7 <strlen+0xf>
  return i;
c01052b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c01052bb:	c9                   	leave  
c01052bc:	c3                   	ret    

c01052bd <strcpy>:

char* strcpy(char* dest,const char* src) {
c01052bd:	55                   	push   %ebp
c01052be:	89 e5                	mov    %esp,%ebp
c01052c0:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for (i=0;i<strlen(src);i++) {
c01052c3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01052ca:	eb 17                	jmp    c01052e3 <strcpy+0x26>
    dest[i]=src[i];
c01052cc:	8b 55 0c             	mov    0xc(%ebp),%edx
c01052cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01052d2:	01 d0                	add    %edx,%eax
c01052d4:	8b 4d 08             	mov    0x8(%ebp),%ecx
c01052d7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01052da:	01 ca                	add    %ecx,%edx
c01052dc:	8a 00                	mov    (%eax),%al
c01052de:	88 02                	mov    %al,(%edx)
  for (i=0;i<strlen(src);i++) {
c01052e0:	ff 45 fc             	incl   -0x4(%ebp)
c01052e3:	ff 75 0c             	pushl  0xc(%ebp)
c01052e6:	e8 ad ff ff ff       	call   c0105298 <strlen>
c01052eb:	83 c4 04             	add    $0x4,%esp
c01052ee:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c01052f1:	72 d9                	jb     c01052cc <strcpy+0xf>
  }
  dest[i]='\0';
c01052f3:	8b 55 08             	mov    0x8(%ebp),%edx
c01052f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01052f9:	01 d0                	add    %edx,%eax
c01052fb:	c6 00 00             	movb   $0x0,(%eax)
  return dest;
c01052fe:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0105301:	c9                   	leave  
c0105302:	c3                   	ret    

c0105303 <strrev>:

char* strrev(char* str) {
c0105303:	55                   	push   %ebp
c0105304:	89 e5                	mov    %esp,%ebp
c0105306:	83 ec 10             	sub    $0x10,%esp
    char chr;
    int i,j;
    for (i=0,j=strlen(str)-1;i<j;i++,j--) {
c0105309:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0105310:	ff 75 08             	pushl  0x8(%ebp)
c0105313:	e8 80 ff ff ff       	call   c0105298 <strlen>
c0105318:	83 c4 04             	add    $0x4,%esp
c010531b:	48                   	dec    %eax
c010531c:	89 45 f8             	mov    %eax,-0x8(%ebp)
c010531f:	eb 34                	jmp    c0105355 <strrev+0x52>
      chr=str[i];
c0105321:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0105324:	8b 45 08             	mov    0x8(%ebp),%eax
c0105327:	01 d0                	add    %edx,%eax
c0105329:	8a 00                	mov    (%eax),%al
c010532b:	88 45 f7             	mov    %al,-0x9(%ebp)
      str[i]=str[j];
c010532e:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0105331:	8b 45 08             	mov    0x8(%ebp),%eax
c0105334:	01 d0                	add    %edx,%eax
c0105336:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c0105339:	8b 55 08             	mov    0x8(%ebp),%edx
c010533c:	01 ca                	add    %ecx,%edx
c010533e:	8a 00                	mov    (%eax),%al
c0105340:	88 02                	mov    %al,(%edx)
      str[j]=chr;
c0105342:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0105345:	8b 45 08             	mov    0x8(%ebp),%eax
c0105348:	01 c2                	add    %eax,%edx
c010534a:	8a 45 f7             	mov    -0x9(%ebp),%al
c010534d:	88 02                	mov    %al,(%edx)
    for (i=0,j=strlen(str)-1;i<j;i++,j--) {
c010534f:	ff 45 fc             	incl   -0x4(%ebp)
c0105352:	ff 4d f8             	decl   -0x8(%ebp)
c0105355:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0105358:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c010535b:	7c c4                	jl     c0105321 <strrev+0x1e>
    }
    return str;
c010535d:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0105360:	c9                   	leave  
c0105361:	c3                   	ret    

c0105362 <int_to_ascii>:

void int_to_ascii(int n,char* str) {
c0105362:	55                   	push   %ebp
c0105363:	89 e5                	mov    %esp,%ebp
c0105365:	83 ec 10             	sub    $0x10,%esp
    int i;
    int sign;
    if ((sign = n)<0) {
c0105368:	8b 45 08             	mov    0x8(%ebp),%eax
c010536b:	89 45 f8             	mov    %eax,-0x8(%ebp)
c010536e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0105372:	79 03                	jns    c0105377 <int_to_ascii+0x15>
      n=-n;
c0105374:	f7 5d 08             	negl   0x8(%ebp)
    }
    i=0;
c0105377:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    do {
      str[i++]=n%10+'0';
c010537e:	8b 45 08             	mov    0x8(%ebp),%eax
c0105381:	b9 0a 00 00 00       	mov    $0xa,%ecx
c0105386:	99                   	cltd   
c0105387:	f7 f9                	idiv   %ecx
c0105389:	89 d0                	mov    %edx,%eax
c010538b:	8d 48 30             	lea    0x30(%eax),%ecx
c010538e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0105391:	8d 50 01             	lea    0x1(%eax),%edx
c0105394:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0105397:	89 c2                	mov    %eax,%edx
c0105399:	8b 45 0c             	mov    0xc(%ebp),%eax
c010539c:	01 d0                	add    %edx,%eax
c010539e:	88 ca                	mov    %cl,%dl
c01053a0:	88 10                	mov    %dl,(%eax)
    } while ((n /= 10) > 0);
c01053a2:	8b 4d 08             	mov    0x8(%ebp),%ecx
c01053a5:	b8 67 66 66 66       	mov    $0x66666667,%eax
c01053aa:	f7 e9                	imul   %ecx
c01053ac:	c1 fa 02             	sar    $0x2,%edx
c01053af:	89 c8                	mov    %ecx,%eax
c01053b1:	c1 f8 1f             	sar    $0x1f,%eax
c01053b4:	29 c2                	sub    %eax,%edx
c01053b6:	89 d0                	mov    %edx,%eax
c01053b8:	89 45 08             	mov    %eax,0x8(%ebp)
c01053bb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c01053bf:	7f bd                	jg     c010537e <int_to_ascii+0x1c>
    if (sign < 0) {
c01053c1:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c01053c5:	79 13                	jns    c01053da <int_to_ascii+0x78>
      str[i++] = '-';
c01053c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01053ca:	8d 50 01             	lea    0x1(%eax),%edx
c01053cd:	89 55 fc             	mov    %edx,-0x4(%ebp)
c01053d0:	89 c2                	mov    %eax,%edx
c01053d2:	8b 45 0c             	mov    0xc(%ebp),%eax
c01053d5:	01 d0                	add    %edx,%eax
c01053d7:	c6 00 2d             	movb   $0x2d,(%eax)
    }
    str[i]='\0';
c01053da:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01053dd:	8b 45 0c             	mov    0xc(%ebp),%eax
c01053e0:	01 d0                	add    %edx,%eax
c01053e2:	c6 00 00             	movb   $0x0,(%eax)
    strrev(str);
c01053e5:	ff 75 0c             	pushl  0xc(%ebp)
c01053e8:	e8 16 ff ff ff       	call   c0105303 <strrev>
c01053ed:	83 c4 04             	add    $0x4,%esp
}
c01053f0:	90                   	nop
c01053f1:	c9                   	leave  
c01053f2:	c3                   	ret    

c01053f3 <hex_to_ascii>:

void hex_to_ascii(unsigned int n, char* str) {
c01053f3:	55                   	push   %ebp
c01053f4:	89 e5                	mov    %esp,%ebp
c01053f6:	83 ec 18             	sub    $0x18,%esp
    str[0]='\0'; 
c01053f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c01053fc:	c6 00 00             	movb   $0x0,(%eax)
    append(str, '0');
c01053ff:	83 ec 08             	sub    $0x8,%esp
c0105402:	6a 30                	push   $0x30
c0105404:	ff 75 0c             	pushl  0xc(%ebp)
c0105407:	e8 cb 00 00 00       	call   c01054d7 <append>
c010540c:	83 c4 10             	add    $0x10,%esp
    append(str, 'x');
c010540f:	83 ec 08             	sub    $0x8,%esp
c0105412:	6a 78                	push   $0x78
c0105414:	ff 75 0c             	pushl  0xc(%ebp)
c0105417:	e8 bb 00 00 00       	call   c01054d7 <append>
c010541c:	83 c4 10             	add    $0x10,%esp
    char zeros = 0;
c010541f:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

    unsigned int tmp;
    int i;
    for (i = 28; i > 0; i -= 4) {
c0105423:	c7 45 f0 1c 00 00 00 	movl   $0x1c,-0x10(%ebp)
c010542a:	eb 61                	jmp    c010548d <hex_to_ascii+0x9a>
        tmp = (n >> i) & 0xF;
c010542c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010542f:	8b 55 08             	mov    0x8(%ebp),%edx
c0105432:	88 c1                	mov    %al,%cl
c0105434:	d3 ea                	shr    %cl,%edx
c0105436:	89 d0                	mov    %edx,%eax
c0105438:	83 e0 0f             	and    $0xf,%eax
c010543b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (tmp == 0 && zeros == 0) continue;
c010543e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0105442:	75 06                	jne    c010544a <hex_to_ascii+0x57>
c0105444:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0105448:	74 3e                	je     c0105488 <hex_to_ascii+0x95>
        zeros = 1;
c010544a:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
        if (tmp >= 0xA) append(str, tmp - 0xA + 'a');
c010544e:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
c0105452:	76 1a                	jbe    c010546e <hex_to_ascii+0x7b>
c0105454:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105457:	83 c0 57             	add    $0x57,%eax
c010545a:	0f be c0             	movsbl %al,%eax
c010545d:	83 ec 08             	sub    $0x8,%esp
c0105460:	50                   	push   %eax
c0105461:	ff 75 0c             	pushl  0xc(%ebp)
c0105464:	e8 6e 00 00 00       	call   c01054d7 <append>
c0105469:	83 c4 10             	add    $0x10,%esp
c010546c:	eb 1b                	jmp    c0105489 <hex_to_ascii+0x96>
        else append(str, tmp + '0');
c010546e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0105471:	83 c0 30             	add    $0x30,%eax
c0105474:	0f be c0             	movsbl %al,%eax
c0105477:	83 ec 08             	sub    $0x8,%esp
c010547a:	50                   	push   %eax
c010547b:	ff 75 0c             	pushl  0xc(%ebp)
c010547e:	e8 54 00 00 00       	call   c01054d7 <append>
c0105483:	83 c4 10             	add    $0x10,%esp
c0105486:	eb 01                	jmp    c0105489 <hex_to_ascii+0x96>
        if (tmp == 0 && zeros == 0) continue;
c0105488:	90                   	nop
    for (i = 28; i > 0; i -= 4) {
c0105489:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
c010548d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0105491:	7f 99                	jg     c010542c <hex_to_ascii+0x39>
    }

    tmp = n & 0xF;
c0105493:	8b 45 08             	mov    0x8(%ebp),%eax
c0105496:	83 e0 0f             	and    $0xf,%eax
c0105499:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (tmp >= 0xA) append(str, tmp - 0xA + 'a');
c010549c:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
c01054a0:	76 1a                	jbe    c01054bc <hex_to_ascii+0xc9>
c01054a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01054a5:	83 c0 57             	add    $0x57,%eax
c01054a8:	0f be c0             	movsbl %al,%eax
c01054ab:	83 ec 08             	sub    $0x8,%esp
c01054ae:	50                   	push   %eax
c01054af:	ff 75 0c             	pushl  0xc(%ebp)
c01054b2:	e8 20 00 00 00       	call   c01054d7 <append>
c01054b7:	83 c4 10             	add    $0x10,%esp
    else append(str, tmp + '0');
}
c01054ba:	eb 18                	jmp    c01054d4 <hex_to_ascii+0xe1>
    else append(str, tmp + '0');
c01054bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01054bf:	83 c0 30             	add    $0x30,%eax
c01054c2:	0f be c0             	movsbl %al,%eax
c01054c5:	83 ec 08             	sub    $0x8,%esp
c01054c8:	50                   	push   %eax
c01054c9:	ff 75 0c             	pushl  0xc(%ebp)
c01054cc:	e8 06 00 00 00       	call   c01054d7 <append>
c01054d1:	83 c4 10             	add    $0x10,%esp
}
c01054d4:	90                   	nop
c01054d5:	c9                   	leave  
c01054d6:	c3                   	ret    

c01054d7 <append>:

void append(char* s, char n) {
c01054d7:	55                   	push   %ebp
c01054d8:	89 e5                	mov    %esp,%ebp
c01054da:	83 ec 14             	sub    $0x14,%esp
c01054dd:	8b 45 0c             	mov    0xc(%ebp),%eax
c01054e0:	88 45 ec             	mov    %al,-0x14(%ebp)
    int len = strlen(s);
c01054e3:	ff 75 08             	pushl  0x8(%ebp)
c01054e6:	e8 ad fd ff ff       	call   c0105298 <strlen>
c01054eb:	83 c4 04             	add    $0x4,%esp
c01054ee:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s[len] = n;
c01054f1:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01054f4:	8b 45 08             	mov    0x8(%ebp),%eax
c01054f7:	01 c2                	add    %eax,%edx
c01054f9:	8a 45 ec             	mov    -0x14(%ebp),%al
c01054fc:	88 02                	mov    %al,(%edx)
    s[len+1] = '\0';
c01054fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0105501:	8d 50 01             	lea    0x1(%eax),%edx
c0105504:	8b 45 08             	mov    0x8(%ebp),%eax
c0105507:	01 d0                	add    %edx,%eax
c0105509:	c6 00 00             	movb   $0x0,(%eax)
}
c010550c:	90                   	nop
c010550d:	c9                   	leave  
c010550e:	c3                   	ret    

c010550f <backspace>:

void backspace(char* s) {
c010550f:	55                   	push   %ebp
c0105510:	89 e5                	mov    %esp,%ebp
c0105512:	83 ec 10             	sub    $0x10,%esp
    int len = strlen(s);
c0105515:	ff 75 08             	pushl  0x8(%ebp)
c0105518:	e8 7b fd ff ff       	call   c0105298 <strlen>
c010551d:	83 c4 04             	add    $0x4,%esp
c0105520:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s[len-1] = '\0';
c0105523:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0105526:	8d 50 ff             	lea    -0x1(%eax),%edx
c0105529:	8b 45 08             	mov    0x8(%ebp),%eax
c010552c:	01 d0                	add    %edx,%eax
c010552e:	c6 00 00             	movb   $0x0,(%eax)
}
c0105531:	90                   	nop
c0105532:	c9                   	leave  
c0105533:	c3                   	ret    

c0105534 <strtok_delim_check>:

static const char* strtok_str=NULL;
static size_t strtok_index;

static char strtok_delim_check(const char* delim) {
c0105534:	55                   	push   %ebp
c0105535:	89 e5                	mov    %esp,%ebp
c0105537:	83 ec 10             	sub    $0x10,%esp
  for (size_t i=0;i<strlen(delim);i++) {
c010553a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0105541:	eb 37                	jmp    c010557a <strtok_delim_check+0x46>
    if (strtok_str[strtok_index]==delim[i]||strtok_str[strtok_index]=='\0') {
c0105543:	8b 15 50 4d 3e c0    	mov    0xc03e4d50,%edx
c0105549:	a1 54 4d 3e c0       	mov    0xc03e4d54,%eax
c010554e:	01 d0                	add    %edx,%eax
c0105550:	8a 10                	mov    (%eax),%dl
c0105552:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0105555:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0105558:	01 c8                	add    %ecx,%eax
c010555a:	8a 00                	mov    (%eax),%al
c010555c:	38 c2                	cmp    %al,%dl
c010555e:	74 13                	je     c0105573 <strtok_delim_check+0x3f>
c0105560:	8b 15 50 4d 3e c0    	mov    0xc03e4d50,%edx
c0105566:	a1 54 4d 3e c0       	mov    0xc03e4d54,%eax
c010556b:	01 d0                	add    %edx,%eax
c010556d:	8a 00                	mov    (%eax),%al
c010556f:	84 c0                	test   %al,%al
c0105571:	75 04                	jne    c0105577 <strtok_delim_check+0x43>
      return 0;
c0105573:	b0 00                	mov    $0x0,%al
c0105575:	eb 15                	jmp    c010558c <strtok_delim_check+0x58>
  for (size_t i=0;i<strlen(delim);i++) {
c0105577:	ff 45 fc             	incl   -0x4(%ebp)
c010557a:	ff 75 08             	pushl  0x8(%ebp)
c010557d:	e8 16 fd ff ff       	call   c0105298 <strlen>
c0105582:	83 c4 04             	add    $0x4,%esp
c0105585:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c0105588:	72 b9                	jb     c0105543 <strtok_delim_check+0xf>
    }
  }
  return 1;
c010558a:	b0 01                	mov    $0x1,%al
}
c010558c:	c9                   	leave  
c010558d:	c3                   	ret    

c010558e <strtok>:

char* strtok(const char* str, const char* delim) {
c010558e:	55                   	push   %ebp
c010558f:	89 e5                	mov    %esp,%ebp
c0105591:	83 ec 18             	sub    $0x18,%esp
  if (str!=NULL) {
c0105594:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0105598:	74 12                	je     c01055ac <strtok+0x1e>
    strtok_str=str;
c010559a:	8b 45 08             	mov    0x8(%ebp),%eax
c010559d:	a3 50 4d 3e c0       	mov    %eax,0xc03e4d50
    strtok_index=0;
c01055a2:	c7 05 54 4d 3e c0 00 	movl   $0x0,0xc03e4d54
c01055a9:	00 00 00 
  }
  if (!strtok_str || strtok_index>strlen(strtok_str)) {
c01055ac:	a1 50 4d 3e c0       	mov    0xc03e4d50,%eax
c01055b1:	85 c0                	test   %eax,%eax
c01055b3:	74 18                	je     c01055cd <strtok+0x3f>
c01055b5:	a1 50 4d 3e c0       	mov    0xc03e4d50,%eax
c01055ba:	50                   	push   %eax
c01055bb:	e8 d8 fc ff ff       	call   c0105298 <strlen>
c01055c0:	83 c4 04             	add    $0x4,%esp
c01055c3:	8b 15 54 4d 3e c0    	mov    0xc03e4d54,%edx
c01055c9:	39 d0                	cmp    %edx,%eax
c01055cb:	73 0a                	jae    c01055d7 <strtok+0x49>
    return NULL;
c01055cd:	b8 00 00 00 00       	mov    $0x0,%eax
c01055d2:	e9 9b 00 00 00       	jmp    c0105672 <strtok+0xe4>
  }
  char* tok=malloc(sizeof(char)*32);
c01055d7:	83 ec 0c             	sub    $0xc,%esp
c01055da:	6a 20                	push   $0x20
c01055dc:	e8 93 ee ff ff       	call   c0104474 <malloc>
c01055e1:	83 c4 10             	add    $0x10,%esp
c01055e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  tok[0]='\0';
c01055e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01055ea:	c6 00 00             	movb   $0x0,(%eax)
  size_t max_len=32;
c01055ed:	c7 45 f0 20 00 00 00 	movl   $0x20,-0x10(%ebp)
  for (;strtok_delim_check(delim);strtok_index++) {
c01055f4:	eb 5c                	jmp    c0105652 <strtok+0xc4>
    if (strlen(tok)+1==max_len) {
c01055f6:	83 ec 0c             	sub    $0xc,%esp
c01055f9:	ff 75 f4             	pushl  -0xc(%ebp)
c01055fc:	e8 97 fc ff ff       	call   c0105298 <strlen>
c0105601:	83 c4 10             	add    $0x10,%esp
c0105604:	40                   	inc    %eax
c0105605:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0105608:	75 1c                	jne    c0105626 <strtok+0x98>
      tok=realloc(tok,sizeof(char)*(max_len+32));
c010560a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010560d:	83 c0 20             	add    $0x20,%eax
c0105610:	83 ec 08             	sub    $0x8,%esp
c0105613:	50                   	push   %eax
c0105614:	ff 75 f4             	pushl  -0xc(%ebp)
c0105617:	e8 7b f7 ff ff       	call   c0104d97 <realloc>
c010561c:	83 c4 10             	add    $0x10,%esp
c010561f:	89 45 f4             	mov    %eax,-0xc(%ebp)
      max_len+=32;
c0105622:	83 45 f0 20          	addl   $0x20,-0x10(%ebp)
    }
    append(tok,strtok_str[strtok_index]);
c0105626:	8b 15 50 4d 3e c0    	mov    0xc03e4d50,%edx
c010562c:	a1 54 4d 3e c0       	mov    0xc03e4d54,%eax
c0105631:	01 d0                	add    %edx,%eax
c0105633:	8a 00                	mov    (%eax),%al
c0105635:	0f be c0             	movsbl %al,%eax
c0105638:	83 ec 08             	sub    $0x8,%esp
c010563b:	50                   	push   %eax
c010563c:	ff 75 f4             	pushl  -0xc(%ebp)
c010563f:	e8 93 fe ff ff       	call   c01054d7 <append>
c0105644:	83 c4 10             	add    $0x10,%esp
  for (;strtok_delim_check(delim);strtok_index++) {
c0105647:	a1 54 4d 3e c0       	mov    0xc03e4d54,%eax
c010564c:	40                   	inc    %eax
c010564d:	a3 54 4d 3e c0       	mov    %eax,0xc03e4d54
c0105652:	83 ec 0c             	sub    $0xc,%esp
c0105655:	ff 75 0c             	pushl  0xc(%ebp)
c0105658:	e8 d7 fe ff ff       	call   c0105534 <strtok_delim_check>
c010565d:	83 c4 10             	add    $0x10,%esp
c0105660:	84 c0                	test   %al,%al
c0105662:	75 92                	jne    c01055f6 <strtok+0x68>
  }
  strtok_index++;
c0105664:	a1 54 4d 3e c0       	mov    0xc03e4d54,%eax
c0105669:	40                   	inc    %eax
c010566a:	a3 54 4d 3e c0       	mov    %eax,0xc03e4d54
  return tok;
c010566f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0105672:	c9                   	leave  
c0105673:	c3                   	ret    

c0105674 <yield>:
#include <tasking.h>

#define QUAUX(X) #X
#define QU(X) QUAUX(X)

void yield() {
c0105674:	55                   	push   %ebp
c0105675:	89 e5                	mov    %esp,%ebp
c0105677:	53                   	push   %ebx
  asm volatile("  \
c0105678:	b8 00 00 00 00       	mov    $0x0,%eax
c010567d:	89 c3                	mov    %eax,%ebx
c010567f:	b8 01 00 00 00       	mov    $0x1,%eax
c0105684:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_YIELD) ", %%eax; \
    int $80; \
  "::"b"(0));
}
c0105686:	90                   	nop
c0105687:	5b                   	pop    %ebx
c0105688:	5d                   	pop    %ebp
c0105689:	c3                   	ret    

c010568a <create_proc>:

void create_proc(void* start,void* address_space,void* param1,void* param2) {
c010568a:	55                   	push   %ebp
c010568b:	89 e5                	mov    %esp,%ebp
c010568d:	56                   	push   %esi
c010568e:	53                   	push   %ebx
  asm volatile("  \
c010568f:	8b 45 08             	mov    0x8(%ebp),%eax
c0105692:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0105695:	8b 55 10             	mov    0x10(%ebp),%edx
c0105698:	8b 75 14             	mov    0x14(%ebp),%esi
c010569b:	89 c3                	mov    %eax,%ebx
c010569d:	b8 00 00 00 00       	mov    $0x0,%eax
c01056a2:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_CREATEPROC) ", %%eax; \
    int $80; \
  "::"b"(start),"c"(address_space),"d"(param1),"S"(param2));
}
c01056a4:	90                   	nop
c01056a5:	5b                   	pop    %ebx
c01056a6:	5e                   	pop    %esi
c01056a7:	5d                   	pop    %ebp
c01056a8:	c3                   	ret    

c01056a9 <exit>:

__attribute__((noreturn)) void exit(int code) {
c01056a9:	55                   	push   %ebp
c01056aa:	89 e5                	mov    %esp,%ebp
c01056ac:	53                   	push   %ebx
  code=code&0xff;
c01056ad:	81 65 08 ff 00 00 00 	andl   $0xff,0x8(%ebp)
  asm volatile("  \
c01056b4:	8b 45 08             	mov    0x8(%ebp),%eax
c01056b7:	89 c3                	mov    %eax,%ebx
c01056b9:	b8 04 00 00 00       	mov    $0x4,%eax
c01056be:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_EXIT) ", %%eax; \
    int $80; \
  "::"b"(code));
  for(;;);
c01056c0:	eb fe                	jmp    c01056c0 <exit+0x17>

c01056c2 <block_thread>:
}


void block_thread(thread_state state) {
c01056c2:	55                   	push   %ebp
c01056c3:	89 e5                	mov    %esp,%ebp
c01056c5:	53                   	push   %ebx
  asm volatile("  \
c01056c6:	8b 45 08             	mov    0x8(%ebp),%eax
c01056c9:	89 c3                	mov    %eax,%ebx
c01056cb:	b8 02 00 00 00       	mov    $0x2,%eax
c01056d0:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_BLOCK) ", %%eax; \
    int $80; \
  "::"b"(state));
}
c01056d2:	90                   	nop
c01056d3:	5b                   	pop    %ebx
c01056d4:	5d                   	pop    %ebp
c01056d5:	c3                   	ret    

c01056d6 <unblock_thread>:

void unblock_thread(pid_t pid,pid_t tid) {
c01056d6:	55                   	push   %ebp
c01056d7:	89 e5                	mov    %esp,%ebp
c01056d9:	53                   	push   %ebx
  asm volatile("  \
c01056da:	8b 45 08             	mov    0x8(%ebp),%eax
c01056dd:	8b 55 0c             	mov    0xc(%ebp),%edx
c01056e0:	89 c3                	mov    %eax,%ebx
c01056e2:	89 d1                	mov    %edx,%ecx
c01056e4:	b8 03 00 00 00       	mov    $0x3,%eax
c01056e9:	cd 50                	int    $0x50
    mov $" QU(SYSCALL_UNBLOCK) ", %%eax; \
    int $80; \
  "::"b"(pid),"c"(tid));
}
c01056eb:	90                   	nop
c01056ec:	5b                   	pop    %ebx
c01056ed:	5d                   	pop    %ebp
c01056ee:	c3                   	ret    

c01056ef <check_proc_exists>:

char check_proc_exists(pid_t pid) {
c01056ef:	55                   	push   %ebp
c01056f0:	89 e5                	mov    %esp,%ebp
c01056f2:	53                   	push   %ebx
c01056f3:	83 ec 10             	sub    $0x10,%esp
  char exists;
  asm volatile("  \
c01056f6:	8b 45 08             	mov    0x8(%ebp),%eax
c01056f9:	89 c3                	mov    %eax,%ebx
c01056fb:	b8 14 00 00 00       	mov    $0x14,%eax
c0105700:	cd 50                	int    $0x50
c0105702:	88 c8                	mov    %cl,%al
c0105704:	88 45 fb             	mov    %al,-0x5(%ebp)
    mov $" QU(SYSCALL_CHECK_PROC_EXISTS) ", %%eax; \
    int $80; \
  ":"=c"(exists):"b"(pid));
  return exists;
c0105707:	8a 45 fb             	mov    -0x5(%ebp),%al
}
c010570a:	83 c4 10             	add    $0x10,%esp
c010570d:	5b                   	pop    %ebx
c010570e:	5d                   	pop    %ebp
c010570f:	c3                   	ret    

c0105710 <__pthread_spin_lock_helper>:
c0105710:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c0105714:	b8 01 00 00 00       	mov    $0x1,%eax
c0105719:	87 03                	xchg   %eax,(%ebx)
c010571b:	85 c0                	test   %eax,%eax
c010571d:	75 f1                	jne    c0105710 <__pthread_spin_lock_helper>
c010571f:	c3                   	ret    
